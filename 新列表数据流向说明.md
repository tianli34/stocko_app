# "新列表"的数据流向说明

## 完整数据流

```
用户界面 (UI)
    ↓
辅单位编辑页面 (AuxiliaryUnitEditScreen)
    ↓
表单状态管理 (unitEditFormProvider)
    ↓
提交表单 (submitForm)
    ↓
Controller 处理 (_saveProductUnits)
    ↓
构建新列表 (list)
    ↓
调用仓储层 (replaceProductUnits)
    ↓
差异更新逻辑
```

## 详细流程

### 1. 用户界面层 (UI)

用户在辅单位编辑页面进行操作：
- 添加辅单位（点击"添加辅单位"按钮）
- 输入单位名称、换算率、价格等
- 删除不需要的辅单位

### 2. 表单状态管理 (unitEditFormProvider)

**文件**: `lib/features/product/application/provider/unit_edit_form_providers.dart`

**状态结构**:
```dart
class UnitEditFormState {
  final List<AuxiliaryUnitData> auxiliaryUnits;  // 辅单位列表
  final int auxiliaryCounter;                     // 计数器
}
```

**辅单位数据结构**:
```dart
class AuxiliaryUnitData {
  final int id;                      // 临时ID（用于UI标识）
  final int? unitId;                 // 单位表的ID
  final String unitName;             // 单位名称（如"箱"、"件"）
  final int conversionRate;          // 换算率
  final String barcode;              // 条码
  final String retailPriceInCents;   // 零售价（分）
  final String wholesalePriceInCents; // 批发价（分）
}
```

**操作方法**:
- `addAuxiliaryUnit()` - 添加新辅单位
- `removeAuxiliaryUnit(id)` - 删除辅单位
- `updateAuxiliaryUnitName(id, name)` - 更新单位名称
- `updateAuxiliaryUnitConversionRate(id, rate)` - 更新换算率
- `updateAuxiliaryUnitRetailPrice(id, price)` - 更新零售价
- `updateAuxiliaryUnitWholesalePrice(id, price)` - 更新批发价

### 3. 提交表单

**文件**: `lib/features/product/presentation/controllers/product_add_edit_actions.dart`

```dart
Future<void> submitForm(...) async {
  // 1. 获取表单状态
  final formState = ref.read(unitEditFormProvider);
  
  // 2. 验证辅单位数据
  if (formState.auxiliaryUnits.isNotEmpty) {
    for (final auxUnit in formState.auxiliaryUnits) {
      if (auxUnit.unitName.trim().isNotEmpty && auxUnit.conversionRate <= 0) {
        onError('❌ 辅单位换算率不能为空');
        return;
      }
    }
  }
  
  // 3. 构建 ProductFormData
  final formData = ProductFormData(
    productId: productId,
    name: nameController.text.trim(),
    // ... 其他字段
  );
  
  // 4. 调用 controller 提交
  final controller = ref.read(productAddEditControllerProvider);
  final result = await controller.submitForm(formData);
}
```

### 4. Controller 处理 (_saveProductUnits)

**文件**: `lib/features/product/presentation/controllers/product_add_edit_controller.dart`

```dart
Future<void> _saveProductUnits(
  ProductModel product,
  List<UnitProduct>? units,
) async {
  // 1. 从表单状态获取辅单位数据
  final formState = ref.read(unitEditFormProvider);
  final auxiliaryUnits = formState.auxiliaryUnits;
  
  // 2. 构建新列表
  final list = <UnitProduct>[];
  
  // 2.1 添加基础单位（换算率=1）
  list.add(
    UnitProduct(
      productId: product.id!,
      unitId: product.baseUnitId,
      conversionRate: 1,
    ),
  );
  
  // 2.2 获取所有单位（用于查找 unitId）
  final allUnits = await ref.read(allUnitsProvider.future);
  
  // 2.3 遍历辅单位，构建 UnitProduct 对象
  for (final auxUnit in auxiliaryUnits) {
    final unitName = auxUnit.unitName.trim();
    
    // 根据单位名称查找 unitId
    Unit? unit = allUnits.where(
      (u) => u.name.toLowerCase() == unitName.toLowerCase(),
    ).firstOrNull;
    
    if (unit != null && unit.id != null) {
      list.add(
        UnitProduct(
          productId: product.id!,
          unitId: unit.id!,                    // 单位表的ID
          conversionRate: auxUnit.conversionRate,
          sellingPriceInCents: int.tryParse(auxUnit.retailPriceInCents),
          wholesalePriceInCents: int.tryParse(auxUnit.wholesalePriceInCents),
        ),
      );
    }
  }
  
  // 3. 调用仓储层保存
  await ctrl.replaceProductUnits(product.id!, list);
}
```

### 5. 新列表的结构

**新列表 (list) 包含**:

```dart
[
  // 基础单位（必有）
  UnitProduct(
    productId: 100,
    unitId: 1,           // 瓶
    conversionRate: 1,   // 基础单位换算率固定为1
  ),
  
  // 辅单位1
  UnitProduct(
    productId: 100,
    unitId: 2,                    // 箱
    conversionRate: 12,           // 1箱 = 12瓶
    sellingPriceInCents: 6000,    // 60元
    wholesalePriceInCents: 5500,  // 55元
  ),
  
  // 辅单位2
  UnitProduct(
    productId: 100,
    unitId: 4,                    // 件
    conversionRate: 24,           // 1件 = 24瓶
    sellingPriceInCents: 11000,   // 110元
    wholesalePriceInCents: 10000, // 100元
  ),
]
```

**关键点**:
- ✅ 新列表中的 `UnitProduct` 对象**没有 id 字段**（或 id 为 null）
- ✅ 只包含 `productId`、`unitId`、`conversionRate` 和价格信息
- ✅ 差异更新逻辑会根据 `unitId` 来匹配旧记录，保持 id 不变

### 6. 差异更新逻辑

**文件**: `lib/features/product/data/repository/product_unit_repository.dart`

```dart
Future<void> replaceProductUnits(
  int productId,
  List<UnitProduct> productUnits,  // 这就是"新列表"
) async {
  await transaction(() async {
    // 1. 获取旧列表（从数据库）
    final existingUnits = await getProductUnitsByProductId(productId);
    // existingUnits 包含完整的数据库记录，包括 id
    
    // 2. 构建映射表
    final existingMap = <int, UnitProductData>{};  // key: unitId
    for (final unit in existingUnits) {
      existingMap[unit.unitId] = unit;  // 包含 id
    }
    
    final newMap = <int, UnitProduct>{};  // key: unitId
    for (final unit in productUnits) {
      newMap[unit.unitId] = unit;  // 不包含 id（或 id 为 null）
    }
    
    // 3. 差异分析
    for (final entry in newMap.entries) {
      if (existingMap.containsKey(entry.key)) {
        // 旧列表中有这个 unitId
        final existingUnit = existingMap[entry.key]!;  // 有 id
        final newUnit = entry.value;                   // 无 id
        
        // 检查是否需要更新
        if (existingUnit.conversionRate != newUnit.conversionRate ||
            existingUnit.sellingPriceInCents != newUnit.sellingPriceInCents ||
            existingUnit.wholesalePriceInCents != newUnit.wholesalePriceInCents) {
          // 需要更新：使用旧记录的 id
          toUpdate.add(
            newUnit.copyWith(id: existingUnit.id)  // 关键：保持 id 不变
          );
        }
      } else {
        // 旧列表中没有这个 unitId，需要新增
        toInsert.add(newUnit);  // 新增时不需要 id，数据库会自动生成
      }
    }
    
    // 4. 执行更新和新增
    // ...
  });
}
```

## 关键理解

### "新列表"的来源

1. **用户输入** → 表单状态 (`unitEditFormProvider`)
2. **表单状态** → Controller (`_saveProductUnits`)
3. **Controller** → 构建 `List<UnitProduct>`（新列表）
4. **新列表** → 仓储层 (`replaceProductUnits`)

### "新列表"的特点

- ✅ 包含用户当前想要保存的所有单位配置
- ✅ 包含基础单位 + 所有辅单位
- ✅ **不包含数据库 id**（或 id 为 null）
- ✅ 只包含业务数据：`unitId`、`conversionRate`、价格等

### 差异更新的核心

```
新列表（无 id）+ 旧列表（有 id）→ 差异分析 → 保持 id 不变
```

**示例**:

```
旧列表（数据库）:
  { id: 1, unitId: 1, conversionRate: 1 }
  { id: 2, unitId: 2, conversionRate: 12, price: 5500 }

新列表（用户输入）:
  { unitId: 1, conversionRate: 1 }
  { unitId: 2, conversionRate: 12, price: 6000 }  ← 价格变了

差异分析:
  unitId=1: 无变化 → 跳过
  unitId=2: 价格变化 → 更新 id=2 的记录

结果（数据库）:
  { id: 1, unitId: 1, conversionRate: 1 }          ← id 不变
  { id: 2, unitId: 2, conversionRate: 12, price: 6000 }  ← id 不变，价格更新
```

## 总结

**"新列表"就是用户当前想要保存的完整单位配置**，它：

1. 来自用户在辅单位编辑页面的输入
2. 通过 `unitEditFormProvider` 管理状态
3. 在 `_saveProductUnits` 中构建为 `List<UnitProduct>`
4. 传递给 `replaceProductUnits` 进行差异更新
5. 通过与旧列表（数据库）比对，智能地执行删除/更新/新增操作
6. **关键**：保持未变化记录的 id 不变，维护数据关联关系

---

**核心优势**: 新列表只关注业务数据，不关心数据库 id，差异更新逻辑负责维护 id 的稳定性。
