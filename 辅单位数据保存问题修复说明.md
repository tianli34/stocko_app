# 辅单位数据保存问题修复说明

## 问题描述

### 原始问题
从"编辑辅单位页"返回到"编辑货品页"时，**数据没有正确保存到 `unitEditFormProvider`**，导致以下问题：

1. ❌ 用户第一次编辑辅单位后返回，数据看似正常
2. ❌ 但如果用户再次点击"添加辅单位"按钮，之前输入的所有数据都会丢失
3. ❌ 用户看到空白的辅单位编辑页面，需要重新输入所有数据

### 问题根源

**`_handleReturn()` 方法只通过 `Navigator.pop()` 返回数据，但没有同步保存到 `unitEditFormProvider`**

```dart
// ❌ 原始代码（有问题）
void _handleReturn() {
  final productUnits = _buildProductUnits();
  final auxiliaryBarcodes = _buildAuxiliaryUnitBarcodes();

  if (productUnits.isNotEmpty) {
    // 只返回数据，没有保存到 provider
    Navigator.of(context).pop({
      'productUnits': productUnits,
      'auxiliaryBarcodes': auxiliaryBarcodes,
    });
  }
}
```

### 数据流问题

```
┌─────────────────────────────────────────────────────────────┐
│ 用户操作流程                                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. 编辑货品页 → 点击"添加辅单位"                              │
│    ↓                                                         │
│ 2. 编辑辅单位页 → 输入数据（箱=12、件=24）                    │
│    ↓                                                         │
│ 3. 返回编辑货品页                                             │
│    ✅ 数据保存到 productFormUiProvider                        │
│    ❌ 数据未保存到 unitEditFormProvider                       │
│    ↓                                                         │
│ 4. 再次点击"添加辅单位"                                       │
│    ❌ unitEditFormProvider 是空的                             │
│    ❌ 页面显示空白，之前的数据全部丢失！                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 修复方案

### 修复内容

在 `_handleReturn()` 方法中添加 `_saveCurrentDataToFormProvider()` 调用，确保数据同时保存到两个地方：

1. ✅ `productFormUiProvider` - 用于最终提交
2. ✅ `unitEditFormProvider` - 用于再次进入时恢复数据

### 修复后的代码

```dart
// ✅ 修复后的代码
void _handleReturn() {
  print('🔍 处理返回，开始构建数据...');
  try {
    final productUnits = _buildProductUnits();
    final auxiliaryBarcodes = _buildAuxiliaryUnitBarcodes();

    if (productUnits.isNotEmpty) {
      print('🔍 数据有效，返回产品单位数据');

      // ✅ 先保存到 unitEditFormProvider，确保下次进入时能恢复数据
      _saveCurrentDataToFormProvider();

      // 返回包含产品单位和条码信息的数据
      Navigator.of(context).pop({
        'productUnits': productUnits,
        'auxiliaryBarcodes': auxiliaryBarcodes,
      });
    } else {
      print('🔍 数据无效或缺少基本单位，直接返回');
      Navigator.of(context).pop();
    }
  } catch (e, s) {
    print('❌ 返回处理异常: $e\n$s');
    Navigator.of(context).pop();
  }
}

/// 将当前编辑的辅单位数据保存到 FormProvider，确保数据持久化
void _saveCurrentDataToFormProvider() {
  print('🔍 保存当前数据到 unitEditFormProvider');
  try {
    final auxiliaryUnitsData = _auxiliaryUnits.map((aux) {
      // 将元转换为分存储
      String retailPriceInCents = '';
      if (aux.retailPriceController.text.trim().isNotEmpty) {
        final priceInYuan = double.tryParse(aux.retailPriceController.text.trim());
        if (priceInYuan != null) {
          retailPriceInCents = (priceInYuan * 100).round().toString();
        }
      }

      String wholesalePriceInCents = '';
      if (aux.wholesalePriceController.text.trim().isNotEmpty) {
        final priceInYuan = double.tryParse(aux.wholesalePriceController.text.trim());
        if (priceInYuan != null) {
          wholesalePriceInCents = (priceInYuan * 100).round().toString();
        }
      }

      return AuxiliaryUnitData(
        id: aux.id,
        unitId: aux.unit?.id,
        unitName: aux.unitController.text.trim(),
        conversionRate: aux.conversionRate,
        barcode: aux.barcodeController.text.trim(),
        retailPriceInCents: retailPriceInCents,
        wholesalePriceInCents: wholesalePriceInCents,
      );
    }).toList();

    ref.read(unitEditFormProvider.notifier).setAuxiliaryUnits(
      auxiliaryUnitsData,
      counter: _auxiliaryCounter,
    );
    print('✅ 数据已保存到 unitEditFormProvider，共 ${auxiliaryUnitsData.length} 个辅单位');
  } catch (e, s) {
    print('❌ 保存数据到 FormProvider 失败: $e\n$s');
  }
}
```

---

## 修复后的数据流

```
┌─────────────────────────────────────────────────────────────┐
│ 修复后的数据流                                                │
├─────────────────────────────────────────────────────────────┤
│ 1. 编辑货品页 → 点击"添加辅单位"                              │
│    ↓                                                         │
│ 2. 编辑辅单位页 → 输入数据（箱=12、件=24）                    │
│    ↓ (每次输入都实时保存到 unitEditFormProvider)              │
│ 3. 返回编辑货品页                                             │
│    ✅ 调用 _saveCurrentDataToFormProvider()                  │
│    ✅ 数据保存到 unitEditFormProvider                         │
│    ✅ 数据保存到 productFormUiProvider                        │
│    ↓                                                         │
│ 4. 再次点击"添加辅单位"                                       │
│    ✅ 从 unitEditFormProvider 恢复数据                        │
│    ✅ 页面显示之前输入的所有辅单位数据                         │
│    ✅ 用户可以继续编辑或添加新的辅单位                         │
│    ↓                                                         │
│ 5. 提交表单                                                   │
│    ✅ 从 productFormUiProvider 读取数据提交                   │
│    ✅ 提交成功后清空 unitEditFormProvider                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 关键改进点

### 1. 双重保存机制
- **实时保存**: 用户每次输入都通过 `onChanged` 保存到 `unitEditFormProvider`
- **返回保存**: 返回时再次完整保存，确保数据一致性

### 2. 价格单位转换
```dart
// 用户输入: 12.50 元
// 保存到 provider: "1250" (分)
// 提交到数据库: 1250 (整数)
```

### 3. 数据恢复逻辑
```dart
void _initializeUnits() async {
  // 编辑模式：从数据库加载
  if (widget.productId != null) {
    await _initializeAuxiliaryUnits();
    return;
  }

  // 新增模式：从 unitEditFormProvider 恢复
  final formState = ref.read(unitEditFormProvider);
  if (formState.auxiliaryUnits.isNotEmpty) {
    _loadFromFormProvider(); // ✅ 恢复之前编辑的数据
    return;
  }

  // 无数据：创建空白表单
  await _initializeAuxiliaryUnits();
}
```

---

## 测试场景

### 场景 1: 多次进出辅单位页面
1. ✅ 进入辅单位页面，添加"箱"（换算率12）
2. ✅ 返回货品页面
3. ✅ 再次进入辅单位页面
4. ✅ 验证："箱"的数据仍然存在
5. ✅ 添加"件"（换算率24）
6. ✅ 返回货品页面
7. ✅ 再次进入辅单位页面
8. ✅ 验证："箱"和"件"的数据都存在

### 场景 2: 编辑后提交
1. ✅ 编辑辅单位数据
2. ✅ 返回货品页面
3. ✅ 提交表单
4. ✅ 验证：辅单位数据正确保存到数据库
5. ✅ 验证：unitEditFormProvider 被清空

### 场景 3: 编辑模式
1. ✅ 打开已有货品的编辑页面
2. ✅ 进入辅单位页面
3. ✅ 验证：从数据库加载的辅单位数据正确显示
4. ✅ 修改辅单位数据
5. ✅ 返回货品页面
6. ✅ 再次进入辅单位页面
7. ✅ 验证：修改后的数据正确显示

---

## 总结

### 问题
❌ 返回时数据只保存到 `productFormUiProvider`，没有保存到 `unitEditFormProvider`

### 修复
✅ 添加 `_saveCurrentDataToFormProvider()` 方法，确保数据同时保存到两个 provider

### 效果
✅ 用户可以多次进出辅单位页面，数据不会丢失
✅ 数据在 `unitEditFormProvider` 和 `productFormUiProvider` 之间保持同步
✅ 提交成功后正确清空临时数据

---

## 修改文件

- `lib/features/product/presentation/screens/auxiliaryunit_edit_screen.dart`
  - 修改 `_handleReturn()` 方法
  - 新增 `_saveCurrentDataToFormProvider()` 方法
