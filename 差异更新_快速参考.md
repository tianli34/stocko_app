# 产品单位差异更新 - 快速参考

## 📌 一句话总结

将产品单位更新从"删除所有再插入"改为"智能比对，只更新变化的部分"。

## 🎯 核心改进

| 方面 | 旧方案 | 新方案 |
|------|--------|--------|
| **操作方式** | 全删全插 | 差异更新 |
| **ID稳定性** | ❌ 每次都变 | ✅ 保持不变 |
| **关联关系** | ❌ 会断裂 | ✅ 保持完好 |
| **性能** | ❌ 低效 | ✅ 高效 |
| **数据库操作** | 2N次 | 最少0次 |

## 📁 修改的文件

```
lib/features/product/data/repository/product_unit_repository.dart
└── replaceProductUnits() 方法
```

## 🔍 差异识别逻辑

```
使用 unitId 作为唯一标识

旧列表有，新列表没有 → 删除
旧列表有，新列表也有 → 比较字段 → 有变化则更新，无变化则跳过
旧列表没有，新列表有 → 新增
```

## 💡 使用示例

### 代码调用（无需修改）
```dart
// 调用方式完全不变
await productUnitRepository.replaceProductUnits(
  productId,
  newProductUnits,
);
```

### 实际效果

**场景**: 产品有3个单位，修改其中1个的价格

```
旧方案:
  DELETE * 3 + INSERT * 3 = 6次操作
  所有ID都变了

新方案:
  UPDATE * 1 = 1次操作
  只有价格变了，ID不变
```

## 🧪 快速测试

### 1. 创建测试产品
```dart
产品: 可乐
基础单位: 瓶 (ID=1, 换算率=1, 价格=5元)
辅单位: 箱 (ID=2, 换算率=12, 价格=55元)
```

### 2. 修改价格
```dart
修改箱的价格: 55元 → 60元
```

### 3. 验证结果
```sql
-- 查询产品单位
SELECT * FROM unit_product WHERE product_id = ?;

-- 预期结果:
-- ID=1 的记录不变
-- ID=2 的记录价格更新为6000（60元）
-- ID 保持为 2，没有变化
```

### 4. 验证条码关联
```sql
-- 查询条码
SELECT * FROM barcode WHERE unit_product_id = 2;

-- 预期结果:
-- 条码仍然关联到 unit_product_id=2
-- 关联关系没有断裂
```

## 📊 性能对比

| 操作 | 旧方案 | 新方案 | 提升 |
|------|--------|--------|------|
| 只修改1个价格 | 20次 | 1次 | 20倍 |
| 新增1个单位 | 20次 | 1次 | 20倍 |
| 删除1个单位 | 20次 | 1次 | 20倍 |
| 完全不变 | 20次 | 0次 | ∞ |

*假设产品有10个单位*

## ⚠️ 注意事项

1. **唯一键约束**: 同一产品的同一单位只能有一个记录
2. **事务保证**: 所有操作在事务中执行
3. **向后兼容**: API接口不变，无需修改调用代码
4. **日志输出**: 保留详细日志，便于调试

## 📚 详细文档

- `CHANGELOG_差异更新方案.md` - 详细改动说明
- `差异更新方案_实施总结.md` - 完整实施总结
- `差异更新流程图.md` - 可视化流程图
- `test/.../product_unit_repository_diff_update_test.dart` - 测试用例

## ✅ 验收标准

- [ ] 修改产品单位价格后，ID保持不变
- [ ] 条码关联关系不会断裂
- [ ] 只对变化的记录进行数据库操作
- [ ] 所有现有功能正常工作
- [ ] 性能有明显提升

---

**实施日期**: 2025-10-11  
**状态**: ✅ 已完成  
**影响范围**: 产品编辑功能
