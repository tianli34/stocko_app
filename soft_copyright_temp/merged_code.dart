import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'core/router/router_provider.dart';
import 'core/theme/theme_provider.dart';
import 'core/initialization/app_initializer.dart';

class StockoApp extends ConsumerWidget {
  const StockoApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    print('ğŸ  StockoApp build called');
    final router = ref.watch(routerProvider);
    
    // æ ¹æ®ç³»ç»Ÿä¸»é¢˜æ›´æ–°UIæ ·å¼
    final brightness = MediaQuery.platformBrightnessOf(context);
    AppTheme.updateSystemUIOverlay(brightness);
    
    return AppInitializer(
      child: MaterialApp.router(
        title: 'é“ºå¾—æ¸?åº“å­˜ç®¡ç†ç³»ç»Ÿ',
        theme: AppTheme.lightTheme,
        darkTheme: AppTheme.darkTheme,
        themeMode: ThemeMode.system,
        routerConfig: router,
        debugShowCheckedModeBanner: false,
        localizationsDelegates: const [
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: const [Locale('zh', 'CN'), Locale('en', 'US')],
      ),
    );
  }
}
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/app.dart';
import 'core/services/image_cache_service.dart';
import 'config/flavor_config.dart';
// AppInitializer is now injected inside StockoApp via MaterialApp.builder

Future<void> runStockoApp(FlavorConfig config) async {
  // 1. ç¡®ä¿ Flutter å¼•æ“çš„ç»‘å®šå·²ç»åˆå§‹åŒ–ã€?
  WidgetsFlutterBinding.ensureInitialized();

  // 2. è®¾ç½®ç³»ç»ŸUIæ ·å¼ï¼Œç§»é™¤åº•éƒ¨å¯¼èˆªæ çš„åŠé€æ˜é®ç½©
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      systemNavigationBarColor: Colors.white, // è®¾ç½®ä¸ºç™½è‰²æˆ–é€æ˜
      systemNavigationBarIconBrightness: Brightness.dark, // å›¾æ ‡é¢œè‰²
      systemNavigationBarDividerColor: Colors.transparent, // åˆ†éš”çº¿é€æ˜
    ),
  );

  // å¯ç”¨è¾¹åˆ°è¾¹æ˜¾ç¤ºï¼ˆå¯é€‰ï¼Œè®©åº”ç”¨å†…å®¹å»¶ä¼¸åˆ°ç³»ç»Ÿæ ä¸‹æ–¹ï¼‰
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);

  // 3. åˆå§‹åŒ–å›¾ç‰‡ç¼“å­˜æœåŠ?
  final imageCacheService = ImageCacheService();
  await imageCacheService.initialize();

  // 4. è¿è¡Œåº”ç”¨
  runApp(
    ProviderScope(
      overrides: [flavorConfigProvider.overrideWithValue(config)],
      child: const StockoApp(),
    ),
  );
}

void main() {
  // é»˜è®¤è¿è¡Œ personalized é…ç½®
  runStockoApp(
    FlavorConfig(
      flavor: AppFlavor.personalized,
      appTitle: "å®šåˆ¶ç‰ˆåº“å­˜ç®¡ç?,
      featureFlags: {Feature.showDatabaseTools: true},
    ),
  );
}
// Entry point for the generic flavor
import 'package:stocko_app/config/flavor_config.dart';
import 'package:stocko_app/main.dart' as app;

void main() {
  // å®šä¹‰é€šç”¨ç‰ˆé…ç½?
  final genericConfig = FlavorConfig(
    flavor: AppFlavor.generic,
    appTitle: "é€šç”¨åº“å­˜ç®¡ç†",
    featureFlags: {
      Feature.showDatabaseTools: false, // é€šç”¨ç‰ˆå…³é—­æ•°æ®åº“å·¥å…·
    },
  );

  // ä½¿ç”¨é€šç”¨é…ç½®è¿è¡Œåº”ç”¨
  app.runStockoApp(genericConfig);
}
// Entry point for the personalized flavor
import 'package:stocko_app/config/flavor_config.dart';
import 'package:stocko_app/main.dart' as app;

void main() {
  // å®šä¹‰å®šåˆ¶ç‰ˆé…ç½?
  final personalizedConfig = FlavorConfig(
    flavor: AppFlavor.personalized,
    appTitle: "å®šåˆ¶ç‰ˆåº“å­˜ç®¡ç?,
    featureFlags: {
      Feature.showDatabaseTools: true, // å®šåˆ¶ç‰ˆä¿ç•™æ•°æ®åº“å·¥å…·
    },
  );

  // ä½¿ç”¨å®šåˆ¶é…ç½®è¿è¡Œåº”ç”¨
  app.runStockoApp(personalizedConfig);
}
import 'package:flutter_riverpod/flutter_riverpod.dart';

// å®šä¹‰æ‰€æœ‰æ”¯æŒçš„ Flavor
enum AppFlavor {
  generic,
  personalized,
}

// å®šä¹‰åŠŸèƒ½å¼€å…³çš„æšä¸¾
enum Feature {
  showDatabaseTools,
}

// Flavor é…ç½®ç±?
class FlavorConfig {
  final AppFlavor flavor;
  final String appTitle;
  // åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šéœ€è¦æ ¹æ?Flavor å˜åŒ–çš„é…ç½?
  // ä¾‹å¦‚ï¼šAPI åœ°å€ã€ä¸»é¢˜é¢œè‰²ã€åŠŸèƒ½å¼€å…³ç­‰
  final Map<Feature, bool> featureFlags;

  FlavorConfig({
    required this.flavor,
    required this.appTitle,
    required this.featureFlags,
  });
}

// åˆ›å»ºä¸€ä¸?Provider æ¥è®¿é—?FlavorConfig
final flavorConfigProvider = Provider<FlavorConfig>((ref) {
  // è¿™ä¸ª provider å¿…é¡»åœ?main å…¥å£æ–‡ä»¶ä¸­è¢« override
  throw UnimplementedError('flavorConfigProvider must be overridden in the main entry point.');
});
// è·¯ç”±è·¯å¾„å¸¸é‡
class AppRoutes {
  static const String home = '/';
  static const String products = '/products';
  static const String productDetail = '/products/:id';
  static const String productEdit = '/product/:id/edit';
  static const String productNew = '/product/new';
  static const String productRanking = '/products/ranking';
  static const String categories = '/categories';
  static const String categoryTest = '/categories/test';
  static const String inventory = '/inventory';
  static const String inventoryQuery = '/inventory-query';
  static const String inventoryInboundRecords = '/inventory/inbound-records';
  static const String inbound = '/inbound';
  static const String inboundCreate = '/inbound/create';
  static const String purchase = '/purchase';
  static const String purchaseCreate = '/inbound/create';
  static const String purchaseRecords = '/purchase/records';
  static const String purchaseDetail = '/purchase/detail/:purchaseNumber';
  static const String sales = '/sales';
  static const String saleCreate = '/sales/create';
  static const String saleRecords = '/sales/records';
  static const String test = '/test';
  static const String databaseViewer = '/database-viewer';
  static const String databaseManagement = '/database-management';
  static const String settings = '/settings';
  static const String customers = '/customers';
  static const String productRestoreDebug = '/debug/product-restore';

  // è¾…åŠ©æ–¹æ³•ï¼Œç”¨äºç”Ÿæˆå¸¦å‚æ•°çš„è·¯ç”?
  static String productDetailPath(String id) => '/products/$id';
  static String productEditPath(String id) => '/product/$id/edit';
  static String purchaseDetailPath(String purchaseNumber) =>
      '/purchase/detail/$purchaseNumber';
}
import 'package:drift/drift.dart';
import 'package:stocko_app/core/database/product_units_table.dart';

/// æ¡ç è¡?
/// å­˜å‚¨äº§å“å•ä½å¯¹åº”çš„æ¡ç ä¿¡æ?
class Barcode extends Table {
  /// ä¸»é”® - æ¡ç ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - äº§å“å•ä½IDï¼Œå…³è”åˆ°product_unitsè¡?
  IntColumn get unitProductId => integer().references(UnitProduct, #id)();

  /// æ¡ç å€?
  TextColumn get barcodeValue => text().unique()();
}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'shops_table.dart';

/// æ‰¹æ¬¡è¡?ä¸ç”¨è¡¨å Batchï¼Œå› ä¸ºBatch æ˜?Drift çš„ä¿ç•™å­—
class ProductBatch extends Table {
  /// ä¸»é”®
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - è´§å“ID
  IntColumn get productId => integer().references(
    Product,
    #id,
    onDelete: KeyAction.restrict,
    onUpdate: KeyAction.cascade,
  )();

  /// ç”Ÿäº§æ—¥æœŸ
  DateTimeColumn get productionDate => dateTime()();

  /// ç´¯è®¡å…¥åº“æ•°é‡ï¼Œéè´Ÿï¼Œå³åŒä¸€æ‰¹æ¬¡çš„è´§å“æ•°é‡?
  IntColumn get totalInboundQuantity =>
      integer().named('total_inbound_quantity')();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer()
      .references(
        Shop,
        #id,
        onDelete: KeyAction.restrict,
        onUpdate: KeyAction.cascade,
      )();

  /// åˆ›å»ºæ—¶é—´ï¼ˆç”±æ•°æ®åº“é»˜è®¤ç”Ÿæˆï¼‰
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—´ï¼ˆæ³¨æ„ï¼šä¸ä¼šè‡ªåŠ¨åœ¨æ›´æ–°æ—¶åˆ·æ–°ï¼Œéœ€è¦åº”ç”¨å±‚æˆ–è§¦å‘å™¨ç»´æŠ¤ï¼?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

  /// ä¸šåŠ¡å”¯ä¸€é”®ï¼šåŒä¸€åº—é“ºã€åŒä¸€äº§å“ã€åŒä¸€ç”Ÿäº§æ—¥æœŸåªèƒ½æœ‰ä¸€ä¸ªæ‰¹æ¬?
  @override
  List<Set<Column>> get uniqueKeys => [
    {productId, productionDate, shopId},
  ];

  /// è¡¨çº§çº¦æŸï¼šæ•°é‡éè´?
  @override
  List<String> get customConstraints => ['CHECK(total_inbound_quantity >= 0)'];
}
import 'package:drift/drift.dart';

/// ç±»åˆ«è¡¨å®šä¹?
/// ç”¨äºå­˜å‚¨äº§å“ç±»åˆ«ä¿¡æ¯çš„æ•°æ®åº“è¡¨ç»“æ?
class Category extends Table {
  /// ç±»åˆ«ID - ä¸»é”®
  IntColumn get id => integer().autoIncrement()();

  /// ç±»åˆ«åç§° - å¿…å¡«
  /// æ·»åŠ å”¯ä¸€çº¦æŸé˜²æ­¢é‡å¤ç±»åˆ«ï¼ˆåœ¨åŒä¸€å±‚çº§ä¸‹ï¼‰
  TextColumn get name => text()();

  /// çˆ¶ç±»åˆ«ID - å¯é€‰ï¼Œç”¨äºæ„å»ºå±‚çº§ç»“æ„
  IntColumn get parentId => integer().nullable()();

  /// æ·»åŠ å¤åˆå”¯ä¸€çº¦æŸï¼šåŒä¸€çˆ¶çº§ä¸‹çš„ç±»åˆ«åç§°ä¸èƒ½é‡å¤
  @override
  List<Set<Column>> get uniqueKeys => [
    {name, parentId}, // çˆ¶ç±»åˆ«ID + ç±»åˆ«åç§°çš„ç»„åˆå¿…é¡»å”¯ä¸€
  ];
}
import 'package:drift/drift.dart';

@DataClassName('Customer')
class Customers extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().withLength(min: 1, max: 50)();
}
import 'package:drift/drift.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'products_table.dart';
import 'categories_table.dart';
import 'units_table.dart';
import 'product_units_table.dart';
import 'shops_table.dart';
import 'suppliers_table.dart';
import 'batches_table.dart';
import 'inventory_table.dart';
import 'inventory_transactions_table.dart';
import 'locations_table.dart';
import 'inbound_receipts_table.dart';
import 'inbound_receipt_items_table.dart';
import 'purchase_orders_table.dart';
import 'purchase_order_items_table.dart';
import 'barcodes_table.dart'; // æ–°å¢æ¡ç è¡?
import 'customers_table.dart';
import 'sales_transactions_table.dart';
import 'sales_transaction_items_table.dart';
import 'outbound_receipts_table.dart';
import 'outbound_receipt_items_table.dart';
import '../../features/product/data/dao/product_dao.dart';
import '../../features/product/data/dao/category_dao.dart';
import '../../features/product/data/dao/unit_dao.dart';
import '../../features/product/data/dao/product_unit_dao.dart';
import '../../features/purchase/data/dao/supplier_dao.dart';
import '../../features/product/data/dao/batch_dao.dart';
import '../../features/inventory/data/dao/shop_dao.dart';
import '../../features/inventory/data/dao/inventory_dao.dart';
import '../../features/inventory/data/dao/inventory_transaction_dao.dart';
import '../../features/inbound/data/dao/location_dao.dart';
import '../../features/inbound/data/dao/inbound_receipt_dao.dart';
import '../../features/inbound/data/dao/inbound_item_dao.dart';
import '../../features/purchase/data/dao/purchase_dao.dart';
import '../../features/product/data/dao/barcode_dao.dart';
import '../../features/sale/data/dao/customer_dao.dart';
import '../../features/sale/data/dao/sales_transaction_dao.dart';
import '../../features/sale/data/dao/sales_transaction_item_dao.dart';
import '../../features/outbound/data/dao/outbound_receipt_dao.dart';
import '../../features/outbound/data/dao/outbound_item_dao.dart';
import '../../features/product/domain/model/product.dart';

part 'database.g.dart';

@DriftDatabase(
  tables: [
    Product,
    Category,
    Unit,
    UnitProduct,
    Shop,
    Supplier,
    ProductBatch,
    Stock,
    InventoryTransaction,
    LocationsTable,
    InboundReceipt,
    InboundItem,
    PurchaseOrder,
    PurchaseOrderItem,
    Barcode, // æ–°å¢æ¡ç è¡?
    Customers,
    SalesTransaction,
    SalesTransactionItem,
    OutboundReceipt,
    OutboundItem,
  ],
  daos: [
    ProductDao,
    CategoryDao,
    UnitDao,
    ProductUnitDao,
    ShopDao,
    SupplierDao,
    BatchDao,
    InventoryDao,
    InventoryTransactionDao,
    LocationDao,
    InboundReceiptDao,
    InboundItemDao,
    PurchaseDao,
    BarcodeDao, // æ–°å¢æ¡ç DAO
    CustomerDao,
    SalesTransactionDao,
    SalesTransactionItemDao,
    OutboundReceiptDao,
    OutboundItemDao,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase(super.e);
  @override
  int get schemaVersion => 22; 

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
      // åˆ›å»ºæ¡ç è¡¨çš„æ¡ç å€¼ç´¢å¼•ä»¥æé«˜æŸ¥è¯¢æ€§èƒ½
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_barcode_barcode_value ON barcode(barcode_value);',
      );
      // åˆ›å»ºæ¡ç è¡¨çš„äº§å“å•ä½IDç´¢å¼•
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_barcode_unit_product_id ON barcode(unit_product_id);',
      );
      // é‡‡è´­å•ç›¸å…³ç´¢å¼?
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_po_supplier ON purchase_order(supplier_id);',
      );
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_po_shop ON purchase_order(shop_id);',
      );
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_po_status ON purchase_order(status);',
      );
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_po_created ON purchase_order(created_at);',
      );
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_poi_po ON purchase_order_item(purchase_order_id);',
      );
      await customStatement(
        'CREATE INDEX IF NOT EXISTS idx_poi_product ON purchase_order_item(product_id);',
      );
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS poi_unique_with_date ON purchase_order_item(purchase_order_id, product_id, production_date) WHERE production_date IS NOT NULL;',
      );
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS poi_unique_without_date ON purchase_order_item(purchase_order_id, product_id) WHERE production_date IS NULL;',
      );
      // ä¸ºåº“å­˜è¡¨åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS stock_unique_with_batch ON stock(product_id, shop_id, batch_id) WHERE batch_id IS NOT NULL;',
      );
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS stock_unique_without_batch ON stock(product_id, shop_id) WHERE batch_id IS NULL;',
      );
      // ä¸ºå…¥åº“å•æ˜ç»†è¡¨åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS inbound_item_unique_with_batch ON inbound_item(receipt_id, product_id, batch_id) WHERE batch_id IS NOT NULL;',
      );
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS inbound_item_unique_without_batch ON inbound_item(receipt_id, product_id) WHERE batch_id IS NULL;',
      );
      // ä¸ºå‡ºåº“å•æ˜ç»†è¡¨åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS outbound_item_unique_with_batch ON outbound_item(receipt_id, product_id, batch_id) WHERE batch_id IS NOT NULL;',
      );
      await customStatement(
        'CREATE UNIQUE INDEX IF NOT EXISTS outbound_item_unique_without_batch ON outbound_item(receipt_id, product_id) WHERE batch_id IS NULL;',
      );
    },
    onUpgrade: (Migrator m, int from, int to) async {
      
      if (from < 22 && to >= 22) {
        // æ·»åŠ ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼å­—æ®µ
        await m.addColumn(stock, stock.averageUnitPriceInCents);
        // æ·»åŠ å…¥åº“å•æ˜ç»†è¡¨å•ä»·å­—æ®µ
        // await m.addColumn(inboundItem, inboundItem.unitPriceInCents);
      }
      if (from < 21 && to >= 21) {
        // åˆ é™¤æ—§çš„å”¯ä¸€ç´¢å¼•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        await customStatement('DROP INDEX IF EXISTS poi_unique_line;');
        // åˆ›å»ºæ–°çš„æ¡ä»¶å”¯ä¸€ç´¢å¼•
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS poi_unique_with_date ON purchase_order_item(purchase_order_id, product_id, production_date) WHERE production_date IS NOT NULL;',
        );
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS poi_unique_without_date ON purchase_order_item(purchase_order_id, product_id) WHERE production_date IS NULL;',
        );

        // ä¸ºåº“å­˜è¡¨åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•ï¼ˆä¸ onCreate ä¿æŒä¸€è‡´ï¼Œç¡®ä¿è€ç‰ˆæœ¬å‡çº§åä¹Ÿå…·å¤‡çº¦æŸï¼‰
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS stock_unique_with_batch ON stock(product_id, shop_id, batch_id) WHERE batch_id IS NOT NULL;',
        );
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS stock_unique_without_batch ON stock(product_id, shop_id) WHERE batch_id IS NULL;',
        );

        // ä¸ºå‡ºåº“å•æ˜ç»†è¡¨åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS outbound_item_unique_with_batch ON outbound_item(receipt_id, product_id, batch_id) WHERE batch_id IS NOT NULL;',
        );
        await customStatement(
          'CREATE UNIQUE INDEX IF NOT EXISTS outbound_item_unique_without_batch ON outbound_item(receipt_id, product_id) WHERE batch_id IS NULL;',
        );
      }
      if (from < 20 && to >= 20) {
        await m.createTable(outboundReceipt);
        await m.createTable(outboundItem);
      }
      if (from < 17 && to >= 17) {
        await m.createTable(salesTransaction);
        await m.createTable(salesTransactionItem);
      }
      if (from < 19 && to >= 19) {
        // æ–°å¢é‡‡è´­å?æ˜ç»†ç´¢å¼•ä¸å”¯ä¸€ç´¢å¼•
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_po_supplier ON purchase_order(supplier_id);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_po_shop ON purchase_order(shop_id);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_po_status ON purchase_order(status);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_po_created ON purchase_order(created_at);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_poi_po ON purchase_order_item(purchase_order_id);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_poi_product ON purchase_order_item(product_id);',
        );
        // This is now handled by the migration to version 21
      }
      if (from < 18 && to >= 18) {
        // ä¸?sales_transaction_items è¡¨çš„ unit_id åˆ—æ·»åŠ æ˜ç¡®çš„åˆ—å
        // ç”±äºæˆ‘ä»¬å·²ç»ä¿®æ”¹äº†è¡¨ç»“æ„ï¼Œéœ€è¦é‡æ–°åˆ›å»ºè¡¨
        await m.createTable(salesTransactionItem);
      }
      if (from < 16 && to >= 16) {
        await m.createTable(customers);
      }
      if (from < 15 && to >= 15) {
        await m.addColumn(inboundReceipt, inboundReceipt.source);
      }
      if (from < 14 && to >= 14) {
        await m.deleteTable('purchases');
        await m.createTable(purchaseOrder);
        await m.createTable(purchaseOrderItem);
      }
      if (from < 13 && to >= 13) {
        // ä¸?product_units è¡¨æ·»åŠ?wholesale_price åˆ?
        await m.addColumn(unitProduct, unitProduct.wholesalePriceInCents);
      }
      if (from < 12 && to >= 12) {
        // é‡å»ºé‡‡è´­è¡¨ä»¥ä½?production_date åˆ—å¯ä¸ºç©º
        // This migration is now obsolete as purchasesTable is removed.
        // The logic is replaced by migration to version 14.
      }
      if (from < 11 && to >= 11) {
        // æ·»åŠ æ¡ç è¡?
        await m.createTable(barcode);
        // åˆ›å»ºæ¡ç è¡¨çš„ç´¢å¼•
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_barcode_barcode_value ON barcode(barcode_value);',
        );
        await customStatement(
          'CREATE INDEX IF NOT EXISTS idx_barcode_unit_product_id ON barcode(unit_product_id);',
        );
      }
      
      if (from < 8 && to >= 8) {
        // This migration is now obsolete as purchasesTable is removed.
        // The logic is replaced by migration to version 14.
      }
      if (from == 1 && to == 2) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šä¿®æ”¹äº§å“è¡¨çš„IDåˆ—ä¸ºéç©º
        // ç”±äºSQLiteä¸æ”¯æŒç›´æ¥ä¿®æ”¹åˆ—çš„nullçº¦æŸï¼Œæˆ‘ä»¬éœ€è¦é‡å»ºè¡¨
        await m.recreateAllViews();
      }
      if (from == 2 && to == 3) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šæ·»åŠ ç±»åˆ«è¡¨
        await m.createTable(category);
      }
      if (from == 3 && to == 4) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šæ·»åŠ å•ä½è¡¨
        await m.createTable(unit);
      }
      if (from == 4 && to == 5) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šæ·»åŠ äº§å“å•ä½è¡¨
        await m.createTable(unitProduct);
      }
      if (from == 5 && to == 6) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šæ·»åŠ åº—é“ºè¡¨
        await m.createTable(shop);
      }
      if (from == 6 && to == 7) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?ï¼šæ·»åŠ æ‰€æœ‰ç¼ºå¤±çš„è¡?
        await m.createTable(supplier);
        await m.createTable(productBatch);
        await m.createTable(stock);
        await m.createTable(inventoryTransaction);
        await m.createTable(locationsTable);
        await m.createTable(inboundReceipt);
        await m.createTable(inboundItem);
      }
      // å¤„ç†ä»æ—§ç‰ˆæœ¬ç›´æ¥å‡çº§åˆ°ç‰ˆæœ?çš„æƒ…å†?
      if (from < 7 && to == 7) {
        // ç¡®ä¿æ‰€æœ‰è¡¨éƒ½å­˜åœ?
        if (from < 3) await m.createTable(category);
        if (from < 4) await m.createTable(unit);
        if (from < 5) await m.createTable(unitProduct);
        if (from < 6) await m.createTable(shop);
        await m.createTable(supplier);
        await m.createTable(productBatch);
        await m.createTable(stock);
        await m.createTable(inventoryTransaction);
        await m.createTable(locationsTable);
        await m.createTable(inboundReceipt);
        await m.createTable(inboundItem);
      }
      // ä¿ç•™åŸæœ‰çš„è¿ç§»é€»è¾‘
      if (from == 1 && to == 3) {
        // ä»ç‰ˆæœ?ç›´æ¥å‡çº§åˆ°ç‰ˆæœ?
        await m.recreateAllViews();
        await m.createTable(category);
      }
      if (from == 1 && to == 4) {
        // ä»ç‰ˆæœ?ç›´æ¥å‡çº§åˆ°ç‰ˆæœ?
        await m.recreateAllViews();
        await m.createTable(category);
        await m.createTable(unit);
      }
      if (from == 1 && to == 5) {
        // ä»ç‰ˆæœ?ç›´æ¥å‡çº§åˆ°ç‰ˆæœ?
        await m.recreateAllViews();
        await m.createTable(category);
        await m.createTable(unit);
        await m.createTable(unitProduct);
      }
      if (from == 2 && to == 4) {
        // ä»ç‰ˆæœ?ç›´æ¥å‡çº§åˆ°ç‰ˆæœ?
        await m.createTable(category);
        await m.createTable(unit);
      }
      if (from == 2 && to == 5) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?
        await m.createTable(category);
        await m.createTable(unit);
        await m.createTable(unitProduct);
      }
      if (from == 3 && to == 5) {
        // ä»ç‰ˆæœ?å‡çº§åˆ°ç‰ˆæœ?
        await m.createTable(unit);
        await m.createTable(unitProduct);
      }
      // åœ¨ä»»ä½•ç‰ˆæœ¬å‡çº§åéƒ½ç¡®ä¿æ¡ç è¡¨ç´¢å¼•å­˜åœ¨ï¼ˆç§»é™¤äº†äº§å“è¡¨æ¡ç ç´¢å¼•ï¼Œå› ä¸ºäº§å“è¡¨å·²æ— æ¡ç å­—æ®µï¼‰
      // æ³¨é‡Šæ‰ï¼šäº§å“è¡¨å·²æ— æ¡ç å­—æ®?
      // await customStatement(
      //   'CREATE INDEX IF NOT EXISTS idx_products_barcode ON products(barcode);',
      // );
    },
  );
}

@riverpod
AppDatabase appDatabase(Ref ref) {
  return AppDatabase(_openConnection());
}

QueryExecutor _openConnection() {
  // Use LazyDatabase with NativeDatabase for native platforms (mobile & desktop)
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'app_database.db'));
    return NativeDatabase(file);
  });
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $UnitTable extends Unit with TableInfo<$UnitTable, UnitData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UnitTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'unit';
  @override
  VerificationContext validateIntegrity(
    Insertable<UnitData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UnitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UnitData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
    );
  }

  @override
  $UnitTable createAlias(String alias) {
    return $UnitTable(attachedDatabase, alias);
  }
}

class UnitData extends DataClass implements Insertable<UnitData> {
  final int id;

  /// å•ä½åç§°ï¼ˆå”¯ä¸€ï¼Œä¾‹å¦?"åƒå…‹"ã€?ç±?ã€?ä»?ï¼?  final String name;
  const UnitData({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  UnitCompanion toCompanion(bool nullToAbsent) {
    return UnitCompanion(id: Value(id), name: Value(name));
  }

  factory UnitData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UnitData(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  UnitData copyWith({int? id, String? name}) =>
      UnitData(id: id ?? this.id, name: name ?? this.name);
  UnitData copyWithCompanion(UnitCompanion data) {
    return UnitData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UnitData(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UnitData && other.id == this.id && other.name == this.name);
}

class UnitCompanion extends UpdateCompanion<UnitData> {
  final Value<int> id;
  final Value<String> name;
  const UnitCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  UnitCompanion.insert({this.id = const Value.absent(), required String name})
    : name = Value(name);
  static Insertable<UnitData> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  UnitCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return UnitCompanion(id: id ?? this.id, name: name ?? this.name);
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UnitCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $CategoryTable extends Category
    with TableInfo<$CategoryTable, CategoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentIdMeta = const VerificationMeta(
    'parentId',
  );
  @override
  late final GeneratedColumn<int> parentId = GeneratedColumn<int>(
    'parent_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, parentId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'category';
  @override
  VerificationContext validateIntegrity(
    Insertable<CategoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_id')) {
      context.handle(
        _parentIdMeta,
        parentId.isAcceptableOrUnknown(data['parent_id']!, _parentIdMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {name, parentId},
  ];
  @override
  CategoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CategoryData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}parent_id'],
      ),
    );
  }

  @override
  $CategoryTable createAlias(String alias) {
    return $CategoryTable(attachedDatabase, alias);
  }
}

class CategoryData extends DataClass implements Insertable<CategoryData> {
  /// ç±»åˆ«ID - ä¸»é”®
  final int id;

  /// ç±»åˆ«åç§° - å¿…å¡«
  /// æ·»åŠ å”¯ä¸€çº¦æŸé˜²æ­¢é‡å¤ç±»åˆ«ï¼ˆåœ¨åŒä¸€å±‚çº§ä¸‹ï¼‰
  final String name;

  /// çˆ¶ç±»åˆ«ID - å¯é€‰ï¼Œç”¨äºæ„å»ºå±‚çº§ç»“æ„
  final int? parentId;
  const CategoryData({required this.id, required this.name, this.parentId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || parentId != null) {
      map['parent_id'] = Variable<int>(parentId);
    }
    return map;
  }

  CategoryCompanion toCompanion(bool nullToAbsent) {
    return CategoryCompanion(
      id: Value(id),
      name: Value(name),
      parentId: parentId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentId),
    );
  }

  factory CategoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CategoryData(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      parentId: serializer.fromJson<int?>(json['parentId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'parentId': serializer.toJson<int?>(parentId),
    };
  }

  CategoryData copyWith({
    int? id,
    String? name,
    Value<int?> parentId = const Value.absent(),
  }) => CategoryData(
    id: id ?? this.id,
    name: name ?? this.name,
    parentId: parentId.present ? parentId.value : this.parentId,
  );
  CategoryData copyWithCompanion(CategoryCompanion data) {
    return CategoryData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      parentId: data.parentId.present ? data.parentId.value : this.parentId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CategoryData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('parentId: $parentId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, parentId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CategoryData &&
          other.id == this.id &&
          other.name == this.name &&
          other.parentId == this.parentId);
}

class CategoryCompanion extends UpdateCompanion<CategoryData> {
  final Value<int> id;
  final Value<String> name;
  final Value<int?> parentId;
  const CategoryCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.parentId = const Value.absent(),
  });
  CategoryCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    this.parentId = const Value.absent(),
  }) : name = Value(name);
  static Insertable<CategoryData> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<int>? parentId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (parentId != null) 'parent_id': parentId,
    });
  }

  CategoryCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<int?>? parentId,
  }) {
    return CategoryCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      parentId: parentId ?? this.parentId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentId.present) {
      map['parent_id'] = Variable<int>(parentId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoryCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('parentId: $parentId')
          ..write(')'))
        .toString();
  }
}

class $ProductTable extends Product with TableInfo<$ProductTable, ProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _skuMeta = const VerificationMeta('sku');
  @override
  late final GeneratedColumn<String> sku = GeneratedColumn<String>(
    'sku',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'UNIQUE',
  );
  static const VerificationMeta _imageMeta = const VerificationMeta('image');
  @override
  late final GeneratedColumn<String> image = GeneratedColumn<String>(
    'image',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _baseUnitIdMeta = const VerificationMeta(
    'baseUnitId',
  );
  @override
  late final GeneratedColumn<int> baseUnitId = GeneratedColumn<int>(
    'base_unit_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES unit (id)',
    ),
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<int> categoryId = GeneratedColumn<int>(
    'category_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES category (id)',
    ),
  );
  static const VerificationMeta _specificationMeta = const VerificationMeta(
    'specification',
  );
  @override
  late final GeneratedColumn<String> specification = GeneratedColumn<String>(
    'specification',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Money?, int>
  suggestedRetailPrice = GeneratedColumn<int>(
    'suggested_retail_price',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  ).withConverter<Money?>($ProductTable.$convertersuggestedRetailPricen);
  @override
  late final GeneratedColumnWithTypeConverter<Money?, int> retailPrice =
      GeneratedColumn<int>(
        'retail_price',
        aliasedName,
        true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
      ).withConverter<Money?>($ProductTable.$converterretailPricen);
  @override
  late final GeneratedColumnWithTypeConverter<Money?, int> promotionalPrice =
      GeneratedColumn<int>(
        'promotional_price',
        aliasedName,
        true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
      ).withConverter<Money?>($ProductTable.$converterpromotionalPricen);
  static const VerificationMeta _stockWarningValueMeta = const VerificationMeta(
    'stockWarningValue',
  );
  @override
  late final GeneratedColumn<int> stockWarningValue = GeneratedColumn<int>(
    'stock_warning_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shelfLifeMeta = const VerificationMeta(
    'shelfLife',
  );
  @override
  late final GeneratedColumn<int> shelfLife = GeneratedColumn<int>(
    'shelf_life',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<ShelfLifeUnit, String>
  shelfLifeUnit = GeneratedColumn<String>(
    'shelf_life_unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: Constant(ShelfLifeUnit.months.name),
  ).withConverter<ShelfLifeUnit>($ProductTable.$convertershelfLifeUnit);
  static const VerificationMeta _enableBatchManagementMeta =
      const VerificationMeta('enableBatchManagement');
  @override
  late final GeneratedColumn<bool> enableBatchManagement =
      GeneratedColumn<bool>(
        'enable_batch_management',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("enable_batch_management" IN (0, 1))',
        ),
        defaultValue: const Constant(false),
      );
  @override
  late final GeneratedColumnWithTypeConverter<ProductStatus, String> status =
      GeneratedColumn<String>(
        'status',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: Constant(ProductStatus.active.name),
      ).withConverter<ProductStatus>($ProductTable.$converterstatus);
  static const VerificationMeta _remarksMeta = const VerificationMeta(
    'remarks',
  );
  @override
  late final GeneratedColumn<String> remarks = GeneratedColumn<String>(
    'remarks',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastUpdatedMeta = const VerificationMeta(
    'lastUpdated',
  );
  @override
  late final GeneratedColumn<DateTime> lastUpdated = GeneratedColumn<DateTime>(
    'last_updated',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    sku,
    image,
    baseUnitId,
    categoryId,
    specification,
    brand,
    suggestedRetailPrice,
    retailPrice,
    promotionalPrice,
    stockWarningValue,
    shelfLife,
    shelfLifeUnit,
    enableBatchManagement,
    status,
    remarks,
    lastUpdated,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProductData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('sku')) {
      context.handle(
        _skuMeta,
        sku.isAcceptableOrUnknown(data['sku']!, _skuMeta),
      );
    }
    if (data.containsKey('image')) {
      context.handle(
        _imageMeta,
        image.isAcceptableOrUnknown(data['image']!, _imageMeta),
      );
    }
    if (data.containsKey('base_unit_id')) {
      context.handle(
        _baseUnitIdMeta,
        baseUnitId.isAcceptableOrUnknown(
          data['base_unit_id']!,
          _baseUnitIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_baseUnitIdMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    }
    if (data.containsKey('specification')) {
      context.handle(
        _specificationMeta,
        specification.isAcceptableOrUnknown(
          data['specification']!,
          _specificationMeta,
        ),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('stock_warning_value')) {
      context.handle(
        _stockWarningValueMeta,
        stockWarningValue.isAcceptableOrUnknown(
          data['stock_warning_value']!,
          _stockWarningValueMeta,
        ),
      );
    }
    if (data.containsKey('shelf_life')) {
      context.handle(
        _shelfLifeMeta,
        shelfLife.isAcceptableOrUnknown(data['shelf_life']!, _shelfLifeMeta),
      );
    }
    if (data.containsKey('enable_batch_management')) {
      context.handle(
        _enableBatchManagementMeta,
        enableBatchManagement.isAcceptableOrUnknown(
          data['enable_batch_management']!,
          _enableBatchManagementMeta,
        ),
      );
    }
    if (data.containsKey('remarks')) {
      context.handle(
        _remarksMeta,
        remarks.isAcceptableOrUnknown(data['remarks']!, _remarksMeta),
      );
    }
    if (data.containsKey('last_updated')) {
      context.handle(
        _lastUpdatedMeta,
        lastUpdated.isAcceptableOrUnknown(
          data['last_updated']!,
          _lastUpdatedMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      sku: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sku'],
      ),
      image: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image'],
      ),
      baseUnitId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_unit_id'],
      )!,
      categoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}category_id'],
      ),
      specification: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}specification'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      ),
      suggestedRetailPrice: $ProductTable.$convertersuggestedRetailPricen
          .fromSql(
            attachedDatabase.typeMapping.read(
              DriftSqlType.int,
              data['${effectivePrefix}suggested_retail_price'],
            ),
          ),
      retailPrice: $ProductTable.$converterretailPricen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.int,
          data['${effectivePrefix}retail_price'],
        ),
      ),
      promotionalPrice: $ProductTable.$converterpromotionalPricen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.int,
          data['${effectivePrefix}promotional_price'],
        ),
      ),
      stockWarningValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}stock_warning_value'],
      ),
      shelfLife: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shelf_life'],
      ),
      shelfLifeUnit: $ProductTable.$convertershelfLifeUnit.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}shelf_life_unit'],
        )!,
      ),
      enableBatchManagement: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}enable_batch_management'],
      )!,
      status: $ProductTable.$converterstatus.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}status'],
        )!,
      ),
      remarks: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remarks'],
      ),
      lastUpdated: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_updated'],
      ),
    );
  }

  @override
  $ProductTable createAlias(String alias) {
    return $ProductTable(attachedDatabase, alias);
  }

  static TypeConverter<Money, int> $convertersuggestedRetailPrice =
      const MoneyConverter();
  static TypeConverter<Money?, int?> $convertersuggestedRetailPricen =
      NullAwareTypeConverter.wrap($convertersuggestedRetailPrice);
  static TypeConverter<Money, int> $converterretailPrice =
      const MoneyConverter();
  static TypeConverter<Money?, int?> $converterretailPricen =
      NullAwareTypeConverter.wrap($converterretailPrice);
  static TypeConverter<Money, int> $converterpromotionalPrice =
      const MoneyConverter();
  static TypeConverter<Money?, int?> $converterpromotionalPricen =
      NullAwareTypeConverter.wrap($converterpromotionalPrice);
  static JsonTypeConverter2<ShelfLifeUnit, String, String>
  $convertershelfLifeUnit = const EnumNameConverter(ShelfLifeUnit.values);
  static JsonTypeConverter2<ProductStatus, String, String> $converterstatus =
      const EnumNameConverter(ProductStatus.values);
}

class ProductData extends DataClass implements Insertable<ProductData> {
  final int id;
  final String name;
  final String? sku;
  final String? image;
  final int baseUnitId;
  final int? categoryId;
  final String? specification;
  final String? brand;
  final Money? suggestedRetailPrice;
  final Money? retailPrice;
  final Money? promotionalPrice;
  final int? stockWarningValue;
  final int? shelfLife;
  final ShelfLifeUnit shelfLifeUnit;
  final bool enableBatchManagement;
  final ProductStatus status;
  final String? remarks;
  final DateTime? lastUpdated;
  const ProductData({
    required this.id,
    required this.name,
    this.sku,
    this.image,
    required this.baseUnitId,
    this.categoryId,
    this.specification,
    this.brand,
    this.suggestedRetailPrice,
    this.retailPrice,
    this.promotionalPrice,
    this.stockWarningValue,
    this.shelfLife,
    required this.shelfLifeUnit,
    required this.enableBatchManagement,
    required this.status,
    this.remarks,
    this.lastUpdated,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || sku != null) {
      map['sku'] = Variable<String>(sku);
    }
    if (!nullToAbsent || image != null) {
      map['image'] = Variable<String>(image);
    }
    map['base_unit_id'] = Variable<int>(baseUnitId);
    if (!nullToAbsent || categoryId != null) {
      map['category_id'] = Variable<int>(categoryId);
    }
    if (!nullToAbsent || specification != null) {
      map['specification'] = Variable<String>(specification);
    }
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    if (!nullToAbsent || suggestedRetailPrice != null) {
      map['suggested_retail_price'] = Variable<int>(
        $ProductTable.$convertersuggestedRetailPricen.toSql(
          suggestedRetailPrice,
        ),
      );
    }
    if (!nullToAbsent || retailPrice != null) {
      map['retail_price'] = Variable<int>(
        $ProductTable.$converterretailPricen.toSql(retailPrice),
      );
    }
    if (!nullToAbsent || promotionalPrice != null) {
      map['promotional_price'] = Variable<int>(
        $ProductTable.$converterpromotionalPricen.toSql(promotionalPrice),
      );
    }
    if (!nullToAbsent || stockWarningValue != null) {
      map['stock_warning_value'] = Variable<int>(stockWarningValue);
    }
    if (!nullToAbsent || shelfLife != null) {
      map['shelf_life'] = Variable<int>(shelfLife);
    }
    {
      map['shelf_life_unit'] = Variable<String>(
        $ProductTable.$convertershelfLifeUnit.toSql(shelfLifeUnit),
      );
    }
    map['enable_batch_management'] = Variable<bool>(enableBatchManagement);
    {
      map['status'] = Variable<String>(
        $ProductTable.$converterstatus.toSql(status),
      );
    }
    if (!nullToAbsent || remarks != null) {
      map['remarks'] = Variable<String>(remarks);
    }
    if (!nullToAbsent || lastUpdated != null) {
      map['last_updated'] = Variable<DateTime>(lastUpdated);
    }
    return map;
  }

  ProductCompanion toCompanion(bool nullToAbsent) {
    return ProductCompanion(
      id: Value(id),
      name: Value(name),
      sku: sku == null && nullToAbsent ? const Value.absent() : Value(sku),
      image: image == null && nullToAbsent
          ? const Value.absent()
          : Value(image),
      baseUnitId: Value(baseUnitId),
      categoryId: categoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(categoryId),
      specification: specification == null && nullToAbsent
          ? const Value.absent()
          : Value(specification),
      brand: brand == null && nullToAbsent
          ? const Value.absent()
          : Value(brand),
      suggestedRetailPrice: suggestedRetailPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(suggestedRetailPrice),
      retailPrice: retailPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(retailPrice),
      promotionalPrice: promotionalPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(promotionalPrice),
      stockWarningValue: stockWarningValue == null && nullToAbsent
          ? const Value.absent()
          : Value(stockWarningValue),
      shelfLife: shelfLife == null && nullToAbsent
          ? const Value.absent()
          : Value(shelfLife),
      shelfLifeUnit: Value(shelfLifeUnit),
      enableBatchManagement: Value(enableBatchManagement),
      status: Value(status),
      remarks: remarks == null && nullToAbsent
          ? const Value.absent()
          : Value(remarks),
      lastUpdated: lastUpdated == null && nullToAbsent
          ? const Value.absent()
          : Value(lastUpdated),
    );
  }

  factory ProductData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductData(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      sku: serializer.fromJson<String?>(json['sku']),
      image: serializer.fromJson<String?>(json['image']),
      baseUnitId: serializer.fromJson<int>(json['baseUnitId']),
      categoryId: serializer.fromJson<int?>(json['categoryId']),
      specification: serializer.fromJson<String?>(json['specification']),
      brand: serializer.fromJson<String?>(json['brand']),
      suggestedRetailPrice: serializer.fromJson<Money?>(
        json['suggestedRetailPrice'],
      ),
      retailPrice: serializer.fromJson<Money?>(json['retailPrice']),
      promotionalPrice: serializer.fromJson<Money?>(json['promotionalPrice']),
      stockWarningValue: serializer.fromJson<int?>(json['stockWarningValue']),
      shelfLife: serializer.fromJson<int?>(json['shelfLife']),
      shelfLifeUnit: $ProductTable.$convertershelfLifeUnit.fromJson(
        serializer.fromJson<String>(json['shelfLifeUnit']),
      ),
      enableBatchManagement: serializer.fromJson<bool>(
        json['enableBatchManagement'],
      ),
      status: $ProductTable.$converterstatus.fromJson(
        serializer.fromJson<String>(json['status']),
      ),
      remarks: serializer.fromJson<String?>(json['remarks']),
      lastUpdated: serializer.fromJson<DateTime?>(json['lastUpdated']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'sku': serializer.toJson<String?>(sku),
      'image': serializer.toJson<String?>(image),
      'baseUnitId': serializer.toJson<int>(baseUnitId),
      'categoryId': serializer.toJson<int?>(categoryId),
      'specification': serializer.toJson<String?>(specification),
      'brand': serializer.toJson<String?>(brand),
      'suggestedRetailPrice': serializer.toJson<Money?>(suggestedRetailPrice),
      'retailPrice': serializer.toJson<Money?>(retailPrice),
      'promotionalPrice': serializer.toJson<Money?>(promotionalPrice),
      'stockWarningValue': serializer.toJson<int?>(stockWarningValue),
      'shelfLife': serializer.toJson<int?>(shelfLife),
      'shelfLifeUnit': serializer.toJson<String>(
        $ProductTable.$convertershelfLifeUnit.toJson(shelfLifeUnit),
      ),
      'enableBatchManagement': serializer.toJson<bool>(enableBatchManagement),
      'status': serializer.toJson<String>(
        $ProductTable.$converterstatus.toJson(status),
      ),
      'remarks': serializer.toJson<String?>(remarks),
      'lastUpdated': serializer.toJson<DateTime?>(lastUpdated),
    };
  }

  ProductData copyWith({
    int? id,
    String? name,
    Value<String?> sku = const Value.absent(),
    Value<String?> image = const Value.absent(),
    int? baseUnitId,
    Value<int?> categoryId = const Value.absent(),
    Value<String?> specification = const Value.absent(),
    Value<String?> brand = const Value.absent(),
    Value<Money?> suggestedRetailPrice = const Value.absent(),
    Value<Money?> retailPrice = const Value.absent(),
    Value<Money?> promotionalPrice = const Value.absent(),
    Value<int?> stockWarningValue = const Value.absent(),
    Value<int?> shelfLife = const Value.absent(),
    ShelfLifeUnit? shelfLifeUnit,
    bool? enableBatchManagement,
    ProductStatus? status,
    Value<String?> remarks = const Value.absent(),
    Value<DateTime?> lastUpdated = const Value.absent(),
  }) => ProductData(
    id: id ?? this.id,
    name: name ?? this.name,
    sku: sku.present ? sku.value : this.sku,
    image: image.present ? image.value : this.image,
    baseUnitId: baseUnitId ?? this.baseUnitId,
    categoryId: categoryId.present ? categoryId.value : this.categoryId,
    specification: specification.present
        ? specification.value
        : this.specification,
    brand: brand.present ? brand.value : this.brand,
    suggestedRetailPrice: suggestedRetailPrice.present
        ? suggestedRetailPrice.value
        : this.suggestedRetailPrice,
    retailPrice: retailPrice.present ? retailPrice.value : this.retailPrice,
    promotionalPrice: promotionalPrice.present
        ? promotionalPrice.value
        : this.promotionalPrice,
    stockWarningValue: stockWarningValue.present
        ? stockWarningValue.value
        : this.stockWarningValue,
    shelfLife: shelfLife.present ? shelfLife.value : this.shelfLife,
    shelfLifeUnit: shelfLifeUnit ?? this.shelfLifeUnit,
    enableBatchManagement: enableBatchManagement ?? this.enableBatchManagement,
    status: status ?? this.status,
    remarks: remarks.present ? remarks.value : this.remarks,
    lastUpdated: lastUpdated.present ? lastUpdated.value : this.lastUpdated,
  );
  ProductData copyWithCompanion(ProductCompanion data) {
    return ProductData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      sku: data.sku.present ? data.sku.value : this.sku,
      image: data.image.present ? data.image.value : this.image,
      baseUnitId: data.baseUnitId.present
          ? data.baseUnitId.value
          : this.baseUnitId,
      categoryId: data.categoryId.present
          ? data.categoryId.value
          : this.categoryId,
      specification: data.specification.present
          ? data.specification.value
          : this.specification,
      brand: data.brand.present ? data.brand.value : this.brand,
      suggestedRetailPrice: data.suggestedRetailPrice.present
          ? data.suggestedRetailPrice.value
          : this.suggestedRetailPrice,
      retailPrice: data.retailPrice.present
          ? data.retailPrice.value
          : this.retailPrice,
      promotionalPrice: data.promotionalPrice.present
          ? data.promotionalPrice.value
          : this.promotionalPrice,
      stockWarningValue: data.stockWarningValue.present
          ? data.stockWarningValue.value
          : this.stockWarningValue,
      shelfLife: data.shelfLife.present ? data.shelfLife.value : this.shelfLife,
      shelfLifeUnit: data.shelfLifeUnit.present
          ? data.shelfLifeUnit.value
          : this.shelfLifeUnit,
      enableBatchManagement: data.enableBatchManagement.present
          ? data.enableBatchManagement.value
          : this.enableBatchManagement,
      status: data.status.present ? data.status.value : this.status,
      remarks: data.remarks.present ? data.remarks.value : this.remarks,
      lastUpdated: data.lastUpdated.present
          ? data.lastUpdated.value
          : this.lastUpdated,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('sku: $sku, ')
          ..write('image: $image, ')
          ..write('baseUnitId: $baseUnitId, ')
          ..write('categoryId: $categoryId, ')
          ..write('specification: $specification, ')
          ..write('brand: $brand, ')
          ..write('suggestedRetailPrice: $suggestedRetailPrice, ')
          ..write('retailPrice: $retailPrice, ')
          ..write('promotionalPrice: $promotionalPrice, ')
          ..write('stockWarningValue: $stockWarningValue, ')
          ..write('shelfLife: $shelfLife, ')
          ..write('shelfLifeUnit: $shelfLifeUnit, ')
          ..write('enableBatchManagement: $enableBatchManagement, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('lastUpdated: $lastUpdated')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    sku,
    image,
    baseUnitId,
    categoryId,
    specification,
    brand,
    suggestedRetailPrice,
    retailPrice,
    promotionalPrice,
    stockWarningValue,
    shelfLife,
    shelfLifeUnit,
    enableBatchManagement,
    status,
    remarks,
    lastUpdated,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductData &&
          other.id == this.id &&
          other.name == this.name &&
          other.sku == this.sku &&
          other.image == this.image &&
          other.baseUnitId == this.baseUnitId &&
          other.categoryId == this.categoryId &&
          other.specification == this.specification &&
          other.brand == this.brand &&
          other.suggestedRetailPrice == this.suggestedRetailPrice &&
          other.retailPrice == this.retailPrice &&
          other.promotionalPrice == this.promotionalPrice &&
          other.stockWarningValue == this.stockWarningValue &&
          other.shelfLife == this.shelfLife &&
          other.shelfLifeUnit == this.shelfLifeUnit &&
          other.enableBatchManagement == this.enableBatchManagement &&
          other.status == this.status &&
          other.remarks == this.remarks &&
          other.lastUpdated == this.lastUpdated);
}

class ProductCompanion extends UpdateCompanion<ProductData> {
  final Value<int> id;
  final Value<String> name;
  final Value<String?> sku;
  final Value<String?> image;
  final Value<int> baseUnitId;
  final Value<int?> categoryId;
  final Value<String?> specification;
  final Value<String?> brand;
  final Value<Money?> suggestedRetailPrice;
  final Value<Money?> retailPrice;
  final Value<Money?> promotionalPrice;
  final Value<int?> stockWarningValue;
  final Value<int?> shelfLife;
  final Value<ShelfLifeUnit> shelfLifeUnit;
  final Value<bool> enableBatchManagement;
  final Value<ProductStatus> status;
  final Value<String?> remarks;
  final Value<DateTime?> lastUpdated;
  const ProductCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.sku = const Value.absent(),
    this.image = const Value.absent(),
    this.baseUnitId = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.specification = const Value.absent(),
    this.brand = const Value.absent(),
    this.suggestedRetailPrice = const Value.absent(),
    this.retailPrice = const Value.absent(),
    this.promotionalPrice = const Value.absent(),
    this.stockWarningValue = const Value.absent(),
    this.shelfLife = const Value.absent(),
    this.shelfLifeUnit = const Value.absent(),
    this.enableBatchManagement = const Value.absent(),
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.lastUpdated = const Value.absent(),
  });
  ProductCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    this.sku = const Value.absent(),
    this.image = const Value.absent(),
    required int baseUnitId,
    this.categoryId = const Value.absent(),
    this.specification = const Value.absent(),
    this.brand = const Value.absent(),
    this.suggestedRetailPrice = const Value.absent(),
    this.retailPrice = const Value.absent(),
    this.promotionalPrice = const Value.absent(),
    this.stockWarningValue = const Value.absent(),
    this.shelfLife = const Value.absent(),
    this.shelfLifeUnit = const Value.absent(),
    this.enableBatchManagement = const Value.absent(),
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.lastUpdated = const Value.absent(),
  }) : name = Value(name),
       baseUnitId = Value(baseUnitId);
  static Insertable<ProductData> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<String>? sku,
    Expression<String>? image,
    Expression<int>? baseUnitId,
    Expression<int>? categoryId,
    Expression<String>? specification,
    Expression<String>? brand,
    Expression<int>? suggestedRetailPrice,
    Expression<int>? retailPrice,
    Expression<int>? promotionalPrice,
    Expression<int>? stockWarningValue,
    Expression<int>? shelfLife,
    Expression<String>? shelfLifeUnit,
    Expression<bool>? enableBatchManagement,
    Expression<String>? status,
    Expression<String>? remarks,
    Expression<DateTime>? lastUpdated,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (sku != null) 'sku': sku,
      if (image != null) 'image': image,
      if (baseUnitId != null) 'base_unit_id': baseUnitId,
      if (categoryId != null) 'category_id': categoryId,
      if (specification != null) 'specification': specification,
      if (brand != null) 'brand': brand,
      if (suggestedRetailPrice != null)
        'suggested_retail_price': suggestedRetailPrice,
      if (retailPrice != null) 'retail_price': retailPrice,
      if (promotionalPrice != null) 'promotional_price': promotionalPrice,
      if (stockWarningValue != null) 'stock_warning_value': stockWarningValue,
      if (shelfLife != null) 'shelf_life': shelfLife,
      if (shelfLifeUnit != null) 'shelf_life_unit': shelfLifeUnit,
      if (enableBatchManagement != null)
        'enable_batch_management': enableBatchManagement,
      if (status != null) 'status': status,
      if (remarks != null) 'remarks': remarks,
      if (lastUpdated != null) 'last_updated': lastUpdated,
    });
  }

  ProductCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<String?>? sku,
    Value<String?>? image,
    Value<int>? baseUnitId,
    Value<int?>? categoryId,
    Value<String?>? specification,
    Value<String?>? brand,
    Value<Money?>? suggestedRetailPrice,
    Value<Money?>? retailPrice,
    Value<Money?>? promotionalPrice,
    Value<int?>? stockWarningValue,
    Value<int?>? shelfLife,
    Value<ShelfLifeUnit>? shelfLifeUnit,
    Value<bool>? enableBatchManagement,
    Value<ProductStatus>? status,
    Value<String?>? remarks,
    Value<DateTime?>? lastUpdated,
  }) {
    return ProductCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      sku: sku ?? this.sku,
      image: image ?? this.image,
      baseUnitId: baseUnitId ?? this.baseUnitId,
      categoryId: categoryId ?? this.categoryId,
      specification: specification ?? this.specification,
      brand: brand ?? this.brand,
      suggestedRetailPrice: suggestedRetailPrice ?? this.suggestedRetailPrice,
      retailPrice: retailPrice ?? this.retailPrice,
      promotionalPrice: promotionalPrice ?? this.promotionalPrice,
      stockWarningValue: stockWarningValue ?? this.stockWarningValue,
      shelfLife: shelfLife ?? this.shelfLife,
      shelfLifeUnit: shelfLifeUnit ?? this.shelfLifeUnit,
      enableBatchManagement:
          enableBatchManagement ?? this.enableBatchManagement,
      status: status ?? this.status,
      remarks: remarks ?? this.remarks,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (sku.present) {
      map['sku'] = Variable<String>(sku.value);
    }
    if (image.present) {
      map['image'] = Variable<String>(image.value);
    }
    if (baseUnitId.present) {
      map['base_unit_id'] = Variable<int>(baseUnitId.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<int>(categoryId.value);
    }
    if (specification.present) {
      map['specification'] = Variable<String>(specification.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (suggestedRetailPrice.present) {
      map['suggested_retail_price'] = Variable<int>(
        $ProductTable.$convertersuggestedRetailPricen.toSql(
          suggestedRetailPrice.value,
        ),
      );
    }
    if (retailPrice.present) {
      map['retail_price'] = Variable<int>(
        $ProductTable.$converterretailPricen.toSql(retailPrice.value),
      );
    }
    if (promotionalPrice.present) {
      map['promotional_price'] = Variable<int>(
        $ProductTable.$converterpromotionalPricen.toSql(promotionalPrice.value),
      );
    }
    if (stockWarningValue.present) {
      map['stock_warning_value'] = Variable<int>(stockWarningValue.value);
    }
    if (shelfLife.present) {
      map['shelf_life'] = Variable<int>(shelfLife.value);
    }
    if (shelfLifeUnit.present) {
      map['shelf_life_unit'] = Variable<String>(
        $ProductTable.$convertershelfLifeUnit.toSql(shelfLifeUnit.value),
      );
    }
    if (enableBatchManagement.present) {
      map['enable_batch_management'] = Variable<bool>(
        enableBatchManagement.value,
      );
    }
    if (status.present) {
      map['status'] = Variable<String>(
        $ProductTable.$converterstatus.toSql(status.value),
      );
    }
    if (remarks.present) {
      map['remarks'] = Variable<String>(remarks.value);
    }
    if (lastUpdated.present) {
      map['last_updated'] = Variable<DateTime>(lastUpdated.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('sku: $sku, ')
          ..write('image: $image, ')
          ..write('baseUnitId: $baseUnitId, ')
          ..write('categoryId: $categoryId, ')
          ..write('specification: $specification, ')
          ..write('brand: $brand, ')
          ..write('suggestedRetailPrice: $suggestedRetailPrice, ')
          ..write('retailPrice: $retailPrice, ')
          ..write('promotionalPrice: $promotionalPrice, ')
          ..write('stockWarningValue: $stockWarningValue, ')
          ..write('shelfLife: $shelfLife, ')
          ..write('shelfLifeUnit: $shelfLifeUnit, ')
          ..write('enableBatchManagement: $enableBatchManagement, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('lastUpdated: $lastUpdated')
          ..write(')'))
        .toString();
  }
}

class $UnitProductTable extends UnitProduct
    with TableInfo<$UnitProductTable, UnitProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UnitProductTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _unitIdMeta = const VerificationMeta('unitId');
  @override
  late final GeneratedColumn<int> unitId = GeneratedColumn<int>(
    'unit_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES unit (id)',
    ),
  );
  static const VerificationMeta _conversionRateMeta = const VerificationMeta(
    'conversionRate',
  );
  @override
  late final GeneratedColumn<int> conversionRate = GeneratedColumn<int>(
    'conversion_rate',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sellingPriceInCentsMeta =
      const VerificationMeta('sellingPriceInCents');
  @override
  late final GeneratedColumn<int> sellingPriceInCents = GeneratedColumn<int>(
    'selling_price_in_cents',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _wholesalePriceInCentsMeta =
      const VerificationMeta('wholesalePriceInCents');
  @override
  late final GeneratedColumn<int> wholesalePriceInCents = GeneratedColumn<int>(
    'wholesale_price_in_cents',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastUpdatedMeta = const VerificationMeta(
    'lastUpdated',
  );
  @override
  late final GeneratedColumn<DateTime> lastUpdated = GeneratedColumn<DateTime>(
    'last_updated',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    productId,
    unitId,
    conversionRate,
    sellingPriceInCents,
    wholesalePriceInCents,
    lastUpdated,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'unit_product';
  @override
  VerificationContext validateIntegrity(
    Insertable<UnitProductData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('unit_id')) {
      context.handle(
        _unitIdMeta,
        unitId.isAcceptableOrUnknown(data['unit_id']!, _unitIdMeta),
      );
    } else if (isInserting) {
      context.missing(_unitIdMeta);
    }
    if (data.containsKey('conversion_rate')) {
      context.handle(
        _conversionRateMeta,
        conversionRate.isAcceptableOrUnknown(
          data['conversion_rate']!,
          _conversionRateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conversionRateMeta);
    }
    if (data.containsKey('selling_price_in_cents')) {
      context.handle(
        _sellingPriceInCentsMeta,
        sellingPriceInCents.isAcceptableOrUnknown(
          data['selling_price_in_cents']!,
          _sellingPriceInCentsMeta,
        ),
      );
    }
    if (data.containsKey('wholesale_price_in_cents')) {
      context.handle(
        _wholesalePriceInCentsMeta,
        wholesalePriceInCents.isAcceptableOrUnknown(
          data['wholesale_price_in_cents']!,
          _wholesalePriceInCentsMeta,
        ),
      );
    }
    if (data.containsKey('last_updated')) {
      context.handle(
        _lastUpdatedMeta,
        lastUpdated.isAcceptableOrUnknown(
          data['last_updated']!,
          _lastUpdatedMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {productId, unitId},
  ];
  @override
  UnitProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UnitProductData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      unitId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}unit_id'],
      )!,
      conversionRate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}conversion_rate'],
      )!,
      sellingPriceInCents: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}selling_price_in_cents'],
      ),
      wholesalePriceInCents: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wholesale_price_in_cents'],
      ),
      lastUpdated: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_updated'],
      )!,
    );
  }

  @override
  $UnitProductTable createAlias(String alias) {
    return $UnitProductTable(attachedDatabase, alias);
  }
}

class UnitProductData extends DataClass implements Insertable<UnitProductData> {
  /// ä¸»é”® - ID
  final int id;

  /// å¤–é”® - äº§å“ID
  final int productId;

  /// å¤–é”® - å•ä½ID
  final int unitId;

  /// æ¢ç®—ç‡ï¼ˆç›¸å¯¹äºåŸºç¡€å•ä½ï¼?  final int conversionRate;

  /// å”®ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½å­˜å‚¨ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼?  final int? sellingPriceInCents;

  /// æ‰¹å‘ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½å­˜å‚¨ï¼‰
  final int? wholesalePriceInCents;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime lastUpdated;
  const UnitProductData({
    required this.id,
    required this.productId,
    required this.unitId,
    required this.conversionRate,
    this.sellingPriceInCents,
    this.wholesalePriceInCents,
    required this.lastUpdated,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_id'] = Variable<int>(productId);
    map['unit_id'] = Variable<int>(unitId);
    map['conversion_rate'] = Variable<int>(conversionRate);
    if (!nullToAbsent || sellingPriceInCents != null) {
      map['selling_price_in_cents'] = Variable<int>(sellingPriceInCents);
    }
    if (!nullToAbsent || wholesalePriceInCents != null) {
      map['wholesale_price_in_cents'] = Variable<int>(wholesalePriceInCents);
    }
    map['last_updated'] = Variable<DateTime>(lastUpdated);
    return map;
  }

  UnitProductCompanion toCompanion(bool nullToAbsent) {
    return UnitProductCompanion(
      id: Value(id),
      productId: Value(productId),
      unitId: Value(unitId),
      conversionRate: Value(conversionRate),
      sellingPriceInCents: sellingPriceInCents == null && nullToAbsent
          ? const Value.absent()
          : Value(sellingPriceInCents),
      wholesalePriceInCents: wholesalePriceInCents == null && nullToAbsent
          ? const Value.absent()
          : Value(wholesalePriceInCents),
      lastUpdated: Value(lastUpdated),
    );
  }

  factory UnitProductData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UnitProductData(
      id: serializer.fromJson<int>(json['id']),
      productId: serializer.fromJson<int>(json['productId']),
      unitId: serializer.fromJson<int>(json['unitId']),
      conversionRate: serializer.fromJson<int>(json['conversionRate']),
      sellingPriceInCents: serializer.fromJson<int?>(
        json['sellingPriceInCents'],
      ),
      wholesalePriceInCents: serializer.fromJson<int?>(
        json['wholesalePriceInCents'],
      ),
      lastUpdated: serializer.fromJson<DateTime>(json['lastUpdated']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productId': serializer.toJson<int>(productId),
      'unitId': serializer.toJson<int>(unitId),
      'conversionRate': serializer.toJson<int>(conversionRate),
      'sellingPriceInCents': serializer.toJson<int?>(sellingPriceInCents),
      'wholesalePriceInCents': serializer.toJson<int?>(wholesalePriceInCents),
      'lastUpdated': serializer.toJson<DateTime>(lastUpdated),
    };
  }

  UnitProductData copyWith({
    int? id,
    int? productId,
    int? unitId,
    int? conversionRate,
    Value<int?> sellingPriceInCents = const Value.absent(),
    Value<int?> wholesalePriceInCents = const Value.absent(),
    DateTime? lastUpdated,
  }) => UnitProductData(
    id: id ?? this.id,
    productId: productId ?? this.productId,
    unitId: unitId ?? this.unitId,
    conversionRate: conversionRate ?? this.conversionRate,
    sellingPriceInCents: sellingPriceInCents.present
        ? sellingPriceInCents.value
        : this.sellingPriceInCents,
    wholesalePriceInCents: wholesalePriceInCents.present
        ? wholesalePriceInCents.value
        : this.wholesalePriceInCents,
    lastUpdated: lastUpdated ?? this.lastUpdated,
  );
  UnitProductData copyWithCompanion(UnitProductCompanion data) {
    return UnitProductData(
      id: data.id.present ? data.id.value : this.id,
      productId: data.productId.present ? data.productId.value : this.productId,
      unitId: data.unitId.present ? data.unitId.value : this.unitId,
      conversionRate: data.conversionRate.present
          ? data.conversionRate.value
          : this.conversionRate,
      sellingPriceInCents: data.sellingPriceInCents.present
          ? data.sellingPriceInCents.value
          : this.sellingPriceInCents,
      wholesalePriceInCents: data.wholesalePriceInCents.present
          ? data.wholesalePriceInCents.value
          : this.wholesalePriceInCents,
      lastUpdated: data.lastUpdated.present
          ? data.lastUpdated.value
          : this.lastUpdated,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UnitProductData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('unitId: $unitId, ')
          ..write('conversionRate: $conversionRate, ')
          ..write('sellingPriceInCents: $sellingPriceInCents, ')
          ..write('wholesalePriceInCents: $wholesalePriceInCents, ')
          ..write('lastUpdated: $lastUpdated')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    productId,
    unitId,
    conversionRate,
    sellingPriceInCents,
    wholesalePriceInCents,
    lastUpdated,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UnitProductData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.unitId == this.unitId &&
          other.conversionRate == this.conversionRate &&
          other.sellingPriceInCents == this.sellingPriceInCents &&
          other.wholesalePriceInCents == this.wholesalePriceInCents &&
          other.lastUpdated == this.lastUpdated);
}

class UnitProductCompanion extends UpdateCompanion<UnitProductData> {
  final Value<int> id;
  final Value<int> productId;
  final Value<int> unitId;
  final Value<int> conversionRate;
  final Value<int?> sellingPriceInCents;
  final Value<int?> wholesalePriceInCents;
  final Value<DateTime> lastUpdated;
  const UnitProductCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.unitId = const Value.absent(),
    this.conversionRate = const Value.absent(),
    this.sellingPriceInCents = const Value.absent(),
    this.wholesalePriceInCents = const Value.absent(),
    this.lastUpdated = const Value.absent(),
  });
  UnitProductCompanion.insert({
    this.id = const Value.absent(),
    required int productId,
    required int unitId,
    required int conversionRate,
    this.sellingPriceInCents = const Value.absent(),
    this.wholesalePriceInCents = const Value.absent(),
    this.lastUpdated = const Value.absent(),
  }) : productId = Value(productId),
       unitId = Value(unitId),
       conversionRate = Value(conversionRate);
  static Insertable<UnitProductData> custom({
    Expression<int>? id,
    Expression<int>? productId,
    Expression<int>? unitId,
    Expression<int>? conversionRate,
    Expression<int>? sellingPriceInCents,
    Expression<int>? wholesalePriceInCents,
    Expression<DateTime>? lastUpdated,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (unitId != null) 'unit_id': unitId,
      if (conversionRate != null) 'conversion_rate': conversionRate,
      if (sellingPriceInCents != null)
        'selling_price_in_cents': sellingPriceInCents,
      if (wholesalePriceInCents != null)
        'wholesale_price_in_cents': wholesalePriceInCents,
      if (lastUpdated != null) 'last_updated': lastUpdated,
    });
  }

  UnitProductCompanion copyWith({
    Value<int>? id,
    Value<int>? productId,
    Value<int>? unitId,
    Value<int>? conversionRate,
    Value<int?>? sellingPriceInCents,
    Value<int?>? wholesalePriceInCents,
    Value<DateTime>? lastUpdated,
  }) {
    return UnitProductCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      unitId: unitId ?? this.unitId,
      conversionRate: conversionRate ?? this.conversionRate,
      sellingPriceInCents: sellingPriceInCents ?? this.sellingPriceInCents,
      wholesalePriceInCents:
          wholesalePriceInCents ?? this.wholesalePriceInCents,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (unitId.present) {
      map['unit_id'] = Variable<int>(unitId.value);
    }
    if (conversionRate.present) {
      map['conversion_rate'] = Variable<int>(conversionRate.value);
    }
    if (sellingPriceInCents.present) {
      map['selling_price_in_cents'] = Variable<int>(sellingPriceInCents.value);
    }
    if (wholesalePriceInCents.present) {
      map['wholesale_price_in_cents'] = Variable<int>(
        wholesalePriceInCents.value,
      );
    }
    if (lastUpdated.present) {
      map['last_updated'] = Variable<DateTime>(lastUpdated.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UnitProductCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('unitId: $unitId, ')
          ..write('conversionRate: $conversionRate, ')
          ..write('sellingPriceInCents: $sellingPriceInCents, ')
          ..write('wholesalePriceInCents: $wholesalePriceInCents, ')
          ..write('lastUpdated: $lastUpdated')
          ..write(')'))
        .toString();
  }
}

class $ShopTable extends Shop with TableInfo<$ShopTable, ShopData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShopTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _managerMeta = const VerificationMeta(
    'manager',
  );
  @override
  late final GeneratedColumn<String> manager = GeneratedColumn<String>(
    'manager',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    manager,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shop';
  @override
  VerificationContext validateIntegrity(
    Insertable<ShopData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('manager')) {
      context.handle(
        _managerMeta,
        manager.isAcceptableOrUnknown(data['manager']!, _managerMeta),
      );
    } else if (isInserting) {
      context.missing(_managerMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ShopData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShopData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      manager: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}manager'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ShopTable createAlias(String alias) {
    return $ShopTable(attachedDatabase, alias);
  }
}

class ShopData extends DataClass implements Insertable<ShopData> {
  /// ä¸»é”® - åº—é“ºID
  final int id;

  /// åº—é“ºåç§°
  final String name;

  /// åº—é•¿
  final String manager;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const ShopData({
    required this.id,
    required this.name,
    required this.manager,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['manager'] = Variable<String>(manager);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ShopCompanion toCompanion(bool nullToAbsent) {
    return ShopCompanion(
      id: Value(id),
      name: Value(name),
      manager: Value(manager),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ShopData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ShopData(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      manager: serializer.fromJson<String>(json['manager']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'manager': serializer.toJson<String>(manager),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ShopData copyWith({
    int? id,
    String? name,
    String? manager,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ShopData(
    id: id ?? this.id,
    name: name ?? this.name,
    manager: manager ?? this.manager,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ShopData copyWithCompanion(ShopCompanion data) {
    return ShopData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      manager: data.manager.present ? data.manager.value : this.manager,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ShopData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('manager: $manager, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, manager, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShopData &&
          other.id == this.id &&
          other.name == this.name &&
          other.manager == this.manager &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ShopCompanion extends UpdateCompanion<ShopData> {
  final Value<int> id;
  final Value<String> name;
  final Value<String> manager;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ShopCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.manager = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ShopCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required String manager,
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : name = Value(name),
       manager = Value(manager);
  static Insertable<ShopData> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<String>? manager,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (manager != null) 'manager': manager,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ShopCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<String>? manager,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ShopCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      manager: manager ?? this.manager,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (manager.present) {
      map['manager'] = Variable<String>(manager.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShopCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('manager: $manager, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $SupplierTable extends Supplier
    with TableInfo<$SupplierTable, SupplierData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplierTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, createdAt, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplier';
  @override
  VerificationContext validateIntegrity(
    Insertable<SupplierData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplierData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplierData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SupplierTable createAlias(String alias) {
    return $SupplierTable(attachedDatabase, alias);
  }
}

class SupplierData extends DataClass implements Insertable<SupplierData> {
  /// ä¸»é”® - ä¾›åº”å•†ID
  final int id;

  /// ä¾›åº”å•†åç§?  final String name;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const SupplierData({
    required this.id,
    required this.name,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SupplierCompanion toCompanion(bool nullToAbsent) {
    return SupplierCompanion(
      id: Value(id),
      name: Value(name),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SupplierData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplierData(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SupplierData copyWith({
    int? id,
    String? name,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => SupplierData(
    id: id ?? this.id,
    name: name ?? this.name,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SupplierData copyWithCompanion(SupplierCompanion data) {
    return SupplierData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplierData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplierData &&
          other.id == this.id &&
          other.name == this.name &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SupplierCompanion extends UpdateCompanion<SupplierData> {
  final Value<int> id;
  final Value<String> name;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const SupplierCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SupplierCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : name = Value(name);
  static Insertable<SupplierData> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SupplierCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return SupplierCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplierCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ProductBatchTable extends ProductBatch
    with TableInfo<$ProductBatchTable, ProductBatchData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductBatchTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id) ON UPDATE CASCADE ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _productionDateMeta = const VerificationMeta(
    'productionDate',
  );
  @override
  late final GeneratedColumn<DateTime> productionDate =
      GeneratedColumn<DateTime>(
        'production_date',
        aliasedName,
        false,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _totalInboundQuantityMeta =
      const VerificationMeta('totalInboundQuantity');
  @override
  late final GeneratedColumn<int> totalInboundQuantity = GeneratedColumn<int>(
    'total_inbound_quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id) ON UPDATE CASCADE ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    productId,
    productionDate,
    totalInboundQuantity,
    shopId,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_batch';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProductBatchData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('production_date')) {
      context.handle(
        _productionDateMeta,
        productionDate.isAcceptableOrUnknown(
          data['production_date']!,
          _productionDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productionDateMeta);
    }
    if (data.containsKey('total_inbound_quantity')) {
      context.handle(
        _totalInboundQuantityMeta,
        totalInboundQuantity.isAcceptableOrUnknown(
          data['total_inbound_quantity']!,
          _totalInboundQuantityMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalInboundQuantityMeta);
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {productId, productionDate, shopId},
  ];
  @override
  ProductBatchData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductBatchData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      productionDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}production_date'],
      )!,
      totalInboundQuantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_inbound_quantity'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ProductBatchTable createAlias(String alias) {
    return $ProductBatchTable(attachedDatabase, alias);
  }
}

class ProductBatchData extends DataClass
    implements Insertable<ProductBatchData> {
  /// ä¸»é”®
  final int id;

  /// å¤–é”® - è´§å“ID
  final int productId;

  /// ç”Ÿäº§æ—¥æœŸ
  final DateTime productionDate;

  /// ç´¯è®¡å…¥åº“æ•°é‡ï¼Œéè´Ÿï¼Œå³åŒä¸€æ‰¹æ¬¡çš„è´§å“æ•°é‡?  final int totalInboundQuantity;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// åˆ›å»ºæ—¶é—´ï¼ˆç”±æ•°æ®åº“é»˜è®¤ç”Ÿæˆï¼‰
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—´ï¼ˆæ³¨æ„ï¼šä¸ä¼šè‡ªåŠ¨åœ¨æ›´æ–°æ—¶åˆ·æ–°ï¼Œéœ€è¦åº”ç”¨å±‚æˆ–è§¦å‘å™¨ç»´æŠ¤ï¼?  final DateTime updatedAt;
  const ProductBatchData({
    required this.id,
    required this.productId,
    required this.productionDate,
    required this.totalInboundQuantity,
    required this.shopId,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_id'] = Variable<int>(productId);
    map['production_date'] = Variable<DateTime>(productionDate);
    map['total_inbound_quantity'] = Variable<int>(totalInboundQuantity);
    map['shop_id'] = Variable<int>(shopId);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ProductBatchCompanion toCompanion(bool nullToAbsent) {
    return ProductBatchCompanion(
      id: Value(id),
      productId: Value(productId),
      productionDate: Value(productionDate),
      totalInboundQuantity: Value(totalInboundQuantity),
      shopId: Value(shopId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ProductBatchData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductBatchData(
      id: serializer.fromJson<int>(json['id']),
      productId: serializer.fromJson<int>(json['productId']),
      productionDate: serializer.fromJson<DateTime>(json['productionDate']),
      totalInboundQuantity: serializer.fromJson<int>(
        json['totalInboundQuantity'],
      ),
      shopId: serializer.fromJson<int>(json['shopId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productId': serializer.toJson<int>(productId),
      'productionDate': serializer.toJson<DateTime>(productionDate),
      'totalInboundQuantity': serializer.toJson<int>(totalInboundQuantity),
      'shopId': serializer.toJson<int>(shopId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ProductBatchData copyWith({
    int? id,
    int? productId,
    DateTime? productionDate,
    int? totalInboundQuantity,
    int? shopId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ProductBatchData(
    id: id ?? this.id,
    productId: productId ?? this.productId,
    productionDate: productionDate ?? this.productionDate,
    totalInboundQuantity: totalInboundQuantity ?? this.totalInboundQuantity,
    shopId: shopId ?? this.shopId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ProductBatchData copyWithCompanion(ProductBatchCompanion data) {
    return ProductBatchData(
      id: data.id.present ? data.id.value : this.id,
      productId: data.productId.present ? data.productId.value : this.productId,
      productionDate: data.productionDate.present
          ? data.productionDate.value
          : this.productionDate,
      totalInboundQuantity: data.totalInboundQuantity.present
          ? data.totalInboundQuantity.value
          : this.totalInboundQuantity,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductBatchData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('productionDate: $productionDate, ')
          ..write('totalInboundQuantity: $totalInboundQuantity, ')
          ..write('shopId: $shopId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    productId,
    productionDate,
    totalInboundQuantity,
    shopId,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductBatchData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.productionDate == this.productionDate &&
          other.totalInboundQuantity == this.totalInboundQuantity &&
          other.shopId == this.shopId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ProductBatchCompanion extends UpdateCompanion<ProductBatchData> {
  final Value<int> id;
  final Value<int> productId;
  final Value<DateTime> productionDate;
  final Value<int> totalInboundQuantity;
  final Value<int> shopId;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ProductBatchCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.productionDate = const Value.absent(),
    this.totalInboundQuantity = const Value.absent(),
    this.shopId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ProductBatchCompanion.insert({
    this.id = const Value.absent(),
    required int productId,
    required DateTime productionDate,
    required int totalInboundQuantity,
    required int shopId,
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : productId = Value(productId),
       productionDate = Value(productionDate),
       totalInboundQuantity = Value(totalInboundQuantity),
       shopId = Value(shopId);
  static Insertable<ProductBatchData> custom({
    Expression<int>? id,
    Expression<int>? productId,
    Expression<DateTime>? productionDate,
    Expression<int>? totalInboundQuantity,
    Expression<int>? shopId,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (productionDate != null) 'production_date': productionDate,
      if (totalInboundQuantity != null)
        'total_inbound_quantity': totalInboundQuantity,
      if (shopId != null) 'shop_id': shopId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ProductBatchCompanion copyWith({
    Value<int>? id,
    Value<int>? productId,
    Value<DateTime>? productionDate,
    Value<int>? totalInboundQuantity,
    Value<int>? shopId,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ProductBatchCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      productionDate: productionDate ?? this.productionDate,
      totalInboundQuantity: totalInboundQuantity ?? this.totalInboundQuantity,
      shopId: shopId ?? this.shopId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (productionDate.present) {
      map['production_date'] = Variable<DateTime>(productionDate.value);
    }
    if (totalInboundQuantity.present) {
      map['total_inbound_quantity'] = Variable<int>(totalInboundQuantity.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductBatchCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('productionDate: $productionDate, ')
          ..write('totalInboundQuantity: $totalInboundQuantity, ')
          ..write('shopId: $shopId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $StockTable extends Stock with TableInfo<$StockTable, StockData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _batchIdMeta = const VerificationMeta(
    'batchId',
  );
  @override
  late final GeneratedColumn<int> batchId = GeneratedColumn<int>(
    'batch_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_batch (id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _averageUnitPriceInCentsMeta =
      const VerificationMeta('averageUnitPriceInCents');
  @override
  late final GeneratedColumn<int> averageUnitPriceInCents =
      GeneratedColumn<int>(
        'average_unit_price_in_cents',
        aliasedName,
        false,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
        defaultValue: const Constant(0),
      );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    productId,
    batchId,
    quantity,
    averageUnitPriceInCents,
    shopId,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock';
  @override
  VerificationContext validateIntegrity(
    Insertable<StockData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('batch_id')) {
      context.handle(
        _batchIdMeta,
        batchId.isAcceptableOrUnknown(data['batch_id']!, _batchIdMeta),
      );
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('average_unit_price_in_cents')) {
      context.handle(
        _averageUnitPriceInCentsMeta,
        averageUnitPriceInCents.isAcceptableOrUnknown(
          data['average_unit_price_in_cents']!,
          _averageUnitPriceInCentsMeta,
        ),
      );
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      batchId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}batch_id'],
      ),
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      averageUnitPriceInCents: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}average_unit_price_in_cents'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $StockTable createAlias(String alias) {
    return $StockTable(attachedDatabase, alias);
  }
}

class StockData extends DataClass implements Insertable<StockData> {
  /// ä¸»é”® - åº“å­˜ID
  final int id;

  /// å¤–é”® - è´§å“ID
  final int productId;

  /// å¤–é”® - æ‰¹æ¬¡å?  final int? batchId;

  /// æ•°é‡
  final int quantity;

  /// ç§»åŠ¨åŠ æƒå¹³å‡å•ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼?  final int averageUnitPriceInCents;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const StockData({
    required this.id,
    required this.productId,
    this.batchId,
    required this.quantity,
    required this.averageUnitPriceInCents,
    required this.shopId,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_id'] = Variable<int>(productId);
    if (!nullToAbsent || batchId != null) {
      map['batch_id'] = Variable<int>(batchId);
    }
    map['quantity'] = Variable<int>(quantity);
    map['average_unit_price_in_cents'] = Variable<int>(averageUnitPriceInCents);
    map['shop_id'] = Variable<int>(shopId);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockCompanion toCompanion(bool nullToAbsent) {
    return StockCompanion(
      id: Value(id),
      productId: Value(productId),
      batchId: batchId == null && nullToAbsent
          ? const Value.absent()
          : Value(batchId),
      quantity: Value(quantity),
      averageUnitPriceInCents: Value(averageUnitPriceInCents),
      shopId: Value(shopId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockData(
      id: serializer.fromJson<int>(json['id']),
      productId: serializer.fromJson<int>(json['productId']),
      batchId: serializer.fromJson<int?>(json['batchId']),
      quantity: serializer.fromJson<int>(json['quantity']),
      averageUnitPriceInCents: serializer.fromJson<int>(
        json['averageUnitPriceInCents'],
      ),
      shopId: serializer.fromJson<int>(json['shopId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productId': serializer.toJson<int>(productId),
      'batchId': serializer.toJson<int?>(batchId),
      'quantity': serializer.toJson<int>(quantity),
      'averageUnitPriceInCents': serializer.toJson<int>(
        averageUnitPriceInCents,
      ),
      'shopId': serializer.toJson<int>(shopId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockData copyWith({
    int? id,
    int? productId,
    Value<int?> batchId = const Value.absent(),
    int? quantity,
    int? averageUnitPriceInCents,
    int? shopId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => StockData(
    id: id ?? this.id,
    productId: productId ?? this.productId,
    batchId: batchId.present ? batchId.value : this.batchId,
    quantity: quantity ?? this.quantity,
    averageUnitPriceInCents:
        averageUnitPriceInCents ?? this.averageUnitPriceInCents,
    shopId: shopId ?? this.shopId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  StockData copyWithCompanion(StockCompanion data) {
    return StockData(
      id: data.id.present ? data.id.value : this.id,
      productId: data.productId.present ? data.productId.value : this.productId,
      batchId: data.batchId.present ? data.batchId.value : this.batchId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      averageUnitPriceInCents: data.averageUnitPriceInCents.present
          ? data.averageUnitPriceInCents.value
          : this.averageUnitPriceInCents,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity, ')
          ..write('averageUnitPriceInCents: $averageUnitPriceInCents, ')
          ..write('shopId: $shopId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    productId,
    batchId,
    quantity,
    averageUnitPriceInCents,
    shopId,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.batchId == this.batchId &&
          other.quantity == this.quantity &&
          other.averageUnitPriceInCents == this.averageUnitPriceInCents &&
          other.shopId == this.shopId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StockCompanion extends UpdateCompanion<StockData> {
  final Value<int> id;
  final Value<int> productId;
  final Value<int?> batchId;
  final Value<int> quantity;
  final Value<int> averageUnitPriceInCents;
  final Value<int> shopId;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const StockCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.batchId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.averageUnitPriceInCents = const Value.absent(),
    this.shopId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockCompanion.insert({
    this.id = const Value.absent(),
    required int productId,
    this.batchId = const Value.absent(),
    required int quantity,
    this.averageUnitPriceInCents = const Value.absent(),
    required int shopId,
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : productId = Value(productId),
       quantity = Value(quantity),
       shopId = Value(shopId);
  static Insertable<StockData> custom({
    Expression<int>? id,
    Expression<int>? productId,
    Expression<int>? batchId,
    Expression<int>? quantity,
    Expression<int>? averageUnitPriceInCents,
    Expression<int>? shopId,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (batchId != null) 'batch_id': batchId,
      if (quantity != null) 'quantity': quantity,
      if (averageUnitPriceInCents != null)
        'average_unit_price_in_cents': averageUnitPriceInCents,
      if (shopId != null) 'shop_id': shopId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockCompanion copyWith({
    Value<int>? id,
    Value<int>? productId,
    Value<int?>? batchId,
    Value<int>? quantity,
    Value<int>? averageUnitPriceInCents,
    Value<int>? shopId,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return StockCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      batchId: batchId ?? this.batchId,
      quantity: quantity ?? this.quantity,
      averageUnitPriceInCents:
          averageUnitPriceInCents ?? this.averageUnitPriceInCents,
      shopId: shopId ?? this.shopId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (batchId.present) {
      map['batch_id'] = Variable<int>(batchId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (averageUnitPriceInCents.present) {
      map['average_unit_price_in_cents'] = Variable<int>(
        averageUnitPriceInCents.value,
      );
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity, ')
          ..write('averageUnitPriceInCents: $averageUnitPriceInCents, ')
          ..write('shopId: $shopId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $InventoryTransactionTable extends InventoryTransaction
    with TableInfo<$InventoryTransactionTable, InventoryTransactionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InventoryTransactionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _transactionTypeMeta = const VerificationMeta(
    'transactionType',
  );
  @override
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    check: () => const CustomExpression<bool>(
      '"type" IN (\'in\', \'out\', \'adjust\', \'transfer\', \'return\')',
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  static const VerificationMeta _batchIdMeta = const VerificationMeta(
    'batchId',
  );
  @override
  late final GeneratedColumn<int> batchId = GeneratedColumn<int>(
    'batch_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_batch (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    productId,
    transactionType,
    quantity,
    shopId,
    batchId,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_transaction';
  @override
  VerificationContext validateIntegrity(
    Insertable<InventoryTransactionData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _transactionTypeMeta,
        transactionType.isAcceptableOrUnknown(
          data['type']!,
          _transactionTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_transactionTypeMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('batch_id')) {
      context.handle(
        _batchIdMeta,
        batchId.isAcceptableOrUnknown(data['batch_id']!, _batchIdMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryTransactionData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryTransactionData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      transactionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      batchId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}batch_id'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $InventoryTransactionTable createAlias(String alias) {
    return $InventoryTransactionTable(attachedDatabase, alias);
  }
}

class InventoryTransactionData extends DataClass
    implements Insertable<InventoryTransactionData> {
  /// ä¸»é”® - æµæ°´ID
  final int id;

  /// å¤–é”® - äº§å“ID
  final int productId;

  /// æµæ°´ç±»å‹ï¼ˆå…¥åº“ã€å‡ºåº“ç­‰ï¼?  final String transactionType;

  /// å˜åŠ¨æ•°é‡
  final int quantity;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// å¤–é”® - æ‰¹æ¬¡IDï¼ˆå¯é€‰ï¼‰
  final int? batchId;

  /// æµæ°´æ—¶é—´
  final DateTime createdAt;
  const InventoryTransactionData({
    required this.id,
    required this.productId,
    required this.transactionType,
    required this.quantity,
    required this.shopId,
    this.batchId,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_id'] = Variable<int>(productId);
    map['type'] = Variable<String>(transactionType);
    map['quantity'] = Variable<int>(quantity);
    map['shop_id'] = Variable<int>(shopId);
    if (!nullToAbsent || batchId != null) {
      map['batch_id'] = Variable<int>(batchId);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  InventoryTransactionCompanion toCompanion(bool nullToAbsent) {
    return InventoryTransactionCompanion(
      id: Value(id),
      productId: Value(productId),
      transactionType: Value(transactionType),
      quantity: Value(quantity),
      shopId: Value(shopId),
      batchId: batchId == null && nullToAbsent
          ? const Value.absent()
          : Value(batchId),
      createdAt: Value(createdAt),
    );
  }

  factory InventoryTransactionData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryTransactionData(
      id: serializer.fromJson<int>(json['id']),
      productId: serializer.fromJson<int>(json['productId']),
      transactionType: serializer.fromJson<String>(json['transactionType']),
      quantity: serializer.fromJson<int>(json['quantity']),
      shopId: serializer.fromJson<int>(json['shopId']),
      batchId: serializer.fromJson<int?>(json['batchId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productId': serializer.toJson<int>(productId),
      'transactionType': serializer.toJson<String>(transactionType),
      'quantity': serializer.toJson<int>(quantity),
      'shopId': serializer.toJson<int>(shopId),
      'batchId': serializer.toJson<int?>(batchId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  InventoryTransactionData copyWith({
    int? id,
    int? productId,
    String? transactionType,
    int? quantity,
    int? shopId,
    Value<int?> batchId = const Value.absent(),
    DateTime? createdAt,
  }) => InventoryTransactionData(
    id: id ?? this.id,
    productId: productId ?? this.productId,
    transactionType: transactionType ?? this.transactionType,
    quantity: quantity ?? this.quantity,
    shopId: shopId ?? this.shopId,
    batchId: batchId.present ? batchId.value : this.batchId,
    createdAt: createdAt ?? this.createdAt,
  );
  InventoryTransactionData copyWithCompanion(
    InventoryTransactionCompanion data,
  ) {
    return InventoryTransactionData(
      id: data.id.present ? data.id.value : this.id,
      productId: data.productId.present ? data.productId.value : this.productId,
      transactionType: data.transactionType.present
          ? data.transactionType.value
          : this.transactionType,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      batchId: data.batchId.present ? data.batchId.value : this.batchId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InventoryTransactionData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('transactionType: $transactionType, ')
          ..write('quantity: $quantity, ')
          ..write('shopId: $shopId, ')
          ..write('batchId: $batchId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    productId,
    transactionType,
    quantity,
    shopId,
    batchId,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryTransactionData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.transactionType == this.transactionType &&
          other.quantity == this.quantity &&
          other.shopId == this.shopId &&
          other.batchId == this.batchId &&
          other.createdAt == this.createdAt);
}

class InventoryTransactionCompanion
    extends UpdateCompanion<InventoryTransactionData> {
  final Value<int> id;
  final Value<int> productId;
  final Value<String> transactionType;
  final Value<int> quantity;
  final Value<int> shopId;
  final Value<int?> batchId;
  final Value<DateTime> createdAt;
  const InventoryTransactionCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.shopId = const Value.absent(),
    this.batchId = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  InventoryTransactionCompanion.insert({
    this.id = const Value.absent(),
    required int productId,
    required String transactionType,
    required int quantity,
    required int shopId,
    this.batchId = const Value.absent(),
    this.createdAt = const Value.absent(),
  }) : productId = Value(productId),
       transactionType = Value(transactionType),
       quantity = Value(quantity),
       shopId = Value(shopId);
  static Insertable<InventoryTransactionData> custom({
    Expression<int>? id,
    Expression<int>? productId,
    Expression<String>? transactionType,
    Expression<int>? quantity,
    Expression<int>? shopId,
    Expression<int>? batchId,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (transactionType != null) 'type': transactionType,
      if (quantity != null) 'quantity': quantity,
      if (shopId != null) 'shop_id': shopId,
      if (batchId != null) 'batch_id': batchId,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  InventoryTransactionCompanion copyWith({
    Value<int>? id,
    Value<int>? productId,
    Value<String>? transactionType,
    Value<int>? quantity,
    Value<int>? shopId,
    Value<int?>? batchId,
    Value<DateTime>? createdAt,
  }) {
    return InventoryTransactionCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      transactionType: transactionType ?? this.transactionType,
      quantity: quantity ?? this.quantity,
      shopId: shopId ?? this.shopId,
      batchId: batchId ?? this.batchId,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (transactionType.present) {
      map['type'] = Variable<String>(transactionType.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (batchId.present) {
      map['batch_id'] = Variable<int>(batchId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryTransactionCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('transactionType: $transactionType, ')
          ..write('quantity: $quantity, ')
          ..write('shopId: $shopId, ')
          ..write('batchId: $batchId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $LocationsTableTable extends LocationsTable
    with TableInfo<$LocationsTableTable, LocationsTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocationsTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('active'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    shopId,
    status,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'locations';
  @override
  VerificationContext validateIntegrity(
    Insertable<LocationsTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {shopId, code},
  ];
  @override
  LocationsTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocationsTableData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $LocationsTableTable createAlias(String alias) {
    return $LocationsTableTable(attachedDatabase, alias);
  }
}

class LocationsTableData extends DataClass
    implements Insertable<LocationsTableData> {
  /// ä¸»é”® - è´§ä½ID
  final String id;

  /// è´§ä½ç¼–ç ï¼ˆå¦‚ï¼šA-01-01ï¼?  final String code;

  /// è´§ä½åç§°
  final String name;

  /// è´§ä½æè¿°
  final String? description;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// è´§ä½çŠ¶æ€ï¼šactive(æ´»è·ƒ), inactive(åœç”¨)
  final String status;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const LocationsTableData({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.shopId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['shop_id'] = Variable<int>(shopId);
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  LocationsTableCompanion toCompanion(bool nullToAbsent) {
    return LocationsTableCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      shopId: Value(shopId),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory LocationsTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocationsTableData(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      shopId: serializer.fromJson<int>(json['shopId']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'shopId': serializer.toJson<int>(shopId),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  LocationsTableData copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? shopId,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => LocationsTableData(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    shopId: shopId ?? this.shopId,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  LocationsTableData copyWithCompanion(LocationsTableCompanion data) {
    return LocationsTableData(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LocationsTableData(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('shopId: $shopId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    description,
    shopId,
    status,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocationsTableData &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.shopId == this.shopId &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class LocationsTableCompanion extends UpdateCompanion<LocationsTableData> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> shopId;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const LocationsTableCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.shopId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocationsTableCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    required int shopId,
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       shopId = Value(shopId);
  static Insertable<LocationsTableData> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? shopId,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (shopId != null) 'shop_id': shopId,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocationsTableCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? shopId,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return LocationsTableCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      shopId: shopId ?? this.shopId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocationsTableCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('shopId: $shopId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrderTable extends PurchaseOrder
    with TableInfo<$PurchaseOrderTable, PurchaseOrderData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrderTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _supplierIdMeta = const VerificationMeta(
    'supplierId',
  );
  @override
  late final GeneratedColumn<int> supplierId = GeneratedColumn<int>(
    'supplier_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES supplier (id)',
    ),
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<PurchaseOrderStatus, String>
  status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('preset'),
  ).withConverter<PurchaseOrderStatus>($PurchaseOrderTable.$converterstatus);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    supplierId,
    shopId,
    status,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_order';
  @override
  VerificationContext validateIntegrity(
    Insertable<PurchaseOrderData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('supplier_id')) {
      context.handle(
        _supplierIdMeta,
        supplierId.isAcceptableOrUnknown(data['supplier_id']!, _supplierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_supplierIdMeta);
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PurchaseOrderData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrderData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      supplierId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}supplier_id'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      status: $PurchaseOrderTable.$converterstatus.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}status'],
        )!,
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PurchaseOrderTable createAlias(String alias) {
    return $PurchaseOrderTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<PurchaseOrderStatus, String, String>
  $converterstatus = const EnumNameConverter<PurchaseOrderStatus>(
    PurchaseOrderStatus.values,
  );
}

class PurchaseOrderData extends DataClass
    implements Insertable<PurchaseOrderData> {
  /// ä¸»é”® - é‡‡è´­è®¢å•å?  final int id;

  /// å¤–é”® - ä¾›åº”å•†ID
  final int supplierId;

  /// å¤–é”® - åº—é“ºID
  final int shopId;
  final PurchaseOrderStatus status;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const PurchaseOrderData({
    required this.id,
    required this.supplierId,
    required this.shopId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['supplier_id'] = Variable<int>(supplierId);
    map['shop_id'] = Variable<int>(shopId);
    {
      map['status'] = Variable<String>(
        $PurchaseOrderTable.$converterstatus.toSql(status),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PurchaseOrderCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrderCompanion(
      id: Value(id),
      supplierId: Value(supplierId),
      shopId: Value(shopId),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PurchaseOrderData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrderData(
      id: serializer.fromJson<int>(json['id']),
      supplierId: serializer.fromJson<int>(json['supplierId']),
      shopId: serializer.fromJson<int>(json['shopId']),
      status: $PurchaseOrderTable.$converterstatus.fromJson(
        serializer.fromJson<String>(json['status']),
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'supplierId': serializer.toJson<int>(supplierId),
      'shopId': serializer.toJson<int>(shopId),
      'status': serializer.toJson<String>(
        $PurchaseOrderTable.$converterstatus.toJson(status),
      ),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PurchaseOrderData copyWith({
    int? id,
    int? supplierId,
    int? shopId,
    PurchaseOrderStatus? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PurchaseOrderData(
    id: id ?? this.id,
    supplierId: supplierId ?? this.supplierId,
    shopId: shopId ?? this.shopId,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PurchaseOrderData copyWithCompanion(PurchaseOrderCompanion data) {
    return PurchaseOrderData(
      id: data.id.present ? data.id.value : this.id,
      supplierId: data.supplierId.present
          ? data.supplierId.value
          : this.supplierId,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderData(')
          ..write('id: $id, ')
          ..write('supplierId: $supplierId, ')
          ..write('shopId: $shopId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, supplierId, shopId, status, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrderData &&
          other.id == this.id &&
          other.supplierId == this.supplierId &&
          other.shopId == this.shopId &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PurchaseOrderCompanion extends UpdateCompanion<PurchaseOrderData> {
  final Value<int> id;
  final Value<int> supplierId;
  final Value<int> shopId;
  final Value<PurchaseOrderStatus> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const PurchaseOrderCompanion({
    this.id = const Value.absent(),
    this.supplierId = const Value.absent(),
    this.shopId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  PurchaseOrderCompanion.insert({
    this.id = const Value.absent(),
    required int supplierId,
    required int shopId,
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : supplierId = Value(supplierId),
       shopId = Value(shopId);
  static Insertable<PurchaseOrderData> custom({
    Expression<int>? id,
    Expression<int>? supplierId,
    Expression<int>? shopId,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (supplierId != null) 'supplier_id': supplierId,
      if (shopId != null) 'shop_id': shopId,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  PurchaseOrderCompanion copyWith({
    Value<int>? id,
    Value<int>? supplierId,
    Value<int>? shopId,
    Value<PurchaseOrderStatus>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return PurchaseOrderCompanion(
      id: id ?? this.id,
      supplierId: supplierId ?? this.supplierId,
      shopId: shopId ?? this.shopId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (supplierId.present) {
      map['supplier_id'] = Variable<int>(supplierId.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(
        $PurchaseOrderTable.$converterstatus.toSql(status.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderCompanion(')
          ..write('id: $id, ')
          ..write('supplierId: $supplierId, ')
          ..write('shopId: $shopId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $InboundReceiptTable extends InboundReceipt
    with TableInfo<$InboundReceiptTable, InboundReceiptData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InboundReceiptTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _purchaseOrderIdMeta = const VerificationMeta(
    'purchaseOrderId',
  );
  @override
  late final GeneratedColumn<int> purchaseOrderId = GeneratedColumn<int>(
    'purchase_order_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES purchase_order (id)',
    ),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('preset'),
  );
  static const VerificationMeta _remarksMeta = const VerificationMeta(
    'remarks',
  );
  @override
  late final GeneratedColumn<String> remarks = GeneratedColumn<String>(
    'remarks',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    shopId,
    source,
    purchaseOrderId,
    status,
    remarks,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inbound_receipt';
  @override
  VerificationContext validateIntegrity(
    Insertable<InboundReceiptData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    } else if (isInserting) {
      context.missing(_sourceMeta);
    }
    if (data.containsKey('purchase_order_id')) {
      context.handle(
        _purchaseOrderIdMeta,
        purchaseOrderId.isAcceptableOrUnknown(
          data['purchase_order_id']!,
          _purchaseOrderIdMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('remarks')) {
      context.handle(
        _remarksMeta,
        remarks.isAcceptableOrUnknown(data['remarks']!, _remarksMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InboundReceiptData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InboundReceiptData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      purchaseOrderId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}purchase_order_id'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      remarks: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remarks'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $InboundReceiptTable createAlias(String alias) {
    return $InboundReceiptTable(attachedDatabase, alias);
  }
}

class InboundReceiptData extends DataClass
    implements Insertable<InboundReceiptData> {
  /// ä¸»é”® - å…¥åº“å•ID
  final int id;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// æ¥æº
  final String source;

  /// å¤–é”® - é‡‡è´­å•IDï¼ˆå¦‚æœæ¥è‡ªé‡‡è´­å•ï¼?  final int? purchaseOrderId;

  /// å…¥åº“å•çŠ¶æ€ï¼špreset draft(è‰ç¨¿), completed(å·²å®Œæˆ?
  final String status;

  /// å¤‡æ³¨
  final String? remarks;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const InboundReceiptData({
    required this.id,
    required this.shopId,
    required this.source,
    this.purchaseOrderId,
    required this.status,
    this.remarks,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['shop_id'] = Variable<int>(shopId);
    map['source'] = Variable<String>(source);
    if (!nullToAbsent || purchaseOrderId != null) {
      map['purchase_order_id'] = Variable<int>(purchaseOrderId);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || remarks != null) {
      map['remarks'] = Variable<String>(remarks);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  InboundReceiptCompanion toCompanion(bool nullToAbsent) {
    return InboundReceiptCompanion(
      id: Value(id),
      shopId: Value(shopId),
      source: Value(source),
      purchaseOrderId: purchaseOrderId == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseOrderId),
      status: Value(status),
      remarks: remarks == null && nullToAbsent
          ? const Value.absent()
          : Value(remarks),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory InboundReceiptData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InboundReceiptData(
      id: serializer.fromJson<int>(json['id']),
      shopId: serializer.fromJson<int>(json['shopId']),
      source: serializer.fromJson<String>(json['source']),
      purchaseOrderId: serializer.fromJson<int?>(json['purchaseOrderId']),
      status: serializer.fromJson<String>(json['status']),
      remarks: serializer.fromJson<String?>(json['remarks']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'shopId': serializer.toJson<int>(shopId),
      'source': serializer.toJson<String>(source),
      'purchaseOrderId': serializer.toJson<int?>(purchaseOrderId),
      'status': serializer.toJson<String>(status),
      'remarks': serializer.toJson<String?>(remarks),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  InboundReceiptData copyWith({
    int? id,
    int? shopId,
    String? source,
    Value<int?> purchaseOrderId = const Value.absent(),
    String? status,
    Value<String?> remarks = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => InboundReceiptData(
    id: id ?? this.id,
    shopId: shopId ?? this.shopId,
    source: source ?? this.source,
    purchaseOrderId: purchaseOrderId.present
        ? purchaseOrderId.value
        : this.purchaseOrderId,
    status: status ?? this.status,
    remarks: remarks.present ? remarks.value : this.remarks,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  InboundReceiptData copyWithCompanion(InboundReceiptCompanion data) {
    return InboundReceiptData(
      id: data.id.present ? data.id.value : this.id,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      source: data.source.present ? data.source.value : this.source,
      purchaseOrderId: data.purchaseOrderId.present
          ? data.purchaseOrderId.value
          : this.purchaseOrderId,
      status: data.status.present ? data.status.value : this.status,
      remarks: data.remarks.present ? data.remarks.value : this.remarks,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InboundReceiptData(')
          ..write('id: $id, ')
          ..write('shopId: $shopId, ')
          ..write('source: $source, ')
          ..write('purchaseOrderId: $purchaseOrderId, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    shopId,
    source,
    purchaseOrderId,
    status,
    remarks,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InboundReceiptData &&
          other.id == this.id &&
          other.shopId == this.shopId &&
          other.source == this.source &&
          other.purchaseOrderId == this.purchaseOrderId &&
          other.status == this.status &&
          other.remarks == this.remarks &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class InboundReceiptCompanion extends UpdateCompanion<InboundReceiptData> {
  final Value<int> id;
  final Value<int> shopId;
  final Value<String> source;
  final Value<int?> purchaseOrderId;
  final Value<String> status;
  final Value<String?> remarks;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const InboundReceiptCompanion({
    this.id = const Value.absent(),
    this.shopId = const Value.absent(),
    this.source = const Value.absent(),
    this.purchaseOrderId = const Value.absent(),
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  InboundReceiptCompanion.insert({
    this.id = const Value.absent(),
    required int shopId,
    required String source,
    this.purchaseOrderId = const Value.absent(),
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : shopId = Value(shopId),
       source = Value(source);
  static Insertable<InboundReceiptData> custom({
    Expression<int>? id,
    Expression<int>? shopId,
    Expression<String>? source,
    Expression<int>? purchaseOrderId,
    Expression<String>? status,
    Expression<String>? remarks,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (shopId != null) 'shop_id': shopId,
      if (source != null) 'source': source,
      if (purchaseOrderId != null) 'purchase_order_id': purchaseOrderId,
      if (status != null) 'status': status,
      if (remarks != null) 'remarks': remarks,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  InboundReceiptCompanion copyWith({
    Value<int>? id,
    Value<int>? shopId,
    Value<String>? source,
    Value<int?>? purchaseOrderId,
    Value<String>? status,
    Value<String?>? remarks,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return InboundReceiptCompanion(
      id: id ?? this.id,
      shopId: shopId ?? this.shopId,
      source: source ?? this.source,
      purchaseOrderId: purchaseOrderId ?? this.purchaseOrderId,
      status: status ?? this.status,
      remarks: remarks ?? this.remarks,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (purchaseOrderId.present) {
      map['purchase_order_id'] = Variable<int>(purchaseOrderId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (remarks.present) {
      map['remarks'] = Variable<String>(remarks.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InboundReceiptCompanion(')
          ..write('id: $id, ')
          ..write('shopId: $shopId, ')
          ..write('source: $source, ')
          ..write('purchaseOrderId: $purchaseOrderId, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $InboundItemTable extends InboundItem
    with TableInfo<$InboundItemTable, InboundItemData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InboundItemTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _receiptIdMeta = const VerificationMeta(
    'receiptId',
  );
  @override
  late final GeneratedColumn<int> receiptId = GeneratedColumn<int>(
    'receipt_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES inbound_receipt (id)',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _batchIdMeta = const VerificationMeta(
    'batchId',
  );
  @override
  late final GeneratedColumn<int> batchId = GeneratedColumn<int>(
    'batch_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_batch (id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    receiptId,
    productId,
    batchId,
    quantity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inbound_item';
  @override
  VerificationContext validateIntegrity(
    Insertable<InboundItemData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('receipt_id')) {
      context.handle(
        _receiptIdMeta,
        receiptId.isAcceptableOrUnknown(data['receipt_id']!, _receiptIdMeta),
      );
    } else if (isInserting) {
      context.missing(_receiptIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('batch_id')) {
      context.handle(
        _batchIdMeta,
        batchId.isAcceptableOrUnknown(data['batch_id']!, _batchIdMeta),
      );
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InboundItemData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InboundItemData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      receiptId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}receipt_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      batchId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}batch_id'],
      ),
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
    );
  }

  @override
  $InboundItemTable createAlias(String alias) {
    return $InboundItemTable(attachedDatabase, alias);
  }
}

class InboundItemData extends DataClass implements Insertable<InboundItemData> {
  /// ä¸»é”® - æ˜ç»†ID
  final int id;

  /// å¤–é”® - å…¥åº“å•ID
  final int receiptId;

  /// å¤–é”® - å•†å“ID
  final int productId;

  /// æ‰¹æ¬¡å?  final int? batchId;

  /// å…¥åº“æ•°é‡
  final int quantity;
  const InboundItemData({
    required this.id,
    required this.receiptId,
    required this.productId,
    this.batchId,
    required this.quantity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['receipt_id'] = Variable<int>(receiptId);
    map['product_id'] = Variable<int>(productId);
    if (!nullToAbsent || batchId != null) {
      map['batch_id'] = Variable<int>(batchId);
    }
    map['quantity'] = Variable<int>(quantity);
    return map;
  }

  InboundItemCompanion toCompanion(bool nullToAbsent) {
    return InboundItemCompanion(
      id: Value(id),
      receiptId: Value(receiptId),
      productId: Value(productId),
      batchId: batchId == null && nullToAbsent
          ? const Value.absent()
          : Value(batchId),
      quantity: Value(quantity),
    );
  }

  factory InboundItemData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InboundItemData(
      id: serializer.fromJson<int>(json['id']),
      receiptId: serializer.fromJson<int>(json['receiptId']),
      productId: serializer.fromJson<int>(json['productId']),
      batchId: serializer.fromJson<int?>(json['batchId']),
      quantity: serializer.fromJson<int>(json['quantity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'receiptId': serializer.toJson<int>(receiptId),
      'productId': serializer.toJson<int>(productId),
      'batchId': serializer.toJson<int?>(batchId),
      'quantity': serializer.toJson<int>(quantity),
    };
  }

  InboundItemData copyWith({
    int? id,
    int? receiptId,
    int? productId,
    Value<int?> batchId = const Value.absent(),
    int? quantity,
  }) => InboundItemData(
    id: id ?? this.id,
    receiptId: receiptId ?? this.receiptId,
    productId: productId ?? this.productId,
    batchId: batchId.present ? batchId.value : this.batchId,
    quantity: quantity ?? this.quantity,
  );
  InboundItemData copyWithCompanion(InboundItemCompanion data) {
    return InboundItemData(
      id: data.id.present ? data.id.value : this.id,
      receiptId: data.receiptId.present ? data.receiptId.value : this.receiptId,
      productId: data.productId.present ? data.productId.value : this.productId,
      batchId: data.batchId.present ? data.batchId.value : this.batchId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InboundItemData(')
          ..write('id: $id, ')
          ..write('receiptId: $receiptId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, receiptId, productId, batchId, quantity);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InboundItemData &&
          other.id == this.id &&
          other.receiptId == this.receiptId &&
          other.productId == this.productId &&
          other.batchId == this.batchId &&
          other.quantity == this.quantity);
}

class InboundItemCompanion extends UpdateCompanion<InboundItemData> {
  final Value<int> id;
  final Value<int> receiptId;
  final Value<int> productId;
  final Value<int?> batchId;
  final Value<int> quantity;
  const InboundItemCompanion({
    this.id = const Value.absent(),
    this.receiptId = const Value.absent(),
    this.productId = const Value.absent(),
    this.batchId = const Value.absent(),
    this.quantity = const Value.absent(),
  });
  InboundItemCompanion.insert({
    this.id = const Value.absent(),
    required int receiptId,
    required int productId,
    this.batchId = const Value.absent(),
    required int quantity,
  }) : receiptId = Value(receiptId),
       productId = Value(productId),
       quantity = Value(quantity);
  static Insertable<InboundItemData> custom({
    Expression<int>? id,
    Expression<int>? receiptId,
    Expression<int>? productId,
    Expression<int>? batchId,
    Expression<int>? quantity,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (receiptId != null) 'receipt_id': receiptId,
      if (productId != null) 'product_id': productId,
      if (batchId != null) 'batch_id': batchId,
      if (quantity != null) 'quantity': quantity,
    });
  }

  InboundItemCompanion copyWith({
    Value<int>? id,
    Value<int>? receiptId,
    Value<int>? productId,
    Value<int?>? batchId,
    Value<int>? quantity,
  }) {
    return InboundItemCompanion(
      id: id ?? this.id,
      receiptId: receiptId ?? this.receiptId,
      productId: productId ?? this.productId,
      batchId: batchId ?? this.batchId,
      quantity: quantity ?? this.quantity,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (receiptId.present) {
      map['receipt_id'] = Variable<int>(receiptId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (batchId.present) {
      map['batch_id'] = Variable<int>(batchId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InboundItemCompanion(')
          ..write('id: $id, ')
          ..write('receiptId: $receiptId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrderItemTable extends PurchaseOrderItem
    with TableInfo<$PurchaseOrderItemTable, PurchaseOrderItemData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrderItemTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _purchaseOrderIdMeta = const VerificationMeta(
    'purchaseOrderId',
  );
  @override
  late final GeneratedColumn<int> purchaseOrderId = GeneratedColumn<int>(
    'purchase_order_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES purchase_order (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _productionDateMeta = const VerificationMeta(
    'productionDate',
  );
  @override
  late final GeneratedColumn<DateTime> productionDate =
      GeneratedColumn<DateTime>(
        'production_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _unitPriceInCentsMeta = const VerificationMeta(
    'unitPriceInCents',
  );
  @override
  late final GeneratedColumn<int> unitPriceInCents = GeneratedColumn<int>(
    'unit_price_in_cents',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    purchaseOrderId,
    productId,
    productionDate,
    unitPriceInCents,
    quantity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_order_item';
  @override
  VerificationContext validateIntegrity(
    Insertable<PurchaseOrderItemData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('purchase_order_id')) {
      context.handle(
        _purchaseOrderIdMeta,
        purchaseOrderId.isAcceptableOrUnknown(
          data['purchase_order_id']!,
          _purchaseOrderIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_purchaseOrderIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('production_date')) {
      context.handle(
        _productionDateMeta,
        productionDate.isAcceptableOrUnknown(
          data['production_date']!,
          _productionDateMeta,
        ),
      );
    }
    if (data.containsKey('unit_price_in_cents')) {
      context.handle(
        _unitPriceInCentsMeta,
        unitPriceInCents.isAcceptableOrUnknown(
          data['unit_price_in_cents']!,
          _unitPriceInCentsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_unitPriceInCentsMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PurchaseOrderItemData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrderItemData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      purchaseOrderId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}purchase_order_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      productionDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}production_date'],
      ),
      unitPriceInCents: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}unit_price_in_cents'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
    );
  }

  @override
  $PurchaseOrderItemTable createAlias(String alias) {
    return $PurchaseOrderItemTable(attachedDatabase, alias);
  }
}

class PurchaseOrderItemData extends DataClass
    implements Insertable<PurchaseOrderItemData> {
  /// ä¸»é”® - è‡ªå¢ID
  final int id;

  /// å¤–é”® - å…³è”åˆ°é‡‡è´­è®¢å•è¡¨
  final int purchaseOrderId;

  /// å¤–é”® - è´§å“ID
  final int productId;

  /// ç”Ÿäº§æ—¥æœŸ
  final DateTime? productionDate;

  /// å•ä½ä»·æ ¼ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼?  final int unitPriceInCents;

  /// æ•°é‡
  final int quantity;
  const PurchaseOrderItemData({
    required this.id,
    required this.purchaseOrderId,
    required this.productId,
    this.productionDate,
    required this.unitPriceInCents,
    required this.quantity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['purchase_order_id'] = Variable<int>(purchaseOrderId);
    map['product_id'] = Variable<int>(productId);
    if (!nullToAbsent || productionDate != null) {
      map['production_date'] = Variable<DateTime>(productionDate);
    }
    map['unit_price_in_cents'] = Variable<int>(unitPriceInCents);
    map['quantity'] = Variable<int>(quantity);
    return map;
  }

  PurchaseOrderItemCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrderItemCompanion(
      id: Value(id),
      purchaseOrderId: Value(purchaseOrderId),
      productId: Value(productId),
      productionDate: productionDate == null && nullToAbsent
          ? const Value.absent()
          : Value(productionDate),
      unitPriceInCents: Value(unitPriceInCents),
      quantity: Value(quantity),
    );
  }

  factory PurchaseOrderItemData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrderItemData(
      id: serializer.fromJson<int>(json['id']),
      purchaseOrderId: serializer.fromJson<int>(json['purchaseOrderId']),
      productId: serializer.fromJson<int>(json['productId']),
      productionDate: serializer.fromJson<DateTime?>(json['productionDate']),
      unitPriceInCents: serializer.fromJson<int>(json['unitPriceInCents']),
      quantity: serializer.fromJson<int>(json['quantity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'purchaseOrderId': serializer.toJson<int>(purchaseOrderId),
      'productId': serializer.toJson<int>(productId),
      'productionDate': serializer.toJson<DateTime?>(productionDate),
      'unitPriceInCents': serializer.toJson<int>(unitPriceInCents),
      'quantity': serializer.toJson<int>(quantity),
    };
  }

  PurchaseOrderItemData copyWith({
    int? id,
    int? purchaseOrderId,
    int? productId,
    Value<DateTime?> productionDate = const Value.absent(),
    int? unitPriceInCents,
    int? quantity,
  }) => PurchaseOrderItemData(
    id: id ?? this.id,
    purchaseOrderId: purchaseOrderId ?? this.purchaseOrderId,
    productId: productId ?? this.productId,
    productionDate: productionDate.present
        ? productionDate.value
        : this.productionDate,
    unitPriceInCents: unitPriceInCents ?? this.unitPriceInCents,
    quantity: quantity ?? this.quantity,
  );
  PurchaseOrderItemData copyWithCompanion(PurchaseOrderItemCompanion data) {
    return PurchaseOrderItemData(
      id: data.id.present ? data.id.value : this.id,
      purchaseOrderId: data.purchaseOrderId.present
          ? data.purchaseOrderId.value
          : this.purchaseOrderId,
      productId: data.productId.present ? data.productId.value : this.productId,
      productionDate: data.productionDate.present
          ? data.productionDate.value
          : this.productionDate,
      unitPriceInCents: data.unitPriceInCents.present
          ? data.unitPriceInCents.value
          : this.unitPriceInCents,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItemData(')
          ..write('id: $id, ')
          ..write('purchaseOrderId: $purchaseOrderId, ')
          ..write('productId: $productId, ')
          ..write('productionDate: $productionDate, ')
          ..write('unitPriceInCents: $unitPriceInCents, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    purchaseOrderId,
    productId,
    productionDate,
    unitPriceInCents,
    quantity,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrderItemData &&
          other.id == this.id &&
          other.purchaseOrderId == this.purchaseOrderId &&
          other.productId == this.productId &&
          other.productionDate == this.productionDate &&
          other.unitPriceInCents == this.unitPriceInCents &&
          other.quantity == this.quantity);
}

class PurchaseOrderItemCompanion
    extends UpdateCompanion<PurchaseOrderItemData> {
  final Value<int> id;
  final Value<int> purchaseOrderId;
  final Value<int> productId;
  final Value<DateTime?> productionDate;
  final Value<int> unitPriceInCents;
  final Value<int> quantity;
  const PurchaseOrderItemCompanion({
    this.id = const Value.absent(),
    this.purchaseOrderId = const Value.absent(),
    this.productId = const Value.absent(),
    this.productionDate = const Value.absent(),
    this.unitPriceInCents = const Value.absent(),
    this.quantity = const Value.absent(),
  });
  PurchaseOrderItemCompanion.insert({
    this.id = const Value.absent(),
    required int purchaseOrderId,
    required int productId,
    this.productionDate = const Value.absent(),
    required int unitPriceInCents,
    required int quantity,
  }) : purchaseOrderId = Value(purchaseOrderId),
       productId = Value(productId),
       unitPriceInCents = Value(unitPriceInCents),
       quantity = Value(quantity);
  static Insertable<PurchaseOrderItemData> custom({
    Expression<int>? id,
    Expression<int>? purchaseOrderId,
    Expression<int>? productId,
    Expression<DateTime>? productionDate,
    Expression<int>? unitPriceInCents,
    Expression<int>? quantity,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (purchaseOrderId != null) 'purchase_order_id': purchaseOrderId,
      if (productId != null) 'product_id': productId,
      if (productionDate != null) 'production_date': productionDate,
      if (unitPriceInCents != null) 'unit_price_in_cents': unitPriceInCents,
      if (quantity != null) 'quantity': quantity,
    });
  }

  PurchaseOrderItemCompanion copyWith({
    Value<int>? id,
    Value<int>? purchaseOrderId,
    Value<int>? productId,
    Value<DateTime?>? productionDate,
    Value<int>? unitPriceInCents,
    Value<int>? quantity,
  }) {
    return PurchaseOrderItemCompanion(
      id: id ?? this.id,
      purchaseOrderId: purchaseOrderId ?? this.purchaseOrderId,
      productId: productId ?? this.productId,
      productionDate: productionDate ?? this.productionDate,
      unitPriceInCents: unitPriceInCents ?? this.unitPriceInCents,
      quantity: quantity ?? this.quantity,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (purchaseOrderId.present) {
      map['purchase_order_id'] = Variable<int>(purchaseOrderId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (productionDate.present) {
      map['production_date'] = Variable<DateTime>(productionDate.value);
    }
    if (unitPriceInCents.present) {
      map['unit_price_in_cents'] = Variable<int>(unitPriceInCents.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItemCompanion(')
          ..write('id: $id, ')
          ..write('purchaseOrderId: $purchaseOrderId, ')
          ..write('productId: $productId, ')
          ..write('productionDate: $productionDate, ')
          ..write('unitPriceInCents: $unitPriceInCents, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }
}

class $BarcodeTable extends Barcode with TableInfo<$BarcodeTable, BarcodeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BarcodeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _unitProductIdMeta = const VerificationMeta(
    'unitProductId',
  );
  @override
  late final GeneratedColumn<int> unitProductId = GeneratedColumn<int>(
    'unit_product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES unit_product (id)',
    ),
  );
  static const VerificationMeta _barcodeValueMeta = const VerificationMeta(
    'barcodeValue',
  );
  @override
  late final GeneratedColumn<String> barcodeValue = GeneratedColumn<String>(
    'barcode_value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  @override
  List<GeneratedColumn> get $columns => [id, unitProductId, barcodeValue];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'barcode';
  @override
  VerificationContext validateIntegrity(
    Insertable<BarcodeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('unit_product_id')) {
      context.handle(
        _unitProductIdMeta,
        unitProductId.isAcceptableOrUnknown(
          data['unit_product_id']!,
          _unitProductIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_unitProductIdMeta);
    }
    if (data.containsKey('barcode_value')) {
      context.handle(
        _barcodeValueMeta,
        barcodeValue.isAcceptableOrUnknown(
          data['barcode_value']!,
          _barcodeValueMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_barcodeValueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BarcodeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BarcodeData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      unitProductId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}unit_product_id'],
      )!,
      barcodeValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode_value'],
      )!,
    );
  }

  @override
  $BarcodeTable createAlias(String alias) {
    return $BarcodeTable(attachedDatabase, alias);
  }
}

class BarcodeData extends DataClass implements Insertable<BarcodeData> {
  /// ä¸»é”® - æ¡ç ID
  final int id;

  /// å¤–é”® - äº§å“å•ä½IDï¼Œå…³è”åˆ°product_unitsè¡?  final int unitProductId;

  /// æ¡ç å€?  final String barcodeValue;
  const BarcodeData({
    required this.id,
    required this.unitProductId,
    required this.barcodeValue,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['unit_product_id'] = Variable<int>(unitProductId);
    map['barcode_value'] = Variable<String>(barcodeValue);
    return map;
  }

  BarcodeCompanion toCompanion(bool nullToAbsent) {
    return BarcodeCompanion(
      id: Value(id),
      unitProductId: Value(unitProductId),
      barcodeValue: Value(barcodeValue),
    );
  }

  factory BarcodeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BarcodeData(
      id: serializer.fromJson<int>(json['id']),
      unitProductId: serializer.fromJson<int>(json['unitProductId']),
      barcodeValue: serializer.fromJson<String>(json['barcodeValue']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'unitProductId': serializer.toJson<int>(unitProductId),
      'barcodeValue': serializer.toJson<String>(barcodeValue),
    };
  }

  BarcodeData copyWith({int? id, int? unitProductId, String? barcodeValue}) =>
      BarcodeData(
        id: id ?? this.id,
        unitProductId: unitProductId ?? this.unitProductId,
        barcodeValue: barcodeValue ?? this.barcodeValue,
      );
  BarcodeData copyWithCompanion(BarcodeCompanion data) {
    return BarcodeData(
      id: data.id.present ? data.id.value : this.id,
      unitProductId: data.unitProductId.present
          ? data.unitProductId.value
          : this.unitProductId,
      barcodeValue: data.barcodeValue.present
          ? data.barcodeValue.value
          : this.barcodeValue,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BarcodeData(')
          ..write('id: $id, ')
          ..write('unitProductId: $unitProductId, ')
          ..write('barcodeValue: $barcodeValue')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, unitProductId, barcodeValue);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BarcodeData &&
          other.id == this.id &&
          other.unitProductId == this.unitProductId &&
          other.barcodeValue == this.barcodeValue);
}

class BarcodeCompanion extends UpdateCompanion<BarcodeData> {
  final Value<int> id;
  final Value<int> unitProductId;
  final Value<String> barcodeValue;
  const BarcodeCompanion({
    this.id = const Value.absent(),
    this.unitProductId = const Value.absent(),
    this.barcodeValue = const Value.absent(),
  });
  BarcodeCompanion.insert({
    this.id = const Value.absent(),
    required int unitProductId,
    required String barcodeValue,
  }) : unitProductId = Value(unitProductId),
       barcodeValue = Value(barcodeValue);
  static Insertable<BarcodeData> custom({
    Expression<int>? id,
    Expression<int>? unitProductId,
    Expression<String>? barcodeValue,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (unitProductId != null) 'unit_product_id': unitProductId,
      if (barcodeValue != null) 'barcode_value': barcodeValue,
    });
  }

  BarcodeCompanion copyWith({
    Value<int>? id,
    Value<int>? unitProductId,
    Value<String>? barcodeValue,
  }) {
    return BarcodeCompanion(
      id: id ?? this.id,
      unitProductId: unitProductId ?? this.unitProductId,
      barcodeValue: barcodeValue ?? this.barcodeValue,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (unitProductId.present) {
      map['unit_product_id'] = Variable<int>(unitProductId.value);
    }
    if (barcodeValue.present) {
      map['barcode_value'] = Variable<String>(barcodeValue.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BarcodeCompanion(')
          ..write('id: $id, ')
          ..write('unitProductId: $unitProductId, ')
          ..write('barcodeValue: $barcodeValue')
          ..write(')'))
        .toString();
  }
}

class $CustomersTable extends Customers
    with TableInfo<$CustomersTable, Customer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Customer> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Customer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Customer(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
    );
  }

  @override
  $CustomersTable createAlias(String alias) {
    return $CustomersTable(attachedDatabase, alias);
  }
}

class Customer extends DataClass implements Insertable<Customer> {
  final int id;
  final String name;
  const Customer({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  CustomersCompanion toCompanion(bool nullToAbsent) {
    return CustomersCompanion(id: Value(id), name: Value(name));
  }

  factory Customer.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Customer(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  Customer copyWith({int? id, String? name}) =>
      Customer(id: id ?? this.id, name: name ?? this.name);
  Customer copyWithCompanion(CustomersCompanion data) {
    return Customer(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Customer(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Customer && other.id == this.id && other.name == this.name);
}

class CustomersCompanion extends UpdateCompanion<Customer> {
  final Value<int> id;
  final Value<String> name;
  const CustomersCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  CustomersCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<Customer> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  CustomersCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return CustomersCompanion(id: id ?? this.id, name: name ?? this.name);
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomersCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $SalesTransactionTable extends SalesTransaction
    with TableInfo<$SalesTransactionTable, SalesTransactionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesTransactionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<int> customerId = GeneratedColumn<int>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (id)',
    ),
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualAmountMeta = const VerificationMeta(
    'actualAmount',
  );
  @override
  late final GeneratedColumn<double> actualAmount = GeneratedColumn<double>(
    'actual_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('preset'),
  );
  static const VerificationMeta _remarksMeta = const VerificationMeta(
    'remarks',
  );
  @override
  late final GeneratedColumn<String> remarks = GeneratedColumn<String>(
    'remarks',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    customerId,
    shopId,
    totalAmount,
    actualAmount,
    status,
    remarks,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_transaction';
  @override
  VerificationContext validateIntegrity(
    Insertable<SalesTransactionData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('actual_amount')) {
      context.handle(
        _actualAmountMeta,
        actualAmount.isAcceptableOrUnknown(
          data['actual_amount']!,
          _actualAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_actualAmountMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('remarks')) {
      context.handle(
        _remarksMeta,
        remarks.isAcceptableOrUnknown(data['remarks']!, _remarksMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesTransactionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesTransactionData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}customer_id'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      actualAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}actual_amount'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      remarks: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remarks'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SalesTransactionTable createAlias(String alias) {
    return $SalesTransactionTable(attachedDatabase, alias);
  }
}

class SalesTransactionData extends DataClass
    implements Insertable<SalesTransactionData> {
  /// ä¸»é”® - è‡ªå¢ID
  final int id;

  /// å®¢æˆ·ID
  final int customerId;

  /// åº—é“ºID
  final int shopId;

  /// æ€»é‡‘é¢?  final double totalAmount;

  /// å®æ”¶é‡‘é¢
  final double actualAmount;

  /// çŠ¶æ€?(preset,credit, Settled, cancelled)
  final String status;

  /// å¤‡æ³¨
  final String? remarks;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;

  /// æœ€åæ›´æ–°æ—¶é—?  final DateTime updatedAt;
  const SalesTransactionData({
    required this.id,
    required this.customerId,
    required this.shopId,
    required this.totalAmount,
    required this.actualAmount,
    required this.status,
    this.remarks,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['customer_id'] = Variable<int>(customerId);
    map['shop_id'] = Variable<int>(shopId);
    map['total_amount'] = Variable<double>(totalAmount);
    map['actual_amount'] = Variable<double>(actualAmount);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || remarks != null) {
      map['remarks'] = Variable<String>(remarks);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SalesTransactionCompanion toCompanion(bool nullToAbsent) {
    return SalesTransactionCompanion(
      id: Value(id),
      customerId: Value(customerId),
      shopId: Value(shopId),
      totalAmount: Value(totalAmount),
      actualAmount: Value(actualAmount),
      status: Value(status),
      remarks: remarks == null && nullToAbsent
          ? const Value.absent()
          : Value(remarks),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SalesTransactionData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesTransactionData(
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<int>(json['customerId']),
      shopId: serializer.fromJson<int>(json['shopId']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      actualAmount: serializer.fromJson<double>(json['actualAmount']),
      status: serializer.fromJson<String>(json['status']),
      remarks: serializer.fromJson<String?>(json['remarks']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<int>(customerId),
      'shopId': serializer.toJson<int>(shopId),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'actualAmount': serializer.toJson<double>(actualAmount),
      'status': serializer.toJson<String>(status),
      'remarks': serializer.toJson<String?>(remarks),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SalesTransactionData copyWith({
    int? id,
    int? customerId,
    int? shopId,
    double? totalAmount,
    double? actualAmount,
    String? status,
    Value<String?> remarks = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => SalesTransactionData(
    id: id ?? this.id,
    customerId: customerId ?? this.customerId,
    shopId: shopId ?? this.shopId,
    totalAmount: totalAmount ?? this.totalAmount,
    actualAmount: actualAmount ?? this.actualAmount,
    status: status ?? this.status,
    remarks: remarks.present ? remarks.value : this.remarks,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SalesTransactionData copyWithCompanion(SalesTransactionCompanion data) {
    return SalesTransactionData(
      id: data.id.present ? data.id.value : this.id,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      actualAmount: data.actualAmount.present
          ? data.actualAmount.value
          : this.actualAmount,
      status: data.status.present ? data.status.value : this.status,
      remarks: data.remarks.present ? data.remarks.value : this.remarks,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SalesTransactionData(')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('shopId: $shopId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('actualAmount: $actualAmount, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    customerId,
    shopId,
    totalAmount,
    actualAmount,
    status,
    remarks,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesTransactionData &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.shopId == this.shopId &&
          other.totalAmount == this.totalAmount &&
          other.actualAmount == this.actualAmount &&
          other.status == this.status &&
          other.remarks == this.remarks &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SalesTransactionCompanion extends UpdateCompanion<SalesTransactionData> {
  final Value<int> id;
  final Value<int> customerId;
  final Value<int> shopId;
  final Value<double> totalAmount;
  final Value<double> actualAmount;
  final Value<String> status;
  final Value<String?> remarks;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const SalesTransactionCompanion({
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.shopId = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.actualAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SalesTransactionCompanion.insert({
    this.id = const Value.absent(),
    required int customerId,
    required int shopId,
    required double totalAmount,
    required double actualAmount,
    this.status = const Value.absent(),
    this.remarks = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : customerId = Value(customerId),
       shopId = Value(shopId),
       totalAmount = Value(totalAmount),
       actualAmount = Value(actualAmount);
  static Insertable<SalesTransactionData> custom({
    Expression<int>? id,
    Expression<int>? customerId,
    Expression<int>? shopId,
    Expression<double>? totalAmount,
    Expression<double>? actualAmount,
    Expression<String>? status,
    Expression<String>? remarks,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (shopId != null) 'shop_id': shopId,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (actualAmount != null) 'actual_amount': actualAmount,
      if (status != null) 'status': status,
      if (remarks != null) 'remarks': remarks,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SalesTransactionCompanion copyWith({
    Value<int>? id,
    Value<int>? customerId,
    Value<int>? shopId,
    Value<double>? totalAmount,
    Value<double>? actualAmount,
    Value<String>? status,
    Value<String?>? remarks,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return SalesTransactionCompanion(
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      shopId: shopId ?? this.shopId,
      totalAmount: totalAmount ?? this.totalAmount,
      actualAmount: actualAmount ?? this.actualAmount,
      status: status ?? this.status,
      remarks: remarks ?? this.remarks,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<int>(customerId.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (actualAmount.present) {
      map['actual_amount'] = Variable<double>(actualAmount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (remarks.present) {
      map['remarks'] = Variable<String>(remarks.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesTransactionCompanion(')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('shopId: $shopId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('actualAmount: $actualAmount, ')
          ..write('status: $status, ')
          ..write('remarks: $remarks, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $SalesTransactionItemTable extends SalesTransactionItem
    with TableInfo<$SalesTransactionItemTable, SalesTransactionItemData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesTransactionItemTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _salesTransactionIdMeta =
      const VerificationMeta('salesTransactionId');
  @override
  late final GeneratedColumn<int> salesTransactionId = GeneratedColumn<int>(
    'sales_transaction_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sales_transaction (id)',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _batchIdMeta = const VerificationMeta(
    'batchId',
  );
  @override
  late final GeneratedColumn<int> batchId = GeneratedColumn<int>(
    'batch_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_batch (id)',
    ),
  );
  static const VerificationMeta _priceInCentsMeta = const VerificationMeta(
    'priceInCents',
  );
  @override
  late final GeneratedColumn<int> priceInCents = GeneratedColumn<int>(
    'price_in_cents',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    salesTransactionId,
    productId,
    batchId,
    priceInCents,
    quantity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_transaction_item';
  @override
  VerificationContext validateIntegrity(
    Insertable<SalesTransactionItemData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('sales_transaction_id')) {
      context.handle(
        _salesTransactionIdMeta,
        salesTransactionId.isAcceptableOrUnknown(
          data['sales_transaction_id']!,
          _salesTransactionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_salesTransactionIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('batch_id')) {
      context.handle(
        _batchIdMeta,
        batchId.isAcceptableOrUnknown(data['batch_id']!, _batchIdMeta),
      );
    }
    if (data.containsKey('price_in_cents')) {
      context.handle(
        _priceInCentsMeta,
        priceInCents.isAcceptableOrUnknown(
          data['price_in_cents']!,
          _priceInCentsMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_priceInCentsMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesTransactionItemData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesTransactionItemData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      salesTransactionId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sales_transaction_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      batchId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}batch_id'],
      ),
      priceInCents: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}price_in_cents'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
    );
  }

  @override
  $SalesTransactionItemTable createAlias(String alias) {
    return $SalesTransactionItemTable(attachedDatabase, alias);
  }
}

class SalesTransactionItemData extends DataClass
    implements Insertable<SalesTransactionItemData> {
  final int id;
  final int salesTransactionId;
  final int productId;
  final int? batchId;
  final int priceInCents;
  final int quantity;
  const SalesTransactionItemData({
    required this.id,
    required this.salesTransactionId,
    required this.productId,
    this.batchId,
    required this.priceInCents,
    required this.quantity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['sales_transaction_id'] = Variable<int>(salesTransactionId);
    map['product_id'] = Variable<int>(productId);
    if (!nullToAbsent || batchId != null) {
      map['batch_id'] = Variable<int>(batchId);
    }
    map['price_in_cents'] = Variable<int>(priceInCents);
    map['quantity'] = Variable<int>(quantity);
    return map;
  }

  SalesTransactionItemCompanion toCompanion(bool nullToAbsent) {
    return SalesTransactionItemCompanion(
      id: Value(id),
      salesTransactionId: Value(salesTransactionId),
      productId: Value(productId),
      batchId: batchId == null && nullToAbsent
          ? const Value.absent()
          : Value(batchId),
      priceInCents: Value(priceInCents),
      quantity: Value(quantity),
    );
  }

  factory SalesTransactionItemData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesTransactionItemData(
      id: serializer.fromJson<int>(json['id']),
      salesTransactionId: serializer.fromJson<int>(json['salesTransactionId']),
      productId: serializer.fromJson<int>(json['productId']),
      batchId: serializer.fromJson<int?>(json['batchId']),
      priceInCents: serializer.fromJson<int>(json['priceInCents']),
      quantity: serializer.fromJson<int>(json['quantity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'salesTransactionId': serializer.toJson<int>(salesTransactionId),
      'productId': serializer.toJson<int>(productId),
      'batchId': serializer.toJson<int?>(batchId),
      'priceInCents': serializer.toJson<int>(priceInCents),
      'quantity': serializer.toJson<int>(quantity),
    };
  }

  SalesTransactionItemData copyWith({
    int? id,
    int? salesTransactionId,
    int? productId,
    Value<int?> batchId = const Value.absent(),
    int? priceInCents,
    int? quantity,
  }) => SalesTransactionItemData(
    id: id ?? this.id,
    salesTransactionId: salesTransactionId ?? this.salesTransactionId,
    productId: productId ?? this.productId,
    batchId: batchId.present ? batchId.value : this.batchId,
    priceInCents: priceInCents ?? this.priceInCents,
    quantity: quantity ?? this.quantity,
  );
  SalesTransactionItemData copyWithCompanion(
    SalesTransactionItemCompanion data,
  ) {
    return SalesTransactionItemData(
      id: data.id.present ? data.id.value : this.id,
      salesTransactionId: data.salesTransactionId.present
          ? data.salesTransactionId.value
          : this.salesTransactionId,
      productId: data.productId.present ? data.productId.value : this.productId,
      batchId: data.batchId.present ? data.batchId.value : this.batchId,
      priceInCents: data.priceInCents.present
          ? data.priceInCents.value
          : this.priceInCents,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SalesTransactionItemData(')
          ..write('id: $id, ')
          ..write('salesTransactionId: $salesTransactionId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('priceInCents: $priceInCents, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    salesTransactionId,
    productId,
    batchId,
    priceInCents,
    quantity,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesTransactionItemData &&
          other.id == this.id &&
          other.salesTransactionId == this.salesTransactionId &&
          other.productId == this.productId &&
          other.batchId == this.batchId &&
          other.priceInCents == this.priceInCents &&
          other.quantity == this.quantity);
}

class SalesTransactionItemCompanion
    extends UpdateCompanion<SalesTransactionItemData> {
  final Value<int> id;
  final Value<int> salesTransactionId;
  final Value<int> productId;
  final Value<int?> batchId;
  final Value<int> priceInCents;
  final Value<int> quantity;
  const SalesTransactionItemCompanion({
    this.id = const Value.absent(),
    this.salesTransactionId = const Value.absent(),
    this.productId = const Value.absent(),
    this.batchId = const Value.absent(),
    this.priceInCents = const Value.absent(),
    this.quantity = const Value.absent(),
  });
  SalesTransactionItemCompanion.insert({
    this.id = const Value.absent(),
    required int salesTransactionId,
    required int productId,
    this.batchId = const Value.absent(),
    required int priceInCents,
    required int quantity,
  }) : salesTransactionId = Value(salesTransactionId),
       productId = Value(productId),
       priceInCents = Value(priceInCents),
       quantity = Value(quantity);
  static Insertable<SalesTransactionItemData> custom({
    Expression<int>? id,
    Expression<int>? salesTransactionId,
    Expression<int>? productId,
    Expression<int>? batchId,
    Expression<int>? priceInCents,
    Expression<int>? quantity,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (salesTransactionId != null)
        'sales_transaction_id': salesTransactionId,
      if (productId != null) 'product_id': productId,
      if (batchId != null) 'batch_id': batchId,
      if (priceInCents != null) 'price_in_cents': priceInCents,
      if (quantity != null) 'quantity': quantity,
    });
  }

  SalesTransactionItemCompanion copyWith({
    Value<int>? id,
    Value<int>? salesTransactionId,
    Value<int>? productId,
    Value<int?>? batchId,
    Value<int>? priceInCents,
    Value<int>? quantity,
  }) {
    return SalesTransactionItemCompanion(
      id: id ?? this.id,
      salesTransactionId: salesTransactionId ?? this.salesTransactionId,
      productId: productId ?? this.productId,
      batchId: batchId ?? this.batchId,
      priceInCents: priceInCents ?? this.priceInCents,
      quantity: quantity ?? this.quantity,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (salesTransactionId.present) {
      map['sales_transaction_id'] = Variable<int>(salesTransactionId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (batchId.present) {
      map['batch_id'] = Variable<int>(batchId.value);
    }
    if (priceInCents.present) {
      map['price_in_cents'] = Variable<int>(priceInCents.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesTransactionItemCompanion(')
          ..write('id: $id, ')
          ..write('salesTransactionId: $salesTransactionId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('priceInCents: $priceInCents, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }
}

class $OutboundReceiptTable extends OutboundReceipt
    with TableInfo<$OutboundReceiptTable, OutboundReceiptData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OutboundReceiptTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _shopIdMeta = const VerificationMeta('shopId');
  @override
  late final GeneratedColumn<int> shopId = GeneratedColumn<int>(
    'shop_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shop (id)',
    ),
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _salesTransactionIdMeta =
      const VerificationMeta('salesTransactionId');
  @override
  late final GeneratedColumn<int> salesTransactionId = GeneratedColumn<int>(
    'sales_transaction_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sales_transaction (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    shopId,
    reason,
    salesTransactionId,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'outbound_receipt';
  @override
  VerificationContext validateIntegrity(
    Insertable<OutboundReceiptData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('shop_id')) {
      context.handle(
        _shopIdMeta,
        shopId.isAcceptableOrUnknown(data['shop_id']!, _shopIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shopIdMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('sales_transaction_id')) {
      context.handle(
        _salesTransactionIdMeta,
        salesTransactionId.isAcceptableOrUnknown(
          data['sales_transaction_id']!,
          _salesTransactionIdMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OutboundReceiptData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OutboundReceiptData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      shopId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}shop_id'],
      )!,
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      )!,
      salesTransactionId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sales_transaction_id'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $OutboundReceiptTable createAlias(String alias) {
    return $OutboundReceiptTable(attachedDatabase, alias);
  }
}

class OutboundReceiptData extends DataClass
    implements Insertable<OutboundReceiptData> {
  /// ä¸»é”® - å‡ºåº“å•ID
  final int id;

  /// å¤–é”® - åº—é“ºID
  final int shopId;

  /// åŸå› 
  final String reason;

  /// å¤–é”® - é”€å”®å•IDï¼ˆå¦‚æœæ¥è‡ªé”€å”®å•ï¼?  final int? salesTransactionId;

  /// åˆ›å»ºæ—¶é—´
  final DateTime createdAt;
  const OutboundReceiptData({
    required this.id,
    required this.shopId,
    required this.reason,
    this.salesTransactionId,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['shop_id'] = Variable<int>(shopId);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || salesTransactionId != null) {
      map['sales_transaction_id'] = Variable<int>(salesTransactionId);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  OutboundReceiptCompanion toCompanion(bool nullToAbsent) {
    return OutboundReceiptCompanion(
      id: Value(id),
      shopId: Value(shopId),
      reason: Value(reason),
      salesTransactionId: salesTransactionId == null && nullToAbsent
          ? const Value.absent()
          : Value(salesTransactionId),
      createdAt: Value(createdAt),
    );
  }

  factory OutboundReceiptData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OutboundReceiptData(
      id: serializer.fromJson<int>(json['id']),
      shopId: serializer.fromJson<int>(json['shopId']),
      reason: serializer.fromJson<String>(json['reason']),
      salesTransactionId: serializer.fromJson<int?>(json['salesTransactionId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'shopId': serializer.toJson<int>(shopId),
      'reason': serializer.toJson<String>(reason),
      'salesTransactionId': serializer.toJson<int?>(salesTransactionId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  OutboundReceiptData copyWith({
    int? id,
    int? shopId,
    String? reason,
    Value<int?> salesTransactionId = const Value.absent(),
    DateTime? createdAt,
  }) => OutboundReceiptData(
    id: id ?? this.id,
    shopId: shopId ?? this.shopId,
    reason: reason ?? this.reason,
    salesTransactionId: salesTransactionId.present
        ? salesTransactionId.value
        : this.salesTransactionId,
    createdAt: createdAt ?? this.createdAt,
  );
  OutboundReceiptData copyWithCompanion(OutboundReceiptCompanion data) {
    return OutboundReceiptData(
      id: data.id.present ? data.id.value : this.id,
      shopId: data.shopId.present ? data.shopId.value : this.shopId,
      reason: data.reason.present ? data.reason.value : this.reason,
      salesTransactionId: data.salesTransactionId.present
          ? data.salesTransactionId.value
          : this.salesTransactionId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OutboundReceiptData(')
          ..write('id: $id, ')
          ..write('shopId: $shopId, ')
          ..write('reason: $reason, ')
          ..write('salesTransactionId: $salesTransactionId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, shopId, reason, salesTransactionId, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OutboundReceiptData &&
          other.id == this.id &&
          other.shopId == this.shopId &&
          other.reason == this.reason &&
          other.salesTransactionId == this.salesTransactionId &&
          other.createdAt == this.createdAt);
}

class OutboundReceiptCompanion extends UpdateCompanion<OutboundReceiptData> {
  final Value<int> id;
  final Value<int> shopId;
  final Value<String> reason;
  final Value<int?> salesTransactionId;
  final Value<DateTime> createdAt;
  const OutboundReceiptCompanion({
    this.id = const Value.absent(),
    this.shopId = const Value.absent(),
    this.reason = const Value.absent(),
    this.salesTransactionId = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  OutboundReceiptCompanion.insert({
    this.id = const Value.absent(),
    required int shopId,
    required String reason,
    this.salesTransactionId = const Value.absent(),
    this.createdAt = const Value.absent(),
  }) : shopId = Value(shopId),
       reason = Value(reason);
  static Insertable<OutboundReceiptData> custom({
    Expression<int>? id,
    Expression<int>? shopId,
    Expression<String>? reason,
    Expression<int>? salesTransactionId,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (shopId != null) 'shop_id': shopId,
      if (reason != null) 'reason': reason,
      if (salesTransactionId != null)
        'sales_transaction_id': salesTransactionId,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  OutboundReceiptCompanion copyWith({
    Value<int>? id,
    Value<int>? shopId,
    Value<String>? reason,
    Value<int?>? salesTransactionId,
    Value<DateTime>? createdAt,
  }) {
    return OutboundReceiptCompanion(
      id: id ?? this.id,
      shopId: shopId ?? this.shopId,
      reason: reason ?? this.reason,
      salesTransactionId: salesTransactionId ?? this.salesTransactionId,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (shopId.present) {
      map['shop_id'] = Variable<int>(shopId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (salesTransactionId.present) {
      map['sales_transaction_id'] = Variable<int>(salesTransactionId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OutboundReceiptCompanion(')
          ..write('id: $id, ')
          ..write('shopId: $shopId, ')
          ..write('reason: $reason, ')
          ..write('salesTransactionId: $salesTransactionId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $OutboundItemTable extends OutboundItem
    with TableInfo<$OutboundItemTable, OutboundItemData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OutboundItemTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _receiptIdMeta = const VerificationMeta(
    'receiptId',
  );
  @override
  late final GeneratedColumn<int> receiptId = GeneratedColumn<int>(
    'receipt_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES outbound_receipt (id)',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<int> productId = GeneratedColumn<int>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product (id)',
    ),
  );
  static const VerificationMeta _batchIdMeta = const VerificationMeta(
    'batchId',
  );
  @override
  late final GeneratedColumn<int> batchId = GeneratedColumn<int>(
    'batch_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_batch (id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    receiptId,
    productId,
    batchId,
    quantity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'outbound_item';
  @override
  VerificationContext validateIntegrity(
    Insertable<OutboundItemData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('receipt_id')) {
      context.handle(
        _receiptIdMeta,
        receiptId.isAcceptableOrUnknown(data['receipt_id']!, _receiptIdMeta),
      );
    } else if (isInserting) {
      context.missing(_receiptIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('batch_id')) {
      context.handle(
        _batchIdMeta,
        batchId.isAcceptableOrUnknown(data['batch_id']!, _batchIdMeta),
      );
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OutboundItemData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OutboundItemData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      receiptId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}receipt_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}product_id'],
      )!,
      batchId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}batch_id'],
      ),
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
    );
  }

  @override
  $OutboundItemTable createAlias(String alias) {
    return $OutboundItemTable(attachedDatabase, alias);
  }
}

class OutboundItemData extends DataClass
    implements Insertable<OutboundItemData> {
  /// ä¸»é”® - æ˜ç»†ID
  final int id;

  /// å¤–é”® - å‡ºåº“å•ID
  final int receiptId;

  /// å¤–é”® - å•†å“ID
  final int productId;

  /// æ‰¹æ¬¡å?  final int? batchId;

  /// æ•°é‡
  final int quantity;
  const OutboundItemData({
    required this.id,
    required this.receiptId,
    required this.productId,
    this.batchId,
    required this.quantity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['receipt_id'] = Variable<int>(receiptId);
    map['product_id'] = Variable<int>(productId);
    if (!nullToAbsent || batchId != null) {
      map['batch_id'] = Variable<int>(batchId);
    }
    map['quantity'] = Variable<int>(quantity);
    return map;
  }

  OutboundItemCompanion toCompanion(bool nullToAbsent) {
    return OutboundItemCompanion(
      id: Value(id),
      receiptId: Value(receiptId),
      productId: Value(productId),
      batchId: batchId == null && nullToAbsent
          ? const Value.absent()
          : Value(batchId),
      quantity: Value(quantity),
    );
  }

  factory OutboundItemData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OutboundItemData(
      id: serializer.fromJson<int>(json['id']),
      receiptId: serializer.fromJson<int>(json['receiptId']),
      productId: serializer.fromJson<int>(json['productId']),
      batchId: serializer.fromJson<int?>(json['batchId']),
      quantity: serializer.fromJson<int>(json['quantity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'receiptId': serializer.toJson<int>(receiptId),
      'productId': serializer.toJson<int>(productId),
      'batchId': serializer.toJson<int?>(batchId),
      'quantity': serializer.toJson<int>(quantity),
    };
  }

  OutboundItemData copyWith({
    int? id,
    int? receiptId,
    int? productId,
    Value<int?> batchId = const Value.absent(),
    int? quantity,
  }) => OutboundItemData(
    id: id ?? this.id,
    receiptId: receiptId ?? this.receiptId,
    productId: productId ?? this.productId,
    batchId: batchId.present ? batchId.value : this.batchId,
    quantity: quantity ?? this.quantity,
  );
  OutboundItemData copyWithCompanion(OutboundItemCompanion data) {
    return OutboundItemData(
      id: data.id.present ? data.id.value : this.id,
      receiptId: data.receiptId.present ? data.receiptId.value : this.receiptId,
      productId: data.productId.present ? data.productId.value : this.productId,
      batchId: data.batchId.present ? data.batchId.value : this.batchId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OutboundItemData(')
          ..write('id: $id, ')
          ..write('receiptId: $receiptId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, receiptId, productId, batchId, quantity);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OutboundItemData &&
          other.id == this.id &&
          other.receiptId == this.receiptId &&
          other.productId == this.productId &&
          other.batchId == this.batchId &&
          other.quantity == this.quantity);
}

class OutboundItemCompanion extends UpdateCompanion<OutboundItemData> {
  final Value<int> id;
  final Value<int> receiptId;
  final Value<int> productId;
  final Value<int?> batchId;
  final Value<int> quantity;
  const OutboundItemCompanion({
    this.id = const Value.absent(),
    this.receiptId = const Value.absent(),
    this.productId = const Value.absent(),
    this.batchId = const Value.absent(),
    this.quantity = const Value.absent(),
  });
  OutboundItemCompanion.insert({
    this.id = const Value.absent(),
    required int receiptId,
    required int productId,
    this.batchId = const Value.absent(),
    required int quantity,
  }) : receiptId = Value(receiptId),
       productId = Value(productId),
       quantity = Value(quantity);
  static Insertable<OutboundItemData> custom({
    Expression<int>? id,
    Expression<int>? receiptId,
    Expression<int>? productId,
    Expression<int>? batchId,
    Expression<int>? quantity,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (receiptId != null) 'receipt_id': receiptId,
      if (productId != null) 'product_id': productId,
      if (batchId != null) 'batch_id': batchId,
      if (quantity != null) 'quantity': quantity,
    });
  }

  OutboundItemCompanion copyWith({
    Value<int>? id,
    Value<int>? receiptId,
    Value<int>? productId,
    Value<int?>? batchId,
    Value<int>? quantity,
  }) {
    return OutboundItemCompanion(
      id: id ?? this.id,
      receiptId: receiptId ?? this.receiptId,
      productId: productId ?? this.productId,
      batchId: batchId ?? this.batchId,
      quantity: quantity ?? this.quantity,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (receiptId.present) {
      map['receipt_id'] = Variable<int>(receiptId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<int>(productId.value);
    }
    if (batchId.present) {
      map['batch_id'] = Variable<int>(batchId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OutboundItemCompanion(')
          ..write('id: $id, ')
          ..write('receiptId: $receiptId, ')
          ..write('productId: $productId, ')
          ..write('batchId: $batchId, ')
          ..write('quantity: $quantity')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $UnitTable unit = $UnitTable(this);
  late final $CategoryTable category = $CategoryTable(this);
  late final $ProductTable product = $ProductTable(this);
  late final $UnitProductTable unitProduct = $UnitProductTable(this);
  late final $ShopTable shop = $ShopTable(this);
  late final $SupplierTable supplier = $SupplierTable(this);
  late final $ProductBatchTable productBatch = $ProductBatchTable(this);
  late final $StockTable stock = $StockTable(this);
  late final $InventoryTransactionTable inventoryTransaction =
      $InventoryTransactionTable(this);
  late final $LocationsTableTable locationsTable = $LocationsTableTable(this);
  late final $PurchaseOrderTable purchaseOrder = $PurchaseOrderTable(this);
  late final $InboundReceiptTable inboundReceipt = $InboundReceiptTable(this);
  late final $InboundItemTable inboundItem = $InboundItemTable(this);
  late final $PurchaseOrderItemTable purchaseOrderItem =
      $PurchaseOrderItemTable(this);
  late final $BarcodeTable barcode = $BarcodeTable(this);
  late final $CustomersTable customers = $CustomersTable(this);
  late final $SalesTransactionTable salesTransaction = $SalesTransactionTable(
    this,
  );
  late final $SalesTransactionItemTable salesTransactionItem =
      $SalesTransactionItemTable(this);
  late final $OutboundReceiptTable outboundReceipt = $OutboundReceiptTable(
    this,
  );
  late final $OutboundItemTable outboundItem = $OutboundItemTable(this);
  late final ProductDao productDao = ProductDao(this as AppDatabase);
  late final CategoryDao categoryDao = CategoryDao(this as AppDatabase);
  late final UnitDao unitDao = UnitDao(this as AppDatabase);
  late final ProductUnitDao productUnitDao = ProductUnitDao(
    this as AppDatabase,
  );
  late final ShopDao shopDao = ShopDao(this as AppDatabase);
  late final SupplierDao supplierDao = SupplierDao(this as AppDatabase);
  late final BatchDao batchDao = BatchDao(this as AppDatabase);
  late final InventoryDao inventoryDao = InventoryDao(this as AppDatabase);
  late final InventoryTransactionDao inventoryTransactionDao =
      InventoryTransactionDao(this as AppDatabase);
  late final LocationDao locationDao = LocationDao(this as AppDatabase);
  late final InboundReceiptDao inboundReceiptDao = InboundReceiptDao(
    this as AppDatabase,
  );
  late final InboundItemDao inboundItemDao = InboundItemDao(
    this as AppDatabase,
  );
  late final PurchaseDao purchaseDao = PurchaseDao(this as AppDatabase);
  late final BarcodeDao barcodeDao = BarcodeDao(this as AppDatabase);
  late final CustomerDao customerDao = CustomerDao(this as AppDatabase);
  late final SalesTransactionDao salesTransactionDao = SalesTransactionDao(
    this as AppDatabase,
  );
  late final SalesTransactionItemDao salesTransactionItemDao =
      SalesTransactionItemDao(this as AppDatabase);
  late final OutboundReceiptDao outboundReceiptDao = OutboundReceiptDao(
    this as AppDatabase,
  );
  late final OutboundItemDao outboundItemDao = OutboundItemDao(
    this as AppDatabase,
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    unit,
    category,
    product,
    unitProduct,
    shop,
    supplier,
    productBatch,
    stock,
    inventoryTransaction,
    locationsTable,
    purchaseOrder,
    inboundReceipt,
    inboundItem,
    purchaseOrderItem,
    barcode,
    customers,
    salesTransaction,
    salesTransactionItem,
    outboundReceipt,
    outboundItem,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'product',
        limitUpdateKind: UpdateKind.update,
      ),
      result: [TableUpdate('product_batch', kind: UpdateKind.update)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'shop',
        limitUpdateKind: UpdateKind.update,
      ),
      result: [TableUpdate('product_batch', kind: UpdateKind.update)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'purchase_order',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('purchase_order_item', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$UnitTableCreateCompanionBuilder =
    UnitCompanion Function({Value<int> id, required String name});
typedef $$UnitTableUpdateCompanionBuilder =
    UnitCompanion Function({Value<int> id, Value<String> name});

final class $$UnitTableReferences
    extends BaseReferences<_$AppDatabase, $UnitTable, UnitData> {
  $$UnitTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductTable, List<ProductData>>
  _productRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.product,
    aliasName: $_aliasNameGenerator(db.unit.id, db.product.baseUnitId),
  );

  $$ProductTableProcessedTableManager get productRefs {
    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.baseUnitId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_productRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UnitProductTable, List<UnitProductData>>
  _unitProductRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.unitProduct,
    aliasName: $_aliasNameGenerator(db.unit.id, db.unitProduct.unitId),
  );

  $$UnitProductTableProcessedTableManager get unitProductRefs {
    final manager = $$UnitProductTableTableManager(
      $_db,
      $_db.unitProduct,
    ).filter((f) => f.unitId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_unitProductRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UnitTableFilterComposer extends Composer<_$AppDatabase, $UnitTable> {
  $$UnitTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productRefs(
    Expression<bool> Function($$ProductTableFilterComposer f) f,
  ) {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.baseUnitId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> unitProductRefs(
    Expression<bool> Function($$UnitProductTableFilterComposer f) f,
  ) {
    final $$UnitProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.unitId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableFilterComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UnitTableOrderingComposer extends Composer<_$AppDatabase, $UnitTable> {
  $$UnitTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UnitTableAnnotationComposer
    extends Composer<_$AppDatabase, $UnitTable> {
  $$UnitTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> productRefs<T extends Object>(
    Expression<T> Function($$ProductTableAnnotationComposer a) f,
  ) {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.baseUnitId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> unitProductRefs<T extends Object>(
    Expression<T> Function($$UnitProductTableAnnotationComposer a) f,
  ) {
    final $$UnitProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.unitId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableAnnotationComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UnitTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UnitTable,
          UnitData,
          $$UnitTableFilterComposer,
          $$UnitTableOrderingComposer,
          $$UnitTableAnnotationComposer,
          $$UnitTableCreateCompanionBuilder,
          $$UnitTableUpdateCompanionBuilder,
          (UnitData, $$UnitTableReferences),
          UnitData,
          PrefetchHooks Function({bool productRefs, bool unitProductRefs})
        > {
  $$UnitTableTableManager(_$AppDatabase db, $UnitTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UnitTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UnitTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UnitTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => UnitCompanion(id: id, name: name),
          createCompanionCallback:
              ({Value<int> id = const Value.absent(), required String name}) =>
                  UnitCompanion.insert(id: id, name: name),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$UnitTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({productRefs = false, unitProductRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (productRefs) db.product,
                    if (unitProductRefs) db.unitProduct,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (productRefs)
                        await $_getPrefetchedData<
                          UnitData,
                          $UnitTable,
                          ProductData
                        >(
                          currentTable: table,
                          referencedTable: $$UnitTableReferences
                              ._productRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UnitTableReferences(db, table, p0).productRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.baseUnitId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (unitProductRefs)
                        await $_getPrefetchedData<
                          UnitData,
                          $UnitTable,
                          UnitProductData
                        >(
                          currentTable: table,
                          referencedTable: $$UnitTableReferences
                              ._unitProductRefsTable(db),
                          managerFromTypedResult: (p0) => $$UnitTableReferences(
                            db,
                            table,
                            p0,
                          ).unitProductRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.unitId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UnitTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UnitTable,
      UnitData,
      $$UnitTableFilterComposer,
      $$UnitTableOrderingComposer,
      $$UnitTableAnnotationComposer,
      $$UnitTableCreateCompanionBuilder,
      $$UnitTableUpdateCompanionBuilder,
      (UnitData, $$UnitTableReferences),
      UnitData,
      PrefetchHooks Function({bool productRefs, bool unitProductRefs})
    >;
typedef $$CategoryTableCreateCompanionBuilder =
    CategoryCompanion Function({
      Value<int> id,
      required String name,
      Value<int?> parentId,
    });
typedef $$CategoryTableUpdateCompanionBuilder =
    CategoryCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<int?> parentId,
    });

final class $$CategoryTableReferences
    extends BaseReferences<_$AppDatabase, $CategoryTable, CategoryData> {
  $$CategoryTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductTable, List<ProductData>>
  _productRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.product,
    aliasName: $_aliasNameGenerator(db.category.id, db.product.categoryId),
  );

  $$ProductTableProcessedTableManager get productRefs {
    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.categoryId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_productRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CategoryTableFilterComposer
    extends Composer<_$AppDatabase, $CategoryTable> {
  $$CategoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get parentId => $composableBuilder(
    column: $table.parentId,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productRefs(
    Expression<bool> Function($$ProductTableFilterComposer f) f,
  ) {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoryTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoryTable> {
  $$CategoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get parentId => $composableBuilder(
    column: $table.parentId,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CategoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoryTable> {
  $$CategoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get parentId =>
      $composableBuilder(column: $table.parentId, builder: (column) => column);

  Expression<T> productRefs<T extends Object>(
    Expression<T> Function($$ProductTableAnnotationComposer a) f,
  ) {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CategoryTable,
          CategoryData,
          $$CategoryTableFilterComposer,
          $$CategoryTableOrderingComposer,
          $$CategoryTableAnnotationComposer,
          $$CategoryTableCreateCompanionBuilder,
          $$CategoryTableUpdateCompanionBuilder,
          (CategoryData, $$CategoryTableReferences),
          CategoryData,
          PrefetchHooks Function({bool productRefs})
        > {
  $$CategoryTableTableManager(_$AppDatabase db, $CategoryTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int?> parentId = const Value.absent(),
              }) => CategoryCompanion(id: id, name: name, parentId: parentId),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                Value<int?> parentId = const Value.absent(),
              }) => CategoryCompanion.insert(
                id: id,
                name: name,
                parentId: parentId,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CategoryTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (productRefs) db.product],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productRefs)
                    await $_getPrefetchedData<
                      CategoryData,
                      $CategoryTable,
                      ProductData
                    >(
                      currentTable: table,
                      referencedTable: $$CategoryTableReferences
                          ._productRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CategoryTableReferences(db, table, p0).productRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.categoryId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CategoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CategoryTable,
      CategoryData,
      $$CategoryTableFilterComposer,
      $$CategoryTableOrderingComposer,
      $$CategoryTableAnnotationComposer,
      $$CategoryTableCreateCompanionBuilder,
      $$CategoryTableUpdateCompanionBuilder,
      (CategoryData, $$CategoryTableReferences),
      CategoryData,
      PrefetchHooks Function({bool productRefs})
    >;
typedef $$ProductTableCreateCompanionBuilder =
    ProductCompanion Function({
      Value<int> id,
      required String name,
      Value<String?> sku,
      Value<String?> image,
      required int baseUnitId,
      Value<int?> categoryId,
      Value<String?> specification,
      Value<String?> brand,
      Value<Money?> suggestedRetailPrice,
      Value<Money?> retailPrice,
      Value<Money?> promotionalPrice,
      Value<int?> stockWarningValue,
      Value<int?> shelfLife,
      Value<ShelfLifeUnit> shelfLifeUnit,
      Value<bool> enableBatchManagement,
      Value<ProductStatus> status,
      Value<String?> remarks,
      Value<DateTime?> lastUpdated,
    });
typedef $$ProductTableUpdateCompanionBuilder =
    ProductCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<String?> sku,
      Value<String?> image,
      Value<int> baseUnitId,
      Value<int?> categoryId,
      Value<String?> specification,
      Value<String?> brand,
      Value<Money?> suggestedRetailPrice,
      Value<Money?> retailPrice,
      Value<Money?> promotionalPrice,
      Value<int?> stockWarningValue,
      Value<int?> shelfLife,
      Value<ShelfLifeUnit> shelfLifeUnit,
      Value<bool> enableBatchManagement,
      Value<ProductStatus> status,
      Value<String?> remarks,
      Value<DateTime?> lastUpdated,
    });

final class $$ProductTableReferences
    extends BaseReferences<_$AppDatabase, $ProductTable, ProductData> {
  $$ProductTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UnitTable _baseUnitIdTable(_$AppDatabase db) => db.unit.createAlias(
    $_aliasNameGenerator(db.product.baseUnitId, db.unit.id),
  );

  $$UnitTableProcessedTableManager get baseUnitId {
    final $_column = $_itemColumn<int>('base_unit_id')!;

    final manager = $$UnitTableTableManager(
      $_db,
      $_db.unit,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_baseUnitIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CategoryTable _categoryIdTable(_$AppDatabase db) => db.category
      .createAlias($_aliasNameGenerator(db.product.categoryId, db.category.id));

  $$CategoryTableProcessedTableManager? get categoryId {
    final $_column = $_itemColumn<int>('category_id');
    if ($_column == null) return null;
    final manager = $$CategoryTableTableManager(
      $_db,
      $_db.category,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_categoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$UnitProductTable, List<UnitProductData>>
  _unitProductRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.unitProduct,
    aliasName: $_aliasNameGenerator(db.product.id, db.unitProduct.productId),
  );

  $$UnitProductTableProcessedTableManager get unitProductRefs {
    final manager = $$UnitProductTableTableManager(
      $_db,
      $_db.unitProduct,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_unitProductRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ProductBatchTable, List<ProductBatchData>>
  _productBatchRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.productBatch,
    aliasName: $_aliasNameGenerator(db.product.id, db.productBatch.productId),
  );

  $$ProductBatchTableProcessedTableManager get productBatchRefs {
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_productBatchRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StockTable, List<StockData>> _stockRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.stock,
    aliasName: $_aliasNameGenerator(db.product.id, db.stock.productId),
  );

  $$StockTableProcessedTableManager get stockRefs {
    final manager = $$StockTableTableManager(
      $_db,
      $_db.stock,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_stockRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $InventoryTransactionTable,
    List<InventoryTransactionData>
  >
  _inventoryTransactionRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.inventoryTransaction,
        aliasName: $_aliasNameGenerator(
          db.product.id,
          db.inventoryTransaction.productId,
        ),
      );

  $$InventoryTransactionTableProcessedTableManager
  get inventoryTransactionRefs {
    final manager = $$InventoryTransactionTableTableManager(
      $_db,
      $_db.inventoryTransaction,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _inventoryTransactionRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$InboundItemTable, List<InboundItemData>>
  _inboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.inboundItem,
    aliasName: $_aliasNameGenerator(db.product.id, db.inboundItem.productId),
  );

  $$InboundItemTableProcessedTableManager get inboundItemRefs {
    final manager = $$InboundItemTableTableManager(
      $_db,
      $_db.inboundItem,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_inboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $PurchaseOrderItemTable,
    List<PurchaseOrderItemData>
  >
  _purchaseOrderItemRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.purchaseOrderItem,
        aliasName: $_aliasNameGenerator(
          db.product.id,
          db.purchaseOrderItem.productId,
        ),
      );

  $$PurchaseOrderItemTableProcessedTableManager get purchaseOrderItemRefs {
    final manager = $$PurchaseOrderItemTableTableManager(
      $_db,
      $_db.purchaseOrderItem,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _purchaseOrderItemRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $SalesTransactionItemTable,
    List<SalesTransactionItemData>
  >
  _salesTransactionItemRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.salesTransactionItem,
        aliasName: $_aliasNameGenerator(
          db.product.id,
          db.salesTransactionItem.productId,
        ),
      );

  $$SalesTransactionItemTableProcessedTableManager
  get salesTransactionItemRefs {
    final manager = $$SalesTransactionItemTableTableManager(
      $_db,
      $_db.salesTransactionItem,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _salesTransactionItemRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$OutboundItemTable, List<OutboundItemData>>
  _outboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.outboundItem,
    aliasName: $_aliasNameGenerator(db.product.id, db.outboundItem.productId),
  );

  $$OutboundItemTableProcessedTableManager get outboundItemRefs {
    final manager = $$OutboundItemTableTableManager(
      $_db,
      $_db.outboundItem,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_outboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductTableFilterComposer
    extends Composer<_$AppDatabase, $ProductTable> {
  $$ProductTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sku => $composableBuilder(
    column: $table.sku,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get image => $composableBuilder(
    column: $table.image,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get specification => $composableBuilder(
    column: $table.specification,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Money?, Money, int> get suggestedRetailPrice =>
      $composableBuilder(
        column: $table.suggestedRetailPrice,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnWithTypeConverterFilters<Money?, Money, int> get retailPrice =>
      $composableBuilder(
        column: $table.retailPrice,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnWithTypeConverterFilters<Money?, Money, int> get promotionalPrice =>
      $composableBuilder(
        column: $table.promotionalPrice,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<int> get stockWarningValue => $composableBuilder(
    column: $table.stockWarningValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shelfLife => $composableBuilder(
    column: $table.shelfLife,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<ShelfLifeUnit, ShelfLifeUnit, String>
  get shelfLifeUnit => $composableBuilder(
    column: $table.shelfLifeUnit,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get enableBatchManagement => $composableBuilder(
    column: $table.enableBatchManagement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<ProductStatus, ProductStatus, String>
  get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnFilters(column),
  );

  $$UnitTableFilterComposer get baseUnitId {
    final $$UnitTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.baseUnitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableFilterComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoryTableFilterComposer get categoryId {
    final $$CategoryTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.category,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoryTableFilterComposer(
            $db: $db,
            $table: $db.category,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> unitProductRefs(
    Expression<bool> Function($$UnitProductTableFilterComposer f) f,
  ) {
    final $$UnitProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableFilterComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> productBatchRefs(
    Expression<bool> Function($$ProductBatchTableFilterComposer f) f,
  ) {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stockRefs(
    Expression<bool> Function($$StockTableFilterComposer f) f,
  ) {
    final $$StockTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableFilterComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inventoryTransactionRefs(
    Expression<bool> Function($$InventoryTransactionTableFilterComposer f) f,
  ) {
    final $$InventoryTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inventoryTransaction,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InventoryTransactionTableFilterComposer(
            $db: $db,
            $table: $db.inventoryTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inboundItemRefs(
    Expression<bool> Function($$InboundItemTableFilterComposer f) f,
  ) {
    final $$InboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableFilterComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrderItemRefs(
    Expression<bool> Function($$PurchaseOrderItemTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrderItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderItemTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrderItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesTransactionItemRefs(
    Expression<bool> Function($$SalesTransactionItemTableFilterComposer f) f,
  ) {
    final $$SalesTransactionItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransactionItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionItemTableFilterComposer(
            $db: $db,
            $table: $db.salesTransactionItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> outboundItemRefs(
    Expression<bool> Function($$OutboundItemTableFilterComposer f) f,
  ) {
    final $$OutboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableFilterComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductTable> {
  $$ProductTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sku => $composableBuilder(
    column: $table.sku,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get image => $composableBuilder(
    column: $table.image,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get specification => $composableBuilder(
    column: $table.specification,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get suggestedRetailPrice => $composableBuilder(
    column: $table.suggestedRetailPrice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retailPrice => $composableBuilder(
    column: $table.retailPrice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get promotionalPrice => $composableBuilder(
    column: $table.promotionalPrice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get stockWarningValue => $composableBuilder(
    column: $table.stockWarningValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shelfLife => $composableBuilder(
    column: $table.shelfLife,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get shelfLifeUnit => $composableBuilder(
    column: $table.shelfLifeUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get enableBatchManagement => $composableBuilder(
    column: $table.enableBatchManagement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnOrderings(column),
  );

  $$UnitTableOrderingComposer get baseUnitId {
    final $$UnitTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.baseUnitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableOrderingComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoryTableOrderingComposer get categoryId {
    final $$CategoryTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.category,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoryTableOrderingComposer(
            $db: $db,
            $table: $db.category,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductTable> {
  $$ProductTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get sku =>
      $composableBuilder(column: $table.sku, builder: (column) => column);

  GeneratedColumn<String> get image =>
      $composableBuilder(column: $table.image, builder: (column) => column);

  GeneratedColumn<String> get specification => $composableBuilder(
    column: $table.specification,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Money?, int> get suggestedRetailPrice =>
      $composableBuilder(
        column: $table.suggestedRetailPrice,
        builder: (column) => column,
      );

  GeneratedColumnWithTypeConverter<Money?, int> get retailPrice =>
      $composableBuilder(
        column: $table.retailPrice,
        builder: (column) => column,
      );

  GeneratedColumnWithTypeConverter<Money?, int> get promotionalPrice =>
      $composableBuilder(
        column: $table.promotionalPrice,
        builder: (column) => column,
      );

  GeneratedColumn<int> get stockWarningValue => $composableBuilder(
    column: $table.stockWarningValue,
    builder: (column) => column,
  );

  GeneratedColumn<int> get shelfLife =>
      $composableBuilder(column: $table.shelfLife, builder: (column) => column);

  GeneratedColumnWithTypeConverter<ShelfLifeUnit, String> get shelfLifeUnit =>
      $composableBuilder(
        column: $table.shelfLifeUnit,
        builder: (column) => column,
      );

  GeneratedColumn<bool> get enableBatchManagement => $composableBuilder(
    column: $table.enableBatchManagement,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<ProductStatus, String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get remarks =>
      $composableBuilder(column: $table.remarks, builder: (column) => column);

  GeneratedColumn<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => column,
  );

  $$UnitTableAnnotationComposer get baseUnitId {
    final $$UnitTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.baseUnitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableAnnotationComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoryTableAnnotationComposer get categoryId {
    final $$CategoryTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.category,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoryTableAnnotationComposer(
            $db: $db,
            $table: $db.category,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> unitProductRefs<T extends Object>(
    Expression<T> Function($$UnitProductTableAnnotationComposer a) f,
  ) {
    final $$UnitProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableAnnotationComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> productBatchRefs<T extends Object>(
    Expression<T> Function($$ProductBatchTableAnnotationComposer a) f,
  ) {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stockRefs<T extends Object>(
    Expression<T> Function($$StockTableAnnotationComposer a) f,
  ) {
    final $$StockTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableAnnotationComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> inventoryTransactionRefs<T extends Object>(
    Expression<T> Function($$InventoryTransactionTableAnnotationComposer a) f,
  ) {
    final $$InventoryTransactionTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.inventoryTransaction,
          getReferencedColumn: (t) => t.productId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$InventoryTransactionTableAnnotationComposer(
                $db: $db,
                $table: $db.inventoryTransaction,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> inboundItemRefs<T extends Object>(
    Expression<T> Function($$InboundItemTableAnnotationComposer a) f,
  ) {
    final $$InboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrderItemRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderItemTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderItemTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.purchaseOrderItem,
          getReferencedColumn: (t) => t.productId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$PurchaseOrderItemTableAnnotationComposer(
                $db: $db,
                $table: $db.purchaseOrderItem,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> salesTransactionItemRefs<T extends Object>(
    Expression<T> Function($$SalesTransactionItemTableAnnotationComposer a) f,
  ) {
    final $$SalesTransactionItemTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.salesTransactionItem,
          getReferencedColumn: (t) => t.productId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SalesTransactionItemTableAnnotationComposer(
                $db: $db,
                $table: $db.salesTransactionItem,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> outboundItemRefs<T extends Object>(
    Expression<T> Function($$OutboundItemTableAnnotationComposer a) f,
  ) {
    final $$OutboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductTable,
          ProductData,
          $$ProductTableFilterComposer,
          $$ProductTableOrderingComposer,
          $$ProductTableAnnotationComposer,
          $$ProductTableCreateCompanionBuilder,
          $$ProductTableUpdateCompanionBuilder,
          (ProductData, $$ProductTableReferences),
          ProductData,
          PrefetchHooks Function({
            bool baseUnitId,
            bool categoryId,
            bool unitProductRefs,
            bool productBatchRefs,
            bool stockRefs,
            bool inventoryTransactionRefs,
            bool inboundItemRefs,
            bool purchaseOrderItemRefs,
            bool salesTransactionItemRefs,
            bool outboundItemRefs,
          })
        > {
  $$ProductTableTableManager(_$AppDatabase db, $ProductTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> sku = const Value.absent(),
                Value<String?> image = const Value.absent(),
                Value<int> baseUnitId = const Value.absent(),
                Value<int?> categoryId = const Value.absent(),
                Value<String?> specification = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<Money?> suggestedRetailPrice = const Value.absent(),
                Value<Money?> retailPrice = const Value.absent(),
                Value<Money?> promotionalPrice = const Value.absent(),
                Value<int?> stockWarningValue = const Value.absent(),
                Value<int?> shelfLife = const Value.absent(),
                Value<ShelfLifeUnit> shelfLifeUnit = const Value.absent(),
                Value<bool> enableBatchManagement = const Value.absent(),
                Value<ProductStatus> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime?> lastUpdated = const Value.absent(),
              }) => ProductCompanion(
                id: id,
                name: name,
                sku: sku,
                image: image,
                baseUnitId: baseUnitId,
                categoryId: categoryId,
                specification: specification,
                brand: brand,
                suggestedRetailPrice: suggestedRetailPrice,
                retailPrice: retailPrice,
                promotionalPrice: promotionalPrice,
                stockWarningValue: stockWarningValue,
                shelfLife: shelfLife,
                shelfLifeUnit: shelfLifeUnit,
                enableBatchManagement: enableBatchManagement,
                status: status,
                remarks: remarks,
                lastUpdated: lastUpdated,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                Value<String?> sku = const Value.absent(),
                Value<String?> image = const Value.absent(),
                required int baseUnitId,
                Value<int?> categoryId = const Value.absent(),
                Value<String?> specification = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<Money?> suggestedRetailPrice = const Value.absent(),
                Value<Money?> retailPrice = const Value.absent(),
                Value<Money?> promotionalPrice = const Value.absent(),
                Value<int?> stockWarningValue = const Value.absent(),
                Value<int?> shelfLife = const Value.absent(),
                Value<ShelfLifeUnit> shelfLifeUnit = const Value.absent(),
                Value<bool> enableBatchManagement = const Value.absent(),
                Value<ProductStatus> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime?> lastUpdated = const Value.absent(),
              }) => ProductCompanion.insert(
                id: id,
                name: name,
                sku: sku,
                image: image,
                baseUnitId: baseUnitId,
                categoryId: categoryId,
                specification: specification,
                brand: brand,
                suggestedRetailPrice: suggestedRetailPrice,
                retailPrice: retailPrice,
                promotionalPrice: promotionalPrice,
                stockWarningValue: stockWarningValue,
                shelfLife: shelfLife,
                shelfLifeUnit: shelfLifeUnit,
                enableBatchManagement: enableBatchManagement,
                status: status,
                remarks: remarks,
                lastUpdated: lastUpdated,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                baseUnitId = false,
                categoryId = false,
                unitProductRefs = false,
                productBatchRefs = false,
                stockRefs = false,
                inventoryTransactionRefs = false,
                inboundItemRefs = false,
                purchaseOrderItemRefs = false,
                salesTransactionItemRefs = false,
                outboundItemRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (unitProductRefs) db.unitProduct,
                    if (productBatchRefs) db.productBatch,
                    if (stockRefs) db.stock,
                    if (inventoryTransactionRefs) db.inventoryTransaction,
                    if (inboundItemRefs) db.inboundItem,
                    if (purchaseOrderItemRefs) db.purchaseOrderItem,
                    if (salesTransactionItemRefs) db.salesTransactionItem,
                    if (outboundItemRefs) db.outboundItem,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (baseUnitId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.baseUnitId,
                                    referencedTable: $$ProductTableReferences
                                        ._baseUnitIdTable(db),
                                    referencedColumn: $$ProductTableReferences
                                        ._baseUnitIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (categoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.categoryId,
                                    referencedTable: $$ProductTableReferences
                                        ._categoryIdTable(db),
                                    referencedColumn: $$ProductTableReferences
                                        ._categoryIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (unitProductRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          UnitProductData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._unitProductRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).unitProductRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (productBatchRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          ProductBatchData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._productBatchRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).productBatchRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (stockRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          StockData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._stockRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(db, table, p0).stockRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inventoryTransactionRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          InventoryTransactionData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._inventoryTransactionRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).inventoryTransactionRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inboundItemRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          InboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._inboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).inboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrderItemRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          PurchaseOrderItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._purchaseOrderItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrderItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (salesTransactionItemRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          SalesTransactionItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._salesTransactionItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).salesTransactionItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (outboundItemRefs)
                        await $_getPrefetchedData<
                          ProductData,
                          $ProductTable,
                          OutboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductTableReferences
                              ._outboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductTableReferences(
                                db,
                                table,
                                p0,
                              ).outboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ProductTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductTable,
      ProductData,
      $$ProductTableFilterComposer,
      $$ProductTableOrderingComposer,
      $$ProductTableAnnotationComposer,
      $$ProductTableCreateCompanionBuilder,
      $$ProductTableUpdateCompanionBuilder,
      (ProductData, $$ProductTableReferences),
      ProductData,
      PrefetchHooks Function({
        bool baseUnitId,
        bool categoryId,
        bool unitProductRefs,
        bool productBatchRefs,
        bool stockRefs,
        bool inventoryTransactionRefs,
        bool inboundItemRefs,
        bool purchaseOrderItemRefs,
        bool salesTransactionItemRefs,
        bool outboundItemRefs,
      })
    >;
typedef $$UnitProductTableCreateCompanionBuilder =
    UnitProductCompanion Function({
      Value<int> id,
      required int productId,
      required int unitId,
      required int conversionRate,
      Value<int?> sellingPriceInCents,
      Value<int?> wholesalePriceInCents,
      Value<DateTime> lastUpdated,
    });
typedef $$UnitProductTableUpdateCompanionBuilder =
    UnitProductCompanion Function({
      Value<int> id,
      Value<int> productId,
      Value<int> unitId,
      Value<int> conversionRate,
      Value<int?> sellingPriceInCents,
      Value<int?> wholesalePriceInCents,
      Value<DateTime> lastUpdated,
    });

final class $$UnitProductTableReferences
    extends BaseReferences<_$AppDatabase, $UnitProductTable, UnitProductData> {
  $$UnitProductTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.unitProduct.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UnitTable _unitIdTable(_$AppDatabase db) => db.unit.createAlias(
    $_aliasNameGenerator(db.unitProduct.unitId, db.unit.id),
  );

  $$UnitTableProcessedTableManager get unitId {
    final $_column = $_itemColumn<int>('unit_id')!;

    final manager = $$UnitTableTableManager(
      $_db,
      $_db.unit,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_unitIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$BarcodeTable, List<BarcodeData>>
  _barcodeRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.barcode,
    aliasName: $_aliasNameGenerator(
      db.unitProduct.id,
      db.barcode.unitProductId,
    ),
  );

  $$BarcodeTableProcessedTableManager get barcodeRefs {
    final manager = $$BarcodeTableTableManager(
      $_db,
      $_db.barcode,
    ).filter((f) => f.unitProductId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_barcodeRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UnitProductTableFilterComposer
    extends Composer<_$AppDatabase, $UnitProductTable> {
  $$UnitProductTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get conversionRate => $composableBuilder(
    column: $table.conversionRate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sellingPriceInCents => $composableBuilder(
    column: $table.sellingPriceInCents,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wholesalePriceInCents => $composableBuilder(
    column: $table.wholesalePriceInCents,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UnitTableFilterComposer get unitId {
    final $$UnitTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableFilterComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> barcodeRefs(
    Expression<bool> Function($$BarcodeTableFilterComposer f) f,
  ) {
    final $$BarcodeTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.barcode,
      getReferencedColumn: (t) => t.unitProductId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BarcodeTableFilterComposer(
            $db: $db,
            $table: $db.barcode,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UnitProductTableOrderingComposer
    extends Composer<_$AppDatabase, $UnitProductTable> {
  $$UnitProductTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get conversionRate => $composableBuilder(
    column: $table.conversionRate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sellingPriceInCents => $composableBuilder(
    column: $table.sellingPriceInCents,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wholesalePriceInCents => $composableBuilder(
    column: $table.wholesalePriceInCents,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UnitTableOrderingComposer get unitId {
    final $$UnitTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableOrderingComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UnitProductTableAnnotationComposer
    extends Composer<_$AppDatabase, $UnitProductTable> {
  $$UnitProductTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get conversionRate => $composableBuilder(
    column: $table.conversionRate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sellingPriceInCents => $composableBuilder(
    column: $table.sellingPriceInCents,
    builder: (column) => column,
  );

  GeneratedColumn<int> get wholesalePriceInCents => $composableBuilder(
    column: $table.wholesalePriceInCents,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastUpdated => $composableBuilder(
    column: $table.lastUpdated,
    builder: (column) => column,
  );

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UnitTableAnnotationComposer get unitId {
    final $$UnitTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitId,
      referencedTable: $db.unit,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitTableAnnotationComposer(
            $db: $db,
            $table: $db.unit,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> barcodeRefs<T extends Object>(
    Expression<T> Function($$BarcodeTableAnnotationComposer a) f,
  ) {
    final $$BarcodeTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.barcode,
      getReferencedColumn: (t) => t.unitProductId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BarcodeTableAnnotationComposer(
            $db: $db,
            $table: $db.barcode,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UnitProductTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UnitProductTable,
          UnitProductData,
          $$UnitProductTableFilterComposer,
          $$UnitProductTableOrderingComposer,
          $$UnitProductTableAnnotationComposer,
          $$UnitProductTableCreateCompanionBuilder,
          $$UnitProductTableUpdateCompanionBuilder,
          (UnitProductData, $$UnitProductTableReferences),
          UnitProductData,
          PrefetchHooks Function({
            bool productId,
            bool unitId,
            bool barcodeRefs,
          })
        > {
  $$UnitProductTableTableManager(_$AppDatabase db, $UnitProductTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UnitProductTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UnitProductTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UnitProductTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<int> unitId = const Value.absent(),
                Value<int> conversionRate = const Value.absent(),
                Value<int?> sellingPriceInCents = const Value.absent(),
                Value<int?> wholesalePriceInCents = const Value.absent(),
                Value<DateTime> lastUpdated = const Value.absent(),
              }) => UnitProductCompanion(
                id: id,
                productId: productId,
                unitId: unitId,
                conversionRate: conversionRate,
                sellingPriceInCents: sellingPriceInCents,
                wholesalePriceInCents: wholesalePriceInCents,
                lastUpdated: lastUpdated,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int productId,
                required int unitId,
                required int conversionRate,
                Value<int?> sellingPriceInCents = const Value.absent(),
                Value<int?> wholesalePriceInCents = const Value.absent(),
                Value<DateTime> lastUpdated = const Value.absent(),
              }) => UnitProductCompanion.insert(
                id: id,
                productId: productId,
                unitId: unitId,
                conversionRate: conversionRate,
                sellingPriceInCents: sellingPriceInCents,
                wholesalePriceInCents: wholesalePriceInCents,
                lastUpdated: lastUpdated,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UnitProductTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({productId = false, unitId = false, barcodeRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (barcodeRefs) db.barcode],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$UnitProductTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$UnitProductTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (unitId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.unitId,
                                    referencedTable:
                                        $$UnitProductTableReferences
                                            ._unitIdTable(db),
                                    referencedColumn:
                                        $$UnitProductTableReferences
                                            ._unitIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (barcodeRefs)
                        await $_getPrefetchedData<
                          UnitProductData,
                          $UnitProductTable,
                          BarcodeData
                        >(
                          currentTable: table,
                          referencedTable: $$UnitProductTableReferences
                              ._barcodeRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UnitProductTableReferences(
                                db,
                                table,
                                p0,
                              ).barcodeRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.unitProductId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UnitProductTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UnitProductTable,
      UnitProductData,
      $$UnitProductTableFilterComposer,
      $$UnitProductTableOrderingComposer,
      $$UnitProductTableAnnotationComposer,
      $$UnitProductTableCreateCompanionBuilder,
      $$UnitProductTableUpdateCompanionBuilder,
      (UnitProductData, $$UnitProductTableReferences),
      UnitProductData,
      PrefetchHooks Function({bool productId, bool unitId, bool barcodeRefs})
    >;
typedef $$ShopTableCreateCompanionBuilder =
    ShopCompanion Function({
      Value<int> id,
      required String name,
      required String manager,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$ShopTableUpdateCompanionBuilder =
    ShopCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<String> manager,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$ShopTableReferences
    extends BaseReferences<_$AppDatabase, $ShopTable, ShopData> {
  $$ShopTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductBatchTable, List<ProductBatchData>>
  _productBatchRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.productBatch,
    aliasName: $_aliasNameGenerator(db.shop.id, db.productBatch.shopId),
  );

  $$ProductBatchTableProcessedTableManager get productBatchRefs {
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_productBatchRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StockTable, List<StockData>> _stockRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.stock,
    aliasName: $_aliasNameGenerator(db.shop.id, db.stock.shopId),
  );

  $$StockTableProcessedTableManager get stockRefs {
    final manager = $$StockTableTableManager(
      $_db,
      $_db.stock,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_stockRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $InventoryTransactionTable,
    List<InventoryTransactionData>
  >
  _inventoryTransactionRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.inventoryTransaction,
        aliasName: $_aliasNameGenerator(
          db.shop.id,
          db.inventoryTransaction.shopId,
        ),
      );

  $$InventoryTransactionTableProcessedTableManager
  get inventoryTransactionRefs {
    final manager = $$InventoryTransactionTableTableManager(
      $_db,
      $_db.inventoryTransaction,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _inventoryTransactionRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PurchaseOrderTable, List<PurchaseOrderData>>
  _purchaseOrderRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrder,
    aliasName: $_aliasNameGenerator(db.shop.id, db.purchaseOrder.shopId),
  );

  $$PurchaseOrderTableProcessedTableManager get purchaseOrderRefs {
    final manager = $$PurchaseOrderTableTableManager(
      $_db,
      $_db.purchaseOrder,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_purchaseOrderRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$InboundReceiptTable, List<InboundReceiptData>>
  _inboundReceiptRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.inboundReceipt,
    aliasName: $_aliasNameGenerator(db.shop.id, db.inboundReceipt.shopId),
  );

  $$InboundReceiptTableProcessedTableManager get inboundReceiptRefs {
    final manager = $$InboundReceiptTableTableManager(
      $_db,
      $_db.inboundReceipt,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_inboundReceiptRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SalesTransactionTable, List<SalesTransactionData>>
  _salesTransactionRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesTransaction,
    aliasName: $_aliasNameGenerator(db.shop.id, db.salesTransaction.shopId),
  );

  $$SalesTransactionTableProcessedTableManager get salesTransactionRefs {
    final manager = $$SalesTransactionTableTableManager(
      $_db,
      $_db.salesTransaction,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _salesTransactionRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$OutboundReceiptTable, List<OutboundReceiptData>>
  _outboundReceiptRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.outboundReceipt,
    aliasName: $_aliasNameGenerator(db.shop.id, db.outboundReceipt.shopId),
  );

  $$OutboundReceiptTableProcessedTableManager get outboundReceiptRefs {
    final manager = $$OutboundReceiptTableTableManager(
      $_db,
      $_db.outboundReceipt,
    ).filter((f) => f.shopId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _outboundReceiptRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ShopTableFilterComposer extends Composer<_$AppDatabase, $ShopTable> {
  $$ShopTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get manager => $composableBuilder(
    column: $table.manager,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productBatchRefs(
    Expression<bool> Function($$ProductBatchTableFilterComposer f) f,
  ) {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stockRefs(
    Expression<bool> Function($$StockTableFilterComposer f) f,
  ) {
    final $$StockTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableFilterComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inventoryTransactionRefs(
    Expression<bool> Function($$InventoryTransactionTableFilterComposer f) f,
  ) {
    final $$InventoryTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inventoryTransaction,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InventoryTransactionTableFilterComposer(
            $db: $db,
            $table: $db.inventoryTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrderRefs(
    Expression<bool> Function($$PurchaseOrderTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inboundReceiptRefs(
    Expression<bool> Function($$InboundReceiptTableFilterComposer f) f,
  ) {
    final $$InboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesTransactionRefs(
    Expression<bool> Function($$SalesTransactionTableFilterComposer f) f,
  ) {
    final $$SalesTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableFilterComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> outboundReceiptRefs(
    Expression<bool> Function($$OutboundReceiptTableFilterComposer f) f,
  ) {
    final $$OutboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShopTableOrderingComposer extends Composer<_$AppDatabase, $ShopTable> {
  $$ShopTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get manager => $composableBuilder(
    column: $table.manager,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ShopTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShopTable> {
  $$ShopTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get manager =>
      $composableBuilder(column: $table.manager, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> productBatchRefs<T extends Object>(
    Expression<T> Function($$ProductBatchTableAnnotationComposer a) f,
  ) {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stockRefs<T extends Object>(
    Expression<T> Function($$StockTableAnnotationComposer a) f,
  ) {
    final $$StockTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableAnnotationComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> inventoryTransactionRefs<T extends Object>(
    Expression<T> Function($$InventoryTransactionTableAnnotationComposer a) f,
  ) {
    final $$InventoryTransactionTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.inventoryTransaction,
          getReferencedColumn: (t) => t.shopId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$InventoryTransactionTableAnnotationComposer(
                $db: $db,
                $table: $db.inventoryTransaction,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> purchaseOrderRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> inboundReceiptRefs<T extends Object>(
    Expression<T> Function($$InboundReceiptTableAnnotationComposer a) f,
  ) {
    final $$InboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesTransactionRefs<T extends Object>(
    Expression<T> Function($$SalesTransactionTableAnnotationComposer a) f,
  ) {
    final $$SalesTransactionTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableAnnotationComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> outboundReceiptRefs<T extends Object>(
    Expression<T> Function($$OutboundReceiptTableAnnotationComposer a) f,
  ) {
    final $$OutboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.shopId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShopTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ShopTable,
          ShopData,
          $$ShopTableFilterComposer,
          $$ShopTableOrderingComposer,
          $$ShopTableAnnotationComposer,
          $$ShopTableCreateCompanionBuilder,
          $$ShopTableUpdateCompanionBuilder,
          (ShopData, $$ShopTableReferences),
          ShopData,
          PrefetchHooks Function({
            bool productBatchRefs,
            bool stockRefs,
            bool inventoryTransactionRefs,
            bool purchaseOrderRefs,
            bool inboundReceiptRefs,
            bool salesTransactionRefs,
            bool outboundReceiptRefs,
          })
        > {
  $$ShopTableTableManager(_$AppDatabase db, $ShopTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShopTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShopTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShopTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> manager = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ShopCompanion(
                id: id,
                name: name,
                manager: manager,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                required String manager,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ShopCompanion.insert(
                id: id,
                name: name,
                manager: manager,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ShopTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                productBatchRefs = false,
                stockRefs = false,
                inventoryTransactionRefs = false,
                purchaseOrderRefs = false,
                inboundReceiptRefs = false,
                salesTransactionRefs = false,
                outboundReceiptRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (productBatchRefs) db.productBatch,
                    if (stockRefs) db.stock,
                    if (inventoryTransactionRefs) db.inventoryTransaction,
                    if (purchaseOrderRefs) db.purchaseOrder,
                    if (inboundReceiptRefs) db.inboundReceipt,
                    if (salesTransactionRefs) db.salesTransaction,
                    if (outboundReceiptRefs) db.outboundReceipt,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (productBatchRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          ProductBatchData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._productBatchRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).productBatchRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (stockRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          StockData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._stockRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ShopTableReferences(db, table, p0).stockRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inventoryTransactionRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          InventoryTransactionData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._inventoryTransactionRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).inventoryTransactionRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrderRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          PurchaseOrderData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._purchaseOrderRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).purchaseOrderRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inboundReceiptRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          InboundReceiptData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._inboundReceiptRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).inboundReceiptRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (salesTransactionRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          SalesTransactionData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._salesTransactionRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).salesTransactionRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (outboundReceiptRefs)
                        await $_getPrefetchedData<
                          ShopData,
                          $ShopTable,
                          OutboundReceiptData
                        >(
                          currentTable: table,
                          referencedTable: $$ShopTableReferences
                              ._outboundReceiptRefsTable(db),
                          managerFromTypedResult: (p0) => $$ShopTableReferences(
                            db,
                            table,
                            p0,
                          ).outboundReceiptRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.shopId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ShopTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ShopTable,
      ShopData,
      $$ShopTableFilterComposer,
      $$ShopTableOrderingComposer,
      $$ShopTableAnnotationComposer,
      $$ShopTableCreateCompanionBuilder,
      $$ShopTableUpdateCompanionBuilder,
      (ShopData, $$ShopTableReferences),
      ShopData,
      PrefetchHooks Function({
        bool productBatchRefs,
        bool stockRefs,
        bool inventoryTransactionRefs,
        bool purchaseOrderRefs,
        bool inboundReceiptRefs,
        bool salesTransactionRefs,
        bool outboundReceiptRefs,
      })
    >;
typedef $$SupplierTableCreateCompanionBuilder =
    SupplierCompanion Function({
      Value<int> id,
      required String name,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$SupplierTableUpdateCompanionBuilder =
    SupplierCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$SupplierTableReferences
    extends BaseReferences<_$AppDatabase, $SupplierTable, SupplierData> {
  $$SupplierTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PurchaseOrderTable, List<PurchaseOrderData>>
  _purchaseOrderRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrder,
    aliasName: $_aliasNameGenerator(
      db.supplier.id,
      db.purchaseOrder.supplierId,
    ),
  );

  $$PurchaseOrderTableProcessedTableManager get purchaseOrderRefs {
    final manager = $$PurchaseOrderTableTableManager(
      $_db,
      $_db.purchaseOrder,
    ).filter((f) => f.supplierId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_purchaseOrderRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SupplierTableFilterComposer
    extends Composer<_$AppDatabase, $SupplierTable> {
  $$SupplierTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> purchaseOrderRefs(
    Expression<bool> Function($$PurchaseOrderTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SupplierTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplierTable> {
  $$SupplierTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SupplierTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplierTable> {
  $$SupplierTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> purchaseOrderRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SupplierTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SupplierTable,
          SupplierData,
          $$SupplierTableFilterComposer,
          $$SupplierTableOrderingComposer,
          $$SupplierTableAnnotationComposer,
          $$SupplierTableCreateCompanionBuilder,
          $$SupplierTableUpdateCompanionBuilder,
          (SupplierData, $$SupplierTableReferences),
          SupplierData,
          PrefetchHooks Function({bool purchaseOrderRefs})
        > {
  $$SupplierTableTableManager(_$AppDatabase db, $SupplierTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplierTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SupplierTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SupplierTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => SupplierCompanion(
                id: id,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => SupplierCompanion.insert(
                id: id,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SupplierTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({purchaseOrderRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (purchaseOrderRefs) db.purchaseOrder,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (purchaseOrderRefs)
                    await $_getPrefetchedData<
                      SupplierData,
                      $SupplierTable,
                      PurchaseOrderData
                    >(
                      currentTable: table,
                      referencedTable: $$SupplierTableReferences
                          ._purchaseOrderRefsTable(db),
                      managerFromTypedResult: (p0) => $$SupplierTableReferences(
                        db,
                        table,
                        p0,
                      ).purchaseOrderRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.supplierId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$SupplierTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SupplierTable,
      SupplierData,
      $$SupplierTableFilterComposer,
      $$SupplierTableOrderingComposer,
      $$SupplierTableAnnotationComposer,
      $$SupplierTableCreateCompanionBuilder,
      $$SupplierTableUpdateCompanionBuilder,
      (SupplierData, $$SupplierTableReferences),
      SupplierData,
      PrefetchHooks Function({bool purchaseOrderRefs})
    >;
typedef $$ProductBatchTableCreateCompanionBuilder =
    ProductBatchCompanion Function({
      Value<int> id,
      required int productId,
      required DateTime productionDate,
      required int totalInboundQuantity,
      required int shopId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$ProductBatchTableUpdateCompanionBuilder =
    ProductBatchCompanion Function({
      Value<int> id,
      Value<int> productId,
      Value<DateTime> productionDate,
      Value<int> totalInboundQuantity,
      Value<int> shopId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$ProductBatchTableReferences
    extends
        BaseReferences<_$AppDatabase, $ProductBatchTable, ProductBatchData> {
  $$ProductBatchTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.productBatch.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.productBatch.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$StockTable, List<StockData>> _stockRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.stock,
    aliasName: $_aliasNameGenerator(db.productBatch.id, db.stock.batchId),
  );

  $$StockTableProcessedTableManager get stockRefs {
    final manager = $$StockTableTableManager(
      $_db,
      $_db.stock,
    ).filter((f) => f.batchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_stockRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $InventoryTransactionTable,
    List<InventoryTransactionData>
  >
  _inventoryTransactionRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.inventoryTransaction,
        aliasName: $_aliasNameGenerator(
          db.productBatch.id,
          db.inventoryTransaction.batchId,
        ),
      );

  $$InventoryTransactionTableProcessedTableManager
  get inventoryTransactionRefs {
    final manager = $$InventoryTransactionTableTableManager(
      $_db,
      $_db.inventoryTransaction,
    ).filter((f) => f.batchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _inventoryTransactionRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$InboundItemTable, List<InboundItemData>>
  _inboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.inboundItem,
    aliasName: $_aliasNameGenerator(db.productBatch.id, db.inboundItem.batchId),
  );

  $$InboundItemTableProcessedTableManager get inboundItemRefs {
    final manager = $$InboundItemTableTableManager(
      $_db,
      $_db.inboundItem,
    ).filter((f) => f.batchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_inboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $SalesTransactionItemTable,
    List<SalesTransactionItemData>
  >
  _salesTransactionItemRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.salesTransactionItem,
        aliasName: $_aliasNameGenerator(
          db.productBatch.id,
          db.salesTransactionItem.batchId,
        ),
      );

  $$SalesTransactionItemTableProcessedTableManager
  get salesTransactionItemRefs {
    final manager = $$SalesTransactionItemTableTableManager(
      $_db,
      $_db.salesTransactionItem,
    ).filter((f) => f.batchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _salesTransactionItemRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$OutboundItemTable, List<OutboundItemData>>
  _outboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.outboundItem,
    aliasName: $_aliasNameGenerator(
      db.productBatch.id,
      db.outboundItem.batchId,
    ),
  );

  $$OutboundItemTableProcessedTableManager get outboundItemRefs {
    final manager = $$OutboundItemTableTableManager(
      $_db,
      $_db.outboundItem,
    ).filter((f) => f.batchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_outboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductBatchTableFilterComposer
    extends Composer<_$AppDatabase, $ProductBatchTable> {
  $$ProductBatchTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalInboundQuantity => $composableBuilder(
    column: $table.totalInboundQuantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> stockRefs(
    Expression<bool> Function($$StockTableFilterComposer f) f,
  ) {
    final $$StockTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableFilterComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inventoryTransactionRefs(
    Expression<bool> Function($$InventoryTransactionTableFilterComposer f) f,
  ) {
    final $$InventoryTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inventoryTransaction,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InventoryTransactionTableFilterComposer(
            $db: $db,
            $table: $db.inventoryTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> inboundItemRefs(
    Expression<bool> Function($$InboundItemTableFilterComposer f) f,
  ) {
    final $$InboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableFilterComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesTransactionItemRefs(
    Expression<bool> Function($$SalesTransactionItemTableFilterComposer f) f,
  ) {
    final $$SalesTransactionItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransactionItem,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionItemTableFilterComposer(
            $db: $db,
            $table: $db.salesTransactionItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> outboundItemRefs(
    Expression<bool> Function($$OutboundItemTableFilterComposer f) f,
  ) {
    final $$OutboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableFilterComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductBatchTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductBatchTable> {
  $$ProductBatchTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalInboundQuantity => $composableBuilder(
    column: $table.totalInboundQuantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductBatchTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductBatchTable> {
  $$ProductBatchTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get totalInboundQuantity => $composableBuilder(
    column: $table.totalInboundQuantity,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> stockRefs<T extends Object>(
    Expression<T> Function($$StockTableAnnotationComposer a) f,
  ) {
    final $$StockTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.stock,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockTableAnnotationComposer(
            $db: $db,
            $table: $db.stock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> inventoryTransactionRefs<T extends Object>(
    Expression<T> Function($$InventoryTransactionTableAnnotationComposer a) f,
  ) {
    final $$InventoryTransactionTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.inventoryTransaction,
          getReferencedColumn: (t) => t.batchId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$InventoryTransactionTableAnnotationComposer(
                $db: $db,
                $table: $db.inventoryTransaction,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> inboundItemRefs<T extends Object>(
    Expression<T> Function($$InboundItemTableAnnotationComposer a) f,
  ) {
    final $$InboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesTransactionItemRefs<T extends Object>(
    Expression<T> Function($$SalesTransactionItemTableAnnotationComposer a) f,
  ) {
    final $$SalesTransactionItemTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.salesTransactionItem,
          getReferencedColumn: (t) => t.batchId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SalesTransactionItemTableAnnotationComposer(
                $db: $db,
                $table: $db.salesTransactionItem,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> outboundItemRefs<T extends Object>(
    Expression<T> Function($$OutboundItemTableAnnotationComposer a) f,
  ) {
    final $$OutboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.batchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductBatchTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductBatchTable,
          ProductBatchData,
          $$ProductBatchTableFilterComposer,
          $$ProductBatchTableOrderingComposer,
          $$ProductBatchTableAnnotationComposer,
          $$ProductBatchTableCreateCompanionBuilder,
          $$ProductBatchTableUpdateCompanionBuilder,
          (ProductBatchData, $$ProductBatchTableReferences),
          ProductBatchData,
          PrefetchHooks Function({
            bool productId,
            bool shopId,
            bool stockRefs,
            bool inventoryTransactionRefs,
            bool inboundItemRefs,
            bool salesTransactionItemRefs,
            bool outboundItemRefs,
          })
        > {
  $$ProductBatchTableTableManager(_$AppDatabase db, $ProductBatchTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductBatchTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductBatchTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductBatchTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<DateTime> productionDate = const Value.absent(),
                Value<int> totalInboundQuantity = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ProductBatchCompanion(
                id: id,
                productId: productId,
                productionDate: productionDate,
                totalInboundQuantity: totalInboundQuantity,
                shopId: shopId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int productId,
                required DateTime productionDate,
                required int totalInboundQuantity,
                required int shopId,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ProductBatchCompanion.insert(
                id: id,
                productId: productId,
                productionDate: productionDate,
                totalInboundQuantity: totalInboundQuantity,
                shopId: shopId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductBatchTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                productId = false,
                shopId = false,
                stockRefs = false,
                inventoryTransactionRefs = false,
                inboundItemRefs = false,
                salesTransactionItemRefs = false,
                outboundItemRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (stockRefs) db.stock,
                    if (inventoryTransactionRefs) db.inventoryTransaction,
                    if (inboundItemRefs) db.inboundItem,
                    if (salesTransactionItemRefs) db.salesTransactionItem,
                    if (outboundItemRefs) db.outboundItem,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$ProductBatchTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$ProductBatchTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$ProductBatchTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$ProductBatchTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (stockRefs)
                        await $_getPrefetchedData<
                          ProductBatchData,
                          $ProductBatchTable,
                          StockData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductBatchTableReferences
                              ._stockRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductBatchTableReferences(
                                db,
                                table,
                                p0,
                              ).stockRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.batchId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inventoryTransactionRefs)
                        await $_getPrefetchedData<
                          ProductBatchData,
                          $ProductBatchTable,
                          InventoryTransactionData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductBatchTableReferences
                              ._inventoryTransactionRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductBatchTableReferences(
                                db,
                                table,
                                p0,
                              ).inventoryTransactionRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.batchId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (inboundItemRefs)
                        await $_getPrefetchedData<
                          ProductBatchData,
                          $ProductBatchTable,
                          InboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductBatchTableReferences
                              ._inboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductBatchTableReferences(
                                db,
                                table,
                                p0,
                              ).inboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.batchId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (salesTransactionItemRefs)
                        await $_getPrefetchedData<
                          ProductBatchData,
                          $ProductBatchTable,
                          SalesTransactionItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductBatchTableReferences
                              ._salesTransactionItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductBatchTableReferences(
                                db,
                                table,
                                p0,
                              ).salesTransactionItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.batchId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (outboundItemRefs)
                        await $_getPrefetchedData<
                          ProductBatchData,
                          $ProductBatchTable,
                          OutboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$ProductBatchTableReferences
                              ._outboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductBatchTableReferences(
                                db,
                                table,
                                p0,
                              ).outboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.batchId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ProductBatchTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductBatchTable,
      ProductBatchData,
      $$ProductBatchTableFilterComposer,
      $$ProductBatchTableOrderingComposer,
      $$ProductBatchTableAnnotationComposer,
      $$ProductBatchTableCreateCompanionBuilder,
      $$ProductBatchTableUpdateCompanionBuilder,
      (ProductBatchData, $$ProductBatchTableReferences),
      ProductBatchData,
      PrefetchHooks Function({
        bool productId,
        bool shopId,
        bool stockRefs,
        bool inventoryTransactionRefs,
        bool inboundItemRefs,
        bool salesTransactionItemRefs,
        bool outboundItemRefs,
      })
    >;
typedef $$StockTableCreateCompanionBuilder =
    StockCompanion Function({
      Value<int> id,
      required int productId,
      Value<int?> batchId,
      required int quantity,
      Value<int> averageUnitPriceInCents,
      required int shopId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$StockTableUpdateCompanionBuilder =
    StockCompanion Function({
      Value<int> id,
      Value<int> productId,
      Value<int?> batchId,
      Value<int> quantity,
      Value<int> averageUnitPriceInCents,
      Value<int> shopId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$StockTableReferences
    extends BaseReferences<_$AppDatabase, $StockTable, StockData> {
  $$StockTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProductTable _productIdTable(_$AppDatabase db) => db.product
      .createAlias($_aliasNameGenerator(db.stock.productId, db.product.id));

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductBatchTable _batchIdTable(_$AppDatabase db) => db.productBatch
      .createAlias($_aliasNameGenerator(db.stock.batchId, db.productBatch.id));

  $$ProductBatchTableProcessedTableManager? get batchId {
    final $_column = $_itemColumn<int>('batch_id');
    if ($_column == null) return null;
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_batchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShopTable _shopIdTable(_$AppDatabase db) =>
      db.shop.createAlias($_aliasNameGenerator(db.stock.shopId, db.shop.id));

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$StockTableFilterComposer extends Composer<_$AppDatabase, $StockTable> {
  $$StockTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get averageUnitPriceInCents => $composableBuilder(
    column: $table.averageUnitPriceInCents,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableFilterComposer get batchId {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockTableOrderingComposer
    extends Composer<_$AppDatabase, $StockTable> {
  $$StockTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get averageUnitPriceInCents => $composableBuilder(
    column: $table.averageUnitPriceInCents,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableOrderingComposer get batchId {
    final $$ProductBatchTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableOrderingComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockTable> {
  $$StockTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<int> get averageUnitPriceInCents => $composableBuilder(
    column: $table.averageUnitPriceInCents,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableAnnotationComposer get batchId {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $StockTable,
          StockData,
          $$StockTableFilterComposer,
          $$StockTableOrderingComposer,
          $$StockTableAnnotationComposer,
          $$StockTableCreateCompanionBuilder,
          $$StockTableUpdateCompanionBuilder,
          (StockData, $$StockTableReferences),
          StockData,
          PrefetchHooks Function({bool productId, bool batchId, bool shopId})
        > {
  $$StockTableTableManager(_$AppDatabase db, $StockTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<int?> batchId = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<int> averageUnitPriceInCents = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => StockCompanion(
                id: id,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
                averageUnitPriceInCents: averageUnitPriceInCents,
                shopId: shopId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int productId,
                Value<int?> batchId = const Value.absent(),
                required int quantity,
                Value<int> averageUnitPriceInCents = const Value.absent(),
                required int shopId,
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => StockCompanion.insert(
                id: id,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
                averageUnitPriceInCents: averageUnitPriceInCents,
                shopId: shopId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$StockTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({productId = false, batchId = false, shopId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable: $$StockTableReferences
                                        ._productIdTable(db),
                                    referencedColumn: $$StockTableReferences
                                        ._productIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (batchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.batchId,
                                    referencedTable: $$StockTableReferences
                                        ._batchIdTable(db),
                                    referencedColumn: $$StockTableReferences
                                        ._batchIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable: $$StockTableReferences
                                        ._shopIdTable(db),
                                    referencedColumn: $$StockTableReferences
                                        ._shopIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$StockTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $StockTable,
      StockData,
      $$StockTableFilterComposer,
      $$StockTableOrderingComposer,
      $$StockTableAnnotationComposer,
      $$StockTableCreateCompanionBuilder,
      $$StockTableUpdateCompanionBuilder,
      (StockData, $$StockTableReferences),
      StockData,
      PrefetchHooks Function({bool productId, bool batchId, bool shopId})
    >;
typedef $$InventoryTransactionTableCreateCompanionBuilder =
    InventoryTransactionCompanion Function({
      Value<int> id,
      required int productId,
      required String transactionType,
      required int quantity,
      required int shopId,
      Value<int?> batchId,
      Value<DateTime> createdAt,
    });
typedef $$InventoryTransactionTableUpdateCompanionBuilder =
    InventoryTransactionCompanion Function({
      Value<int> id,
      Value<int> productId,
      Value<String> transactionType,
      Value<int> quantity,
      Value<int> shopId,
      Value<int?> batchId,
      Value<DateTime> createdAt,
    });

final class $$InventoryTransactionTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $InventoryTransactionTable,
          InventoryTransactionData
        > {
  $$InventoryTransactionTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.inventoryTransaction.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.inventoryTransaction.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductBatchTable _batchIdTable(_$AppDatabase db) =>
      db.productBatch.createAlias(
        $_aliasNameGenerator(
          db.inventoryTransaction.batchId,
          db.productBatch.id,
        ),
      );

  $$ProductBatchTableProcessedTableManager? get batchId {
    final $_column = $_itemColumn<int>('batch_id');
    if ($_column == null) return null;
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_batchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$InventoryTransactionTableFilterComposer
    extends Composer<_$AppDatabase, $InventoryTransactionTable> {
  $$InventoryTransactionTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get transactionType => $composableBuilder(
    column: $table.transactionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableFilterComposer get batchId {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InventoryTransactionTableOrderingComposer
    extends Composer<_$AppDatabase, $InventoryTransactionTable> {
  $$InventoryTransactionTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transactionType => $composableBuilder(
    column: $table.transactionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableOrderingComposer get batchId {
    final $$ProductBatchTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableOrderingComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InventoryTransactionTableAnnotationComposer
    extends Composer<_$AppDatabase, $InventoryTransactionTable> {
  $$InventoryTransactionTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get transactionType => $composableBuilder(
    column: $table.transactionType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableAnnotationComposer get batchId {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InventoryTransactionTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $InventoryTransactionTable,
          InventoryTransactionData,
          $$InventoryTransactionTableFilterComposer,
          $$InventoryTransactionTableOrderingComposer,
          $$InventoryTransactionTableAnnotationComposer,
          $$InventoryTransactionTableCreateCompanionBuilder,
          $$InventoryTransactionTableUpdateCompanionBuilder,
          (InventoryTransactionData, $$InventoryTransactionTableReferences),
          InventoryTransactionData,
          PrefetchHooks Function({bool productId, bool shopId, bool batchId})
        > {
  $$InventoryTransactionTableTableManager(
    _$AppDatabase db,
    $InventoryTransactionTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InventoryTransactionTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InventoryTransactionTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$InventoryTransactionTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<String> transactionType = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<int?> batchId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => InventoryTransactionCompanion(
                id: id,
                productId: productId,
                transactionType: transactionType,
                quantity: quantity,
                shopId: shopId,
                batchId: batchId,
                createdAt: createdAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int productId,
                required String transactionType,
                required int quantity,
                required int shopId,
                Value<int?> batchId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => InventoryTransactionCompanion.insert(
                id: id,
                productId: productId,
                transactionType: transactionType,
                quantity: quantity,
                shopId: shopId,
                batchId: batchId,
                createdAt: createdAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$InventoryTransactionTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({productId = false, shopId = false, batchId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$InventoryTransactionTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$InventoryTransactionTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$InventoryTransactionTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$InventoryTransactionTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (batchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.batchId,
                                    referencedTable:
                                        $$InventoryTransactionTableReferences
                                            ._batchIdTable(db),
                                    referencedColumn:
                                        $$InventoryTransactionTableReferences
                                            ._batchIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$InventoryTransactionTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $InventoryTransactionTable,
      InventoryTransactionData,
      $$InventoryTransactionTableFilterComposer,
      $$InventoryTransactionTableOrderingComposer,
      $$InventoryTransactionTableAnnotationComposer,
      $$InventoryTransactionTableCreateCompanionBuilder,
      $$InventoryTransactionTableUpdateCompanionBuilder,
      (InventoryTransactionData, $$InventoryTransactionTableReferences),
      InventoryTransactionData,
      PrefetchHooks Function({bool productId, bool shopId, bool batchId})
    >;
typedef $$LocationsTableTableCreateCompanionBuilder =
    LocationsTableCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      required int shopId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$LocationsTableTableUpdateCompanionBuilder =
    LocationsTableCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> shopId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$LocationsTableTableFilterComposer
    extends Composer<_$AppDatabase, $LocationsTableTable> {
  $$LocationsTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get shopId => $composableBuilder(
    column: $table.shopId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$LocationsTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LocationsTableTable> {
  $$LocationsTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get shopId => $composableBuilder(
    column: $table.shopId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$LocationsTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LocationsTableTable> {
  $$LocationsTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get shopId =>
      $composableBuilder(column: $table.shopId, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$LocationsTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LocationsTableTable,
          LocationsTableData,
          $$LocationsTableTableFilterComposer,
          $$LocationsTableTableOrderingComposer,
          $$LocationsTableTableAnnotationComposer,
          $$LocationsTableTableCreateCompanionBuilder,
          $$LocationsTableTableUpdateCompanionBuilder,
          (
            LocationsTableData,
            BaseReferences<
              _$AppDatabase,
              $LocationsTableTable,
              LocationsTableData
            >,
          ),
          LocationsTableData,
          PrefetchHooks Function()
        > {
  $$LocationsTableTableTableManager(
    _$AppDatabase db,
    $LocationsTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocationsTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocationsTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocationsTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationsTableCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                shopId: shopId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                required int shopId,
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationsTableCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                shopId: shopId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$LocationsTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LocationsTableTable,
      LocationsTableData,
      $$LocationsTableTableFilterComposer,
      $$LocationsTableTableOrderingComposer,
      $$LocationsTableTableAnnotationComposer,
      $$LocationsTableTableCreateCompanionBuilder,
      $$LocationsTableTableUpdateCompanionBuilder,
      (
        LocationsTableData,
        BaseReferences<_$AppDatabase, $LocationsTableTable, LocationsTableData>,
      ),
      LocationsTableData,
      PrefetchHooks Function()
    >;
typedef $$PurchaseOrderTableCreateCompanionBuilder =
    PurchaseOrderCompanion Function({
      Value<int> id,
      required int supplierId,
      required int shopId,
      Value<PurchaseOrderStatus> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$PurchaseOrderTableUpdateCompanionBuilder =
    PurchaseOrderCompanion Function({
      Value<int> id,
      Value<int> supplierId,
      Value<int> shopId,
      Value<PurchaseOrderStatus> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$PurchaseOrderTableReferences
    extends
        BaseReferences<_$AppDatabase, $PurchaseOrderTable, PurchaseOrderData> {
  $$PurchaseOrderTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SupplierTable _supplierIdTable(_$AppDatabase db) =>
      db.supplier.createAlias(
        $_aliasNameGenerator(db.purchaseOrder.supplierId, db.supplier.id),
      );

  $$SupplierTableProcessedTableManager get supplierId {
    final $_column = $_itemColumn<int>('supplier_id')!;

    final manager = $$SupplierTableTableManager(
      $_db,
      $_db.supplier,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.purchaseOrder.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$InboundReceiptTable, List<InboundReceiptData>>
  _inboundReceiptRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.inboundReceipt,
    aliasName: $_aliasNameGenerator(
      db.purchaseOrder.id,
      db.inboundReceipt.purchaseOrderId,
    ),
  );

  $$InboundReceiptTableProcessedTableManager get inboundReceiptRefs {
    final manager = $$InboundReceiptTableTableManager(
      $_db,
      $_db.inboundReceipt,
    ).filter((f) => f.purchaseOrderId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_inboundReceiptRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $PurchaseOrderItemTable,
    List<PurchaseOrderItemData>
  >
  _purchaseOrderItemRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.purchaseOrderItem,
        aliasName: $_aliasNameGenerator(
          db.purchaseOrder.id,
          db.purchaseOrderItem.purchaseOrderId,
        ),
      );

  $$PurchaseOrderItemTableProcessedTableManager get purchaseOrderItemRefs {
    final manager = $$PurchaseOrderItemTableTableManager(
      $_db,
      $_db.purchaseOrderItem,
    ).filter((f) => f.purchaseOrderId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _purchaseOrderItemRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PurchaseOrderTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTable> {
  $$PurchaseOrderTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    PurchaseOrderStatus,
    PurchaseOrderStatus,
    String
  >
  get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SupplierTableFilterComposer get supplierId {
    final $$SupplierTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.supplier,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SupplierTableFilterComposer(
            $db: $db,
            $table: $db.supplier,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> inboundReceiptRefs(
    Expression<bool> Function($$InboundReceiptTableFilterComposer f) f,
  ) {
    final $$InboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.purchaseOrderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrderItemRefs(
    Expression<bool> Function($$PurchaseOrderItemTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.purchaseOrderItem,
      getReferencedColumn: (t) => t.purchaseOrderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderItemTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrderItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PurchaseOrderTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTable> {
  $$PurchaseOrderTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SupplierTableOrderingComposer get supplierId {
    final $$SupplierTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.supplier,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SupplierTableOrderingComposer(
            $db: $db,
            $table: $db.supplier,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTable> {
  $$PurchaseOrderTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumnWithTypeConverter<PurchaseOrderStatus, String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SupplierTableAnnotationComposer get supplierId {
    final $$SupplierTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.supplier,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SupplierTableAnnotationComposer(
            $db: $db,
            $table: $db.supplier,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> inboundReceiptRefs<T extends Object>(
    Expression<T> Function($$InboundReceiptTableAnnotationComposer a) f,
  ) {
    final $$InboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.purchaseOrderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrderItemRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderItemTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderItemTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.purchaseOrderItem,
          getReferencedColumn: (t) => t.purchaseOrderId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$PurchaseOrderItemTableAnnotationComposer(
                $db: $db,
                $table: $db.purchaseOrderItem,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$PurchaseOrderTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PurchaseOrderTable,
          PurchaseOrderData,
          $$PurchaseOrderTableFilterComposer,
          $$PurchaseOrderTableOrderingComposer,
          $$PurchaseOrderTableAnnotationComposer,
          $$PurchaseOrderTableCreateCompanionBuilder,
          $$PurchaseOrderTableUpdateCompanionBuilder,
          (PurchaseOrderData, $$PurchaseOrderTableReferences),
          PurchaseOrderData,
          PrefetchHooks Function({
            bool supplierId,
            bool shopId,
            bool inboundReceiptRefs,
            bool purchaseOrderItemRefs,
          })
        > {
  $$PurchaseOrderTableTableManager(_$AppDatabase db, $PurchaseOrderTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrderTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrderTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrderTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> supplierId = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<PurchaseOrderStatus> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => PurchaseOrderCompanion(
                id: id,
                supplierId: supplierId,
                shopId: shopId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int supplierId,
                required int shopId,
                Value<PurchaseOrderStatus> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => PurchaseOrderCompanion.insert(
                id: id,
                supplierId: supplierId,
                shopId: shopId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PurchaseOrderTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                supplierId = false,
                shopId = false,
                inboundReceiptRefs = false,
                purchaseOrderItemRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (inboundReceiptRefs) db.inboundReceipt,
                    if (purchaseOrderItemRefs) db.purchaseOrderItem,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (supplierId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.supplierId,
                                    referencedTable:
                                        $$PurchaseOrderTableReferences
                                            ._supplierIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrderTableReferences
                                            ._supplierIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$PurchaseOrderTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrderTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (inboundReceiptRefs)
                        await $_getPrefetchedData<
                          PurchaseOrderData,
                          $PurchaseOrderTable,
                          InboundReceiptData
                        >(
                          currentTable: table,
                          referencedTable: $$PurchaseOrderTableReferences
                              ._inboundReceiptRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PurchaseOrderTableReferences(
                                db,
                                table,
                                p0,
                              ).inboundReceiptRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.purchaseOrderId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrderItemRefs)
                        await $_getPrefetchedData<
                          PurchaseOrderData,
                          $PurchaseOrderTable,
                          PurchaseOrderItemData
                        >(
                          currentTable: table,
                          referencedTable: $$PurchaseOrderTableReferences
                              ._purchaseOrderItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PurchaseOrderTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrderItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.purchaseOrderId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$PurchaseOrderTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PurchaseOrderTable,
      PurchaseOrderData,
      $$PurchaseOrderTableFilterComposer,
      $$PurchaseOrderTableOrderingComposer,
      $$PurchaseOrderTableAnnotationComposer,
      $$PurchaseOrderTableCreateCompanionBuilder,
      $$PurchaseOrderTableUpdateCompanionBuilder,
      (PurchaseOrderData, $$PurchaseOrderTableReferences),
      PurchaseOrderData,
      PrefetchHooks Function({
        bool supplierId,
        bool shopId,
        bool inboundReceiptRefs,
        bool purchaseOrderItemRefs,
      })
    >;
typedef $$InboundReceiptTableCreateCompanionBuilder =
    InboundReceiptCompanion Function({
      Value<int> id,
      required int shopId,
      required String source,
      Value<int?> purchaseOrderId,
      Value<String> status,
      Value<String?> remarks,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$InboundReceiptTableUpdateCompanionBuilder =
    InboundReceiptCompanion Function({
      Value<int> id,
      Value<int> shopId,
      Value<String> source,
      Value<int?> purchaseOrderId,
      Value<String> status,
      Value<String?> remarks,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$InboundReceiptTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $InboundReceiptTable,
          InboundReceiptData
        > {
  $$InboundReceiptTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.inboundReceipt.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $PurchaseOrderTable _purchaseOrderIdTable(_$AppDatabase db) =>
      db.purchaseOrder.createAlias(
        $_aliasNameGenerator(
          db.inboundReceipt.purchaseOrderId,
          db.purchaseOrder.id,
        ),
      );

  $$PurchaseOrderTableProcessedTableManager? get purchaseOrderId {
    final $_column = $_itemColumn<int>('purchase_order_id');
    if ($_column == null) return null;
    final manager = $$PurchaseOrderTableTableManager(
      $_db,
      $_db.purchaseOrder,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_purchaseOrderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$InboundItemTable, List<InboundItemData>>
  _inboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.inboundItem,
    aliasName: $_aliasNameGenerator(
      db.inboundReceipt.id,
      db.inboundItem.receiptId,
    ),
  );

  $$InboundItemTableProcessedTableManager get inboundItemRefs {
    final manager = $$InboundItemTableTableManager(
      $_db,
      $_db.inboundItem,
    ).filter((f) => f.receiptId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_inboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$InboundReceiptTableFilterComposer
    extends Composer<_$AppDatabase, $InboundReceiptTable> {
  $$InboundReceiptTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PurchaseOrderTableFilterComposer get purchaseOrderId {
    final $$PurchaseOrderTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> inboundItemRefs(
    Expression<bool> Function($$InboundItemTableFilterComposer f) f,
  ) {
    final $$InboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableFilterComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$InboundReceiptTableOrderingComposer
    extends Composer<_$AppDatabase, $InboundReceiptTable> {
  $$InboundReceiptTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PurchaseOrderTableOrderingComposer get purchaseOrderId {
    final $$PurchaseOrderTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableOrderingComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InboundReceiptTableAnnotationComposer
    extends Composer<_$AppDatabase, $InboundReceiptTable> {
  $$InboundReceiptTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get remarks =>
      $composableBuilder(column: $table.remarks, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PurchaseOrderTableAnnotationComposer get purchaseOrderId {
    final $$PurchaseOrderTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> inboundItemRefs<T extends Object>(
    Expression<T> Function($$InboundItemTableAnnotationComposer a) f,
  ) {
    final $$InboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.inboundItem,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$InboundReceiptTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $InboundReceiptTable,
          InboundReceiptData,
          $$InboundReceiptTableFilterComposer,
          $$InboundReceiptTableOrderingComposer,
          $$InboundReceiptTableAnnotationComposer,
          $$InboundReceiptTableCreateCompanionBuilder,
          $$InboundReceiptTableUpdateCompanionBuilder,
          (InboundReceiptData, $$InboundReceiptTableReferences),
          InboundReceiptData,
          PrefetchHooks Function({
            bool shopId,
            bool purchaseOrderId,
            bool inboundItemRefs,
          })
        > {
  $$InboundReceiptTableTableManager(
    _$AppDatabase db,
    $InboundReceiptTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InboundReceiptTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InboundReceiptTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$InboundReceiptTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<int?> purchaseOrderId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => InboundReceiptCompanion(
                id: id,
                shopId: shopId,
                source: source,
                purchaseOrderId: purchaseOrderId,
                status: status,
                remarks: remarks,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int shopId,
                required String source,
                Value<int?> purchaseOrderId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => InboundReceiptCompanion.insert(
                id: id,
                shopId: shopId,
                source: source,
                purchaseOrderId: purchaseOrderId,
                status: status,
                remarks: remarks,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$InboundReceiptTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                shopId = false,
                purchaseOrderId = false,
                inboundItemRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (inboundItemRefs) db.inboundItem,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$InboundReceiptTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$InboundReceiptTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (purchaseOrderId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.purchaseOrderId,
                                    referencedTable:
                                        $$InboundReceiptTableReferences
                                            ._purchaseOrderIdTable(db),
                                    referencedColumn:
                                        $$InboundReceiptTableReferences
                                            ._purchaseOrderIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (inboundItemRefs)
                        await $_getPrefetchedData<
                          InboundReceiptData,
                          $InboundReceiptTable,
                          InboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$InboundReceiptTableReferences
                              ._inboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$InboundReceiptTableReferences(
                                db,
                                table,
                                p0,
                              ).inboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.receiptId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$InboundReceiptTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $InboundReceiptTable,
      InboundReceiptData,
      $$InboundReceiptTableFilterComposer,
      $$InboundReceiptTableOrderingComposer,
      $$InboundReceiptTableAnnotationComposer,
      $$InboundReceiptTableCreateCompanionBuilder,
      $$InboundReceiptTableUpdateCompanionBuilder,
      (InboundReceiptData, $$InboundReceiptTableReferences),
      InboundReceiptData,
      PrefetchHooks Function({
        bool shopId,
        bool purchaseOrderId,
        bool inboundItemRefs,
      })
    >;
typedef $$InboundItemTableCreateCompanionBuilder =
    InboundItemCompanion Function({
      Value<int> id,
      required int receiptId,
      required int productId,
      Value<int?> batchId,
      required int quantity,
    });
typedef $$InboundItemTableUpdateCompanionBuilder =
    InboundItemCompanion Function({
      Value<int> id,
      Value<int> receiptId,
      Value<int> productId,
      Value<int?> batchId,
      Value<int> quantity,
    });

final class $$InboundItemTableReferences
    extends BaseReferences<_$AppDatabase, $InboundItemTable, InboundItemData> {
  $$InboundItemTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $InboundReceiptTable _receiptIdTable(_$AppDatabase db) =>
      db.inboundReceipt.createAlias(
        $_aliasNameGenerator(db.inboundItem.receiptId, db.inboundReceipt.id),
      );

  $$InboundReceiptTableProcessedTableManager get receiptId {
    final $_column = $_itemColumn<int>('receipt_id')!;

    final manager = $$InboundReceiptTableTableManager(
      $_db,
      $_db.inboundReceipt,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_receiptIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.inboundItem.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductBatchTable _batchIdTable(_$AppDatabase db) =>
      db.productBatch.createAlias(
        $_aliasNameGenerator(db.inboundItem.batchId, db.productBatch.id),
      );

  $$ProductBatchTableProcessedTableManager? get batchId {
    final $_column = $_itemColumn<int>('batch_id');
    if ($_column == null) return null;
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_batchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$InboundItemTableFilterComposer
    extends Composer<_$AppDatabase, $InboundItemTable> {
  $$InboundItemTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  $$InboundReceiptTableFilterComposer get receiptId {
    final $$InboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableFilterComposer get batchId {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InboundItemTableOrderingComposer
    extends Composer<_$AppDatabase, $InboundItemTable> {
  $$InboundItemTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  $$InboundReceiptTableOrderingComposer get receiptId {
    final $$InboundReceiptTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableOrderingComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableOrderingComposer get batchId {
    final $$ProductBatchTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableOrderingComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InboundItemTableAnnotationComposer
    extends Composer<_$AppDatabase, $InboundItemTable> {
  $$InboundItemTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  $$InboundReceiptTableAnnotationComposer get receiptId {
    final $$InboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.inboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$InboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.inboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableAnnotationComposer get batchId {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$InboundItemTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $InboundItemTable,
          InboundItemData,
          $$InboundItemTableFilterComposer,
          $$InboundItemTableOrderingComposer,
          $$InboundItemTableAnnotationComposer,
          $$InboundItemTableCreateCompanionBuilder,
          $$InboundItemTableUpdateCompanionBuilder,
          (InboundItemData, $$InboundItemTableReferences),
          InboundItemData,
          PrefetchHooks Function({bool receiptId, bool productId, bool batchId})
        > {
  $$InboundItemTableTableManager(_$AppDatabase db, $InboundItemTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InboundItemTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InboundItemTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$InboundItemTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> receiptId = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<int?> batchId = const Value.absent(),
                Value<int> quantity = const Value.absent(),
              }) => InboundItemCompanion(
                id: id,
                receiptId: receiptId,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int receiptId,
                required int productId,
                Value<int?> batchId = const Value.absent(),
                required int quantity,
              }) => InboundItemCompanion.insert(
                id: id,
                receiptId: receiptId,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$InboundItemTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({receiptId = false, productId = false, batchId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (receiptId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.receiptId,
                                    referencedTable:
                                        $$InboundItemTableReferences
                                            ._receiptIdTable(db),
                                    referencedColumn:
                                        $$InboundItemTableReferences
                                            ._receiptIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$InboundItemTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$InboundItemTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (batchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.batchId,
                                    referencedTable:
                                        $$InboundItemTableReferences
                                            ._batchIdTable(db),
                                    referencedColumn:
                                        $$InboundItemTableReferences
                                            ._batchIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$InboundItemTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $InboundItemTable,
      InboundItemData,
      $$InboundItemTableFilterComposer,
      $$InboundItemTableOrderingComposer,
      $$InboundItemTableAnnotationComposer,
      $$InboundItemTableCreateCompanionBuilder,
      $$InboundItemTableUpdateCompanionBuilder,
      (InboundItemData, $$InboundItemTableReferences),
      InboundItemData,
      PrefetchHooks Function({bool receiptId, bool productId, bool batchId})
    >;
typedef $$PurchaseOrderItemTableCreateCompanionBuilder =
    PurchaseOrderItemCompanion Function({
      Value<int> id,
      required int purchaseOrderId,
      required int productId,
      Value<DateTime?> productionDate,
      required int unitPriceInCents,
      required int quantity,
    });
typedef $$PurchaseOrderItemTableUpdateCompanionBuilder =
    PurchaseOrderItemCompanion Function({
      Value<int> id,
      Value<int> purchaseOrderId,
      Value<int> productId,
      Value<DateTime?> productionDate,
      Value<int> unitPriceInCents,
      Value<int> quantity,
    });

final class $$PurchaseOrderItemTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $PurchaseOrderItemTable,
          PurchaseOrderItemData
        > {
  $$PurchaseOrderItemTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PurchaseOrderTable _purchaseOrderIdTable(_$AppDatabase db) =>
      db.purchaseOrder.createAlias(
        $_aliasNameGenerator(
          db.purchaseOrderItem.purchaseOrderId,
          db.purchaseOrder.id,
        ),
      );

  $$PurchaseOrderTableProcessedTableManager get purchaseOrderId {
    final $_column = $_itemColumn<int>('purchase_order_id')!;

    final manager = $$PurchaseOrderTableTableManager(
      $_db,
      $_db.purchaseOrder,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_purchaseOrderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.purchaseOrderItem.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PurchaseOrderItemTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTable> {
  $$PurchaseOrderItemTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get unitPriceInCents => $composableBuilder(
    column: $table.unitPriceInCents,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  $$PurchaseOrderTableFilterComposer get purchaseOrderId {
    final $$PurchaseOrderTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTable> {
  $$PurchaseOrderItemTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get unitPriceInCents => $composableBuilder(
    column: $table.unitPriceInCents,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  $$PurchaseOrderTableOrderingComposer get purchaseOrderId {
    final $$PurchaseOrderTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableOrderingComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTable> {
  $$PurchaseOrderItemTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get productionDate => $composableBuilder(
    column: $table.productionDate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get unitPriceInCents => $composableBuilder(
    column: $table.unitPriceInCents,
    builder: (column) => column,
  );

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  $$PurchaseOrderTableAnnotationComposer get purchaseOrderId {
    final $$PurchaseOrderTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.purchaseOrderId,
      referencedTable: $db.purchaseOrder,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrder,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PurchaseOrderItemTable,
          PurchaseOrderItemData,
          $$PurchaseOrderItemTableFilterComposer,
          $$PurchaseOrderItemTableOrderingComposer,
          $$PurchaseOrderItemTableAnnotationComposer,
          $$PurchaseOrderItemTableCreateCompanionBuilder,
          $$PurchaseOrderItemTableUpdateCompanionBuilder,
          (PurchaseOrderItemData, $$PurchaseOrderItemTableReferences),
          PurchaseOrderItemData,
          PrefetchHooks Function({bool purchaseOrderId, bool productId})
        > {
  $$PurchaseOrderItemTableTableManager(
    _$AppDatabase db,
    $PurchaseOrderItemTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrderItemTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrderItemTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrderItemTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> purchaseOrderId = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<DateTime?> productionDate = const Value.absent(),
                Value<int> unitPriceInCents = const Value.absent(),
                Value<int> quantity = const Value.absent(),
              }) => PurchaseOrderItemCompanion(
                id: id,
                purchaseOrderId: purchaseOrderId,
                productId: productId,
                productionDate: productionDate,
                unitPriceInCents: unitPriceInCents,
                quantity: quantity,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int purchaseOrderId,
                required int productId,
                Value<DateTime?> productionDate = const Value.absent(),
                required int unitPriceInCents,
                required int quantity,
              }) => PurchaseOrderItemCompanion.insert(
                id: id,
                purchaseOrderId: purchaseOrderId,
                productId: productId,
                productionDate: productionDate,
                unitPriceInCents: unitPriceInCents,
                quantity: quantity,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PurchaseOrderItemTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({purchaseOrderId = false, productId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (purchaseOrderId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.purchaseOrderId,
                                    referencedTable:
                                        $$PurchaseOrderItemTableReferences
                                            ._purchaseOrderIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrderItemTableReferences
                                            ._purchaseOrderIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$PurchaseOrderItemTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrderItemTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$PurchaseOrderItemTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PurchaseOrderItemTable,
      PurchaseOrderItemData,
      $$PurchaseOrderItemTableFilterComposer,
      $$PurchaseOrderItemTableOrderingComposer,
      $$PurchaseOrderItemTableAnnotationComposer,
      $$PurchaseOrderItemTableCreateCompanionBuilder,
      $$PurchaseOrderItemTableUpdateCompanionBuilder,
      (PurchaseOrderItemData, $$PurchaseOrderItemTableReferences),
      PurchaseOrderItemData,
      PrefetchHooks Function({bool purchaseOrderId, bool productId})
    >;
typedef $$BarcodeTableCreateCompanionBuilder =
    BarcodeCompanion Function({
      Value<int> id,
      required int unitProductId,
      required String barcodeValue,
    });
typedef $$BarcodeTableUpdateCompanionBuilder =
    BarcodeCompanion Function({
      Value<int> id,
      Value<int> unitProductId,
      Value<String> barcodeValue,
    });

final class $$BarcodeTableReferences
    extends BaseReferences<_$AppDatabase, $BarcodeTable, BarcodeData> {
  $$BarcodeTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UnitProductTable _unitProductIdTable(_$AppDatabase db) =>
      db.unitProduct.createAlias(
        $_aliasNameGenerator(db.barcode.unitProductId, db.unitProduct.id),
      );

  $$UnitProductTableProcessedTableManager get unitProductId {
    final $_column = $_itemColumn<int>('unit_product_id')!;

    final manager = $$UnitProductTableTableManager(
      $_db,
      $_db.unitProduct,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_unitProductIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BarcodeTableFilterComposer
    extends Composer<_$AppDatabase, $BarcodeTable> {
  $$BarcodeTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => ColumnFilters(column),
  );

  $$UnitProductTableFilterComposer get unitProductId {
    final $$UnitProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitProductId,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableFilterComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BarcodeTableOrderingComposer
    extends Composer<_$AppDatabase, $BarcodeTable> {
  $$BarcodeTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => ColumnOrderings(column),
  );

  $$UnitProductTableOrderingComposer get unitProductId {
    final $$UnitProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitProductId,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableOrderingComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BarcodeTableAnnotationComposer
    extends Composer<_$AppDatabase, $BarcodeTable> {
  $$BarcodeTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => column,
  );

  $$UnitProductTableAnnotationComposer get unitProductId {
    final $$UnitProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.unitProductId,
      referencedTable: $db.unitProduct,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UnitProductTableAnnotationComposer(
            $db: $db,
            $table: $db.unitProduct,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BarcodeTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BarcodeTable,
          BarcodeData,
          $$BarcodeTableFilterComposer,
          $$BarcodeTableOrderingComposer,
          $$BarcodeTableAnnotationComposer,
          $$BarcodeTableCreateCompanionBuilder,
          $$BarcodeTableUpdateCompanionBuilder,
          (BarcodeData, $$BarcodeTableReferences),
          BarcodeData,
          PrefetchHooks Function({bool unitProductId})
        > {
  $$BarcodeTableTableManager(_$AppDatabase db, $BarcodeTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BarcodeTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BarcodeTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BarcodeTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> unitProductId = const Value.absent(),
                Value<String> barcodeValue = const Value.absent(),
              }) => BarcodeCompanion(
                id: id,
                unitProductId: unitProductId,
                barcodeValue: barcodeValue,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int unitProductId,
                required String barcodeValue,
              }) => BarcodeCompanion.insert(
                id: id,
                unitProductId: unitProductId,
                barcodeValue: barcodeValue,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BarcodeTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({unitProductId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (unitProductId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.unitProductId,
                                referencedTable: $$BarcodeTableReferences
                                    ._unitProductIdTable(db),
                                referencedColumn: $$BarcodeTableReferences
                                    ._unitProductIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BarcodeTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BarcodeTable,
      BarcodeData,
      $$BarcodeTableFilterComposer,
      $$BarcodeTableOrderingComposer,
      $$BarcodeTableAnnotationComposer,
      $$BarcodeTableCreateCompanionBuilder,
      $$BarcodeTableUpdateCompanionBuilder,
      (BarcodeData, $$BarcodeTableReferences),
      BarcodeData,
      PrefetchHooks Function({bool unitProductId})
    >;
typedef $$CustomersTableCreateCompanionBuilder =
    CustomersCompanion Function({Value<int> id, required String name});
typedef $$CustomersTableUpdateCompanionBuilder =
    CustomersCompanion Function({Value<int> id, Value<String> name});

final class $$CustomersTableReferences
    extends BaseReferences<_$AppDatabase, $CustomersTable, Customer> {
  $$CustomersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$SalesTransactionTable, List<SalesTransactionData>>
  _salesTransactionRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesTransaction,
    aliasName: $_aliasNameGenerator(
      db.customers.id,
      db.salesTransaction.customerId,
    ),
  );

  $$SalesTransactionTableProcessedTableManager get salesTransactionRefs {
    final manager = $$SalesTransactionTableTableManager(
      $_db,
      $_db.salesTransaction,
    ).filter((f) => f.customerId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _salesTransactionRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CustomersTableFilterComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> salesTransactionRefs(
    Expression<bool> Function($$SalesTransactionTableFilterComposer f) f,
  ) {
    final $$SalesTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableFilterComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CustomersTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> salesTransactionRefs<T extends Object>(
    Expression<T> Function($$SalesTransactionTableAnnotationComposer a) f,
  ) {
    final $$SalesTransactionTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableAnnotationComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CustomersTable,
          Customer,
          $$CustomersTableFilterComposer,
          $$CustomersTableOrderingComposer,
          $$CustomersTableAnnotationComposer,
          $$CustomersTableCreateCompanionBuilder,
          $$CustomersTableUpdateCompanionBuilder,
          (Customer, $$CustomersTableReferences),
          Customer,
          PrefetchHooks Function({bool salesTransactionRefs})
        > {
  $$CustomersTableTableManager(_$AppDatabase db, $CustomersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => CustomersCompanion(id: id, name: name),
          createCompanionCallback:
              ({Value<int> id = const Value.absent(), required String name}) =>
                  CustomersCompanion.insert(id: id, name: name),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CustomersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({salesTransactionRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (salesTransactionRefs) db.salesTransaction,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (salesTransactionRefs)
                    await $_getPrefetchedData<
                      Customer,
                      $CustomersTable,
                      SalesTransactionData
                    >(
                      currentTable: table,
                      referencedTable: $$CustomersTableReferences
                          ._salesTransactionRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CustomersTableReferences(
                            db,
                            table,
                            p0,
                          ).salesTransactionRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.customerId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CustomersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CustomersTable,
      Customer,
      $$CustomersTableFilterComposer,
      $$CustomersTableOrderingComposer,
      $$CustomersTableAnnotationComposer,
      $$CustomersTableCreateCompanionBuilder,
      $$CustomersTableUpdateCompanionBuilder,
      (Customer, $$CustomersTableReferences),
      Customer,
      PrefetchHooks Function({bool salesTransactionRefs})
    >;
typedef $$SalesTransactionTableCreateCompanionBuilder =
    SalesTransactionCompanion Function({
      Value<int> id,
      required int customerId,
      required int shopId,
      required double totalAmount,
      required double actualAmount,
      Value<String> status,
      Value<String?> remarks,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });
typedef $$SalesTransactionTableUpdateCompanionBuilder =
    SalesTransactionCompanion Function({
      Value<int> id,
      Value<int> customerId,
      Value<int> shopId,
      Value<double> totalAmount,
      Value<double> actualAmount,
      Value<String> status,
      Value<String?> remarks,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

final class $$SalesTransactionTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $SalesTransactionTable,
          SalesTransactionData
        > {
  $$SalesTransactionTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.salesTransaction.customerId, db.customers.id),
      );

  $$CustomersTableProcessedTableManager get customerId {
    final $_column = $_itemColumn<int>('customer_id')!;

    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.salesTransaction.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $SalesTransactionItemTable,
    List<SalesTransactionItemData>
  >
  _salesTransactionItemRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.salesTransactionItem,
        aliasName: $_aliasNameGenerator(
          db.salesTransaction.id,
          db.salesTransactionItem.salesTransactionId,
        ),
      );

  $$SalesTransactionItemTableProcessedTableManager
  get salesTransactionItemRefs {
    final manager =
        $$SalesTransactionItemTableTableManager(
          $_db,
          $_db.salesTransactionItem,
        ).filter(
          (f) => f.salesTransactionId.id.sqlEquals($_itemColumn<int>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _salesTransactionItemRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$OutboundReceiptTable, List<OutboundReceiptData>>
  _outboundReceiptRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.outboundReceipt,
    aliasName: $_aliasNameGenerator(
      db.salesTransaction.id,
      db.outboundReceipt.salesTransactionId,
    ),
  );

  $$OutboundReceiptTableProcessedTableManager get outboundReceiptRefs {
    final manager =
        $$OutboundReceiptTableTableManager($_db, $_db.outboundReceipt).filter(
          (f) => f.salesTransactionId.id.sqlEquals($_itemColumn<int>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _outboundReceiptRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SalesTransactionTableFilterComposer
    extends Composer<_$AppDatabase, $SalesTransactionTable> {
  $$SalesTransactionTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get actualAmount => $composableBuilder(
    column: $table.actualAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> salesTransactionItemRefs(
    Expression<bool> Function($$SalesTransactionItemTableFilterComposer f) f,
  ) {
    final $$SalesTransactionItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.salesTransactionItem,
      getReferencedColumn: (t) => t.salesTransactionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionItemTableFilterComposer(
            $db: $db,
            $table: $db.salesTransactionItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> outboundReceiptRefs(
    Expression<bool> Function($$OutboundReceiptTableFilterComposer f) f,
  ) {
    final $$OutboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.salesTransactionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SalesTransactionTableOrderingComposer
    extends Composer<_$AppDatabase, $SalesTransactionTable> {
  $$SalesTransactionTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get actualAmount => $composableBuilder(
    column: $table.actualAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remarks => $composableBuilder(
    column: $table.remarks,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesTransactionTableAnnotationComposer
    extends Composer<_$AppDatabase, $SalesTransactionTable> {
  $$SalesTransactionTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get actualAmount => $composableBuilder(
    column: $table.actualAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get remarks =>
      $composableBuilder(column: $table.remarks, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> salesTransactionItemRefs<T extends Object>(
    Expression<T> Function($$SalesTransactionItemTableAnnotationComposer a) f,
  ) {
    final $$SalesTransactionItemTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.salesTransactionItem,
          getReferencedColumn: (t) => t.salesTransactionId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SalesTransactionItemTableAnnotationComposer(
                $db: $db,
                $table: $db.salesTransactionItem,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> outboundReceiptRefs<T extends Object>(
    Expression<T> Function($$OutboundReceiptTableAnnotationComposer a) f,
  ) {
    final $$OutboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.salesTransactionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SalesTransactionTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SalesTransactionTable,
          SalesTransactionData,
          $$SalesTransactionTableFilterComposer,
          $$SalesTransactionTableOrderingComposer,
          $$SalesTransactionTableAnnotationComposer,
          $$SalesTransactionTableCreateCompanionBuilder,
          $$SalesTransactionTableUpdateCompanionBuilder,
          (SalesTransactionData, $$SalesTransactionTableReferences),
          SalesTransactionData,
          PrefetchHooks Function({
            bool customerId,
            bool shopId,
            bool salesTransactionItemRefs,
            bool outboundReceiptRefs,
          })
        > {
  $$SalesTransactionTableTableManager(
    _$AppDatabase db,
    $SalesTransactionTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SalesTransactionTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SalesTransactionTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SalesTransactionTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> customerId = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<double> actualAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => SalesTransactionCompanion(
                id: id,
                customerId: customerId,
                shopId: shopId,
                totalAmount: totalAmount,
                actualAmount: actualAmount,
                status: status,
                remarks: remarks,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int customerId,
                required int shopId,
                required double totalAmount,
                required double actualAmount,
                Value<String> status = const Value.absent(),
                Value<String?> remarks = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => SalesTransactionCompanion.insert(
                id: id,
                customerId: customerId,
                shopId: shopId,
                totalAmount: totalAmount,
                actualAmount: actualAmount,
                status: status,
                remarks: remarks,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SalesTransactionTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerId = false,
                shopId = false,
                salesTransactionItemRefs = false,
                outboundReceiptRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (salesTransactionItemRefs) db.salesTransactionItem,
                    if (outboundReceiptRefs) db.outboundReceipt,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable:
                                        $$SalesTransactionTableReferences
                                            ._customerIdTable(db),
                                    referencedColumn:
                                        $$SalesTransactionTableReferences
                                            ._customerIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$SalesTransactionTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$SalesTransactionTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (salesTransactionItemRefs)
                        await $_getPrefetchedData<
                          SalesTransactionData,
                          $SalesTransactionTable,
                          SalesTransactionItemData
                        >(
                          currentTable: table,
                          referencedTable: $$SalesTransactionTableReferences
                              ._salesTransactionItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SalesTransactionTableReferences(
                                db,
                                table,
                                p0,
                              ).salesTransactionItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.salesTransactionId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (outboundReceiptRefs)
                        await $_getPrefetchedData<
                          SalesTransactionData,
                          $SalesTransactionTable,
                          OutboundReceiptData
                        >(
                          currentTable: table,
                          referencedTable: $$SalesTransactionTableReferences
                              ._outboundReceiptRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SalesTransactionTableReferences(
                                db,
                                table,
                                p0,
                              ).outboundReceiptRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.salesTransactionId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SalesTransactionTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SalesTransactionTable,
      SalesTransactionData,
      $$SalesTransactionTableFilterComposer,
      $$SalesTransactionTableOrderingComposer,
      $$SalesTransactionTableAnnotationComposer,
      $$SalesTransactionTableCreateCompanionBuilder,
      $$SalesTransactionTableUpdateCompanionBuilder,
      (SalesTransactionData, $$SalesTransactionTableReferences),
      SalesTransactionData,
      PrefetchHooks Function({
        bool customerId,
        bool shopId,
        bool salesTransactionItemRefs,
        bool outboundReceiptRefs,
      })
    >;
typedef $$SalesTransactionItemTableCreateCompanionBuilder =
    SalesTransactionItemCompanion Function({
      Value<int> id,
      required int salesTransactionId,
      required int productId,
      Value<int?> batchId,
      required int priceInCents,
      required int quantity,
    });
typedef $$SalesTransactionItemTableUpdateCompanionBuilder =
    SalesTransactionItemCompanion Function({
      Value<int> id,
      Value<int> salesTransactionId,
      Value<int> productId,
      Value<int?> batchId,
      Value<int> priceInCents,
      Value<int> quantity,
    });

final class $$SalesTransactionItemTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $SalesTransactionItemTable,
          SalesTransactionItemData
        > {
  $$SalesTransactionItemTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SalesTransactionTable _salesTransactionIdTable(_$AppDatabase db) =>
      db.salesTransaction.createAlias(
        $_aliasNameGenerator(
          db.salesTransactionItem.salesTransactionId,
          db.salesTransaction.id,
        ),
      );

  $$SalesTransactionTableProcessedTableManager get salesTransactionId {
    final $_column = $_itemColumn<int>('sales_transaction_id')!;

    final manager = $$SalesTransactionTableTableManager(
      $_db,
      $_db.salesTransaction,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_salesTransactionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.salesTransactionItem.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductBatchTable _batchIdTable(_$AppDatabase db) =>
      db.productBatch.createAlias(
        $_aliasNameGenerator(
          db.salesTransactionItem.batchId,
          db.productBatch.id,
        ),
      );

  $$ProductBatchTableProcessedTableManager? get batchId {
    final $_column = $_itemColumn<int>('batch_id');
    if ($_column == null) return null;
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_batchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SalesTransactionItemTableFilterComposer
    extends Composer<_$AppDatabase, $SalesTransactionItemTable> {
  $$SalesTransactionItemTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priceInCents => $composableBuilder(
    column: $table.priceInCents,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  $$SalesTransactionTableFilterComposer get salesTransactionId {
    final $$SalesTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableFilterComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableFilterComposer get batchId {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesTransactionItemTableOrderingComposer
    extends Composer<_$AppDatabase, $SalesTransactionItemTable> {
  $$SalesTransactionItemTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priceInCents => $composableBuilder(
    column: $table.priceInCents,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  $$SalesTransactionTableOrderingComposer get salesTransactionId {
    final $$SalesTransactionTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableOrderingComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableOrderingComposer get batchId {
    final $$ProductBatchTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableOrderingComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesTransactionItemTableAnnotationComposer
    extends Composer<_$AppDatabase, $SalesTransactionItemTable> {
  $$SalesTransactionItemTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get priceInCents => $composableBuilder(
    column: $table.priceInCents,
    builder: (column) => column,
  );

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  $$SalesTransactionTableAnnotationComposer get salesTransactionId {
    final $$SalesTransactionTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableAnnotationComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableAnnotationComposer get batchId {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesTransactionItemTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SalesTransactionItemTable,
          SalesTransactionItemData,
          $$SalesTransactionItemTableFilterComposer,
          $$SalesTransactionItemTableOrderingComposer,
          $$SalesTransactionItemTableAnnotationComposer,
          $$SalesTransactionItemTableCreateCompanionBuilder,
          $$SalesTransactionItemTableUpdateCompanionBuilder,
          (SalesTransactionItemData, $$SalesTransactionItemTableReferences),
          SalesTransactionItemData,
          PrefetchHooks Function({
            bool salesTransactionId,
            bool productId,
            bool batchId,
          })
        > {
  $$SalesTransactionItemTableTableManager(
    _$AppDatabase db,
    $SalesTransactionItemTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SalesTransactionItemTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SalesTransactionItemTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SalesTransactionItemTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> salesTransactionId = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<int?> batchId = const Value.absent(),
                Value<int> priceInCents = const Value.absent(),
                Value<int> quantity = const Value.absent(),
              }) => SalesTransactionItemCompanion(
                id: id,
                salesTransactionId: salesTransactionId,
                productId: productId,
                batchId: batchId,
                priceInCents: priceInCents,
                quantity: quantity,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int salesTransactionId,
                required int productId,
                Value<int?> batchId = const Value.absent(),
                required int priceInCents,
                required int quantity,
              }) => SalesTransactionItemCompanion.insert(
                id: id,
                salesTransactionId: salesTransactionId,
                productId: productId,
                batchId: batchId,
                priceInCents: priceInCents,
                quantity: quantity,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SalesTransactionItemTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                salesTransactionId = false,
                productId = false,
                batchId = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (salesTransactionId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.salesTransactionId,
                                    referencedTable:
                                        $$SalesTransactionItemTableReferences
                                            ._salesTransactionIdTable(db),
                                    referencedColumn:
                                        $$SalesTransactionItemTableReferences
                                            ._salesTransactionIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$SalesTransactionItemTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$SalesTransactionItemTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (batchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.batchId,
                                    referencedTable:
                                        $$SalesTransactionItemTableReferences
                                            ._batchIdTable(db),
                                    referencedColumn:
                                        $$SalesTransactionItemTableReferences
                                            ._batchIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$SalesTransactionItemTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SalesTransactionItemTable,
      SalesTransactionItemData,
      $$SalesTransactionItemTableFilterComposer,
      $$SalesTransactionItemTableOrderingComposer,
      $$SalesTransactionItemTableAnnotationComposer,
      $$SalesTransactionItemTableCreateCompanionBuilder,
      $$SalesTransactionItemTableUpdateCompanionBuilder,
      (SalesTransactionItemData, $$SalesTransactionItemTableReferences),
      SalesTransactionItemData,
      PrefetchHooks Function({
        bool salesTransactionId,
        bool productId,
        bool batchId,
      })
    >;
typedef $$OutboundReceiptTableCreateCompanionBuilder =
    OutboundReceiptCompanion Function({
      Value<int> id,
      required int shopId,
      required String reason,
      Value<int?> salesTransactionId,
      Value<DateTime> createdAt,
    });
typedef $$OutboundReceiptTableUpdateCompanionBuilder =
    OutboundReceiptCompanion Function({
      Value<int> id,
      Value<int> shopId,
      Value<String> reason,
      Value<int?> salesTransactionId,
      Value<DateTime> createdAt,
    });

final class $$OutboundReceiptTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OutboundReceiptTable,
          OutboundReceiptData
        > {
  $$OutboundReceiptTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ShopTable _shopIdTable(_$AppDatabase db) => db.shop.createAlias(
    $_aliasNameGenerator(db.outboundReceipt.shopId, db.shop.id),
  );

  $$ShopTableProcessedTableManager get shopId {
    final $_column = $_itemColumn<int>('shop_id')!;

    final manager = $$ShopTableTableManager(
      $_db,
      $_db.shop,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shopIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SalesTransactionTable _salesTransactionIdTable(_$AppDatabase db) =>
      db.salesTransaction.createAlias(
        $_aliasNameGenerator(
          db.outboundReceipt.salesTransactionId,
          db.salesTransaction.id,
        ),
      );

  $$SalesTransactionTableProcessedTableManager? get salesTransactionId {
    final $_column = $_itemColumn<int>('sales_transaction_id');
    if ($_column == null) return null;
    final manager = $$SalesTransactionTableTableManager(
      $_db,
      $_db.salesTransaction,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_salesTransactionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OutboundItemTable, List<OutboundItemData>>
  _outboundItemRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.outboundItem,
    aliasName: $_aliasNameGenerator(
      db.outboundReceipt.id,
      db.outboundItem.receiptId,
    ),
  );

  $$OutboundItemTableProcessedTableManager get outboundItemRefs {
    final manager = $$OutboundItemTableTableManager(
      $_db,
      $_db.outboundItem,
    ).filter((f) => f.receiptId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_outboundItemRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OutboundReceiptTableFilterComposer
    extends Composer<_$AppDatabase, $OutboundReceiptTable> {
  $$OutboundReceiptTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ShopTableFilterComposer get shopId {
    final $$ShopTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableFilterComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesTransactionTableFilterComposer get salesTransactionId {
    final $$SalesTransactionTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableFilterComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> outboundItemRefs(
    Expression<bool> Function($$OutboundItemTableFilterComposer f) f,
  ) {
    final $$OutboundItemTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableFilterComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OutboundReceiptTableOrderingComposer
    extends Composer<_$AppDatabase, $OutboundReceiptTable> {
  $$OutboundReceiptTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ShopTableOrderingComposer get shopId {
    final $$ShopTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableOrderingComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesTransactionTableOrderingComposer get salesTransactionId {
    final $$SalesTransactionTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableOrderingComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OutboundReceiptTableAnnotationComposer
    extends Composer<_$AppDatabase, $OutboundReceiptTable> {
  $$OutboundReceiptTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ShopTableAnnotationComposer get shopId {
    final $$ShopTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shopId,
      referencedTable: $db.shop,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShopTableAnnotationComposer(
            $db: $db,
            $table: $db.shop,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesTransactionTableAnnotationComposer get salesTransactionId {
    final $$SalesTransactionTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.salesTransactionId,
      referencedTable: $db.salesTransaction,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesTransactionTableAnnotationComposer(
            $db: $db,
            $table: $db.salesTransaction,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> outboundItemRefs<T extends Object>(
    Expression<T> Function($$OutboundItemTableAnnotationComposer a) f,
  ) {
    final $$OutboundItemTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.outboundItem,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundItemTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundItem,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OutboundReceiptTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OutboundReceiptTable,
          OutboundReceiptData,
          $$OutboundReceiptTableFilterComposer,
          $$OutboundReceiptTableOrderingComposer,
          $$OutboundReceiptTableAnnotationComposer,
          $$OutboundReceiptTableCreateCompanionBuilder,
          $$OutboundReceiptTableUpdateCompanionBuilder,
          (OutboundReceiptData, $$OutboundReceiptTableReferences),
          OutboundReceiptData,
          PrefetchHooks Function({
            bool shopId,
            bool salesTransactionId,
            bool outboundItemRefs,
          })
        > {
  $$OutboundReceiptTableTableManager(
    _$AppDatabase db,
    $OutboundReceiptTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OutboundReceiptTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OutboundReceiptTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OutboundReceiptTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> shopId = const Value.absent(),
                Value<String> reason = const Value.absent(),
                Value<int?> salesTransactionId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => OutboundReceiptCompanion(
                id: id,
                shopId: shopId,
                reason: reason,
                salesTransactionId: salesTransactionId,
                createdAt: createdAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int shopId,
                required String reason,
                Value<int?> salesTransactionId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => OutboundReceiptCompanion.insert(
                id: id,
                shopId: shopId,
                reason: reason,
                salesTransactionId: salesTransactionId,
                createdAt: createdAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OutboundReceiptTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                shopId = false,
                salesTransactionId = false,
                outboundItemRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (outboundItemRefs) db.outboundItem,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (shopId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shopId,
                                    referencedTable:
                                        $$OutboundReceiptTableReferences
                                            ._shopIdTable(db),
                                    referencedColumn:
                                        $$OutboundReceiptTableReferences
                                            ._shopIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (salesTransactionId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.salesTransactionId,
                                    referencedTable:
                                        $$OutboundReceiptTableReferences
                                            ._salesTransactionIdTable(db),
                                    referencedColumn:
                                        $$OutboundReceiptTableReferences
                                            ._salesTransactionIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (outboundItemRefs)
                        await $_getPrefetchedData<
                          OutboundReceiptData,
                          $OutboundReceiptTable,
                          OutboundItemData
                        >(
                          currentTable: table,
                          referencedTable: $$OutboundReceiptTableReferences
                              ._outboundItemRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OutboundReceiptTableReferences(
                                db,
                                table,
                                p0,
                              ).outboundItemRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.receiptId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$OutboundReceiptTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OutboundReceiptTable,
      OutboundReceiptData,
      $$OutboundReceiptTableFilterComposer,
      $$OutboundReceiptTableOrderingComposer,
      $$OutboundReceiptTableAnnotationComposer,
      $$OutboundReceiptTableCreateCompanionBuilder,
      $$OutboundReceiptTableUpdateCompanionBuilder,
      (OutboundReceiptData, $$OutboundReceiptTableReferences),
      OutboundReceiptData,
      PrefetchHooks Function({
        bool shopId,
        bool salesTransactionId,
        bool outboundItemRefs,
      })
    >;
typedef $$OutboundItemTableCreateCompanionBuilder =
    OutboundItemCompanion Function({
      Value<int> id,
      required int receiptId,
      required int productId,
      Value<int?> batchId,
      required int quantity,
    });
typedef $$OutboundItemTableUpdateCompanionBuilder =
    OutboundItemCompanion Function({
      Value<int> id,
      Value<int> receiptId,
      Value<int> productId,
      Value<int?> batchId,
      Value<int> quantity,
    });

final class $$OutboundItemTableReferences
    extends
        BaseReferences<_$AppDatabase, $OutboundItemTable, OutboundItemData> {
  $$OutboundItemTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OutboundReceiptTable _receiptIdTable(_$AppDatabase db) =>
      db.outboundReceipt.createAlias(
        $_aliasNameGenerator(db.outboundItem.receiptId, db.outboundReceipt.id),
      );

  $$OutboundReceiptTableProcessedTableManager get receiptId {
    final $_column = $_itemColumn<int>('receipt_id')!;

    final manager = $$OutboundReceiptTableTableManager(
      $_db,
      $_db.outboundReceipt,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_receiptIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductTable _productIdTable(_$AppDatabase db) =>
      db.product.createAlias(
        $_aliasNameGenerator(db.outboundItem.productId, db.product.id),
      );

  $$ProductTableProcessedTableManager get productId {
    final $_column = $_itemColumn<int>('product_id')!;

    final manager = $$ProductTableTableManager(
      $_db,
      $_db.product,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductBatchTable _batchIdTable(_$AppDatabase db) =>
      db.productBatch.createAlias(
        $_aliasNameGenerator(db.outboundItem.batchId, db.productBatch.id),
      );

  $$ProductBatchTableProcessedTableManager? get batchId {
    final $_column = $_itemColumn<int>('batch_id');
    if ($_column == null) return null;
    final manager = $$ProductBatchTableTableManager(
      $_db,
      $_db.productBatch,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_batchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OutboundItemTableFilterComposer
    extends Composer<_$AppDatabase, $OutboundItemTable> {
  $$OutboundItemTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  $$OutboundReceiptTableFilterComposer get receiptId {
    final $$OutboundReceiptTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableFilterComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableFilterComposer get productId {
    final $$ProductTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableFilterComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableFilterComposer get batchId {
    final $$ProductBatchTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableFilterComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OutboundItemTableOrderingComposer
    extends Composer<_$AppDatabase, $OutboundItemTable> {
  $$OutboundItemTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  $$OutboundReceiptTableOrderingComposer get receiptId {
    final $$OutboundReceiptTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableOrderingComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableOrderingComposer get productId {
    final $$ProductTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableOrderingComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableOrderingComposer get batchId {
    final $$ProductBatchTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableOrderingComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OutboundItemTableAnnotationComposer
    extends Composer<_$AppDatabase, $OutboundItemTable> {
  $$OutboundItemTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  $$OutboundReceiptTableAnnotationComposer get receiptId {
    final $$OutboundReceiptTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.outboundReceipt,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OutboundReceiptTableAnnotationComposer(
            $db: $db,
            $table: $db.outboundReceipt,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductTableAnnotationComposer get productId {
    final $$ProductTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.product,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductTableAnnotationComposer(
            $db: $db,
            $table: $db.product,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductBatchTableAnnotationComposer get batchId {
    final $$ProductBatchTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.batchId,
      referencedTable: $db.productBatch,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductBatchTableAnnotationComposer(
            $db: $db,
            $table: $db.productBatch,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OutboundItemTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OutboundItemTable,
          OutboundItemData,
          $$OutboundItemTableFilterComposer,
          $$OutboundItemTableOrderingComposer,
          $$OutboundItemTableAnnotationComposer,
          $$OutboundItemTableCreateCompanionBuilder,
          $$OutboundItemTableUpdateCompanionBuilder,
          (OutboundItemData, $$OutboundItemTableReferences),
          OutboundItemData,
          PrefetchHooks Function({bool receiptId, bool productId, bool batchId})
        > {
  $$OutboundItemTableTableManager(_$AppDatabase db, $OutboundItemTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OutboundItemTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OutboundItemTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OutboundItemTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> receiptId = const Value.absent(),
                Value<int> productId = const Value.absent(),
                Value<int?> batchId = const Value.absent(),
                Value<int> quantity = const Value.absent(),
              }) => OutboundItemCompanion(
                id: id,
                receiptId: receiptId,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required int receiptId,
                required int productId,
                Value<int?> batchId = const Value.absent(),
                required int quantity,
              }) => OutboundItemCompanion.insert(
                id: id,
                receiptId: receiptId,
                productId: productId,
                batchId: batchId,
                quantity: quantity,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OutboundItemTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({receiptId = false, productId = false, batchId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (receiptId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.receiptId,
                                    referencedTable:
                                        $$OutboundItemTableReferences
                                            ._receiptIdTable(db),
                                    referencedColumn:
                                        $$OutboundItemTableReferences
                                            ._receiptIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$OutboundItemTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$OutboundItemTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (batchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.batchId,
                                    referencedTable:
                                        $$OutboundItemTableReferences
                                            ._batchIdTable(db),
                                    referencedColumn:
                                        $$OutboundItemTableReferences
                                            ._batchIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$OutboundItemTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OutboundItemTable,
      OutboundItemData,
      $$OutboundItemTableFilterComposer,
      $$OutboundItemTableOrderingComposer,
      $$OutboundItemTableAnnotationComposer,
      $$OutboundItemTableCreateCompanionBuilder,
      $$OutboundItemTableUpdateCompanionBuilder,
      (OutboundItemData, $$OutboundItemTableReferences),
      OutboundItemData,
      PrefetchHooks Function({bool receiptId, bool productId, bool batchId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$UnitTableTableManager get unit => $$UnitTableTableManager(_db, _db.unit);
  $$CategoryTableTableManager get category =>
      $$CategoryTableTableManager(_db, _db.category);
  $$ProductTableTableManager get product =>
      $$ProductTableTableManager(_db, _db.product);
  $$UnitProductTableTableManager get unitProduct =>
      $$UnitProductTableTableManager(_db, _db.unitProduct);
  $$ShopTableTableManager get shop => $$ShopTableTableManager(_db, _db.shop);
  $$SupplierTableTableManager get supplier =>
      $$SupplierTableTableManager(_db, _db.supplier);
  $$ProductBatchTableTableManager get productBatch =>
      $$ProductBatchTableTableManager(_db, _db.productBatch);
  $$StockTableTableManager get stock =>
      $$StockTableTableManager(_db, _db.stock);
  $$InventoryTransactionTableTableManager get inventoryTransaction =>
      $$InventoryTransactionTableTableManager(_db, _db.inventoryTransaction);
  $$LocationsTableTableTableManager get locationsTable =>
      $$LocationsTableTableTableManager(_db, _db.locationsTable);
  $$PurchaseOrderTableTableManager get purchaseOrder =>
      $$PurchaseOrderTableTableManager(_db, _db.purchaseOrder);
  $$InboundReceiptTableTableManager get inboundReceipt =>
      $$InboundReceiptTableTableManager(_db, _db.inboundReceipt);
  $$InboundItemTableTableManager get inboundItem =>
      $$InboundItemTableTableManager(_db, _db.inboundItem);
  $$PurchaseOrderItemTableTableManager get purchaseOrderItem =>
      $$PurchaseOrderItemTableTableManager(_db, _db.purchaseOrderItem);
  $$BarcodeTableTableManager get barcode =>
      $$BarcodeTableTableManager(_db, _db.barcode);
  $$CustomersTableTableManager get customers =>
      $$CustomersTableTableManager(_db, _db.customers);
  $$SalesTransactionTableTableManager get salesTransaction =>
      $$SalesTransactionTableTableManager(_db, _db.salesTransaction);
  $$SalesTransactionItemTableTableManager get salesTransactionItem =>
      $$SalesTransactionItemTableTableManager(_db, _db.salesTransactionItem);
  $$OutboundReceiptTableTableManager get outboundReceipt =>
      $$OutboundReceiptTableTableManager(_db, _db.outboundReceipt);
  $$OutboundItemTableTableManager get outboundItem =>
      $$OutboundItemTableTableManager(_db, _db.outboundItem);
}

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$appDatabaseHash() => r'9742fe3ee5567f29d157b720a4b4aed93a22005a';

/// See also [appDatabase].
@ProviderFor(appDatabase)
final appDatabaseProvider = AutoDisposeProvider<AppDatabase>.internal(
  appDatabase,
  name: r'appDatabaseProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$appDatabaseHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef AppDatabaseRef = AutoDisposeProviderRef<AppDatabase>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:drift/drift.dart';
import 'database.dart';

/// æ•°æ®åº“åˆå§‹åŒ–æœåŠ¡
/// è´Ÿè´£åˆå§‹åŒ–å„ç§é»˜è®¤æ•°æ?
class DatabaseInitializer {
  final AppDatabase _database;

  DatabaseInitializer(this._database);

  /// åˆå§‹åŒ–æ‰€æœ‰é»˜è®¤æ•°æ?
  Future<void> initializeAllDefaults() async {
    await initializeDefaultShops();
    await initializeDefaultCategories();
    await initializeDefaultUnits();
    await initializeDefaultProducts();
    await initializeDefaultProductUnits();
    await initializeDefaultBarcodes();
    await initializeDefaultCustomers();
    // å¯ä»¥ç»§ç»­æ·»åŠ å…¶ä»–åˆå§‹åŒ–æ–¹æ³?
  }

  /// åˆå§‹åŒ–é»˜è®¤åº—é“?
  Future<void> initializeDefaultShops() async {
    try {
      // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ•°æ?
      final count = await (_database.select(
        _database.shop,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸª åº—é“ºæ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultShops = [
        ShopCompanion.insert(
          id: Value(1),
          name: 'é•¿å±±çš„åº—',
          manager: 'changshan',
          
          updatedAt: Value(DateTime.now()),
        ),
        ShopCompanion.insert(
          id: Value(2),
          name: 'ç”°ç«‹çš„åº—',
          manager: 'tianli',
          
          updatedAt: Value(DateTime.now()),
        ),
      ];

      // ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ’å…¥
      await _database.transaction(() async {
        for (final shop in defaultShops) {
          await _database.into(_database.shop).insert(shop);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultShops.length} ä¸ªé»˜è®¤åº—é“?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤åº—é“ºå¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤ç±»åˆ?
  Future<void> initializeDefaultCategories() async {
    try {
      final count = await (_database.select(
        _database.category,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ“‚ ç±»åˆ«æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultCategories = [
        CategoryCompanion.insert(
          id: const Value(1),
          name: 'é£Ÿå“',
        ),
        CategoryCompanion.insert(
          id: const Value(2),
          name: 'é¥®æ–™',
        ),
        CategoryCompanion.insert(
          id: const Value(3),
          name: 'æ—¥ç”¨å“?,
        ),
      ];

      await _database.transaction(() async {
        for (final category in defaultCategories) {
          await _database.into(_database.category).insert(category);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultCategories.length} ä¸ªé»˜è®¤ç±»åˆ?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤ç±»åˆ«å¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤å•ä½?
  Future<void> initializeDefaultUnits() async {
    try {
      final count = await (_database.select(
        _database.unit,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ“ å•ä½æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }
      final defaultUnits = [
        UnitCompanion.insert(
          id: Value(1),
          name: 'ä¸?,
          
          
        ),
        UnitCompanion.insert(
          id: Value(2),
          name: 'åƒå…‹',
        ),
        UnitCompanion.insert(
          id: Value(3),
          name: 'ç®?,
          
          
        ),
        UnitCompanion.insert(
          id: Value(4),
          name: 'ç“?,
          
          
        ),
        UnitCompanion.insert(
          id: Value(5),
          name: 'åŒ?,
          
        ),
      ];

      await _database.transaction(() async {
        for (final unit in defaultUnits) {
          await _database.into(_database.unit).insert(unit);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultUnits.length} ä¸ªé»˜è®¤å•ä½?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤å•†å“?
  Future<void> initializeDefaultProducts() async {
    try {
      final count = await (_database.select(
        _database.product,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ“¦ å•†å“æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultProducts = [
        ProductCompanion.insert(
          id: const Value(1),
          name: 'å¯å£å¯ä¹',
          categoryId: const Value(2),
          baseUnitId: 4, // ç“?
        ),
        ProductCompanion.insert(
          id: const Value(2),
          name: 'åº·å¸ˆå‚…å†°çº¢èŒ¶',
          categoryId: const Value(2),
          baseUnitId: 4, // ç“?
        ),
        ProductCompanion.insert(
          id: const Value(3),
          name: 'å†œå¤«å±±æ³‰',
          categoryId: const Value(2),
          baseUnitId: 4, // ç“?
        ),
        ProductCompanion.insert(
          id: const Value(4),
          name: 'å¥¥åˆ©å¥?,
          categoryId: const Value(1),
          baseUnitId: 5, // åŒ?
        ),
        ProductCompanion.insert(
          id: const Value(5),
          name: 'ä¹äº‹è–¯ç‰‡',
          categoryId: const Value(1),
          baseUnitId: 5, // åŒ?
        ),
        ProductCompanion.insert(
          id: const Value(6),
          name: 'ç»Ÿä¸€è€å›é…¸èœç‰›è‚‰é?,
          categoryId: const Value(1),
          baseUnitId: 5, // åŒ?
        ),
        ProductCompanion.insert(
          id: const Value(7),
          name: 'æ¸…é£æŠ½çº¸',
          categoryId: const Value(3),
          baseUnitId: 5, // åŒ?
        ),
        ProductCompanion.insert(
          id: const Value(8),
          name: 'é«˜éœ²æ´ç‰™è†?,
          categoryId: const Value(3),
          baseUnitId: 1, // ä¸?
        ),
        ProductCompanion.insert(
          id: const Value(9),
          name: 'å¨ƒå“ˆå“ˆADé’™å¥¶',
          categoryId: const Value(2),
          baseUnitId: 4, // ç“?
        ),
        ProductCompanion.insert(
          id: const Value(10),
          name: 'è¾¾åˆ©å›­è›‹é»„æ´¾',
          categoryId: const Value(1),
          baseUnitId: 5, // åŒ?
        ),
      ];

      await _database.transaction(() async {
        for (final product in defaultProducts) {
          await _database.into(_database.product).insert(product);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultProducts.length} ä¸ªé»˜è®¤å•†å“?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤å•†å“å¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤å•†å“å•ä½å…³è?
  Future<void> initializeDefaultProductUnits() async {
    try {
      final count = await (_database.select(
        _database.unitProduct,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ“¦ äº§å“å•ä½æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultProductUnits = [
        // å¯å£å¯ä¹, ç“?
        UnitProductCompanion.insert(
          id: const Value(1),
          productId: 1,
          unitId: 4,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // åº·å¸ˆå‚…å†°çº¢èŒ¶, ç“?
        UnitProductCompanion.insert(
          id: const Value(2),
          productId: 2,
          unitId: 4,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // å†œå¤«å±±æ³‰, ç“?
        UnitProductCompanion.insert(
          id: const Value(3),
          productId: 3,
          unitId: 4,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // å¥¥åˆ©å¥? åŒ?
        UnitProductCompanion.insert(
          id: const Value(4),
          productId: 4,
          unitId: 5,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // ä¹äº‹è–¯ç‰‡, åŒ?
        UnitProductCompanion.insert(
          id: const Value(5),
          productId: 5,
          unitId: 5,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // ç»Ÿä¸€è€å›é…¸èœç‰›è‚‰é? åŒ?
        UnitProductCompanion.insert(
          id: const Value(6),
          productId: 6,
          unitId: 5,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // æ¸…é£æŠ½çº¸, åŒ?
        UnitProductCompanion.insert(
          id: const Value(7),
          productId: 7,
          unitId: 5,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // é«˜éœ²æ´ç‰™è†? ä¸?
        UnitProductCompanion.insert(
          id: const Value(8),
          productId: 8,
          unitId: 1,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // å¨ƒå“ˆå“ˆADé’™å¥¶, ç“?
        UnitProductCompanion.insert(
          id: const Value(9),
          productId: 9,
          unitId: 4,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
        // è¾¾åˆ©å›­è›‹é»„æ´¾, åŒ?
        UnitProductCompanion.insert(
          id: const Value(10),
          productId: 10,
          unitId: 5,
          conversionRate: 1,
          lastUpdated: Value(DateTime.now()),
        ),
      ];

      await _database.transaction(() async {
        for (final unitProduct in defaultProductUnits) {
          await _database.into(_database.unitProduct).insert(unitProduct);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultProductUnits.length} ä¸ªé»˜è®¤äº§å“å•ä½?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤äº§å“å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤æ¡ç ?
  Future<void> initializeDefaultBarcodes() async {
    try {
      final count = await (_database.select(
        _database.barcode,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ·ï¸?æ¡ç æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultBarcodes = [
        BarcodeCompanion.insert(unitProductId: 1, barcodeValue: '6901234567890'), // å¯å£å¯ä¹
        BarcodeCompanion.insert(unitProductId: 2, barcodeValue: '6901234567891'), // åº·å¸ˆå‚…å†°çº¢èŒ¶
        BarcodeCompanion.insert(unitProductId: 3, barcodeValue: '6901234567892'), // å†œå¤«å±±æ³‰
        BarcodeCompanion.insert(unitProductId: 4, barcodeValue: '6901234567893'), // å¥¥åˆ©å¥?
        BarcodeCompanion.insert(unitProductId: 5, barcodeValue: '6901234567894'), // ä¹äº‹è–¯ç‰‡
        BarcodeCompanion.insert(unitProductId: 6, barcodeValue: '6901234567895'), // ç»Ÿä¸€è€å›é…¸èœç‰›è‚‰é?
        BarcodeCompanion.insert(unitProductId: 7, barcodeValue: '6901234567896'), // æ¸…é£æŠ½çº¸
        BarcodeCompanion.insert(unitProductId: 8, barcodeValue: '6901234567897'), // é«˜éœ²æ´ç‰™è†?
        BarcodeCompanion.insert(unitProductId: 9, barcodeValue: '6901234567898'), // å¨ƒå“ˆå“ˆADé’™å¥¶
        BarcodeCompanion.insert(unitProductId: 10, barcodeValue: '6901234567899'), // è¾¾åˆ©å›­è›‹é»„æ´¾
      ];

      await _database.transaction(() async {
        for (final barcode in defaultBarcodes) {
          await _database.into(_database.barcode).insert(barcode);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultBarcodes.length} ä¸ªé»˜è®¤æ¡ç ?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤æ¡ç å¤±è´? $e');
      rethrow;
    }
  }

  /// åˆå§‹åŒ–é»˜è®¤å®¢æˆ?
  Future<void> initializeDefaultCustomers() async {
    try {
      final count = await (_database.select(
        _database.customers,
      )..limit(1)).get();

      if (count.isNotEmpty) {
        print('ğŸ‘¥ å®¢æˆ·æ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ?);
        return;
      }

      final defaultCustomers = [
        CustomersCompanion.insert(
          id: const Value(0),
          name: 'åŒ¿åæ•£å®¢',
        ),
      ];

      await _database.transaction(() async {
        for (final customer in defaultCustomers) {
          await _database.into(_database.customers).insert(customer);
        }
      });

      print('âœ?æˆåŠŸåˆå§‹åŒ?${defaultCustomers.length} ä¸ªé»˜è®¤å®¢æˆ?);
    } catch (e) {
      print('â?åˆå§‹åŒ–é»˜è®¤å®¢æˆ·å¤±è´? $e');
      rethrow;
    }
  }

  /// é‡ç½®æ‰€æœ‰æ•°æ®ï¼ˆä»…ç”¨äºå¼€å?æµ‹è¯•ï¼?
  Future<void> resetAllData() async {
    await _database.transaction(() async {
      // åˆ é™¤é”€å”®ç›¸å…³çš„è¡¨æ•°æ?
      await _database.delete(_database.salesTransactionItem).go();
      await _database.delete(_database.salesTransaction).go();
      await _database.delete(_database.customers).go();

      // åˆ é™¤ä¸šåŠ¡æ•°æ®è¡?
      await _database.delete(_database.inboundItem).go();
      await _database.delete(_database.inboundReceipt).go();
      await _database.delete(_database.purchaseOrderItem).go();
      await _database.delete(_database.purchaseOrder).go();
      await _database.delete(_database.inventoryTransaction).go();
      await _database.delete(_database.stock).go();
      await _database.delete(_database.productBatch).go();
      await _database.delete(_database.supplier).go();

      // åˆ é™¤åŸºç¡€æ•°æ®è¡?
      await _database.delete(_database.barcode).go();
      await _database.delete(_database.unitProduct).go();
      await _database.delete(_database.product).go();
      await _database.delete(_database.shop).go();
      await _database.delete(_database.category).go();
      await _database.delete(_database.unit).go();
    });

    await initializeAllDefaults();
    print('ğŸ”„ æ•°æ®åº“å·²é‡ç½®å¹¶é‡æ–°åˆå§‹åŒ–');
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'database.dart';
import 'database_initializer.dart';
import '../../features/backup/data/services/backup_initialization_service.dart';

/// æ•°æ®åº“åˆå§‹åŒ– Provider
/// åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨ï¼Œç¡®ä¿æ•°æ®åº“æœ‰åŸºç¡€æ•°æ®
final databaseInitializationProvider = FutureProvider<void>((ref) async {
  final database = ref.watch(appDatabaseProvider);
  final initializer = DatabaseInitializer(database);

  try {
    // åˆå§‹åŒ–æ•°æ®åº“åŸºç¡€æ•°æ®
    await initializer.initializeAllDefaults();
    print('ğŸ‰ æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');
    
    // åˆå§‹åŒ–å¤‡ä»½åŠŸèƒ?
    await BackupInitializationService.initialize(database);
    print('ğŸ‰ å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–å®Œæˆ?);
  } catch (e) {
    print('ğŸ’¥ åˆå§‹åŒ–å¤±è´? $e');
    rethrow;
  }
});

/// æ‰‹åŠ¨é‡ç½®æ•°æ®åº?Providerï¼ˆç”¨äºå¼€å?æµ‹è¯•ï¼?
final resetDatabaseProvider = FutureProvider.family<void, bool>((
  ref,
  force,
) async {
  if (!force) return;

  final database = ref.watch(appDatabaseProvider);
  final initializer = DatabaseInitializer(database);

  await initializer.resetAllData();
  ref.invalidateSelf();
});
import 'package:drift/drift.dart';
import 'shops_table.dart';
import 'purchase_orders_table.dart';

/// å…¥åº“å•è¡¨
/// å­˜å‚¨å…¥åº“å•çš„åŸºæœ¬ä¿¡æ¯
class InboundReceipt extends Table {
  /// ä¸»é”® - å…¥åº“å•ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  /// æ¥æº
  TextColumn get source => text()();

  /// å¤–é”® - é‡‡è´­å•IDï¼ˆå¦‚æœæ¥è‡ªé‡‡è´­å•ï¼?
  IntColumn get purchaseOrderId =>
      integer().references(PurchaseOrder, #id).nullable()();

  /// å…¥åº“å•çŠ¶æ€ï¼špreset draft(è‰ç¨¿), completed(å·²å®Œæˆ?
  TextColumn get status => text().withDefault(const Constant('preset'))();

  /// å¤‡æ³¨
  TextColumn get remarks => text().nullable()();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'inbound_receipts_table.dart';
import 'batches_table.dart';

/// å…¥åº“å•æ˜ç»†è¡¨
/// å­˜å‚¨å…¥åº“å•ä¸­çš„å…·ä½“å•†å“æ˜ç»†ä¿¡æ?
class InboundItem extends Table {
  /// ä¸»é”® - æ˜ç»†ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - å…¥åº“å•ID
  IntColumn get receiptId => integer().references(InboundReceipt, #id)();

  /// å¤–é”® - å•†å“ID
  IntColumn get productId => integer().references(Product, #id)();

  /// æ‰¹æ¬¡å?
  IntColumn get batchId => integer().references(ProductBatch, #id).nullable()();

  /// å…¥åº“æ•°é‡
  IntColumn get quantity => integer()();
}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'shops_table.dart';
import 'batches_table.dart';

/// åº“å­˜è¡?
/// å­˜å‚¨äº§å“åœ¨å„åº—é“ºçš„åº“å­˜ä¿¡æ?
class Stock extends Table {
  /// ä¸»é”® - åº“å­˜ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - è´§å“ID
  IntColumn get productId => integer().references(Product, #id)();

  /// å¤–é”® - æ‰¹æ¬¡å?
  IntColumn get batchId =>
      integer().references(ProductBatch, #id).nullable()();

  /// æ•°é‡
  IntColumn get quantity => integer()();

  /// ç§»åŠ¨åŠ æƒå¹³å‡å•ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼?
  IntColumn get averageUnitPriceInCents => integer().withDefault(const Constant(0))();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'shops_table.dart';
import 'batches_table.dart';

/// åº“å­˜æµæ°´è¡?
/// è®°å½•äº§å“åº“å­˜å˜åŠ¨çš„å†å²è®°å½?
class InventoryTransaction extends Table {
  /// ä¸»é”® - æµæ°´ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - äº§å“ID
  IntColumn get productId => integer().references(Product, #id)();

  /// æµæ°´ç±»å‹ï¼ˆå…¥åº“ã€å‡ºåº“ç­‰ï¼?
  TextColumn get transactionType => text()
      .named('type')
      .check(
        const CustomExpression<bool>(
          '"type" IN (\'in\', \'out\', \'adjust\', \'transfer\', \'return\')',
        ),
      )();

  /// å˜åŠ¨æ•°é‡
  IntColumn get quantity => integer()();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  /// å¤–é”® - æ‰¹æ¬¡IDï¼ˆå¯é€‰ï¼‰
  IntColumn get batchId =>
      integer().references(ProductBatch, #id).nullable()();

  /// æµæ°´æ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';

/// è´§ä½è¡?
/// å­˜å‚¨ä»“åº“è´§ä½ä¿¡æ¯
class LocationsTable extends Table {
  @override
  String get tableName => 'locations';

  /// ä¸»é”® - è´§ä½ID
  TextColumn get id => text().named('id')();

  /// è´§ä½ç¼–ç ï¼ˆå¦‚ï¼šA-01-01ï¼?
  TextColumn get code => text().named('code').unique()();

  /// è´§ä½åç§°
  TextColumn get name => text().named('name')();

  /// è´§ä½æè¿°
  TextColumn get description => text().named('description').nullable()();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().named('shop_id')();

  /// è´§ä½çŠ¶æ€ï¼šactive(æ´»è·ƒ), inactive(åœç”¨)
  TextColumn get status =>
      text().named('status').withDefault(const Constant('active'))();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt =>
      dateTime().named('created_at').withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt =>
      dateTime().named('updated_at').withDefault(currentDateAndTime)();

  @override
  Set<Column> get primaryKey => {id};

  @override
  List<Set<Column>> get uniqueKeys => [
    // åŒä¸€åº—é“ºå†…è´§ä½ç¼–ç å”¯ä¸€
    {shopId, code},
  ];
}
import 'package:drift/drift.dart';
import 'shops_table.dart';
import 'sales_transactions_table.dart';

/// å‡ºåº“å•è¡¨
/// å­˜å‚¨å‡ºåº“å•çš„åŸºæœ¬ä¿¡æ¯
class OutboundReceipt extends Table {
  /// ä¸»é”® - å‡ºåº“å•ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  /// åŸå› 
  TextColumn get reason => text()();

  /// å¤–é”® - é”€å”®å•IDï¼ˆå¦‚æœæ¥è‡ªé”€å”®å•ï¼?
  IntColumn get salesTransactionId =>
      integer().references(SalesTransaction, #id).nullable()();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'outbound_receipts_table.dart';
import 'batches_table.dart';

/// å‡ºåº“å•æ˜ç»†è¡¨
/// å­˜å‚¨å‡ºåº“å•ä¸­çš„å…·ä½“å•†å“æ˜ç»†ä¿¡æ?
class OutboundItem extends Table {
  /// ä¸»é”® - æ˜ç»†ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - å‡ºåº“å•ID
  IntColumn get receiptId => integer().references(OutboundReceipt, #id)();

  /// å¤–é”® - å•†å“ID
  IntColumn get productId => integer().references(Product, #id)();

  /// æ‰¹æ¬¡å?
  IntColumn get batchId => integer().references(ProductBatch, #id).nullable()();

  /// æ•°é‡
  IntColumn get quantity => integer()();
}
import 'package:drift/drift.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';
import 'categories_table.dart';
import 'units_table.dart';

// --- ç±»å‹è½¬æ¢å™?---
class MoneyConverter extends TypeConverter<Money, int> {
  const MoneyConverter();
  @override
  Money fromSql(int fromDb) {
    return Money(fromDb);
  }

  @override
  int toSql(Money value) {
    return value.cents;
  }
}

class Product extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  TextColumn get sku => text().nullable().customConstraint('UNIQUE')();
  TextColumn get image => text().nullable()();
  IntColumn get baseUnitId => integer().references(Unit, #id)();
  IntColumn get categoryId => integer().references(Category, #id).nullable()();
  TextColumn get specification => text().nullable()();
  TextColumn get brand => text().nullable()();

  // ä½¿ç”¨ MoneyConverterï¼Œåˆ—åæ›´ç®€æ´?
  IntColumn get suggestedRetailPrice =>
      integer().map(const MoneyConverter()).nullable()();
  IntColumn get retailPrice =>
      integer().map(const MoneyConverter()).nullable()();
  IntColumn get promotionalPrice =>
      integer().map(const MoneyConverter()).nullable()();

  IntColumn get stockWarningValue => integer().nullable()();
  IntColumn get shelfLife =>
      integer().nullable()(); // æ³¨é‡Šï¼šä¿è´¨æœŸæ•°å€¼ï¼Œå•ä½ç”?shelfLifeUnit å†³å®š

  TextColumn get shelfLifeUnit => text()
      .map(const EnumNameConverter(ShelfLifeUnit.values))
      .withDefault(Constant(ShelfLifeUnit.months.name))();

  BoolColumn get enableBatchManagement =>
      boolean().withDefault(const Constant(false))();

  TextColumn get status => text()
      .map(const EnumNameConverter(ProductStatus.values))
      .withDefault(Constant(ProductStatus.active.name))();

  TextColumn get remarks => text().nullable()();
  DateTimeColumn get lastUpdated => dateTime().nullable()();
}
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'units_table.dart';

/// äº§å“å•ä½å…³è”è¡?
/// å­˜å‚¨äº§å“ä¸å•ä½çš„å…³è”å…³ç³»åŠæ¢ç®—ç‡ä¿¡æ¯
class UnitProduct extends Table {
  /// ä¸»é”® - ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - äº§å“ID
  IntColumn get productId => integer().references(Product, #id)();

  /// å¤–é”® - å•ä½ID
  IntColumn get unitId => integer().references(Unit, #id)();

  /// æ¢ç®—ç‡ï¼ˆç›¸å¯¹äºåŸºç¡€å•ä½ï¼?
  IntColumn get conversionRate => integer()();

  /// å”®ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½å­˜å‚¨ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼?
  IntColumn get sellingPriceInCents => integer().nullable()();

  /// æ‰¹å‘ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½å­˜å‚¨ï¼‰
  IntColumn get wholesalePriceInCents => integer().nullable()();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get lastUpdated =>
      dateTime().withDefault(currentDateAndTime)();

  @override
  List<Set<Column>> get uniqueKeys => [
    {productId, unitId}, // åŒä¸€äº§å“çš„åŒä¸€å•ä½åªèƒ½æœ‰ä¸€ä¸ªè®°å½?
  ];
}
import 'package:drift/drift.dart';
import 'shops_table.dart';
import 'suppliers_table.dart';

/// é‡‡è´­è®¢å•è¡?
/// å­˜å‚¨é‡‡è´­è®¢å•çš„å®è§‚ä¿¡æ¯ï¼Œå¦‚ä¾›åº”å•†ã€åº—é“ºã€é‡‡è´­æ—¥æœŸç­‰ã€?
class PurchaseOrder extends Table {
  /// ä¸»é”® - é‡‡è´­è®¢å•å?
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - ä¾›åº”å•†ID
  IntColumn get supplierId => integer().references(Supplier, #id)();

  /// å¤–é”® - åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  // ä½¿ç”¨å—é™æšä¸¾ï¼Œé¿å…ä»»æ„å­—ç¬¦ä¸²
  TextColumn get status =>
      textEnum<PurchaseOrderStatus>().withDefault(const Constant('preset'))();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}

/// è®¢å•çŠ¶æ€æšä¸?
enum PurchaseOrderStatus { preset, draft, completed }
import 'package:drift/drift.dart';
import 'products_table.dart';
import 'purchase_orders_table.dart';

/// é‡‡è´­è®¢å•æ˜ç»†è¡?
/// å­˜å‚¨é‡‡è´­è®¢å•ä¸­çš„å…·ä½“è´§å“ä¿¡æ¯
class PurchaseOrderItem extends Table {
  /// ä¸»é”® - è‡ªå¢ID
  IntColumn get id => integer().autoIncrement()();

  /// å¤–é”® - å…³è”åˆ°é‡‡è´­è®¢å•è¡¨
  IntColumn get purchaseOrderId =>
      integer().references(PurchaseOrder, #id, onDelete: KeyAction.cascade)();

  /// å¤–é”® - è´§å“ID
  IntColumn get productId =>
      integer().references(Product, #id, onDelete: KeyAction.restrict)();

  /// ç”Ÿäº§æ—¥æœŸ
  DateTimeColumn get productionDate => dateTime().nullable()();

  /// å•ä½ä»·æ ¼ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼?
  IntColumn get unitPriceInCents => integer()();

  /// æ•°é‡
  IntColumn get quantity => integer()();

  @override
  List<String> get customConstraints => [
        'CHECK(quantity >= 1)',
        'CHECK(unit_price_in_cents >= 0)',
      ];
}
import 'package:drift/drift.dart';
import 'customers_table.dart';
import 'shops_table.dart';

/// é”€å”®äº¤æ˜“è¡¨
class SalesTransaction extends Table {
  /// ä¸»é”® - è‡ªå¢ID
  IntColumn get id => integer().autoIncrement()();

  /// å®¢æˆ·ID
  IntColumn get customerId => integer().references(Customers, #id)();

  /// åº—é“ºID
  IntColumn get shopId => integer().references(Shop, #id)();

  /// æ€»é‡‘é¢?
  RealColumn get totalAmount => real()();

  /// å®æ”¶é‡‘é¢
  RealColumn get actualAmount => real()();

  /// çŠ¶æ€?(preset,credit, Settled, cancelled)
  TextColumn get status => text().withDefault(const Constant('preset'))();

  /// å¤‡æ³¨
  TextColumn get remarks => text().nullable()();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';
import 'sales_transactions_table.dart';
import 'batches_table.dart';
import 'products_table.dart';

class SalesTransactionItem extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get salesTransactionId =>
      integer().references(SalesTransaction, #id)();
  IntColumn get productId => integer().references(Product, #id)();
  IntColumn get batchId => integer().references(ProductBatch, #id).nullable()();
  IntColumn get priceInCents => integer()();
  IntColumn get quantity => integer()();
}
import 'package:drift/drift.dart';

/// åº—é“ºè¡?
/// å­˜å‚¨åº—é“ºçš„åŸºæœ¬ä¿¡æ?
class Shop extends Table {
  /// ä¸»é”® - åº—é“ºID
  IntColumn get id => integer().autoIncrement()();

  /// åº—é“ºåç§°
  TextColumn get name => text()();

  /// åº—é•¿
  TextColumn get manager => text()();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';

/// ä¾›åº”å•†è¡¨
/// å­˜å‚¨ä¾›åº”å•†ä¿¡æ?
class Supplier extends Table {
  /// ä¸»é”® - ä¾›åº”å•†ID
  IntColumn get id => integer().autoIncrement()();

  /// ä¾›åº”å•†åç§?
  TextColumn get name => text()();

  /// åˆ›å»ºæ—¶é—´
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// æœ€åæ›´æ–°æ—¶é—?
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}
import 'package:drift/drift.dart';

/// å•ä½è¡?
/// å­˜å‚¨äº§å“çš„è®¡é‡å•ä½ä¿¡æ¯ï¼ˆå¦?kg, pcs, mï¼?
class Unit extends Table {

  IntColumn get id => integer().autoIncrement()();

  /// å•ä½åç§°ï¼ˆå”¯ä¸€ï¼Œä¾‹å¦?"åƒå…‹"ã€?ç±?ã€?ä»?ï¼?
  TextColumn get name => text().unique()();
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../database/database_providers.dart';
import '../services/user_agreement_provider.dart';
import '../../features/settings/presentation/widgets/privacy_policy_dialog.dart';

/// åº”ç”¨å¯åŠ¨åˆå§‹åŒ–Widget
/// è´Ÿè´£æ•°æ®åº“åˆå§‹åŒ–å’Œç”¨æˆ·åè®®æ£€æŸ?
class AppInitializer extends ConsumerStatefulWidget {
  final Widget child;

  const AppInitializer({super.key, required this.child});

  @override
  ConsumerState<AppInitializer> createState() => _AppInitializerState();
}

class _AppInitializerState extends ConsumerState<AppInitializer> {
  bool _agreementDialogShown = false;

  @override
  Widget build(BuildContext context) {
    final initializationState = ref.watch(databaseInitializationProvider);
    final agreementStatus = ref.watch(userAgreementStatusProvider);

    return initializationState.when(
      data: (_) {
        // æ•°æ®åº“åˆå§‹åŒ–å®Œæˆåï¼Œæ£€æŸ¥ç”¨æˆ·åè®?
        return agreementStatus.when(
          data: (hasAccepted) {
            if (!hasAccepted && !_agreementDialogShown) {
              // ç”¨æˆ·æœªåŒæ„åè®®ï¼Œæ˜¾ç¤ºåè®®å¯¹è¯æ¡?
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted && !_agreementDialogShown) {
                  _agreementDialogShown = true;
                  _showAgreementDialog();
                }
              });
            }
            return widget.child;
          },
          loading: () => const _LoadingScreen(),
          error: (error, stackTrace) => _ErrorScreen(
            error: error,
            onRetry: () => ref.invalidate(userAgreementStatusProvider),
          ),
        );
      },
      loading: () => const _LoadingScreen(),
      error: (error, stackTrace) => _ErrorScreen(
        error: error,
        onRetry: () => ref.invalidate(databaseInitializationProvider),
      ),
    );
  }

  void _showAgreementDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => PrivacyPolicyDialog(
        onAgreed: () async {
          final service = ref.read(userAgreementServiceProvider);
          await service.acceptAgreement();
          ref.invalidate(userAgreementStatusProvider);
          if (mounted) {
            Navigator.of(context).pop();
          }
        },
      ),
    );
  }
}

/// åˆå§‹åŒ–åŠ è½½ç•Œé?
class _LoadingScreen extends StatelessWidget {
  const _LoadingScreen();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // App Logo
              Container(
                width: 100,
                height: 100,
                decoration: BoxDecoration(
                  color: Colors.blue.shade100,
                  borderRadius: BorderRadius.circular(20),
                ),
                child: Icon(Icons.store, size: 60, color: Colors.blue.shade600),
              ),
              const SizedBox(height: 32),

              // App Title
              Text(
                'é“ºå¾—æ¸?App',
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey.shade800,
                ),
              ),
              const SizedBox(height: 16),

              // Loading Text
              Text(
                'æ­£åœ¨åˆå§‹åŒ–æ•°æ®åº“...',
                style: TextStyle(fontSize: 16, color: Colors.grey.shade600),
              ),
              const SizedBox(height: 24),

              // Loading Indicator
              SizedBox(
                width: 40,
                height: 40,
                child: CircularProgressIndicator(
                  strokeWidth: 3,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.blue.shade600,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// åˆå§‹åŒ–é”™è¯¯ç•Œé?
class _ErrorScreen extends StatelessWidget {
  final Object error;
  final VoidCallback onRetry;

  const _ErrorScreen({required this.error, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Error Icon
                Icon(Icons.error_outline, size: 80, color: Colors.red.shade400),
                const SizedBox(height: 24),

                // Error Title
                Text(
                  'åˆå§‹åŒ–å¤±è´?,
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey.shade800,
                  ),
                ),
                const SizedBox(height: 16),

                // Error Message
                Text(
                  'æ•°æ®åº“åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯?,
                  style: TextStyle(fontSize: 16, color: Colors.grey.shade600),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),

                // Error Details
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    error.toString(),
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey.shade700,
                      fontFamily: 'monospace',
                    ),
                  ),
                ),
                const SizedBox(height: 32),

                // Retry Button
                ElevatedButton.icon(
                  onPressed: onRetry,
                  icon: const Icon(Icons.refresh),
                  label: const Text('é‡è¯•'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 24,
                      vertical: 12,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:equatable/equatable.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';

/// æ‰«ç å¾—åˆ°å¹¶åœ¨é¡µé¢é—´ä¼ é€’çš„è´§å“æ•°æ®
class ScannedProductPayload extends Equatable {
  final ProductModel product;
  final String barcode;
  final int unitId;
  final String unitName;
  final int conversionRate;
  final int? sellingPriceInCents;
  final int? wholesalePriceInCents;
  final int? averageUnitPriceInCents;

  const ScannedProductPayload({
    required this.product,
    required this.barcode,
    required this.unitId,
    required this.unitName,
    required this.conversionRate,
    this.sellingPriceInCents,
    this.wholesalePriceInCents,
    this.averageUnitPriceInCents,
  });

  @override
  List<Object?> get props => [
        product.id,
        barcode,
        unitId,
        unitName,
        conversionRate,
        sellingPriceInCents,
        wholesalePriceInCents,
        averageUnitPriceInCents,
      ];
}
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../constants/app_routes.dart';
import '../widgets/scaffold_with_nav_bar.dart';
import '../widgets/privacy_policy_checker.dart';
import '../../features/product/presentation/screens/product_list_screen.dart';
import '../../features/product/presentation/screens/product_add_edit_screen.dart';
import '../../features/product/presentation/screens/product_detail_screen.dart';
import '../../features/product/presentation/screens/product_ranking_screen.dart';
import '../../features/product/presentation/screens/category_selection_screen.dart';
import '../../features/product/application/provider/product_providers.dart';
import '../../features/database/presentation/screens/database_viewer_screen.dart';
import '../../features/debug/screens/database_management_screen.dart';
import '../../features/inbound/presentation/screens/screens.dart';
import '../../features/inventory/presentation/screens/screens.dart';
import '../../features/sale/presentation/screens/create_sale_screen.dart';
import '../../features/sale/presentation/screens/sales_records_screen.dart';
import '../../features/purchase/presentation/screens/purchase_records_screen.dart';
import '../../features/settings/presentation/screens/settings_screen.dart';
import '../../features/settings/presentation/screens/terms_of_service_screen.dart';
import '../../features/settings/presentation/screens/privacy_policy_screen.dart';
import '../../features/sale/presentation/screens/customer_selection_screen.dart';
import '../../features/home/presentation/screens/home_screen.dart';
import '../../core/models/scanned_product_payload.dart';
import '../../debug/product_restore_debug_page.dart';

// GoRouter Provider
final routerProvider = Provider<GoRouter>((ref) {
  return GoRouter(
    initialLocation: AppRoutes.home,
    routes: [
      // åº•éƒ¨å¯¼èˆªæ æ‰¿è½½çš„ 4 ä¸ªä¸»åˆ†æ”¯
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) => PrivacyPolicyChecker(
          child: ScaffoldWithNavBar(navigationShell: navigationShell),
        ),
        branches: [
          // é¦–é¡µ
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: AppRoutes.home,
                name: 'home',
                builder: (context, state) => const HomeScreen(),
              ),
            ],
          ),
          // è´§å“
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: AppRoutes.products,
                name: 'products',
                builder: (context, state) => const ProductListScreen(),
                routes: [
                  GoRoute(
                    path: 'ranking',
                    name: 'product-ranking',
                    builder: (context, state) => const ProductRankingScreen(),
                  ),
                  GoRoute(
                    path: ':id',
                    name: 'product-detail',
                    builder: (context, state) {
                      final productId = int.parse(state.pathParameters['id']!);
                      return ProductDetailScreen(productId: productId);
                    },
                  ),
                ],
              ),
            ],
          ),
          // é”€å”?
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: AppRoutes.sales,
                name: 'sales',
                builder: (context, state) => Scaffold(
                  appBar: AppBar(title: const Text('é”€å”®ç®¡ç?)),
                  body: Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Text(
                          'é”€å”®ç®¡ç†åŠŸèƒ?,
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 40),
                        SizedBox(
                          width: 200,
                          child: ElevatedButton(
                            onPressed: () => context.push(AppRoutes.saleCreate),
                            child: const Text('æ–°å»ºé”€å”®å•'),
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 200,
                          child: ElevatedButton(
                            onPressed: () =>
                                context.push(AppRoutes.saleRecords),
                            child: const Text('é”€å”®è®°å½?),
                          ),
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton(
                          onPressed: () => context.go(AppRoutes.home),
                          child: const Text('è¿”å›é¦–é¡µ'),
                        ),
                      ],
                    ),
                  ),
                ),
                routes: [
                  GoRoute(
                    path: 'records',
                    name: 'sale-records',
                    builder: (context, state) => const SalesRecordsScreen(),
                  ),
                ],
              ),
            ],
          ),
          // åº“å­˜
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: AppRoutes.inventory,
                name: 'inventory',
                builder: (context, state) => Scaffold(
                  appBar: AppBar(title: const Text('åº“å­˜ç®¡ç†')),
                  body: Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Text(
                          'åº“å­˜ç®¡ç†åŠŸèƒ½',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 40),
                        SizedBox(
                          width: 200,
                          child: ElevatedButton(
                            onPressed: () =>
                                context.go(AppRoutes.inboundCreate),
                            child: const Text('æ–°å»ºå…¥åº“å?),
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 200,
                          child: ElevatedButton(
                            onPressed: () =>
                                context.push(AppRoutes.inventoryInboundRecords),
                            child: const Text('å…¥åº“è®°å½•'),
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 200,
                          child: ElevatedButton(
                            onPressed: () => context.push('/inventory-query'),
                            child: const Text('åº“å­˜æŸ¥è¯¢'),
                          ),
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton(
                          onPressed: () => context.go(AppRoutes.home),
                          child: const Text('è¿”å›é¦–é¡µ'),
                        ),
                      ],
                    ),
                  ),
                ),
                routes: [
                  GoRoute(
                    path: 'inbound-records',
                    name: 'inventory-inbound-records',
                    builder: (context, state) => const InventoryRecordsScreen(),
                  ),
                ],
              ),
            ],
          ),
        ],
      ),

      // å…¶ä½™ï¼ˆä¸åœ¨åº•éƒ¨å¯¼èˆªä¸­çš„ï¼‰åŠŸèƒ½è·¯ç”±
      GoRoute(
        path: AppRoutes.settings,
        name: 'settings',
        builder: (context, state) => const SettingsScreen(),
        routes: [
          GoRoute(
            path: 'user-agreement',
            name: 'user-agreement',
            builder: (context, state) => const TermsOfServiceScreen(),
          ),
          GoRoute(
            path: 'privacy-policy',
            name: 'privacy-policy',
            builder: (context, state) => const PrivacyPolicyScreen(),
          ),
        ],
      ),
      GoRoute(
        path: '/product/new',
        name: 'product-new',
        builder: (context, state) {
          final barcode = state.extra is String ? state.extra as String : null;
          return ProductAddEditScreen(initialBarcode: barcode);
        },
      ),
      GoRoute(
        path: '/product/:id/edit',
        name: 'product-edit',
        builder: (context, state) {
          final productId = int.parse(state.pathParameters['id']!);
          // éœ€è¦è·å–å•†å“æ•°æ®ä»¥ä¼ é€’ç»™ç¼–è¾‘é¡µé¢
          return Consumer(
            builder: (context, ref, child) {
              final productsAsyncValue = ref.watch(allProductsProvider);
              return productsAsyncValue.when(
                data: (products) {
                  final product = products
                      .where((p) => p.id == productId)
                      .firstOrNull;
                  return ProductAddEditScreen(product: product);
                },
                loading: () => const Scaffold(
                  body: Center(child: CircularProgressIndicator()),
                ),
                error: (error, stackTrace) => Scaffold(
                  appBar: AppBar(title: const Text('é”™è¯¯')),
                  body: Center(child: Text('åŠ è½½å•†å“å¤±è´¥: $error')),
                ),
              );
            },
          );
        },
      ),
      GoRoute(
        path: AppRoutes.categories,
        name: 'categories',
        builder: (context, state) =>
            const CategorySelectionScreen(isSelectionMode: false),
        routes: [],
      ),
      GoRoute(
        path: AppRoutes.inboundCreate,
        name: 'inbound-create',
        builder: (context, state) {
          final payload = state.extra is ScannedProductPayload
              ? state.extra as ScannedProductPayload
              : null;
          return CreateInboundScreen(payload: payload);
        },
      ),
      GoRoute(
        path: AppRoutes.purchase,
        name: 'purchase',
        builder: (context, state) => Scaffold(
          appBar: AppBar(title: const Text('é‡‡è´­ç®¡ç†')),
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'é‡‡è´­ç®¡ç†åŠŸèƒ½',
                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 40),
                SizedBox(
                  width: 200,
                  child: ElevatedButton(
                    onPressed: () => context.push(AppRoutes.purchaseRecords),
                    child: const Text('é‡‡è´­è®°å½•'),
                  ),
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () => context.go(AppRoutes.home),
                  child: const Text('è¿”å›é¦–é¡µ'),
                ),
              ],
            ),
          ),
        ),
      ),
      GoRoute(
        path: AppRoutes.purchaseRecords,
        name: 'purchase-records',
        builder: (context, state) => const PurchaseRecordsScreen(),
      ),
      GoRoute(
        path: AppRoutes.databaseViewer,
        name: 'database-viewer',
        builder: (context, state) => const DatabaseViewerScreen(),
      ),
      GoRoute(
        path: AppRoutes.databaseManagement,
        name: 'database-management',
        builder: (context, state) => const DatabaseManagementScreen(),
      ),
      GoRoute(
        path: AppRoutes.customers,
        name: 'customers',
        builder: (context, state) => const CustomerSelectionScreen(),
      ),
      GoRoute(
        path: AppRoutes.saleCreate,
        name: 'sale-create',
        builder: (context, state) {
          final payload = state.extra is ScannedProductPayload
              ? state.extra as ScannedProductPayload
              : null;
          return CreateSaleScreen(payload: payload);
        },
      ),
      GoRoute(
        path: AppRoutes.inventoryQuery,
        name: 'inventory-query',
        builder: (context, state) => const InventoryQueryScreen(),
      ),
      GoRoute(
        path: AppRoutes.productRestoreDebug,
        name: 'product-restore-debug',
        builder: (context, state) => const ProductRestoreDebugPage(),
      ),
    ],
    errorBuilder: (context, state) => Scaffold(
      appBar: AppBar(title: const Text('é¡µé¢æœªæ‰¾åˆ?)),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('é”™è¯¯: ${state.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => context.go(AppRoutes.home),
              child: const Text('è¿”å›é¦–é¡µ'),
            ),
          ],
        ),
      ),
    ),
  );
});
import 'package:flutter/material.dart';
import 'package:stocko_app/core/utils/snackbar_helper.dart';
import '../widgets/universal_barcode_scanner.dart';

/// æ‰«ç æœåŠ¡ç±?
class BarcodeScannerService {
  /// å¯æ³¨å…¥çš„æ‰«æå™¨Widgetæ„å»ºå™¨ï¼ˆç”¨äºæµ‹è¯•æ›¿æ¢ï¼?
  /// ç”Ÿäº§ç¯å¢ƒé»˜è®¤æ„å»º UniversalBarcodeScanner
  static Widget Function({
    required BarcodeScannerConfig config,
    required OnBarcodeScanned onBarcodeScanned,
    Widget? loadingWidget,
    bool isLoading,
  }) scannerBuilder = ({
    required BarcodeScannerConfig config,
    required OnBarcodeScanned onBarcodeScanned,
    Widget? loadingWidget,
    bool isLoading = false,
  }) => UniversalBarcodeScanner(
        config: config,
        onBarcodeScanned: onBarcodeScanned,
        loadingWidget: loadingWidget,
        isLoading: isLoading,
      );

  /// é€šç”¨æ‰«ç æ–¹æ³•
  /// è¿”å›æ‰«æåˆ°çš„æ¡ç å­—ç¬¦ä¸²ï¼Œå¦‚æœå–æ¶ˆåˆ™è¿”å›null
  static Future<String?> scan(
    BuildContext context, {
    BarcodeScannerConfig? config,
    Widget? loadingWidget,
    bool isLoading = false,
  }) async {
    final scannerConfig = config ?? const BarcodeScannerConfig();

    return await Navigator.of(context).push<String>(
      MaterialPageRoute(
        builder: (context) => scannerBuilder(
          config: scannerConfig,
          onBarcodeScanned: (barcode) {
            Navigator.of(context).pop(barcode);
          },
          loadingWidget: loadingWidget,
          isLoading: isLoading,
        ),
      ),
    );
  }

  /// ç®€å•æ‰«ç ï¼ˆä½¿ç”¨é»˜è®¤é…ç½®ï¼?
  static Future<String?> quickScan(
    BuildContext context, {
    String? title,
  }) async {
    return await scan(
      context,
      config: BarcodeScannerConfig(title: title ?? 'æ‰«ææ¡ç '),
    );
  }

  /// äº§å“æ¡ç æ‰«æï¼ˆé’ˆå¯¹äº§å“ç®¡ç†ä¼˜åŒ–ï¼‰
  static Future<String?> scanForProduct(
    BuildContext context, {
    bool continuousMode = false,
  }) async {
    return await scan(
      context,
      config: BarcodeScannerConfig(
        title: 'æ‰«æäº§å“æ¡ç ',
        subtitle: 'å°†äº§å“æ¡ç å¯¹å‡†æ‰«ææ¡†',
        enableManualInput: true,
        enableGalleryPicker: true,
        continuousMode: continuousMode,
        continuousDelay: 1000,
      ),
    );
  }

  /// å…¥åº“æ‰«ç ï¼ˆæ”¯æŒå¼‚æ­¥å¤„ç†çŠ¶æ€ï¼‰
  static Future<T?> scanForInbound<T>(
    BuildContext context, {
    required Future<T?> Function(String barcode) onBarcodeScanned,
    Widget? loadingWidget,
  }) async {
    T? result;
    bool isLoading = false;

    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => StatefulBuilder(
          builder: (context, setState) {
            return UniversalBarcodeScanner(
              config: const BarcodeScannerConfig(
                title: 'æ‰«ç æ·»åŠ å•†å“',
                subtitle: 'å°†å•†å“æ¡ç å¯¹å‡†æ‰«ææ¡†',
                enableManualInput: true,
                enableGalleryPicker: true,
              ),
              onBarcodeScanned: (barcode) async {
                setState(() {
                  isLoading = true;
                });

                try {
                  result = await onBarcodeScanned(barcode);
                  if (context.mounted) {
                    Navigator.of(context).pop();
                  }
                } catch (e) {
                  if (context.mounted) {
                    setState(() {
                      isLoading = false;
                    });
                    showAppSnackBar(context,
                        message: 'å¤„ç†å¤±è´¥: ${e.toString()}', isError: true);
                  }
                }
              },
              loadingWidget: loadingWidget,
              isLoading: isLoading,
            );
          },
        ),
      ),
    );

    return result;
  }

  /// é‡‡è´­æ‰«ç ï¼ˆæ”¯æŒè¿ç»­æ‰«ç ï¼‰
  static Future<List<String>> scanForPurchase(
    BuildContext context, {
    bool continuousMode = false,
    int? maxScans,
  }) async {
    final scannedCodes = <String>[];

    if (!continuousMode) {
      final code = await scan(
        context,
        config: const BarcodeScannerConfig(
          title: 'æ‰«ç æ·»åŠ å•†å“',
          subtitle: 'å°†å•†å“æ¡ç å¯¹å‡†æ‰«ææ¡†',
        ),
      );
      if (code != null) {
        scannedCodes.add(code);
      }
      return scannedCodes;
    }

    // è¿ç»­æ‰«ç æ¨¡å¼çš„å®ç°ä¼šåœ¨åç»­å®Œå–?
    // è¿™é‡Œå…ˆè¿”å›å•æ¬¡æ‰«ç ç»“æ?
    final code = await scan(
      context,
      config: const BarcodeScannerConfig(
        title: 'è¿ç»­æ‰«ç æ¨¡å¼',
        subtitle: 'æ‰«æå®Œæˆåç‚¹å‡»è¿”å›æŒ‰é’®ç»“æ?,
      ),
    );
    if (code != null) {
      scannedCodes.add(code);
    }

    return scannedCodes;
  }
}
import 'package:flutter/foundation.dart';

/// å›¾ç‰‡ç¼“å­˜æ€§èƒ½ç›‘æ§
/// ç”¨äºè·Ÿè¸ªå’Œåˆ†æå›¾ç‰‡ç¼“å­˜çš„æ€§èƒ½æŒ‡æ ‡
class ImageCachePerformanceMonitor {
  static final ImageCachePerformanceMonitor _instance =
      ImageCachePerformanceMonitor._internal();
  factory ImageCachePerformanceMonitor() => _instance;
  ImageCachePerformanceMonitor._internal();

  // æ€§èƒ½ç»Ÿè®¡
  int _cacheHits = 0;
  int _cacheMisses = 0;
  int _totalRequests = 0;

  final List<Duration> _loadTimes = [];
  final Map<String, int> _imageRequests = {};

  DateTime? _sessionStartTime;

  /// åˆå§‹åŒ–ç›‘æ?
  void initialize() {
    _sessionStartTime = DateTime.now();
    _cacheHits = 0;
    _cacheMisses = 0;
    _totalRequests = 0;
    _loadTimes.clear();
    _imageRequests.clear();

    debugPrint('å›¾ç‰‡ç¼“å­˜æ€§èƒ½ç›‘æ§å·²å¯åŠ?);
  }

  /// è®°å½•ç¼“å­˜å‘½ä¸­
  void recordCacheHit(String imagePath) {
    _cacheHits++;
    _totalRequests++;
    _recordImageRequest(imagePath);

    if (kDebugMode) {
      debugPrint('ç¼“å­˜å‘½ä¸­: $imagePath');
    }
  }

  /// è®°å½•ç¼“å­˜æœªå‘½ä¸?
  void recordCacheMiss(String imagePath) {
    _cacheMisses++;
    _totalRequests++;
    _recordImageRequest(imagePath);

    if (kDebugMode) {
      debugPrint('ç¼“å­˜æœªå‘½ä¸? $imagePath');
    }
  }

  /// è®°å½•å›¾ç‰‡åŠ è½½æ—¶é—´
  void recordLoadTime(Duration duration) {
    _loadTimes.add(duration);

    if (kDebugMode) {
      debugPrint('å›¾ç‰‡åŠ è½½æ—¶é—´: ${duration.inMilliseconds}ms');
    }
  }

  /// è®°å½•å›¾ç‰‡è¯·æ±‚
  void _recordImageRequest(String imagePath) {
    final fileName = imagePath.split('/').last;
    _imageRequests[fileName] = (_imageRequests[fileName] ?? 0) + 1;
  }

  /// è·å–ç¼“å­˜å‘½ä¸­ç?
  double getCacheHitRate() {
    if (_totalRequests == 0) return 0.0;
    return _cacheHits / _totalRequests;
  }

  /// è·å–å¹³å‡åŠ è½½æ—¶é—´
  Duration getAverageLoadTime() {
    if (_loadTimes.isEmpty) return Duration.zero;

    final totalMs = _loadTimes.fold<int>(
      0,
      (sum, duration) => sum + duration.inMilliseconds,
    );
    return Duration(milliseconds: (totalMs / _loadTimes.length).round());
  }

  /// è·å–æœ€å¿«åŠ è½½æ—¶é—?
  Duration getFastestLoadTime() {
    if (_loadTimes.isEmpty) return Duration.zero;

    return _loadTimes.reduce(
      (a, b) => a.inMilliseconds < b.inMilliseconds ? a : b,
    );
  }

  /// è·å–æœ€æ…¢åŠ è½½æ—¶é—?
  Duration getSlowestLoadTime() {
    if (_loadTimes.isEmpty) return Duration.zero;

    return _loadTimes.reduce(
      (a, b) => a.inMilliseconds > b.inMilliseconds ? a : b,
    );
  }

  /// è·å–æœ€å¸¸è¯·æ±‚çš„å›¾ç‰‡
  List<MapEntry<String, int>> getMostRequestedImages({int limit = 10}) {
    final sortedEntries = _imageRequests.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));

    return sortedEntries.take(limit).toList();
  }

  /// è·å–ä¼šè¯æ—¶é•¿
  Duration getSessionDuration() {
    if (_sessionStartTime == null) return Duration.zero;
    return DateTime.now().difference(_sessionStartTime!);
  }

  /// è·å–æ€§èƒ½æŠ¥å‘Š
  Map<String, dynamic> getPerformanceReport() {
    return {
      'sessionDuration': getSessionDuration(),
      'totalRequests': _totalRequests,
      'cacheHits': _cacheHits,
      'cacheMisses': _cacheMisses,
      'hitRate': getCacheHitRate(),
      'averageLoadTime': getAverageLoadTime(),
      'fastestLoadTime': getFastestLoadTime(),
      'slowestLoadTime': getSlowestLoadTime(),
      'totalLoadTimes': _loadTimes.length,
      'mostRequestedImages': getMostRequestedImages(limit: 5),
      'sessionStartTime': _sessionStartTime,
    };
  }

  /// æ‰“å°æ€§èƒ½æŠ¥å‘Š
  void printPerformanceReport() {
    if (!kDebugMode) return;

    final report = getPerformanceReport();

    debugPrint('=== å›¾ç‰‡ç¼“å­˜æ€§èƒ½æŠ¥å‘Š ===');
    debugPrint('ä¼šè¯æ—¶é•¿: ${_formatDuration(report['sessionDuration'])}');
    debugPrint('æ€»è¯·æ±‚æ•°: ${report['totalRequests']}');
    debugPrint('ç¼“å­˜å‘½ä¸­: ${report['cacheHits']}');
    debugPrint('ç¼“å­˜æœªå‘½ä¸? ${report['cacheMisses']}');
    debugPrint('å‘½ä¸­ç? ${(report['hitRate'] * 100).toStringAsFixed(1)}%');
    debugPrint('å¹³å‡åŠ è½½æ—¶é—´: ${report['averageLoadTime'].inMilliseconds}ms');
    debugPrint('æœ€å¿«åŠ è½½æ—¶é—? ${report['fastestLoadTime'].inMilliseconds}ms');
    debugPrint('æœ€æ…¢åŠ è½½æ—¶é—? ${report['slowestLoadTime'].inMilliseconds}ms');

    final mostRequested =
        report['mostRequestedImages'] as List<MapEntry<String, int>>;
    if (mostRequested.isNotEmpty) {
      debugPrint('æœ€å¸¸è¯·æ±‚çš„å›¾ç‰‡:');
      for (final entry in mostRequested) {
        debugPrint('  ${entry.key}: ${entry.value}æ¬?);
      }
    }

    debugPrint('========================');
  }

  /// é‡ç½®ç»Ÿè®¡æ•°æ®
  void reset() {
    _cacheHits = 0;
    _cacheMisses = 0;
    _totalRequests = 0;
    _loadTimes.clear();
    _imageRequests.clear();
    _sessionStartTime = DateTime.now();

    debugPrint('æ€§èƒ½ç›‘æ§æ•°æ®å·²é‡ç½?);
  }

  /// æ ¼å¼åŒ–æŒç»­æ—¶é—?
  String _formatDuration(Duration duration) {
    final hours = duration.inHours;
    final minutes = duration.inMinutes.remainder(60);
    final seconds = duration.inSeconds.remainder(60);

    if (hours > 0) {
      return '${hours}h ${minutes}m ${seconds}s';
    } else if (minutes > 0) {
      return '${minutes}m ${seconds}s';
    } else {
      return '${seconds}s';
    }
  }

  /// è·å–æ€§èƒ½ç­‰çº§
  String getPerformanceGrade() {
    final hitRate = getCacheHitRate();
    final avgLoadTime = getAverageLoadTime().inMilliseconds;

    if (hitRate >= 0.9 && avgLoadTime <= 100) {
      return 'A+'; // ä¼˜ç§€
    } else if (hitRate >= 0.8 && avgLoadTime <= 200) {
      return 'A'; // è‰¯å¥½
    } else if (hitRate >= 0.7 && avgLoadTime <= 300) {
      return 'B'; // ä¸­ç­‰
    } else if (hitRate >= 0.6 && avgLoadTime <= 500) {
      return 'C'; // ä¸€èˆ?
    } else {
      return 'D'; // éœ€è¦ä¼˜åŒ?
    }
  }

  /// è·å–ä¼˜åŒ–å»ºè®®
  List<String> getOptimizationSuggestions() {
    final suggestions = <String>[];
    final hitRate = getCacheHitRate();
    final avgLoadTime = getAverageLoadTime().inMilliseconds;

    if (hitRate < 0.7) {
      suggestions.add('ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½ï¼Œè€ƒè™‘å¢åŠ ç¼“å­˜å¤§å°æˆ–é¢„åŠ è½½å¸¸ç”¨å›¾ç‰‡');
    }

    if (avgLoadTime > 300) {
      suggestions.add('å¹³å‡åŠ è½½æ—¶é—´è¾ƒé•¿ï¼Œè€ƒè™‘é™ä½å›¾ç‰‡è´¨é‡æˆ–ä¼˜åŒ–å‹ç¼©ç®—æ³?);
    }

    if (_totalRequests > 1000 && _loadTimes.length < _totalRequests * 0.8) {
      suggestions.add('éƒ¨åˆ†å›¾ç‰‡åŠ è½½æ—¶é—´æœªè®°å½•ï¼Œæ£€æŸ¥ç›‘æ§è¦†ç›–ç‡');
    }

    final mostRequested = getMostRequestedImages(limit: 3);
    if (mostRequested.isNotEmpty && mostRequested.first.value > 10) {
      suggestions.add('è€ƒè™‘ä¸ºé«˜é¢‘è®¿é—®å›¾ç‰?"${mostRequested.first.key}" è®¾ç½®æ›´é«˜çš„ç¼“å­˜ä¼˜å…ˆçº§');
    }

    if (suggestions.isEmpty) {
      suggestions.add('ç¼“å­˜æ€§èƒ½è‰¯å¥½ï¼Œç»§ç»­ä¿æŒå½“å‰é…ç½?);
    }

    return suggestions;
  }
}
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

/// å›¾ç‰‡ç¼“å­˜æœåŠ¡
/// æä¾›æœ¬åœ°å›¾ç‰‡ç¼“å­˜ã€å†…å­˜ç¼“å­˜å’Œå›¾ç‰‡ä¼˜åŒ–åŠŸèƒ½
class ImageCacheService {
  static final ImageCacheService _instance = ImageCacheService._internal();
  factory ImageCacheService() => _instance;
  ImageCacheService._internal();

  // å†…å­˜ç¼“å­˜
  final Map<String, ui.Image> _memoryCache = {};
  final Map<String, Uint8List> _byteCache = {};

  // ç¼“å­˜å¤§å°é™åˆ¶
  static const int maxMemoryCacheSize = 50; // æœ€å¤§å†…å­˜ç¼“å­˜å›¾ç‰‡æ•°é‡?
  static const int maxByteCacheSize = 20; // æœ€å¤§å­—èŠ‚ç¼“å­˜æ•°é‡?

  // ç¼©ç•¥å›¾ç¼“å­˜ç›®å½?
  String? _thumbnailCacheDir;

  /// åˆå§‹åŒ–ç¼“å­˜æœåŠ?
  Future<void> initialize() async {
    try {
      final Directory appDir = await getApplicationDocumentsDirectory();
      _thumbnailCacheDir = path.join(appDir.path, 'image_cache', 'thumbnails');

      // åˆ›å»ºç¼“å­˜ç›®å½•
      final Directory cacheDir = Directory(_thumbnailCacheDir!);
      if (!await cacheDir.exists()) {
        await cacheDir.create(recursive: true);
      }

      debugPrint('å›¾ç‰‡ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å®Œæˆ? $_thumbnailCacheDir');
    } catch (e) {
      debugPrint('å›¾ç‰‡ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å¤±è´? $e');
    }
  }

  /// è·å–ä¼˜åŒ–åçš„å›¾ç‰‡
  /// [imagePath] åŸå§‹å›¾ç‰‡è·¯å¾„
  /// [width] ç›®æ ‡å®½åº¦
  /// [height] ç›®æ ‡é«˜åº¦
  /// [quality] å‹ç¼©è´¨é‡ (0-100)
  Future<Uint8List?> getOptimizedImage(
    String imagePath, {
    int? width,
    int? height,
    int quality = 100,
    DateTime? fileModifiedTime,
  }) async {
    try {
      // ç”Ÿæˆç¼“å­˜é”?
      final cacheKey =
          _generateCacheKey(imagePath, width, height, quality, fileModifiedTime);

      // æ£€æŸ¥å­—èŠ‚ç¼“å­?
      if (_byteCache.containsKey(cacheKey)) {
        debugPrint('ä»å­—èŠ‚ç¼“å­˜åŠ è½½å›¾ç‰? $cacheKey');
        return _byteCache[cacheKey];
      }

      // æ£€æŸ¥ç£ç›˜ç¼“å­?
      final cachedBytes = await _getCachedThumbnail(cacheKey);
      if (cachedBytes != null) {
        debugPrint('ä»ç£ç›˜ç¼“å­˜åŠ è½½å›¾ç‰? $cacheKey');
        _addToByteCache(cacheKey, cachedBytes);
        return cachedBytes;
      }

      // ç”Ÿæˆä¼˜åŒ–åçš„å›¾ç‰‡
      final optimizedBytes = await _generateOptimizedImage(
        imagePath,
        width: width,
        height: height,
        quality: quality,
      );

      if (optimizedBytes != null) {
        // ä¿å­˜åˆ°ç¼“å­?
        await _saveThumbnailCache(cacheKey, optimizedBytes);
        _addToByteCache(cacheKey, optimizedBytes);
        debugPrint('ç”Ÿæˆå¹¶ç¼“å­˜ä¼˜åŒ–å›¾ç‰? $cacheKey');
      }

      return optimizedBytes;
    } catch (e) {
      debugPrint('è·å–ä¼˜åŒ–å›¾ç‰‡å¤±è´¥: $e');
      return null;
    }
  }

  /// è·å–å†…å­˜ä¸­çš„UIå›¾ç‰‡å¯¹è±¡
  Future<ui.Image?> getUIImage(String imagePath) async {
    try {
      // æ£€æŸ¥å†…å­˜ç¼“å­?
      if (_memoryCache.containsKey(imagePath)) {
        debugPrint('ä»å†…å­˜ç¼“å­˜åŠ è½½UIå›¾ç‰‡: $imagePath');
        return _memoryCache[imagePath];
      }

      // ä»æ–‡ä»¶åŠ è½?
      final file = File(imagePath);
      if (!await file.exists()) {
        return null;
      }

      final bytes = await file.readAsBytes();
      final codec = await ui.instantiateImageCodec(bytes);
      final frame = await codec.getNextFrame();
      final image = frame.image;

      // æ·»åŠ åˆ°å†…å­˜ç¼“å­?
      _addToMemoryCache(imagePath, image);
      debugPrint('åŠ è½½å¹¶ç¼“å­˜UIå›¾ç‰‡: $imagePath');

      return image;
    } catch (e) {
      debugPrint('è·å–UIå›¾ç‰‡å¤±è´¥: $e');
      return null;
    }
  }

  /// é¢„åŠ è½½å›¾ç‰‡åˆ°ç¼“å­˜
  Future<void> preloadImage(String imagePath) async {
    try {
      // è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼Œç¡®ä¿é¢„åŠ è½½çš„ç¼“å­˜é”®ä¸å®é™…ä½¿ç”¨æ—¶ä¸€è‡?
      DateTime? fileModifiedTime;
      try {
        final file = File(imagePath);
        if (await file.exists()) {
          final stat = await file.stat();
          fileModifiedTime = stat.modified;
          debugPrint('é¢„åŠ è½½æ—¶è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´: $fileModifiedTime');
        }
      } catch (e) {
        debugPrint('é¢„åŠ è½½æ—¶è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´å¤±è´¥: $e');
      }
      
      // é¢„åŠ è½½å¸¸ç”¨å°ºå¯¸çš„ç¼©ç•¥å›?
      await Future.wait([
        getOptimizedImage(imagePath, width: 60, height: 80, fileModifiedTime: fileModifiedTime), // åˆ—è¡¨ç¼©ç•¥å›?
        getOptimizedImage(imagePath, width: 120, height: 120, fileModifiedTime: fileModifiedTime), // å¯¹è¯æ¡†å›¾ç‰?
        getOptimizedImage(imagePath, width: 200, height: 200, fileModifiedTime: fileModifiedTime), // è¯¦æƒ…é¡µå›¾ç‰?
      ]);
      debugPrint('é¢„åŠ è½½å›¾ç‰‡å®Œæˆ? $imagePath');
    } catch (e) {
      debugPrint('é¢„åŠ è½½å›¾ç‰‡å¤±è´? $e');
    }
  }

  /// æ¸…ç†å•ä¸ªå›¾ç‰‡çš„ç¼“å­?
  Future<void> clearImageCache(String imagePath) async {
    try {
      // ä»å†…å­˜ç¼“å­˜ç§»é™?
      _memoryCache.remove(imagePath);

      // ä»å­—èŠ‚ç¼“å­˜ç§»é™¤ç›¸å…³é¡¹
      final keysToRemove = _byteCache.keys
          .where((key) => key.contains(imagePath.hashCode.toString()))
          .toList();

      for (final key in keysToRemove) {
        _byteCache.remove(key);
      }

      // ä»ç£ç›˜ç¼“å­˜ç§»é™¤ç›¸å…³æ–‡ä»?
      if (_thumbnailCacheDir != null) {
        final cacheDir = Directory(_thumbnailCacheDir!);
        if (await cacheDir.exists()) {
          final files = await cacheDir.list().toList();
          for (final file in files) {
            if (file.path.contains(imagePath.hashCode.toString())) {
              await file.delete();
            }
          }
        }
      }

      debugPrint('æ¸…ç†å›¾ç‰‡ç¼“å­˜: $imagePath');
    } catch (e) {
      debugPrint('æ¸…ç†å›¾ç‰‡ç¼“å­˜å¤±è´¥: $e');
    }
  }

  /// æ¸…ç†æ‰€æœ‰ç¼“å­?
  Future<void> clearAllCache() async {
    try {
      // æ¸…ç†å†…å­˜ç¼“å­˜
      _memoryCache.clear();
      _byteCache.clear();

      // æ¸…ç†ç£ç›˜ç¼“å­˜
      if (_thumbnailCacheDir != null) {
        final cacheDir = Directory(_thumbnailCacheDir!);
        if (await cacheDir.exists()) {
          await cacheDir.delete(recursive: true);
          await cacheDir.create(recursive: true);
        }
      }

      debugPrint('æ¸…ç†æ‰€æœ‰å›¾ç‰‡ç¼“å­?);
    } catch (e) {
      debugPrint('æ¸…ç†æ‰€æœ‰ç¼“å­˜å¤±è´? $e');
    }
  }

  /// è·å–ç¼“å­˜çŠ¶æ€ä¿¡æ?
  Map<String, dynamic> getCacheStatus() {
    return {
      'memoryCount': _memoryCache.length,
      'byteCount': _byteCache.length,
      'maxMemorySize': maxMemoryCacheSize,
      'maxByteSize': maxByteCacheSize,
      'thumbnailCacheDir': _thumbnailCacheDir,
    };
  }

  // ç§æœ‰æ–¹æ³•

  /// ç”Ÿæˆç¼“å­˜é”?
  String _generateCacheKey(
    String imagePath,
    int? width,
    int? height,
    int quality,
    DateTime? fileModifiedTime,
  ) {
    final timeStamp = fileModifiedTime?.millisecondsSinceEpoch ?? 'null';
    return '${imagePath.hashCode}_${width ?? 'null'}_${height ?? 'null'}_${quality}_$timeStamp';
  }

  /// ç”Ÿæˆä¼˜åŒ–åçš„å›¾ç‰‡
  Future<Uint8List?> _generateOptimizedImage(
    String imagePath, {
    int? width,
    int? height,
    int quality = 100,
  }) async {
    try {
      final file = File(imagePath);
      if (!await file.exists()) {
        return null;
      }

      final originalBytes = await file.readAsBytes();

      // å¦‚æœä¸éœ€è¦è°ƒæ•´å¤§å°ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ®
      if (width == null && height == null) {
        return originalBytes;
      }

      // è§£ç å›¾ç‰‡
      final codec = await ui.instantiateImageCodec(originalBytes);
      final frame = await codec.getNextFrame();
      final originalImage = frame.image;

      // è®¡ç®—ç›®æ ‡å°ºå¯¸
      final targetWidth = width ?? originalImage.width;
      final targetHeight = height ?? originalImage.height;

      // å¦‚æœå°ºå¯¸ç›¸åŒï¼Œè¿”å›åŸå§‹æ•°æ?
      if (targetWidth == originalImage.width &&
          targetHeight == originalImage.height) {
        return originalBytes;
      }

      // åˆ›å»ºç”»å¸ƒå¹¶ç»˜åˆ¶ç¼©æ”¾åçš„å›¾ç‰?
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);

      final paint = Paint()
        ..isAntiAlias = true
        ..filterQuality = FilterQuality.high;

      canvas.drawImageRect(
        originalImage,
        Rect.fromLTWH(
          0,
          0,
          originalImage.width.toDouble(),
          originalImage.height.toDouble(),
        ),
        Rect.fromLTWH(0, 0, targetWidth.toDouble(), targetHeight.toDouble()),
        paint,
      );

      final picture = recorder.endRecording();
      final resizedImage = await picture.toImage(targetWidth, targetHeight);

      // è½¬æ¢ä¸ºå­—èŠ‚æ•°æ?
      final byteData = await resizedImage.toByteData(
        format: ui.ImageByteFormat.png,
      );

      originalImage.dispose();
      resizedImage.dispose();
      picture.dispose();

      return byteData?.buffer.asUint8List();
    } catch (e) {
      debugPrint('ç”Ÿæˆä¼˜åŒ–å›¾ç‰‡å¤±è´¥: $e');
      return null;
    }
  }

  /// ä»ç£ç›˜ç¼“å­˜è·å–ç¼©ç•¥å›¾
  Future<Uint8List?> _getCachedThumbnail(String cacheKey) async {
    try {
      if (_thumbnailCacheDir == null) return null;

      final cacheFile = File(path.join(_thumbnailCacheDir!, '$cacheKey.png'));
      if (await cacheFile.exists()) {
        return await cacheFile.readAsBytes();
      }
      return null;
    } catch (e) {
      debugPrint('è¯»å–ç£ç›˜ç¼“å­˜å¤±è´¥: $e');
      return null;
    }
  }

  /// ä¿å­˜ç¼©ç•¥å›¾åˆ°ç£ç›˜ç¼“å­˜
  Future<void> _saveThumbnailCache(String cacheKey, Uint8List bytes) async {
    try {
      if (_thumbnailCacheDir == null) return;

      final cacheFile = File(path.join(_thumbnailCacheDir!, '$cacheKey.png'));
      await cacheFile.writeAsBytes(bytes);
    } catch (e) {
      debugPrint('ä¿å­˜ç£ç›˜ç¼“å­˜å¤±è´¥: $e');
    }
  }

  /// æ·»åŠ åˆ°å†…å­˜ç¼“å­?
  void _addToMemoryCache(String key, ui.Image image) {
    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œç§»é™¤æœ€æ—§çš„é¡?
    if (_memoryCache.length >= maxMemoryCacheSize) {
      final firstKey = _memoryCache.keys.first;
      _memoryCache[firstKey]?.dispose();
      _memoryCache.remove(firstKey);
    }

    _memoryCache[key] = image;
  }

  /// æ·»åŠ åˆ°å­—èŠ‚ç¼“å­?
  void _addToByteCache(String key, Uint8List bytes) {
    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œç§»é™¤æœ€æ—§çš„é¡?
    if (_byteCache.length >= maxByteCacheSize) {
      final firstKey = _byteCache.keys.first;
      _byteCache.remove(firstKey);
    }

    _byteCache[key] = bytes;
  }

  /// é‡Šæ”¾èµ„æº
  void dispose() {
    // é‡Šæ”¾å†…å­˜ä¸­çš„UIå›¾ç‰‡
    for (final image in _memoryCache.values) {
      image.dispose();
    }
    _memoryCache.clear();
    _byteCache.clear();
  }
}
import 'dart:async';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'image_cache_service.dart';

/// å›¾ç‰‡æœåŠ¡
/// æä¾›å›¾ç‰‡é€‰æ‹©ã€ä¿å­˜å’Œç®¡ç†åŠŸèƒ½
class ImageService {
  static final ImageService _instance = ImageService._internal();
  factory ImageService() => _instance;

  ImagePicker _picker;
  ImageCacheService _cacheService;

  ImageService._internal({ImagePicker? picker, ImageCacheService? cacheService})
      : _picker = picker ?? ImagePicker(),
        _cacheService = cacheService ?? ImageCacheService();

  @visibleForTesting
  factory ImageService.forTest({
    required ImagePicker picker,
    required ImageCacheService cacheService,
  }) {
    return ImageService._internal(picker: picker, cacheService: cacheService);
  }

  /// ä»ç›¸æœºæ‹ç…?
  Future<String?> pickImageFromCamera() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.camera,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 85,
      );

      if (image != null) {
        return await _saveImageToLocal(image);
      }
      return null;
    } catch (e) {
      debugPrint('ä»ç›¸æœºé€‰æ‹©å›¾ç‰‡å¤±è´¥: $e');
      rethrow;
    }
  }

  /// ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡
  Future<String?> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1080,
        maxHeight: 1080,
        imageQuality: 100,
      );

      if (image != null) {
        return await _saveImageToLocal(image);
      }
      return null;
    } catch (e) {
      debugPrint('ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡å¤±è´¥: $e');
      rethrow;
    }
  }

  /// æ˜¾ç¤ºå›¾ç‰‡é€‰æ‹©åº•éƒ¨å¯¹è¯æ¡?
  Future<String?> showImagePickerBottomSheet() async {
    // è¿™ä¸ªæ–¹æ³•éœ€è¦åœ¨è°ƒç”¨è€…ä¸­å®ç°UIé€»è¾‘
    // è¿”å›é€‰æ‹©çš„å›¾ç‰‡è·¯å¾?
    return null;
  }

  /// ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°åº”ç”¨ç›®å½?
  Future<String> _saveImageToLocal(XFile image) async {
    try {
      // è·å–åº”ç”¨æ–‡æ¡£ç›®å½•
      final Directory appDir = await getApplicationDocumentsDirectory();
      final String imagesDir = path.join(appDir.path, 'product_images');

      // åˆ›å»ºå›¾ç‰‡ç›®å½•
      final Directory imageDirectory = Directory(imagesDir);
      if (!await imageDirectory.exists()) {
        await imageDirectory.create(recursive: true);
      }

      // ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶å
      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();
      final String extension = path.extension(image.path);
      final String fileName = 'product_$timestamp$extension';
      final String localPath = path.join(imagesDir, fileName); // å¤åˆ¶æ–‡ä»¶åˆ°æœ¬åœ°ç›®å½?
      await File(image.path).copy(localPath);
      debugPrint('å›¾ç‰‡ä¿å­˜æˆåŠŸ: $localPath');

      // å¼‚æ­¥é¢„åŠ è½½åˆ°ç¼“å­˜
      _preloadImageToCache(localPath);

      return localPath;
    } catch (e) {
      debugPrint('ä¿å­˜å›¾ç‰‡å¤±è´¥: $e');
      rethrow;
    }
  }

  /// åˆ é™¤æœ¬åœ°å›¾ç‰‡æ–‡ä»¶
  Future<bool> deleteImage(String imagePath) async {
    try {
      final File imageFile = File(imagePath);
      if (await imageFile.exists()) {
        await imageFile.delete();
        debugPrint('å›¾ç‰‡åˆ é™¤æˆåŠŸ: $imagePath');
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('åˆ é™¤å›¾ç‰‡å¤±è´¥: $e');
      return false;
    }
  }

  /// æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶æ˜¯å¦å­˜åœ?
  Future<bool> imageExists(String imagePath) async {
    try {
      final File imageFile = File(imagePath);
      return await imageFile.exists();
    } catch (e) {
      return false;
    }
  }

  /// è·å–å›¾ç‰‡æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  Future<int> getImageSize(String imagePath) async {
    try {
      final File imageFile = File(imagePath);
      if (await imageFile.exists()) {
        return await imageFile.length();
      }
      return 0;
    } catch (e) {
      return 0;
    }
  }

  /// æ¸…ç†æ‰€æœ‰äº§å“å›¾ç‰‡ï¼ˆæ…ç”¨ï¼?
  Future<void> clearAllProductImages() async {
    try {
      final Directory appDir = await getApplicationDocumentsDirectory();
      final String imagesDir = path.join(appDir.path, 'product_images');
      final Directory imageDirectory = Directory(imagesDir);

      if (await imageDirectory.exists()) {
        await imageDirectory.delete(recursive: true);
        debugPrint('æ‰€æœ‰äº§å“å›¾ç‰‡å·²æ¸…ç†');
      }
    } catch (e) {
      debugPrint('æ¸…ç†å›¾ç‰‡å¤±è´¥: $e');
    }
  }

  /// é¢„åŠ è½½å›¾ç‰‡åˆ°ç¼“å­˜
  Future<void> _preloadImageToCache(String imagePath) async {
    try {
      // åœ¨åå°å¼‚æ­¥é¢„åŠ è½½å¸¸ç”¨å°ºå¯¸çš„å›¾ç‰?
      unawaited(_cacheService.preloadImage(imagePath));
    } catch (e) {
      debugPrint('é¢„åŠ è½½å›¾ç‰‡åˆ°ç¼“å­˜å¤±è´¥: $e');
    }
  }

  /// æ¸…ç†å›¾ç‰‡ç¼“å­˜
  Future<void> clearImageCache(String imagePath) async {
    try {
      await _cacheService.clearImageCache(imagePath);
    } catch (e) {
      debugPrint('æ¸…ç†å›¾ç‰‡ç¼“å­˜å¤±è´¥: $e');
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../features/product/application/provider/product_providers.dart';
import '../models/scanned_product_payload.dart';
import '../services/barcode_scanner_service.dart';
import '../utils/snackbar_helper.dart';
import '../widgets/product_info_dialog.dart';
import '../constants/app_routes.dart';

/// æ‰«ç äº§å“æœåŠ¡ï¼Œè´Ÿè´£å¤„ç†æ‰«ç ã€æŸ¥è¯¢äº§å“ã€å±•ç¤ºå¯¹è¯æ¡†ç­‰ä¸šåŠ¡é€»è¾‘
class ScanProductService {
  /// æ‰«ç å¹¶æ˜¾ç¤ºäº§å“ä¿¡æ¯å¯¹è¯æ¡†
  /// 
  /// æµç¨‹ï¼?
  /// 1. è°ƒèµ·æ‰«ç ç•Œé¢
  /// 2. æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“ä¿¡æ¯
  /// 3. å¦‚æœæ‰¾åˆ°äº§å“ï¼Œæ˜¾ç¤ºäº§å“ä¿¡æ¯å¯¹è¯æ¡†
  /// 4. å¦‚æœæœªæ‰¾åˆ°ï¼Œæç¤ºç”¨æˆ·æ˜¯å¦æ–°å¢äº§å“
  static Future<void> scanAndShowProductDialog(
    BuildContext context,
    WidgetRef ref,
  ) async {
    // 1) è°ƒèµ·æ‰«ç 
    final barcode = await BarcodeScannerService.quickScan(
      context,
      title: 'æ‰«ææ¡ç ',
    );
    if (!context.mounted || barcode == null || barcode.isEmpty) return;

    // 2) æŸ¥è¯¢è´§å“ä¸»è¦ä¿¡æ¯
    try {
      final operations = ref.read(productOperationsProvider.notifier);
      final result = await operations.getProductWithUnitByBarcode(barcode);

      if (!context.mounted) return;

      if (result == null) {
        // æœªæ‰¾åˆ°æ¡ç ï¼Œæ˜¾ç¤ºå¯¹è¯æ¡†è®©ç”¨æˆ·é€‰æ‹©
        await _handleProductNotFound(context, barcode);
        return;
      }

      // 3) æ„å»º payload å¹¶å±•ç¤ºå¤ç”¨å¯¹è¯æ¡†
      final payload = ScannedProductPayload(
        product: result.product,
        barcode: barcode,
        unitId: result.unitId,
        unitName: result.unitName,
        conversionRate: result.conversionRate,
        sellingPriceInCents: result.sellingPriceInCents,
        wholesalePriceInCents: result.wholesalePriceInCents,
        averageUnitPriceInCents: result.averageUnitPriceInCents,
      );

      await _handleProductFound(context, payload);
    } catch (e) {
      if (!context.mounted) return;
      showAppSnackBar(context, message: 'æŸ¥è¯¢è´§å“å¤±è´¥ï¼?e', isError: true);
    }
  }

  /// å¤„ç†æœªæ‰¾åˆ°äº§å“çš„æƒ…å†µ
  static Future<void> _handleProductNotFound(
    BuildContext context,
    String barcode,
  ) async {
    final shouldAddProduct = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('æœªæ‰¾åˆ°è´§å“?),
        content: Text('æœªæ‰¾åˆ°æ¡ç ?"$barcode" å¯¹åº”çš„è´§å“ï¼Œæ˜¯å¦æ–°å¢ï¼?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('å–æ¶ˆ'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('æ–°å¢è´§å“'),
          ),
        ],
      ),
    );

    if (!context.mounted) return;

    if (shouldAddProduct == true) {
      context.push(AppRoutes.productNew, extra: barcode);
    }
  }

  /// å¤„ç†æ‰¾åˆ°äº§å“çš„æƒ…å†?
  static Future<void> _handleProductFound(
    BuildContext context,
    ScannedProductPayload payload,
  ) async {
    final action = await showProductInfoDialog(context, payload: payload);
    if (!context.mounted) return;

    switch (action) {
      case ProductInfoAction.sale:
        context.push(AppRoutes.saleCreate, extra: payload);
        break;
      case ProductInfoAction.purchase:
        context.push(AppRoutes.inboundCreate, extra: payload);
        break;
      case ProductInfoAction.cancel:
      case null:
        break;
    }
  }
}
import 'package:flutter/material.dart';
import 'package:fluttertoast/fluttertoast.dart';

/// Toast æç¤ºæœåŠ¡
/// æä¾›ç»Ÿä¸€çš„æ¶ˆæ¯æç¤ºåŠŸèƒ?
class ToastService {
  /// æ˜¾ç¤ºæˆåŠŸæç¤º
  static void success(String message) {
    show(message, backgroundColor: Colors.green);
  }

  /// æ˜¾ç¤ºé”™è¯¯æç¤º
  static void error(String message) {
    show(
      message,
      length: Toast.LENGTH_LONG,
      backgroundColor: Colors.red,
    );
  }

  /// æ˜¾ç¤ºè­¦å‘Šæç¤º
  static void warning(String message) {
    show(message, backgroundColor: Colors.orange);
  }

  /// æ˜¾ç¤ºä¿¡æ¯æç¤º
  static void info(String message) {
    show(message, backgroundColor: Colors.blue);
  }

  /// é€šç”¨æç¤ºæ–¹æ³•
  static void show(
    String message, {
    Toast length = Toast.LENGTH_SHORT,
    ToastGravity gravity = ToastGravity.BOTTOM,
    Color backgroundColor = Colors.grey,
    Color textColor = Colors.white,
    double fontSize = 16.0,
  }) {
    Fluttertoast.showToast(
      msg: message,
      toastLength: length,
      gravity: gravity,
      backgroundColor: backgroundColor,
      textColor: textColor,
      fontSize: fontSize,
    );
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'user_agreement_service.dart';

final userAgreementServiceProvider = Provider<UserAgreementService>((ref) {
  return UserAgreementService();
});

final userAgreementStatusProvider = FutureProvider<bool>((ref) async {
  final service = ref.watch(userAgreementServiceProvider);
  return await service.hasAcceptedAgreement();
});
import 'package:shared_preferences/shared_preferences.dart';

class UserAgreementService {
  static const String _keyAgreementAccepted = 'user_agreement_accepted';
  static const String _keyAgreementVersion = 'user_agreement_version';
  static const String currentVersion = '1.0.0'; // åè®®ç‰ˆæœ¬å?

  /// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²åŒæ„å½“å‰ç‰ˆæœ¬çš„åè®?
  Future<bool> hasAcceptedAgreement() async {
    final prefs = await SharedPreferences.getInstance();
    final accepted = prefs.getBool(_keyAgreementAccepted) ?? false;
    final version = prefs.getString(_keyAgreementVersion) ?? '';
    
    // åªæœ‰åŒæ„è¿‡ä¸”ç‰ˆæœ¬åŒ¹é…æ‰è¿”å›true
    return accepted && version == currentVersion;
  }

  /// ä¿å­˜ç”¨æˆ·åŒæ„çŠ¶æ€?
  Future<void> acceptAgreement() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_keyAgreementAccepted, true);
    await prefs.setString(_keyAgreementVersion, currentVersion);
  }

  /// æ¸…é™¤åŒæ„çŠ¶æ€ï¼ˆç”¨äºæµ‹è¯•æˆ–é‡ç½®ï¼‰
  Future<void> clearAgreement() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_keyAgreementAccepted);
    await prefs.remove(_keyAgreementVersion);
  }
}
import 'package:flutter/material.dart';

class CustomErrorWidget extends StatelessWidget {
  final String? title;
  final String message;
  final IconData? icon;
  final VoidCallback? onRetry;
  final String? retryText;
  final VoidCallback? onSecondaryAction;
  final String? secondaryActionText;
  final bool showIcon;

  const CustomErrorWidget({
    super.key,
    this.title,
    required this.message,
    this.icon,
    this.onRetry,
    this.retryText,
    this.onSecondaryAction,
    this.secondaryActionText,
    this.showIcon = true,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (showIcon) ...[
              Icon(
                icon ?? Icons.error_outline,
                size: 64,
                color: Colors.grey[400],
              ),
              const SizedBox(height: 16),
            ],
            if (title != null) ...[
              Text(
                title!,
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: Colors.grey[700],
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
            ],
            Text(
              message,
              style: Theme.of(
                context,
              ).textTheme.bodyMedium?.copyWith(color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (onRetry != null) ...[
                  ElevatedButton.icon(
                    onPressed: onRetry,
                    icon: const Icon(Icons.refresh),
                    label: Text(retryText ?? 'é‡è¯•'),
                  ),
                  if (onSecondaryAction != null) const SizedBox(width: 12),
                ],
                if (onSecondaryAction != null)
                  OutlinedButton(
                    onPressed: onSecondaryAction,
                    child: Text(secondaryActionText ?? 'å…¶ä»–æ“ä½œ'),
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class NetworkErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  final String? customMessage;

  const NetworkErrorWidget({super.key, this.onRetry, this.customMessage});

  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: 'ç½‘ç»œè¿æ¥é”™è¯¯',
      message: customMessage ?? 'è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥å¹¶é‡è¯•',
      icon: Icons.wifi_off,
      onRetry: onRetry,
      retryText: 'é‡æ–°åŠ è½½',
    );
  }
}

class EmptyStateWidget extends StatelessWidget {
  final String? title;
  final String message;
  final IconData? icon;
  final VoidCallback? onAction;
  final String? actionText;

  const EmptyStateWidget({
    super.key,
    this.title,
    required this.message,
    this.icon,
    this.onAction,
    this.actionText,
  });

  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: title ?? 'æš‚æ— æ•°æ®',
      message: message,
      icon: icon ?? Icons.inbox_outlined,
      onRetry: onAction,
      retryText: actionText ?? 'åˆ·æ–°',
      showIcon: true,
    );
  }
}
import 'package:flutter/material.dart';

class LoadingWidget extends StatelessWidget {
  final String? message;
  final double size;
  final Color? color;
  final bool showMessage;

  const LoadingWidget({
    super.key,
    this.message,
    this.size = 40.0,
    this.color,
    this.showMessage = true,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(
            width: size,
            height: size,
            child: CircularProgressIndicator(
              color: color ?? Theme.of(context).primaryColor,
              strokeWidth: 3.0,
            ),
          ),
          if (showMessage && message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: Theme.of(
                context,
              ).textTheme.bodyMedium?.copyWith(color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}

class LoadingOverlay extends StatelessWidget {
  final Widget child;
  final bool isLoading;
  final String? loadingMessage;

  const LoadingOverlay({
    super.key,
    required this.child,
    required this.isLoading,
    this.loadingMessage,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Container(
            color: Colors.black.withOpacity(0.3),
            child: LoadingWidget(message: loadingMessage ?? 'åŠ è½½ä¸?..'),
          ),
      ],
    );
  }
}
export 'loading_widget.dart';
export 'error_widget.dart';
export '../services/toast_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class AppTheme {
  // ä¸»è‰²è°?
  static const Color primaryColor = Color(0xFF2196F3);
  static const Color secondaryColor = Color(0xFF03DAC6);
  static const Color errorColor = Color(0xFFB00020);

  // å­—ä½“
  static const String fontFamily = 'Roboto';

  // æ›´æ–°ç³»ç»ŸUIæ ·å¼ï¼ˆç”¨äºç§»é™¤åº•éƒ¨é»‘è‰²é®ç½©ï¼‰
  static void updateSystemUIOverlay(Brightness brightness) {
    SystemChrome.setSystemUIOverlayStyle(
      SystemUiOverlayStyle(
        systemNavigationBarColor: brightness == Brightness.light 
            ? Colors.white 
            : const Color(0xFF121212),
        systemNavigationBarIconBrightness: brightness == Brightness.light 
            ? Brightness.dark 
            : Brightness.light,
        systemNavigationBarDividerColor: Colors.transparent,
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: brightness == Brightness.light 
            ? Brightness.dark 
            : Brightness.light,
      ),
    );
  }

  // äº®è‰²ä¸»é¢˜
  static ThemeData lightTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.light,
    colorScheme: ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: Brightness.light,
    ),
    fontFamily: fontFamily,

    appBarTheme: const AppBarTheme(
      // backgroundColor: Color.fromARGB(255, 33, 243, 44),
      foregroundColor: Color.fromARGB(255, 33, 124, 243), // æ–‡å­—å’Œå›¾æ ‡é¢œè‰?
      elevation: 8.0,
      toolbarHeight: 37,

      titleTextStyle: TextStyle(
        color: Color.fromARGB(255, 0, 0, 0), // æ˜¾å¼è®¾ç½®é¢œè‰²
        fontSize: 19,
      ),
    ),

    // NavigationBar æ ·å¼
    navigationBarTheme: NavigationBarThemeData(
      height: 64,
      indicatorColor: primaryColor.withOpacity(0.12),
      backgroundColor: Colors.transparent,
      labelTextStyle: WidgetStatePropertyAll(
        TextStyle(fontSize: 12, color: Colors.grey.shade700),
      ),
      iconTheme: const WidgetStatePropertyAll(
        IconThemeData(size: 24),
      ),
      surfaceTintColor: Colors.transparent,
    ),

    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      isDense: true,
      filled: true,
      fillColor: Colors.grey.shade50, // æ·¡ç°è‰²èƒŒæ™?
      border: UnderlineInputBorder(
        borderSide: BorderSide(color: Colors.grey.shade300),
      ),
      enabledBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: Colors.grey.shade300),
      ),
      focusedBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: primaryColor, width: 2),
      ),
      errorBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: errorColor),
      ),
      focusedErrorBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: errorColor, width: 2),
      ),
      floatingLabelBehavior: FloatingLabelBehavior.never,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      constraints: const BoxConstraints(minHeight: 48, maxHeight: 48),
      hintStyle: TextStyle(color: Colors.grey.shade600),
      labelStyle: TextStyle(color: Colors.grey.shade700),
      helperStyle: TextStyle(color: Colors.grey.shade600, fontSize: 12),
      errorStyle: TextStyle(color: errorColor, fontSize: 12),
      suffixIconColor: Colors.grey.shade600,
    ),
  );

  // æš—è‰²ä¸»é¢˜
  static ThemeData darkTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.dark,
    colorScheme: ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: Brightness.dark,
    ),
    fontFamily: fontFamily,

    navigationBarTheme: NavigationBarThemeData(
      height: 64,
      indicatorColor: primaryColor.withOpacity(0.24),
      backgroundColor: Colors.transparent,
      labelTextStyle: WidgetStatePropertyAll(
        TextStyle(fontSize: 12, color: Colors.grey.shade300),
      ),
      iconTheme: const WidgetStatePropertyAll(
        IconThemeData(size: 24),
      ),
      surfaceTintColor: Colors.transparent,
    ),

    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      isDense: true,
      filled: true,
      fillColor: Colors.grey.shade800, // æš—è‰²ä¸»é¢˜çš„æ·¡èƒŒæ™¯
      border: UnderlineInputBorder(
        borderSide: BorderSide(color: Colors.grey.shade600),
      ),
      enabledBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: Colors.grey.shade600),
      ),
      focusedBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: primaryColor, width: 2),
      ),
      errorBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: errorColor),
      ),
      focusedErrorBorder: UnderlineInputBorder(
        borderSide: BorderSide(color: errorColor, width: 2),
      ),
      floatingLabelBehavior: FloatingLabelBehavior.never,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
      hintStyle: TextStyle(color: Colors.grey.shade400),
      labelStyle: TextStyle(color: Colors.grey.shade300),
      helperStyle: TextStyle(color: Colors.grey.shade400, fontSize: 12),
      errorStyle: TextStyle(color: errorColor, fontSize: 12),
      suffixIconColor: Colors.grey.shade400,
    ),
  );
}
import '../../../features/product/domain/model/product_unit.dart';

/// UnitProduct çš„æ‰©å±•æ–¹æ³?
extension ProductUnitExtensions on UnitProduct {
  /// åˆ¤æ–­æ˜¯å¦ä¸ºåŸºç¡€å•ä½
  bool get isBaseUnit => conversionRate == 1.0;

  /// åˆ¤æ–­æ˜¯å¦ä¸ºå¤§å•ä½ï¼ˆæ¢ç®—ç‡å¤§äº1ï¼?
  bool get isLargerUnit => conversionRate > 1.0;

  /// åˆ¤æ–­æ˜¯å¦ä¸ºå°å•ä½ï¼ˆæ¢ç®—ç‡å°äº1ï¼?
  bool get isSmallerUnit => conversionRate < 1.0;

  /// è·å–ç›¸å¯¹äºåŸºç¡€å•ä½çš„å¤§å°å…³ç³»æè¿?
  String get sizeRelativeToBase {
    if (isBaseUnit) return 'åŸºç¡€å•ä½';
    if (isLargerUnit) return 'å¤§å•ä½?;
    return 'å°å•ä½?;
  }
}

/// List<UnitProduct> çš„æ‰©å±•æ–¹æ³?
extension ProductUnitListExtensions on List<UnitProduct> {
  /// æŒ‰æ¢ç®—ç‡ä»å¤§åˆ°å°æ’åº
  List<UnitProduct> get sortedByConversionRateDesc {
    final sorted = List<UnitProduct>.from(this);
    sorted.sort((a, b) => b.conversionRate.compareTo(a.conversionRate));
    return sorted;
  }

  /// æŒ‰æ¢ç®—ç‡ä»å°åˆ°å¤§æ’åº
  List<UnitProduct> get sortedByConversionRateAsc {
    final sorted = List<UnitProduct>.from(this);
    sorted.sort((a, b) => a.conversionRate.compareTo(b.conversionRate));
    return sorted;
  }

  /// æŸ¥æ‰¾åŸºç¡€å•ä½
  UnitProduct? get baseUnit {
    try {
      return firstWhere((unit) => unit.isBaseUnit);
    } catch (e) {
      return null;
    }
  }

  /// æŸ¥æ‰¾æœ€å¤§å•ä½ï¼ˆæ¢ç®—ç‡æœ€å¤§ï¼‰
  UnitProduct? get largestUnit {
    if (isEmpty) return null;
    return reduce((a, b) => a.conversionRate > b.conversionRate ? a : b);
  }

  /// æŸ¥æ‰¾æœ€å°å•ä½ï¼ˆæ¢ç®—ç‡æœ€å°ï¼‰
  UnitProduct? get smallestUnit {
    if (isEmpty) return null;
    return reduce((a, b) => a.conversionRate < b.conversionRate ? a : b);
  }

  /// æ ¹æ®å•ä½IDæŸ¥æ‰¾ProductUnit
  UnitProduct? findByUnitId(int unitId) {
    try {
      return firstWhere((pu) => pu.unitId == unitId);
    } catch (e) {
      return null;
    }
  }

  /// éªŒè¯å•ä½é…ç½®æ˜¯å¦æœ‰æ•ˆ
  bool get isValidConfiguration {
    if (isEmpty) return false;

    // å¿…é¡»æœ‰ä¸”åªæœ‰ä¸€ä¸ªåŸºç¡€å•ä½
    final baseUnits = where((unit) => unit.isBaseUnit).toList();
    if (baseUnits.length != 1) return false;

    // æ‰€æœ‰æ¢ç®—ç‡å¿…é¡»å¤§äº0
    return every((unit) => unit.conversionRate > 0);
  }

  /// è·å–é…ç½®éªŒè¯é”™è¯¯ä¿¡æ¯
  String? get configurationError {
    if (isEmpty) return 'è‡³å°‘éœ€è¦é…ç½®ä¸€ä¸ªå•ä½?;

  // å…ˆæ ¡éªŒæ¢ç®—ç‡æœ‰æ•ˆæ€§ï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰
  final invalidRates = where((unit) => unit.conversionRate <= 0);
  if (invalidRates.isNotEmpty) return 'æ¢ç®—ç‡å¿…é¡»å¤§äº?';

  // å†æ ¡éªŒåŸºç¡€å•ä½çº¦æŸ
  final baseUnits = where((unit) => unit.isBaseUnit).toList();
  if (baseUnits.isEmpty) return 'å¿…é¡»æœ‰ä¸€ä¸ªåŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?ï¼?;
  if (baseUnits.length > 1) return 'åªèƒ½æœ‰ä¸€ä¸ªåŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?ï¼?;

    return null;
  }
}
import 'package:flutter/material.dart';

/// A helper function to show a SnackBar with a consistent style and duration.
///
/// [context]: The BuildContext from which to find the ScaffoldMessenger.
/// [message]: The text content of the SnackBar.
/// [isError]: Determines the background color of the SnackBar. Defaults to `false`.
void showAppSnackBar(
  BuildContext context, {
  required String message,
  bool isError = false,
}) {
  // Ensure the context is still valid before trying to show a SnackBar.
  if (!context.mounted) return;

  // Hide any currently displayed SnackBar to avoid queuing.
  ScaffoldMessenger.of(context).hideCurrentSnackBar();

  // Show the new SnackBar.
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      duration: const Duration(milliseconds: 500),
      backgroundColor: isError ? Colors.redAccent : Colors.green,
      behavior: SnackBarBehavior.floating,
    ),
  );
}
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:audioplayers/audioplayers.dart';

/// éŸ³æ•ˆæ’­æ”¾å·¥å…·ç±?
class SoundHelper {
  static final AudioPlayer _audioPlayer = AudioPlayer();

  /// æ’­æ”¾æ‰«ç æˆåŠŸéŸ³æ•ˆ
  static Future<void> playSuccessSound() async {
    try {
      await _audioPlayer.stop();
      await _audioPlayer.play(AssetSource('sounds/scan_success2.mp3'));
    } catch (e) {
      if (kDebugMode) {
        print('æ’­æ”¾éŸ³æ•ˆå¤±è´¥ï¼Œä½¿ç”¨ç³»ç»ŸéŸ³æ•? $e');
      }
      SystemSound.play(SystemSoundType.click);
    }
  }
}
import 'package:stocko_app/features/product/domain/model/unit.dart';
import 'package:stocko_app/features/product/domain/model/product_unit.dart';

/// å•ä½æ¢ç®—å·¥å…·ç±?
///
/// æä¾›ä»¥ä¸‹åŠŸèƒ½ï¼?
/// 1. å°†ä»»æ„å•ä½çš„æ•°é‡æ¢ç®—æˆåŸºç¡€å•ä½æ•°é‡
/// 2. å°†åŸºç¡€å•ä½çš„åº“å­˜é‡æ ¼å¼åŒ–æˆç”¨æˆ·å‹å¥½çš„å­—ç¬¦ä¸²
class UnitConverter {
  /// å°†ä»»æ„å•ä½çš„æ•°é‡æ¢ç®—æˆåŸºç¡€å•ä½æ•°é‡
  ///
  /// [quantity] è¾“å…¥çš„æ•°é‡?
  /// [unit] è¾“å…¥æ•°é‡å¯¹åº”çš„å•ä½?
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡?
  ///
  /// è¿”å›æ¢ç®—åçš„åŸºç¡€å•ä½æ•°é‡
  /// å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„å•ä½é…ç½®ï¼Œè¿”å›åŸæ•°é‡
  static int convertToBaseUnit(
    int quantity,
    Unit unit,
    List<UnitProduct> allUnits,
  ) {
    // æŸ¥æ‰¾å¯¹åº”çš„äº§å“å•ä½é…ç½?
    final unitProduct = allUnits.firstWhere(
      (pu) => pu.unitId == unit.id,
      orElse: () => throw ArgumentError('æ‰¾ä¸åˆ°å•ä½é…ç½? ${unit.name}'),
    );

    // ä½¿ç”¨æ¢ç®—ç‡è®¡ç®—åŸºç¡€å•ä½æ•°é‡
    return unitProduct.calculateBaseQuantity(quantity);
  }

  /// å°†åŸºç¡€å•ä½çš„åº“å­˜é‡æ ¼å¼åŒ–æˆç”¨æˆ·å‹å¥½çš„å­—ç¬¦ä¸²
  ///
  /// [stockInBaseUnit] åŸºç¡€å•ä½çš„åº“å­˜æ•°é‡?
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡¨ï¼Œåº”æŒ‰æ¢ç®—ç‡ä»å¤§åˆ°å°æ’åº?
  /// [unitMap] å•ä½IDåˆ°å•ä½å¯¹è±¡çš„æ˜ å°„
  ///
  /// è¿”å›æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼Œå¦?"1 ç®?5 ç“? æˆ?"15 ç“?
  static String formatStockForDisplay(
    int stockInBaseUnit,
    List<UnitProduct> allUnits,
    Map<String, Unit> unitMap,
  ) {
    if (stockInBaseUnit <= 0) {
      return '0';
    }

    // æŒ‰æ¢ç®—ç‡ä»å¤§åˆ°å°æ’åºï¼ˆç¡®ä¿ä»å¤§å•ä½å¼€å§‹è®¡ç®—ï¼‰
    final sortedUnits = List<UnitProduct>.from(allUnits)
      ..sort((a, b) => b.conversionRate.compareTo(a.conversionRate));

    final List<String> parts = [];
    int remainingStock = stockInBaseUnit;

    for (int i = 0; i < sortedUnits.length; i++) {
      final unitProduct = sortedUnits[i];
      final unit = unitMap[unitProduct.unitId];

      if (unit == null) continue;

      // è®¡ç®—å½“å‰å•ä½å¯ä»¥è¡¨ç¤ºçš„æ•°é‡?
      final unitQuantity = unitProduct.calculateUnitQuantity(remainingStock);

      // å¦‚æœæ˜¯æœ€åä¸€ä¸ªå•ä½ï¼Œç›´æ¥ä½¿ç”¨å‰©ä½™æ•°é‡
      if (i == sortedUnits.length - 1) {
        if (unitQuantity > 0) {
          parts.add('${_formatNumber(unitQuantity)} ${unit.name}');
        }
        break;
      }

      // å¯¹äºéæœ€åä¸€ä¸ªå•ä½ï¼Œå–æ•´æ•°éƒ¨åˆ?
      final wholeUnits = unitQuantity.floor();
      if (wholeUnits > 0) {
        parts.add('$wholeUnits ${unit.name}');
        // è®¡ç®—å‰©ä½™çš„åŸºç¡€å•ä½æ•°é‡
        remainingStock -= unitProduct.calculateBaseQuantity(
          wholeUnits,
        );
      }
    }

    return parts.isEmpty ? '0' : parts.join(' ');
  }

  /// è·å–æŒ‡å®šå•ä½çš„åº“å­˜æ•°é‡?
  ///
  /// [stockInBaseUnit] åŸºç¡€å•ä½çš„åº“å­˜æ•°é‡?
  /// [targetUnit] ç›®æ ‡å•ä½
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡?
  ///
  /// è¿”å›ç›®æ ‡å•ä½çš„åº“å­˜æ•°é‡?
  static int getStockInUnit(
    int stockInBaseUnit,
    Unit targetUnit,
    List<UnitProduct> allUnits,
  ) {
    final unitProduct = allUnits.firstWhere(
      (pu) => pu.unitId == targetUnit.id,
      orElse: () => throw ArgumentError('æ‰¾ä¸åˆ°å•ä½é…ç½? ${targetUnit.name}'),
    );

    return unitProduct.calculateUnitQuantity(stockInBaseUnit);
  }

  /// éªŒè¯å•ä½æ¢ç®—é…ç½®æ˜¯å¦åˆç†
  ///
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡?
  ///
  /// è¿”å›éªŒè¯ç»“æœå’Œé”™è¯¯ä¿¡æ?
  static (bool isValid, String? errorMessage) validateUnitConfiguration(
    List<UnitProduct> allUnits,
  ) {
    if (allUnits.isEmpty) {
      return (false, 'è‡³å°‘éœ€è¦é…ç½®ä¸€ä¸ªå•ä½?);
    }

    // æ£€æŸ¥æ¢ç®—ç‡æ˜¯å¦éƒ½å¤§äº?
    final invalidRates = allUnits.where((unit) => unit.conversionRate <= 0);
    if (invalidRates.isNotEmpty) {
      return (false, 'æ¢ç®—ç‡å¿…é¡»å¤§äº?');
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰åŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?çš„å•ä½ï¼‰
    final baseUnits = allUnits.where((unit) => unit.conversionRate == 1.0);
    if (baseUnits.isEmpty) {
      return (false, 'å¿…é¡»æœ‰ä¸€ä¸ªåŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?ï¼?);
    }

    if (baseUnits.length > 1) {
      return (false, 'åªèƒ½æœ‰ä¸€ä¸ªåŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?ï¼?);
    }

    return (true, null);
  }

  /// æ ¼å¼åŒ–æ•°å­—æ˜¾ç¤ºï¼ˆå»é™¤ä¸å¿…è¦çš„å°æ•°ç‚¹ï¼‰
  static String _formatNumber(int number) {
    if (number == number.truncateToDouble()) {
      return number.truncate().toString();
    } else {
      return number.toStringAsFixed(2).replaceAll(RegExp(r'\.?0+$'), '');
    }
  }

  /// æŸ¥æ‰¾åŸºç¡€å•ä½
  ///
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡?
  ///
  /// è¿”å›åŸºç¡€å•ä½ï¼Œå¦‚æœæ‰¾ä¸åˆ°æˆ–æœ‰å¤šä¸ªåŸºç¡€å•ä½åˆ™æŠ›å‡ºå¼‚å¸?
  static UnitProduct findBaseUnit(List<UnitProduct> allUnits) {
    final baseUnits = allUnits.where((unit) => unit.conversionRate == 1.0).toList();

    if (baseUnits.isEmpty) {
      throw ArgumentError('æ‰¾ä¸åˆ°åŸºç¡€å•ä½');
    }

    if (baseUnits.length > 1) {
      throw ArgumentError('åªèƒ½æœ‰ä¸€ä¸ªåŸºç¡€å•ä½');
    }

    return baseUnits.first;
  }

  /// æ¯”è¾ƒä¸¤ä¸ªå•ä½çš„å¤§å°å…³ç³?
  ///
  /// [unit1] ç¬¬ä¸€ä¸ªå•ä½?
  /// [unit2] ç¬¬äºŒä¸ªå•ä½?
  /// [allUnits] äº§å“çš„æ‰€æœ‰å•ä½é…ç½®åˆ—è¡?
  ///
  /// è¿”å›æ¯”è¾ƒç»“æœï¼?
  /// - æ­£æ•°ï¼šunit1 æ¯?unit2 å¤?
  /// - è´Ÿæ•°ï¼šunit1 æ¯?unit2 å°?
  /// - 0ï¼šunit1 å’?unit2 ç›¸ç­‰
  static int compareUnits(Unit unit1, Unit unit2, List<UnitProduct> allUnits) {
    final productUnit1 = allUnits.firstWhere(
      (pu) => pu.unitId == unit1.id,
      orElse: () => throw ArgumentError('æ‰¾ä¸åˆ°å•ä½é…ç½? ${unit1.name}'),
    );

    final productUnit2 = allUnits.firstWhere(
      (pu) => pu.unitId == unit2.id,
      orElse: () => throw ArgumentError('æ‰¾ä¸åˆ°å•ä½é…ç½? ${unit2.name}'),
    );

    return productUnit1.conversionRate.compareTo(productUnit2.conversionRate);
  }
}
export 'unit_converter.dart';
export 'product_unit_extensions.dart';
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import '../../core/services/image_cache_service.dart';
import '../../core/services/image_cache_performance_monitor.dart';

/// ç¼“å­˜å›¾ç‰‡ç»„ä»¶
/// æä¾›å›¾ç‰‡ç¼“å­˜ã€åŠ è½½ä¼˜åŒ–å’Œé”™è¯¯å¤„ç†åŠŸèƒ½
class CachedImageWidget extends StatefulWidget {
  final String imagePath;
  final double? width;
  final double? height;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? errorWidget;
  final BorderRadius? borderRadius;
  final bool enableCache;
  final int quality;
  final DateTime? fileModifiedTime;

  const CachedImageWidget({
    super.key,
    required this.imagePath,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
    this.borderRadius,
    this.enableCache = true,
    this.quality = 100,
    this.fileModifiedTime,
  });

  @override
  State<CachedImageWidget> createState() => _CachedImageWidgetState();
}

class _CachedImageWidgetState extends State<CachedImageWidget> {
  final ImageCacheService _cacheService = ImageCacheService();
  final ImageCachePerformanceMonitor _performanceMonitor =
      ImageCachePerformanceMonitor();
  Uint8List? _imageBytes;
  bool _isLoading = true;
  bool _hasError = false;

  @override
  void initState() {
    super.initState();
    _loadImage();
  }

  @override
  void didUpdateWidget(CachedImageWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    // å¦‚æœå›¾ç‰‡è·¯å¾„ã€å°ºå¯¸ã€è´¨é‡æˆ–ä¿®æ”¹æ—¶é—´å‘ç”Ÿå˜åŒ–ï¼Œé‡æ–°åŠ è½?
    if (oldWidget.imagePath != widget.imagePath ||
        oldWidget.width != widget.width ||
        oldWidget.height != widget.height ||
        oldWidget.quality != widget.quality ||
        oldWidget.fileModifiedTime != widget.fileModifiedTime) {
      _loadImage();
    }
  }

  Future<void> _loadImage() async {
    if (!mounted) return;

    setState(() {
      _isLoading = true;
      _hasError = false;
      _imageBytes = null;
    });

    final startTime = DateTime.now();

    try {
      // æ£€æŸ¥å›¾ç‰‡è·¯å¾„æ˜¯å¦ä¸ºç©ºæˆ–æ— æ•ˆ
      debugPrint('å¼€å§‹åŠ è½½å›¾ç‰? ${widget.imagePath}');
      if (widget.imagePath.isEmpty) {
        debugPrint('å›¾ç‰‡è·¯å¾„ä¸ºç©º');
        _performanceMonitor.recordCacheMiss(widget.imagePath);
        if (mounted) {
          setState(() {
            _isLoading = false;
            _hasError = true;
          });
        }
        return;
      } // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?
      final file = File(widget.imagePath);
      debugPrint('æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ? ${widget.imagePath}');

      bool fileExists = false;
      try {

        // åœ¨æµ‹è¯•ç¯å¢ƒä¸­ï¼Œå¯¹äºæ˜æ˜¾ä¸å­˜åœ¨çš„è·¯å¾„ï¼Œç›´æ¥è¿”å›false
        if (widget.imagePath.startsWith('/non/existent/')) {
          fileExists = false;
          debugPrint('éå­˜åœ¨æµ‹è¯•è·¯å¾„ï¼Œå‡å®šæ–‡ä»¶ä¸å­˜åœ? $fileExists');
        } else {
          fileExists = await file.exists();
          debugPrint('æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥å®Œæˆ? $fileExists');
        }
      } catch (e) {
        debugPrint('æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥å¼‚å¸? $e');
        fileExists = false;
      }

      debugPrint('æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥ç»“æ? $fileExists');

      if (!fileExists) {
        debugPrint('å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè®¾ç½®é”™è¯¯çŠ¶æ€? ${widget.imagePath}');
        _performanceMonitor.recordCacheMiss(widget.imagePath);
        if (mounted) {
          setState(() {
            _isLoading = false;
            _hasError = true;
          });
          debugPrint(
            'é”™è¯¯çŠ¶æ€å·²è®¾ç½®: _hasError = $_hasError, _isLoading = $_isLoading',
          );
        }
        return;
      }

      Uint8List? imageBytes;
      if (widget.enableCache) {
        // å¦‚æœæ²¡æœ‰æä¾›fileModifiedTimeï¼Œè‡ªåŠ¨è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—?
        DateTime? effectiveFileModifiedTime = widget.fileModifiedTime;
        if (effectiveFileModifiedTime == null) {
          try {
            final fileStat = await file.stat();
            effectiveFileModifiedTime = fileStat.modified;
            debugPrint('è‡ªåŠ¨è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´: $effectiveFileModifiedTime');
          } catch (e) {
            debugPrint('è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´å¤±è´¥: $e');
          }
        }
        
        // ä½¿ç”¨ç¼“å­˜æœåŠ¡è·å–ä¼˜åŒ–åçš„å›¾ç‰‡
        try {
          imageBytes = await _cacheService.getOptimizedImage(
            widget.imagePath,
            width: widget.width?.toInt(),
            height: widget.height?.toInt(),
            quality: widget.quality,
            fileModifiedTime: effectiveFileModifiedTime,
          );
        } catch (e) {
          debugPrint('å›¾ç‰‡ç¼“å­˜åŠ è½½å¤±è´¥: $e');
          imageBytes = null;
        }

        if (imageBytes != null) {
          _performanceMonitor.recordCacheHit(widget.imagePath);
        } else {
          _performanceMonitor.recordCacheMiss(widget.imagePath);
          // å¦‚æœç¼“å­˜å¤±è´¥ï¼Œç›´æ¥è¯»å–åŸå§‹æ–‡ä»?
          try {
            imageBytes = await file.readAsBytes();
          } catch (e) {
            debugPrint('è¯»å–åŸå§‹æ–‡ä»¶å¤±è´¥: $e');
            imageBytes = null;
          }
        }
      } else {
        // ç›´æ¥è¯»å–åŸå§‹æ–‡ä»¶
        try {
          imageBytes = await file.readAsBytes();
          _performanceMonitor.recordCacheMiss(widget.imagePath);
        } catch (e) {
          debugPrint('è¯»å–åŸå§‹æ–‡ä»¶å¤±è´¥: $e');
          imageBytes = null;
          _performanceMonitor.recordCacheMiss(widget.imagePath);
        }
      }

      // è®°å½•åŠ è½½æ—¶é—´
      final loadTime = DateTime.now().difference(startTime);
      _performanceMonitor.recordLoadTime(loadTime);

      if (mounted) {
        setState(() {
          _imageBytes = imageBytes;
          _isLoading = false;
          _hasError = imageBytes == null;
        });
      }
    } catch (e) {
      _performanceMonitor.recordCacheMiss(widget.imagePath);
      final loadTime = DateTime.now().difference(startTime);
      _performanceMonitor.recordLoadTime(loadTime);

      debugPrint('åŠ è½½å›¾ç‰‡å¤±è´¥: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
          _hasError = true;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    Widget child;

    if (_isLoading) {
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€?
      child = widget.placeholder ?? _buildDefaultPlaceholder();
    } else if (_hasError || _imageBytes == null) {
      // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€?
      child = widget.errorWidget ?? _buildDefaultErrorWidget();
    } else {
      // æ˜¾ç¤ºå›¾ç‰‡
      // ç¡®ä¿å°ºå¯¸ä¸ä¸ºè´Ÿæ•°
      final safeWidth = widget.width != null && widget.width! > 0
          ? widget.width
          : null;
      final safeHeight = widget.height != null && widget.height! > 0
          ? widget.height
          : null;

      child = Image.memory(
        _imageBytes!,
        width: safeWidth,
        height: safeHeight,
        fit: widget.fit,
        gaplessPlayback: true, // é¿å…å›¾ç‰‡åˆ‡æ¢æ—¶çš„é—ªçƒ
        errorBuilder: (context, error, stackTrace) {
          return widget.errorWidget ?? _buildDefaultErrorWidget();
        },
      );
    }

    // åº”ç”¨è¾¹æ¡†åœ†è§’
    if (widget.borderRadius != null) {
      child = ClipRRect(borderRadius: widget.borderRadius!, child: child);
    }

    return child;
  }

  Widget _buildDefaultPlaceholder() {
    // ç¡®ä¿å°ºå¯¸ä¸ä¸ºè´Ÿæ•°
    final safeWidth = widget.width != null && widget.width! > 0
        ? widget.width
        : null;
    final safeHeight = widget.height != null && widget.height! > 0
        ? widget.height
        : null;

    return Container(
      width: safeWidth,
      height: safeHeight,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: widget.borderRadius,
      ),
      child: Center(
        child: SizedBox(
          width: 20,
          height: 20,
          child: CircularProgressIndicator(
            strokeWidth: 2,
            color: Colors.grey.shade400,
          ),
        ),
      ),
    );
  }

  Widget _buildDefaultErrorWidget() {
    // ç¡®ä¿å°ºå¯¸ä¸ä¸ºè´Ÿæ•°
    final safeWidth = widget.width != null && widget.width! > 0
        ? widget.width
        : null;
    final safeHeight = widget.height != null && widget.height! > 0
        ? widget.height
        : null;

    return Container(
      width: safeWidth,
      height: safeHeight,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: widget.borderRadius,
      ),
      child: Icon(
        Icons.broken_image,
        size: (safeWidth != null && safeHeight != null)
            ? (safeWidth + safeHeight) / 6
            : 40,
        color: Colors.grey.shade400,
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}

/// é¢„æ„å»ºçš„ç¼“å­˜å›¾ç‰‡ç»„ä»¶å˜ä½“

/// äº§å“åˆ—è¡¨ç¼©ç•¥å›?
class ProductThumbnailImage extends StatelessWidget {
  final String imagePath;
  final VoidCallback? onTap;

  const ProductThumbnailImage({super.key, required this.imagePath, this.onTap});

  @override
  Widget build(BuildContext context) {
    // æ ¹æ®è®¾å¤‡åƒç´ å¯†åº¦è¯·æ±‚æ›´é«˜åˆ†è¾¨ç‡çš„ç¼“å­˜ï¼Œä»¥æé«˜æ¸…æ™°åº?
    final pixelRatio = MediaQuery.of(context).devicePixelRatio;

    final cacheWidth = (60 * pixelRatio).round();
    final cacheHeight = (80 * pixelRatio).round();

    return GestureDetector(
      onTap: onTap,
      child: SizedBox(
        width: 60,
        height: 80,
        child: CachedImageWidget(
          imagePath: imagePath,
          // è¯·æ±‚æ›´é«˜åˆ†è¾¨ç‡çš„ç¼“å­˜
          width: cacheWidth.toDouble(),
          height: cacheHeight.toDouble(),
          fit: BoxFit.cover,
          borderRadius: BorderRadius.circular(6),
          // åˆ†è¾¨ç‡æé«˜åï¼Œå¯é€‚å½“é™ä½è´¨é‡ä»¥å¹³è¡¡æ–‡ä»¶å¤§å°?
          quality: 100,
          placeholder: _buildPlaceholder(),
          errorWidget: _buildErrorWidget(),
        ),
      ),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      width: 60,
      height: 60,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(6),
      ),
      child: const Center(
        child: SizedBox(
          width: 16,
          height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
    );
  }

  Widget _buildErrorWidget() {
    return Container(
      width: 60,
      height: 60,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Icon(Icons.image_outlined, color: Colors.grey.shade400, size: 30),
    );
  }
}

/// äº§å“è¯¦æƒ…å›¾ç‰‡
class ProductDetailImage extends StatelessWidget {
  final String imagePath;
  final VoidCallback? onTap;

  const ProductDetailImage({super.key, required this.imagePath, this.onTap});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Hero(
        tag: 'product_detail_image_$imagePath',
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: Colors.grey.withOpacity(0.3),
                spreadRadius: 1,
                blurRadius: 5,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: CachedImageWidget(
            imagePath: imagePath,
            width: 200,
            height: 200,
            fit: BoxFit.cover,
            borderRadius: BorderRadius.circular(12),
            quality: 90, // è¯¦æƒ…å›¾ç‰‡ä½¿ç”¨è¾ƒé«˜è´¨é‡
            placeholder: _buildPlaceholder(),
            errorWidget: _buildErrorWidget(),
          ),
        ),
      ),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      width: 200,
      height: 200,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
      ),
      child: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 8),
            Text('åŠ è½½ä¸?..', style: TextStyle(color: Colors.grey)),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorWidget() {
    return Container(
      width: 200,
      height: 200,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.broken_image, size: 60, color: Colors.grey.shade400),
          const SizedBox(height: 8),
          Text(
            'å›¾ç‰‡åŠ è½½å¤±è´¥',
            style: TextStyle(color: Colors.grey.shade600, fontSize: 12),
          ),
        ],
      ),
    );
  }
}

/// äº§å“å¯¹è¯æ¡†å›¾ç‰?
class ProductDialogImage extends StatelessWidget {
  final String imagePath;

  const ProductDialogImage({super.key, required this.imagePath});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.3),
              spreadRadius: 1,
              blurRadius: 3,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: CachedImageWidget(
          imagePath: imagePath,
          width: 120,
          height: 120,
          fit: BoxFit.cover,
          borderRadius: BorderRadius.circular(8),
          quality: 80,
          placeholder: _buildPlaceholder(),
          errorWidget: _buildErrorWidget(),
        ),
      ),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      width: 120,
      height: 120,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Center(child: CircularProgressIndicator()),
    );
  }

  Widget _buildErrorWidget() {
    return Container(
      width: 120,
      height: 120,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Icon(Icons.broken_image, size: 40, color: Colors.grey.shade400),
    );
  }
}
import 'package:flutter/material.dart';

/// è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™?
/// æä¾›æ›´æ–¹ä¾¿çš„å¹´æœˆæ—¥é€‰æ‹©ä½“éªŒ
class CustomDatePicker {
  /// æ˜¾ç¤ºè‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™?
  static Future<DateTime?> show({
    required BuildContext context,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
    String title = 'é€‰æ‹©æ—¥æœŸ',
  }) {
    return showDialog<DateTime>(
      context: context,
      builder: (context) => _CustomDatePickerDialog(
        initialDate: initialDate ?? DateTime.now(),
        firstDate: firstDate ?? DateTime(2023),
        lastDate: lastDate ?? DateTime.now(),
        title: title,
      ),
    );
  }
}

class _CustomDatePickerDialog extends StatefulWidget {
  final DateTime initialDate;
  final DateTime firstDate;
  final DateTime lastDate;
  final String title;

  const _CustomDatePickerDialog({
    required this.initialDate,
    required this.firstDate,
    required this.lastDate,
    required this.title,
  });

  @override
  State<_CustomDatePickerDialog> createState() =>
      _CustomDatePickerDialogState();
}

class _CustomDatePickerDialogState extends State<_CustomDatePickerDialog> {
  late int selectedYear;
  late int selectedMonth;
  late int selectedDay;

  @override
  void initState() {
    super.initState();
    selectedYear = widget.initialDate.year;
    selectedMonth = widget.initialDate.month;
    selectedDay = widget.initialDate.day;
  }

  List<int> get availableYears {
    return List.generate(
      widget.lastDate.year - widget.firstDate.year + 1,
      (index) => widget.firstDate.year + index,
    ).reversed.toList();
  }

  List<int> get availableMonths {
    if (selectedYear == widget.firstDate.year &&
        selectedYear == widget.lastDate.year) {
      return List.generate(
        widget.lastDate.month - widget.firstDate.month + 1,
        (index) => widget.firstDate.month + index,
      );
    } else if (selectedYear == widget.firstDate.year) {
      return List.generate(
        12 - widget.firstDate.month + 1,
        (index) => widget.firstDate.month + index,
      );
    } else if (selectedYear == widget.lastDate.year) {
      return List.generate(widget.lastDate.month, (index) => index + 1);
    }
    return List.generate(12, (index) => index + 1);
  }

  List<int> get availableDays {
    final daysInMonth = DateTime(selectedYear, selectedMonth + 1, 0).day;
    final maxDay =
        selectedYear == widget.lastDate.year &&
            selectedMonth == widget.lastDate.month
        ? widget.lastDate.day
        : daysInMonth;
    final minDay =
        selectedYear == widget.firstDate.year &&
            selectedMonth == widget.firstDate.month
        ? widget.firstDate.day
        : 1;

    print(
      'Available Days - Year: $selectedYear, Month: $selectedMonth, '
      'DaysInMonth: $daysInMonth, MaxDay: $maxDay, MinDay: $minDay',
    );

    return List.generate(maxDay - minDay + 1, (index) => minDay + index);
  }

  void _updateDay() {
    final availableDays = this.availableDays;
    if (!availableDays.contains(selectedDay)) {
      selectedDay = availableDays.last;
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.title),
      content: SizedBox(
        width: 300,
        height: 250,
        child: Row(
          children: [
            // å¹´ä»½é€‰æ‹©
            Expanded(
              child: Column(
                children: [
                  const Text(
                    'å¹?,
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: ListView.builder(
                      itemCount: availableYears.length,
                      itemBuilder: (context, index) {
                        final year = availableYears[index];
                        final isSelected = year == selectedYear;
                        return Container(
                          margin: const EdgeInsets.symmetric(vertical: 2),
                          child: InkWell(
                            onTap: () {
                              setState(() {
                                selectedYear = year;
                                if (!availableMonths.contains(selectedMonth)) {
                                  selectedMonth = availableMonths.first;
                                }
                                _updateDay();
                              });
                            },
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                vertical: 8,
                                horizontal: 12,
                              ),
                              decoration: BoxDecoration(
                                color: isSelected
                                    ? Theme.of(context).primaryColor
                                    : null,
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                '$year',
                                style: TextStyle(
                                  color: isSelected ? Colors.white : null,
                                  fontWeight: isSelected
                                      ? FontWeight.bold
                                      : null,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
            // æœˆä»½é€‰æ‹©
            Expanded(
              child: Column(
                children: [
                  const Text(
                    'æœ?,
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: ListView.builder(
                      itemCount: availableMonths.length,
                      itemBuilder: (context, index) {
                        final month = availableMonths[index];
                        final isSelected = month == selectedMonth;
                        return Container(
                          margin: const EdgeInsets.symmetric(vertical: 2),
                          child: InkWell(
                            onTap: () {
                              setState(() {
                                selectedMonth = month;
                                _updateDay();
                              });
                            },
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                vertical: 8,
                                horizontal: 12,
                              ),
                              decoration: BoxDecoration(
                                color: isSelected
                                    ? Theme.of(context).primaryColor
                                    : null,
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                '$month',
                                style: TextStyle(
                                  color: isSelected ? Colors.white : null,
                                  fontWeight: isSelected
                                      ? FontWeight.bold
                                      : null,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
            // æ—¥æœŸé€‰æ‹©
            Expanded(
              child: Column(
                children: [
                  const Text(
                    'æ—?,
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: ListView.builder(
                      itemCount: availableDays.length,
                      itemBuilder: (context, index) {
                        final day = availableDays[index];
                        final isSelected = day == selectedDay;
                        return Container(
                          margin: const EdgeInsets.symmetric(vertical: 2),
                          child: InkWell(
                            onTap: () {
                              setState(() {
                                selectedDay = day;
                              });
                            },
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                vertical: 8,
                                horizontal: 12,
                              ),
                              decoration: BoxDecoration(
                                color: isSelected
                                    ? Theme.of(context).primaryColor
                                    : null,
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                '$day',
                                style: TextStyle(
                                  color: isSelected ? Colors.white : null,
                                  fontWeight: isSelected
                                      ? FontWeight.bold
                                      : null,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        TextButton(
          onPressed: () {
            final selectedDate = DateTime(
              selectedYear,
              selectedMonth,
              selectedDay,
            );
            Navigator.of(context).pop(selectedDate);
          },
          child: const Text('ç¡®å®š'),
        ),
      ],
    );
  }
}
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// å…¨å±å›¾ç‰‡æŸ¥çœ‹å™?
/// æ”¯æŒç¼©æ”¾ã€å¹³ç§»ã€æ—‹è½¬ç­‰åŠŸèƒ½
class FullScreenImageViewer extends StatefulWidget {
  final String imagePath;
  final String? heroTag;

  const FullScreenImageViewer({
    super.key,
    required this.imagePath,
    this.heroTag,
  });

  @override
  State<FullScreenImageViewer> createState() => _FullScreenImageViewerState();
}

class _FullScreenImageViewerState extends State<FullScreenImageViewer>
    with SingleTickerProviderStateMixin {
  late TransformationController _transformationController;
  late AnimationController _animationController;
  Animation<Matrix4>? _animation;

  double _currentScale = 1.0;
  static const double _minScale = 0.5;
  static const double _maxScale = 4.0;

  @override
  void initState() {
    super.initState();
    _transformationController = TransformationController();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    // ç›‘å¬ç¼©æ”¾å˜åŒ–
    _transformationController.addListener(() {
      final scale = _transformationController.value.getMaxScaleOnAxis();
      if (scale != _currentScale) {
        setState(() {
          _currentScale = scale;
        });
      }
    });
  }

  @override
  void dispose() {
    _transformationController.dispose();
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        systemOverlayStyle: SystemUiOverlayStyle.light,
        leading: IconButton(
          onPressed: () => Navigator.of(context).pop(),
          icon: Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.5),
              shape: BoxShape.circle,
            ),
            child: const Icon(Icons.close, color: Colors.white, size: 20),
          ),
        ),
        actions: [
          IconButton(
            onPressed: _resetZoom,
            icon: Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.5),
                shape: BoxShape.circle,
              ),
              child: const Icon(Icons.refresh, color: Colors.white, size: 20),
            ),
          ),
        ],
      ),
      body: Stack(
        children: [
          // ä¸»è¦çš„å›¾ç‰‡æŸ¥çœ‹åŒºåŸ?
          Center(
            child: InteractiveViewer(
              transformationController: _transformationController,
              minScale: _minScale,
              maxScale: _maxScale,
              panEnabled: true,
              scaleEnabled: true,
              onInteractionStart: (_) {
                // å¼€å§‹äº¤äº’æ—¶éšè—çŠ¶æ€æ 
                SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersive);
              },
              onInteractionEnd: (_) {
                // ç»“æŸäº¤äº’åæ˜¾ç¤ºçŠ¶æ€æ 
                Future.delayed(const Duration(seconds: 2), () {
                  if (mounted) {
                    SystemChrome.setEnabledSystemUIMode(
                      SystemUiMode.edgeToEdge,
                    );
                  }
                });
              },
              child: _buildImageContent(),
            ),
          ),

          // åº•éƒ¨æ§åˆ¶æ ?
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                  colors: [Colors.black.withOpacity(0.7), Colors.transparent],
                ),
              ),
              padding: const EdgeInsets.only(
                left: 16,
                right: 16,
                bottom: 40,
                top: 20,
              ),
              child: _buildBottomControls(),
            ),
          ),

          // ç¼©æ”¾çº§åˆ«æŒ‡ç¤ºå™?
          if (_currentScale != 1.0)
            Positioned(
              top: 100,
              right: 16,
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.7),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Text(
                  '${(_currentScale * 100).toInt()}%',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildImageContent() {
    Widget imageWidget;

    if (widget.heroTag != null) {
      imageWidget = Hero(tag: widget.heroTag!, child: _buildImage());
    } else {
      imageWidget = _buildImage();
    }

    return imageWidget;
  }

  Widget _buildImage() {
    return Image.file(
      File(widget.imagePath),
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) {
        return Container(
          width: 200,
          height: 200,
          decoration: BoxDecoration(
            color: Colors.grey.shade800,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.broken_image, size: 60, color: Colors.grey.shade600),
              const SizedBox(height: 8),
              Text(
                'å›¾ç‰‡åŠ è½½å¤±è´¥',
                style: TextStyle(color: Colors.grey.shade400, fontSize: 14),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildBottomControls() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildControlButton(
          icon: Icons.zoom_out,
          label: 'ç¼©å°',
          onPressed: _zoomOut,
        ),
        _buildControlButton(
          icon: Icons.zoom_in,
          label: 'æ”¾å¤§',
          onPressed: _zoomIn,
        ),
        _buildControlButton(
          icon: Icons.fit_screen,
          label: 'é€‚åº”å±å¹•',
          onPressed: _fitToScreen,
        ),
        _buildControlButton(
          icon: Icons.refresh,
          label: 'é‡ç½®',
          onPressed: _resetZoom,
        ),
      ],
    );
  }

  Widget _buildControlButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 48,
          height: 48,
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.2),
            shape: BoxShape.circle,
            border: Border.all(color: Colors.white.withOpacity(0.3), width: 1),
          ),
          child: IconButton(
            onPressed: onPressed,
            icon: Icon(icon, color: Colors.white, size: 20),
            padding: EdgeInsets.zero,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 10,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  void _zoomIn() {
    final double newScale = (_currentScale * 1.5).clamp(_minScale, _maxScale);
    _animateToScale(newScale);
  }

  void _zoomOut() {
    final double newScale = (_currentScale / 1.5).clamp(_minScale, _maxScale);
    _animateToScale(newScale);
  }

  void _fitToScreen() {
    _animateToScale(1.0);
  }

  void _resetZoom() {
    _animateToTransform(Matrix4.identity());
  }

  void _animateToScale(double scale) {
    final Matrix4 newMatrix = Matrix4.identity()..scale(scale);
    _animateToTransform(newMatrix);
  }

  void _animateToTransform(Matrix4 transform) {
    _animation?.removeListener(_onAnimationUpdate);
    _animationController.reset();

    _animation =
        Matrix4Tween(
          begin: _transformationController.value,
          end: transform,
        ).animate(
          CurvedAnimation(
            parent: _animationController,
            curve: Curves.easeInOut,
          ),
        );

    _animation!.addListener(_onAnimationUpdate);
    _animationController.forward();
  }

  void _onAnimationUpdate() {
    _transformationController.value = _animation!.value;
  }
}
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class PrivacyDebugHelper {
  /// æ£€æŸ¥éšç§æ”¿ç­–åŒæ„çŠ¶æ€?
  static Future<Map<String, dynamic>> checkPrivacyStatus() async {
    final prefs = await SharedPreferences.getInstance();
    
    final oldKeyAgreed = prefs.getBool('privacy_policy_agreed');
    final newKeyAgreed = prefs.getBool('isPrivacyPolicyAgreed');
    
    return {
      'oldKey': oldKeyAgreed,
      'newKey': newKeyAgreed,
      'shouldShowDialog': !(newKeyAgreed == true || oldKeyAgreed == true),
      'allKeys': prefs.getKeys().toList(),
    };
  }
  
  /// é‡ç½®éšç§æ”¿ç­–çŠ¶æ€ï¼ˆç”¨äºæµ‹è¯•ï¼?
  static Future<void> resetPrivacyStatus() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('privacy_policy_agreed');
    await prefs.remove('isPrivacyPolicyAgreed');
  }
  
  /// æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
  static void showDebugInfo(BuildContext context) async {
    final status = await checkPrivacyStatus();
    
    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('éšç§æ”¿ç­–è°ƒè¯•ä¿¡æ¯'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('æ—§KeyçŠ¶æ€? ${status['oldKey']}'),
              Text('æ–°KeyçŠ¶æ€? ${status['newKey']}'),
              Text('åº”æ˜¾ç¤ºå¼¹çª? ${status['shouldShowDialog']}'),
              const SizedBox(height: 16),
              const Text('æ‰€æœ‰å­˜å‚¨çš„Keys:'),
              ...((status['allKeys'] as List).map((key) => Text('- $key'))),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('å…³é—­'),
            ),
            TextButton(
              onPressed: () async {
                await resetPrivacyStatus();
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('éšç§æ”¿ç­–çŠ¶æ€å·²é‡ç½®')),
                );
              },
              child: const Text('é‡ç½®çŠ¶æ€?),
            ),
          ],
        ),
      );
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../features/settings/presentation/widgets/privacy_policy_dialog.dart';

class PrivacyInitializer extends ConsumerStatefulWidget {
  const PrivacyInitializer({super.key, required this.child});

  final Widget child;

  @override
  ConsumerState<PrivacyInitializer> createState() => _PrivacyInitializerState();
}

class _PrivacyInitializerState extends ConsumerState<PrivacyInitializer> {
  bool _isDialogShown = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.delayed(const Duration(milliseconds: 100), () {
        _showDialogsIfNeeded();
      });
    });
  }

  Future<void> _showDialogsIfNeeded() async {
    if (_isDialogShown || !mounted) return;

    try {
      final prefs = await SharedPreferences.getInstance();
      
      bool isPrivacyPolicyAgreed = await _handlePrivacyPolicy(prefs);

      if (!isPrivacyPolicyAgreed && mounted) {
        _isDialogShown = true;
        await _showPrivacyPolicyDialog(prefs, (context) {
          Navigator.of(context).pop();
        });
        _isDialogShown = false;
      }
    } catch (e) {
      print('â?Dialog check failed: $e');
    }
  }

  Future<bool> _handlePrivacyPolicy(SharedPreferences prefs) async {
    final oldKeyAgreed = prefs.getBool('privacy_policy_agreed') ?? false;
    final newKeyAgreed = prefs.getBool('isPrivacyPolicyAgreed') ?? false;
    bool isAgreed = newKeyAgreed || oldKeyAgreed;

    if (oldKeyAgreed && !newKeyAgreed) {
      await prefs.setBool('isPrivacyPolicyAgreed', true);
      await prefs.remove('privacy_policy_agreed');
      isAgreed = true;
    }
    return isAgreed;
  }

  Future<void> _showPrivacyPolicyDialog(SharedPreferences prefs, Function(BuildContext) onAgreed) async {
    final result = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return PrivacyPolicyDialog(
          onAgreed: () async {
            await prefs.setBool('isPrivacyPolicyAgreed', true);
            if (mounted) onAgreed(context);
          },
        );
      },
    );
    
    // å¦‚æœç”¨æˆ·ç‚¹å‡»"ä¸åŒæ„?ï¼Œé€€å‡ºåº”ç”?
    if (result == false) {
      SystemNavigator.pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../features/settings/presentation/widgets/privacy_policy_dialog.dart';

/// éšç§æ”¿ç­–æ£€æŸ¥å™¨
/// åœ?MaterialApp å†…éƒ¨ä½¿ç”¨ï¼Œç¡®ä¿æœ‰ Navigator å¯ç”¨
class PrivacyPolicyChecker extends StatefulWidget {
  final Widget child;

  const PrivacyPolicyChecker({super.key, required this.child});

  @override
  State<PrivacyPolicyChecker> createState() => _PrivacyPolicyCheckerState();
}

class _PrivacyPolicyCheckerState extends State<PrivacyPolicyChecker> {
  bool _isChecking = true;
  bool _needsAgreement = false;

  @override
  void initState() {
    super.initState();
    _checkPrivacyPolicy();
  }

  Future<void> _checkPrivacyPolicy() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final isAgreed = prefs.getBool('isPrivacyPolicyAgreed') ?? false;

      debugPrint('ğŸ” éšç§æ”¿ç­–çŠ¶æ€? isAgreed=$isAgreed');

      if (mounted) {
        setState(() {
          _needsAgreement = !isAgreed;
          _isChecking = false;
        });
      }
    } catch (e) {
      debugPrint('â?éšç§æ”¿ç­–æ£€æŸ¥å¤±è´? $e');
      if (mounted) {
        setState(() {
          _isChecking = false;
        });
      }
    }
  }

  Future<void> _onAgreed() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('isPrivacyPolicyAgreed', true);
    if (mounted) {
      setState(() {
        _needsAgreement = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isChecking) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    if (_needsAgreement) {
      return _PrivacyPolicyScreen(onAgreed: _onAgreed);
    }

    return widget.child;
  }
}

/// éšç§æ”¿ç­–å…¨å±é¡µé¢
class _PrivacyPolicyScreen extends StatelessWidget {
  final Future<void> Function() onAgreed;

  const _PrivacyPolicyScreen({required this.onAgreed});

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false, // ç¦æ­¢è¿”å›
      child: Scaffold(
        body: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: PrivacyPolicyDialog(
                onAgreed: onAgreed,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/core/models/scanned_product_payload.dart';
import 'package:stocko_app/features/inventory/application/inventory_service.dart';

enum ProductInfoAction { sale, purchase, cancel }

Future<ProductInfoAction?> showProductInfoDialog(
  BuildContext context, {
  required ScannedProductPayload payload,
}) async {
  return showDialog<ProductInfoAction>(
    context: context,
    builder: (context) {
      return _ProductInfoDialog(payload: payload);
    },
  );
}

class _ProductInfoDialog extends ConsumerWidget {
  final ScannedProductPayload payload;

  const _ProductInfoDialog({required this.payload});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final inventoryService = ref.watch(inventoryServiceProvider);
    final product = payload.product;

    return AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      title: const Text('è´§å“ä¿¡æ¯'),
      content: product.id == null
          ? _buildContent(null)
          : FutureBuilder<List<dynamic>>(
              future: inventoryService.getProductInventory(product.id!),
              builder: (context, snapshot) {
                if (!snapshot.hasData) {
                  return _buildContent(null);
                }
                // è®¡ç®—æ‰€æœ‰åº—é“ºçš„æ€»åº“å­?
                final totalQuantity = snapshot.data!.fold<int>(
                  0,
                  (sum, inventory) => sum + (inventory.quantity as int),
                );
                return _buildContent(totalQuantity);
              },
            ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(ProductInfoAction.cancel),
          child: const Text('å–æ¶ˆ'),
        ),
        TextButton(
          onPressed: () =>
              Navigator.of(context).pop(ProductInfoAction.purchase),
          child: const Text('é‡‡è´­'),
        ),
        ElevatedButton(
          onPressed: () => Navigator.of(context).pop(ProductInfoAction.sale),
          child: const Text('é”€å”?),
        ),
      ],
    );
  }

  Widget _buildContent(int? stockQuantity) {
    final product = payload.product;

    // åˆ¤æ–­æ˜¯å¦ä¸ºåŸºæœ¬å•ä½ï¼ˆconversionRate == 1ï¼?
    final isBaseUnit = payload.conversionRate == 1;

    // å”®ä»·é€»è¾‘ï¼?
    // - åŸºæœ¬å•ä½ï¼šä½¿ç”?Product è¡¨çš„ effectivePrice
    // - è¾…åŠ©å•ä½ï¼šä½¿ç”?UnitProduct è¡¨çš„ sellingPriceInCents
    int? sellingPriceInCents;
    if (isBaseUnit) {
      sellingPriceInCents = product.effectivePrice?.cents;
    } else {
      sellingPriceInCents = payload.sellingPriceInCents;
    }

    // è®¡ç®—é‡‡è´­ä»·ï¼šä¼˜å…ˆä½¿ç”¨ averageUnitPriceInCents * conversionRateï¼Œå¦åˆ™ä½¿ç”?wholesalePriceInCents
    int? purchasePriceInCents;
    String priceSource = '';
    if (payload.averageUnitPriceInCents != null) {
      purchasePriceInCents =
          payload.averageUnitPriceInCents! * payload.conversionRate;
      priceSource = '(åº“å­˜å‡ä»·)';
    } else if (payload.wholesalePriceInCents != null) {
      purchasePriceInCents = payload.wholesalePriceInCents;
      priceSource = '(æ‰¹å‘ä»?';
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('åç§°ï¼?{product.name}'),
        const SizedBox(height: 8),
        Text('æ¡ç ï¼?{payload.barcode}'),
        const SizedBox(height: 8),
        Text('å•ä½ï¼?{payload.unitName}'),
        const SizedBox(height: 8),
        Text(
          'å”®ä»·ï¼?{sellingPriceInCents != null ? 'Â¥${(sellingPriceInCents / 100).toStringAsFixed(2)}' : '-'}',
        ),
        const SizedBox(height: 8),
        Text(
          'é‡‡è´­ä»·ï¼š${purchasePriceInCents != null ? 'Â¥${(purchasePriceInCents / 100).toStringAsFixed(2)}$priceSource' : '-'}',
        ),
        const SizedBox(height: 8),
        Text('åº“å­˜ï¼?{stockQuantity != null ? '$stockQuantity' : '-'}'),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/scan_product_service.dart';

/// ä¸€ä¸ªå¸¦åº•éƒ¨å¯¼èˆªæ çš„é€šç”¨ Scaffoldï¼Œç”¨äºé…å?GoRouter çš?StatefulShellRoute ä½¿ç”¨ã€?
class ScaffoldWithNavBar extends ConsumerWidget {
  const ScaffoldWithNavBar({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  void _onDestinationSelected(BuildContext context, int index) {
    // è·³è¿‡ä¸­é—´çš„å ä½ç¬¦ï¼ˆindex 2ï¼?
    if (index == 2) return;

    // è°ƒæ•´ç´¢å¼•ï¼šindex 3, 4 å¯¹åº”å®é™…çš„åˆ†æ”?2, 3
    final branchIndex = index > 2 ? index - 1 : index;

    // åˆ‡æ¢åˆ†æ”¯ï¼›å¦‚æœç‚¹å‡»å½“å‰åˆ†æ”¯ï¼Œåˆ™è¿”å›è¯¥åˆ†æ”¯çš„åˆå§‹è·¯ç”?
    navigationShell.goBranch(
      branchIndex,
      initialLocation: branchIndex == navigationShell.currentIndex,
    );
  }

  // æ¸å˜æ–¹æ¡ˆï¼ˆæ¯ä¸?Tab ä¸€å¥—ï¼‰
  static const _homeGradient = LinearGradient(
    colors: [Color(0xFFFF9966), Color(0xFFFF5E62)],
  );
  static const _productsGradient = LinearGradient(
    colors: [Color(0xFF36D1DC), Color(0xFF5B86E5)],
  );
  static const _salesGradient = LinearGradient(
    colors: [Color(0xFFF7971E), Color(0xFFFFD200)],
  );
  static const _inventoryGradient = LinearGradient(
    colors: [Color(0xFF8E2DE2), Color(0xFF4A00E0)],
  );
  static const _fabGradient = LinearGradient(
    colors: [Color(0xFF667EEA), Color(0xFF764BA2)],
  );

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: navigationShell,

      bottomNavigationBar: Stack(
        clipBehavior: Clip.none,
        children: [
          NavigationBarTheme(
            data: const NavigationBarThemeData(
              indicatorColor: Colors.transparent,
              height: 64,
            ),
            child: NavigationBar(
              // è°ƒæ•´é€‰ä¸­ç´¢å¼•ï¼šåˆ†æ”?2, 3 å¯¹åº”æ˜¾ç¤ºç´¢å¼• 3, 4
              selectedIndex: navigationShell.currentIndex >= 2
                  ? navigationShell.currentIndex + 1
                  : navigationShell.currentIndex,
              onDestinationSelected: (index) =>
                  _onDestinationSelected(context, index),
              labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
              destinations: const [
                NavigationDestination(
                  icon: _GradientIcon(
                    icon: Icons.dashboard_outlined,
                    gradient: _homeGradient,
                  ),
                  selectedIcon: _GradientPillIcon(
                    icon: Icons.dashboard_rounded,
                    gradient: _homeGradient,
                  ),
                  label: 'é¦–é¡µ',
                ),
                NavigationDestination(
                  icon: _GradientIcon(
                    icon: Icons.inventory_2_outlined,
                    gradient: _productsGradient,
                  ),
                  selectedIcon: _GradientPillIcon(
                    icon: Icons.inventory_2_rounded,
                    gradient: _productsGradient,
                  ),
                  label: 'è´§å“',
                ),
                // å ä½ç¬¦ï¼Œä¸?FAB ç•™å‡ºç©ºé—´
                NavigationDestination(icon: SizedBox(width: 64), label: ''),
                NavigationDestination(
                  icon: _GradientIcon(
                    icon: Icons.shopping_bag_outlined,
                    gradient: _salesGradient,
                  ),
                  selectedIcon: _GradientPillIcon(
                    icon: Icons.shopping_bag_rounded,
                    gradient: _salesGradient,
                  ),
                  label: 'é”€å”?,
                ),
                NavigationDestination(
                  icon: _GradientIcon(
                    icon: Icons.warehouse_outlined,
                    gradient: _inventoryGradient,
                  ),
                  selectedIcon: _GradientPillIcon(
                    icon: Icons.warehouse_rounded,
                    gradient: _inventoryGradient,
                  ),
                  label: 'åº“å­˜',
                ),
              ],
            ),
          ),
          // å°?FAB ç²¾ç¡®å®šä½åˆ°å¯¼èˆªæ ï¼Œåº•éƒ¨å¯¹é½?
          Positioned(
            left: 0,
            right: 0,
            bottom: 16, // åº•éƒ¨å¯¹é½ï¼Œä¸å¯¼èˆªå›¾æ ‡åº•éƒ¨åœ¨åŒä¸€æ°´å¹³çº?
            child: Center(
              child: Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  gradient: _fabGradient,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.2),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                child: Material(
                  color: Colors.transparent,
                  child: InkWell(
                    borderRadius: BorderRadius.circular(28),
                    onTap: () => ScanProductService.scanAndShowProductDialog(
                      context,
                      ref,
                    ),
                    child: const Icon(
                      Icons.qr_code_scanner_rounded,
                      color: Colors.white,
                      size: 28,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// æœªé€‰ä¸­æ€ï¼šæ¸å˜ç€è‰²å›¾æ ?
class _GradientIcon extends StatelessWidget {
  const _GradientIcon({required this.icon, required this.gradient});
  final IconData icon;
  final Gradient gradient;

  @override
  Widget build(BuildContext context) {
    return ShaderMask(
      shaderCallback: (rect) => gradient.createShader(rect),
      blendMode: BlendMode.srcIn,
      child: Icon(icon, size: 26, color: Colors.white),
    );
  }
}

// é€‰ä¸­æ€ï¼šæ¸å˜èƒ¶å›ŠèƒŒæ™¯ + çº¯ç™½å›¾æ ‡
class _GradientPillIcon extends StatelessWidget {
  const _GradientPillIcon({required this.icon, required this.gradient});
  final IconData icon;
  final Gradient gradient;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        gradient: gradient,
        borderRadius: BorderRadius.circular(14),
      ),
      child: Icon(icon, size: 24, color: Colors.white),
    );
  }
}
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:stocko_app/core/utils/snackbar_helper.dart';

/// æ‰«ç ç»“æœå›è°ƒç±»å‹å®šä¹‰
typedef OnBarcodeScanned = void Function(String barcode);
typedef OnScanError = void Function(String error);

/// æ‰«ç é…ç½®ç±?
class BarcodeScannerConfig {
  final String title;
  final String subtitle;
  final bool enableManualInput;
  final bool enableGalleryPicker;
  final bool enableFlashlight;
  final bool enableCameraSwitch;
  final bool enableScanSound;
  final bool continuousMode; // è¿ç»­æ‰«ç æ¨¡å¼
  final int? continuousDelay; // è¿ç»­æ‰«ç å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
  final List<Widget>? additionalActions;
  final Color? backgroundColor;
  final Color? foregroundColor;

  const BarcodeScannerConfig({
    this.title = 'æ‰«ææ¡ç ',
    this.subtitle = 'å°†æ¡ç å¯¹å‡†æ‰«ææ¡†',
    this.enableManualInput = true,
    this.enableGalleryPicker = true,
    this.enableFlashlight = true,
    this.enableCameraSwitch = true,
    this.enableScanSound = true,
    this.continuousMode = false,
    this.continuousDelay = 1000, // é»˜è®¤1ç§’å»¶è¿?
    this.additionalActions,
    this.backgroundColor = Colors.black,
    this.foregroundColor = Colors.white,
  });
}

/// é€šç”¨æ¡ç æ‰«æå™¨ç»„ä»?
class UniversalBarcodeScanner extends StatefulWidget {
  final BarcodeScannerConfig config;
  final OnBarcodeScanned onBarcodeScanned;
  final OnScanError? onScanError;
  final Widget? loadingWidget;
  final bool isLoading;

  const UniversalBarcodeScanner({
    super.key,
    required this.config,
    required this.onBarcodeScanned,
    this.onScanError,
    this.loadingWidget,
    this.isLoading = false,
  });

  @override
  State<UniversalBarcodeScanner> createState() =>
      _UniversalBarcodeScannerState();
}

class _UniversalBarcodeScannerState extends State<UniversalBarcodeScanner> {
  late MobileScannerController _cameraController;
  late AudioPlayer _audioPlayer;
  bool _isScanning = true;
  @override
  void initState() {
    super.initState();
    _cameraController = MobileScannerController();
    _audioPlayer = AudioPlayer();
    _initializeAudioPlayer();
  }

  /// åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
  void _initializeAudioPlayer() {
    try {
      // è®¾ç½®éŸ³é¢‘æ’­æ”¾å™¨çš„æ¨¡å¼ï¼Œå…è®¸ä¸å…¶ä»–éŸ³é¢‘æ··åˆ
      _audioPlayer.setPlayerMode(PlayerMode.lowLatency);
      if (kDebugMode) {
        print('AudioPlayer åˆå§‹åŒ–å®Œæˆ?);
      }
    } catch (e) {
      if (kDebugMode) {
        print('AudioPlayer åˆå§‹åŒ–å¤±è´? $e');
      }
    }
  }

  @override
  void dispose() {
    _cameraController.dispose();
    _audioPlayer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.config.title),
        backgroundColor: widget.config.backgroundColor,
        foregroundColor: widget.config.foregroundColor,
        elevation: 0,
        actions: _buildAppBarActions(),
      ),
      backgroundColor: widget.config.backgroundColor,
      body: Column(
        children: [
          // æ‰«æå™¨åŒºåŸ?
          Expanded(
            flex: 4,
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16.0),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(16.0),
                child: _buildScannerView(),
              ),
            ),
          ),
          // åº•éƒ¨æ“ä½œåŒºåŸŸ
          Expanded(
            flex: 1,
            child: SingleChildScrollView(
              child: Container(
                width: double.infinity,
                padding: const EdgeInsets.symmetric(
                  horizontal: 24.0,
                  vertical: 12.0,
                ),
                child: _buildBottomContent(),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// æ„å»ºAppBaræ“ä½œæŒ‰é’®
  List<Widget> _buildAppBarActions() {
    final actions = <Widget>[];

    if (widget.config.enableFlashlight) {
      actions.add(
        IconButton(
          color: widget.config.foregroundColor,
          icon: const Icon(Icons.flash_on),
          iconSize: 32.0,
          onPressed: () => _cameraController.toggleTorch(),
        ),
      );
    }

    if (widget.config.enableCameraSwitch) {
      actions.add(
        IconButton(
          color: widget.config.foregroundColor,
          icon: const Icon(Icons.flip_camera_ios),
          iconSize: 32.0,
          onPressed: () => _cameraController.switchCamera(),
        ),
      );
    }

    if (widget.config.additionalActions != null) {
      actions.addAll(widget.config.additionalActions!);
    }

    return actions;
  }

  /// æ„å»ºæ‰«æå™¨è§†å›?
  Widget _buildScannerView() {
    if (kIsWeb || const bool.fromEnvironment('flutter.test')) {
      return Container(
        color: Colors.grey.shade800,
        child: const Center(
          child: Text(
            'ç›¸æœºé¢„è§ˆ\n(æµ‹è¯•æ¨¡å¼)',
            style: TextStyle(color: Colors.white),
            textAlign: TextAlign.center,
          ),
        ),
      );
    }
    return MobileScanner(
      controller: _cameraController,
      onDetect: (capture) {
        if (!_isScanning) return;
        final List<Barcode> barcodes = capture.barcodes;
        if (barcodes.isNotEmpty) {
          final String? code = barcodes.first.rawValue;
          if (code != null && code.isNotEmpty) {
            setState(() {
              _isScanning = false;
            });
            widget.onBarcodeScanned(code);

            // è¿ç»­æ‰«ç æ¨¡å¼ä¸‹ï¼Œå»¶è¿Ÿåé‡æ–°å¯ç”¨æ‰«ç ?
            if (widget.config.continuousMode) {
              Future.delayed(
                Duration(milliseconds: widget.config.continuousDelay ?? 1000),
                () {
                  if (mounted) {
                    setState(() {
                      _isScanning = true;
                    });
                  }
                },
              );
            }
          }
        }
      },
    );
  }

  /// æ„å»ºåº•éƒ¨å†…å®¹
  Widget _buildBottomContent() {
    if (widget.isLoading) {
      return widget.loadingWidget ?? _buildDefaultLoadingWidget();
    }

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          widget.config.subtitle,
          style: TextStyle(
            color: widget.config.foregroundColor,
            fontSize: 18,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 16),
        _buildActionButtons(),
      ],
    );
  }

  /// æ„å»ºé»˜è®¤åŠ è½½Widget
  Widget _buildDefaultLoadingWidget() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        CircularProgressIndicator(color: widget.config.foregroundColor),
        const SizedBox(height: 16),
        Text(
          'æ­£åœ¨å¤„ç†ä¸?..',
          style: TextStyle(color: widget.config.foregroundColor, fontSize: 16),
        ),
      ],
    );
  }

  /// æ„å»ºæ“ä½œæŒ‰é’®
  Widget _buildActionButtons() {
    final buttons = <Widget>[];

    if (widget.config.enableManualInput) {
      buttons.add(
        _buildActionButton(
          icon: Icons.keyboard,
          label: 'æ‰‹åŠ¨è¾“å…¥',
          onPressed: _showManualInputDialog,
        ),
      );
    }

    if (widget.config.enableGalleryPicker) {
      buttons.add(
        _buildActionButton(
          icon: Icons.photo_library,
          label: 'ä»ç›¸å†Œé€‰æ‹©',
          onPressed: _pickFromGallery,
        ),
      );
    }

    if (buttons.isEmpty) {
      return const SizedBox.shrink();
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: buttons,
    );
  }

  /// æ„å»ºå•ä¸ªæ“ä½œæŒ‰é’®
  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return Flexible(
      child: GestureDetector(
        onTap: onPressed,
        child: Container(
          constraints: const BoxConstraints(maxWidth: 80),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  color: widget.config.foregroundColor?.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  icon,
                  color: widget.config.foregroundColor,
                  size: 20,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                label,
                style: TextStyle(
                  color: widget.config.foregroundColor,
                  fontSize: 10,
                ),
                textAlign: TextAlign.center,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// æ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥å¯¹è¯æ¡?
  void _showManualInputDialog() {
    final TextEditingController controller = TextEditingController();

    // å®šä¹‰ç¡®å®šæŒ‰é’®çš„ç‚¹å‡»é€»è¾‘ï¼Œæ–¹ä¾¿å¤ç”?
    void onConfirm() {
      final code = controller.text.trim();
      if (code.isNotEmpty) {
        Navigator.of(context).pop();
        widget.onBarcodeScanned(code);

        // è¿ç»­æ‰«ç æ¨¡å¼ä¸‹ï¼Œå»¶è¿Ÿåé‡æ–°å¯ç”¨æ‰«ç ?
        if (widget.config.continuousMode) {
          Future.delayed(
            Duration(milliseconds: widget.config.continuousDelay ?? 1000),
            () {
              if (mounted) {
                setState(() {
                  _isScanning = true;
                });
              }
            },
          );
        }
      }
    }

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          title: const Text('æ‰‹åŠ¨è¾“å…¥æ¡ç '),
          content: TextField(
            controller: controller,
            autofocus: true,
            keyboardType: TextInputType.text,
            decoration: const InputDecoration(
              labelText: 'æ¡ç ',
              hintText: 'è¯·è¾“å…¥æ¡ç ?,
              border: OutlineInputBorder(),
            ),
            // æ·»åŠ å›è½¦é”®ç›‘å?
            onSubmitted: (value) => onConfirm(),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å–æ¶ˆ'),
            ),
            ElevatedButton(
              onPressed: onConfirm,
              style: ElevatedButton.styleFrom(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              child: const Text('ç¡®å®š'),
            ),
          ],
        );
      },
    );
  }

  /// ä»ç›¸å†Œé€‰æ‹©ï¼ˆå ä½ç¬¦åŠŸèƒ½ï¼?
  void _pickFromGallery() {
    final error = 'è¯¥åŠŸèƒ½æš‚ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨ç›¸æœºæ‰«æ?;
    if (widget.onScanError != null) {
      widget.onScanError!(error);
    } else {
      showAppSnackBar(context, message: 'è¯¥åŠŸèƒ½æš‚ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨ç›¸æœºæ‰«æ?, isError: true);
    }
  }

  /// é‡ç½®æ‰«æçŠ¶æ€?
  void resetScanningState() {
    if (mounted) {
      setState(() {
        _isScanning = true;
      });
    }
  }

  /// æ‰‹åŠ¨å¯ç”¨/ç¦ç”¨æ‰«ç 
  void setScanningEnabled(bool enabled) {
    if (mounted) {
      setState(() {
        _isScanning = enabled;
      });
    }
  }
}
export 'product_item.dart';
export 'product_list.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/features/inventory/presentation/widgets/adjust_inventory_dialog.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';
import 'package:stocko_app/features/product/application/provider/unit_providers.dart';
import 'package:stocko_app/core/widgets/cached_image_widget.dart';
import 'package:flutter/services.dart';

class ProductItem extends ConsumerStatefulWidget {
  final ProductModel item;
  final String mode;
  final bool isSelected;
  final Function(dynamic)? onToggleSelect;
  final Function(ProductModel)? onEdit;
  final Function(ProductModel)? onDelete;
  final Function(ProductModel)? onAdjustInventory;
  final VoidCallback? onHideActions;

  const ProductItem({
    super.key,
    required this.item,
    required this.mode,
    required this.isSelected,
    this.onToggleSelect,
    this.onEdit,
    this.onDelete,
    this.onAdjustInventory,
    this.onHideActions,
  });

  @override
  ConsumerState<ProductItem> createState() => _ProductItemState();
}

class _ProductItemState extends ConsumerState<ProductItem> {
  String? _unitName;
  bool _unitLoaded = false;
  int? _lastBaseUnitId;

  @override
  void initState() {
    super.initState();
    _lastBaseUnitId = widget.item.baseUnitId;
  }

  @override
  void didUpdateWidget(covariant ProductItem oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.item.baseUnitId != oldWidget.item.baseUnitId) {
      _lastBaseUnitId = widget.item.baseUnitId;
      _unitLoaded = false;
    }
  }

  Future<void> _loadUnitName(WidgetRef ref) async {
    if (!_unitLoaded && _lastBaseUnitId != null) {
      try {
        final unit = await ref
            .read(unitControllerProvider.notifier)
            .getUnitById(_lastBaseUnitId!);
        if (mounted) {
          setState(() {
            _unitName = unit?.name;
            _unitLoaded = true;
          });
        }
      } catch (e) {
        print('â?è·å–å•ä½ä¿¡æ¯å¤±è´¥: $e');
        if (mounted) {
          setState(() {
            _unitLoaded = true;
          });
        }
      }
    }
  }

  void _showMenu(BuildContext context, LongPressStartDetails details) {
    final RenderBox overlay =
        Overlay.of(context).context.findRenderObject() as RenderBox;
    showMenu<String>(
      context: context,
      position: RelativeRect.fromLTRB(
        details.globalPosition.dx,
        details.globalPosition.dy,
        overlay.size.width - details.globalPosition.dx,
        overlay.size.height - details.globalPosition.dy,
      ),
      items: [
        const PopupMenuItem<String>(
          value: 'edit',
          child: Text('ç¼–è¾‘'),
        ),
        const PopupMenuItem<String>(
          value: 'delete',
          child: Text('åˆ é™¤', style: TextStyle(color: Colors.red)),
        ),
        const PopupMenuItem<String>(
          value: 'adjust_inventory',
          child: Text('è°ƒæ•´åº“å­˜'),
        ),
      ],
    ).then((value) {
      if (value == 'edit') {
        widget.onEdit?.call(widget.item);
      } else if (value == 'delete') {
        widget.onDelete?.call(widget.item);
      } else if (value == 'adjust_inventory') {
        showDialog(
          context: context,
          builder: (context) => AdjustInventoryDialog(product: widget.item),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    // åœ¨buildæ–¹æ³•ä¸­åŠ è½½å•ä½åç§°ï¼Œç¡®ä¿ref.read()åœ¨æ­£ç¡®çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨
    if (!_unitLoaded) {
      _loadUnitName(ref);
    }
    
    return GestureDetector(
      onTap: () {
        if (widget.mode == 'select') {
          widget.onToggleSelect?.call(widget.item.id);
        }
      },
      onLongPressStart: (details) {
        if (widget.mode == 'display') {
          HapticFeedback.mediumImpact();
          _showMenu(context, details);
        }
      },
      child: Container(
        margin: const EdgeInsets.all(8),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          border: Border.all(
            color: widget.isSelected ? Colors.blue : Colors.grey.shade300,
            width: widget.isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(8),
          color: widget.isSelected ? Colors.blue.shade50 : Colors.white,
        ),
        child: Row(
          children: [
            const SizedBox(width: 12),
            if (widget.item.image != null && widget.item.image!.isNotEmpty)
              ProductThumbnailImage(imagePath: widget.item.image!)
            else
              Container(
                width: 60,
                height: 80,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Icon(
                  Icons.image_outlined,
                  color: Colors.grey.shade400,
                  size: 30,
                ),
              ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.item.name,
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  Text(widget.item.formattedPrice),
                  if (_unitName != null)
                    Text(
                      'å•ä½: $_unitName',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../../features/product/domain/model/product.dart';
import 'product_item.dart';

// å…¨å±€å˜é‡æ¥ç®¡ç†æ´»è·ƒçš„å•†å“é¡?
class ProductItemManager {
  static void Function()? _hideAllActions;

  static void setHideAllActions(void Function() callback) {
    _hideAllActions = callback;
  }

  static void hideAllActions() {
    _hideAllActions?.call();
  }
}

class ProductList extends StatefulWidget {
  final List<ProductModel> data;
  final String mode;
  final List<dynamic> selectedIds;
  final Function(List<dynamic>)? onSelectionChange;
  final Function(ProductModel)? onEdit;
  final Function(ProductModel)? onDelete;
  final Function(ProductModel)? onAdjustInventory;

  const ProductList({
    super.key,
    required this.data,
    this.mode = 'display',
    this.selectedIds = const [],
    this.onSelectionChange,
    this.onEdit,
    this.onDelete,
    this.onAdjustInventory,
  });

  @override
  State<ProductList> createState() => _ProductListState();
}

class _ProductListState extends State<ProductList> {
  void _handleToggleSelect(dynamic id) {
    final newSelectedIds = List<dynamic>.from(widget.selectedIds);
    if (newSelectedIds.contains(id)) {
      newSelectedIds.remove(id);
    } else {
      newSelectedIds.add(id);
    }
    widget.onSelectionChange?.call(newSelectedIds);
  }

  void _handleSelectAll() {
    final allIds = widget.data.map((item) => item.id).toList();
    widget.onSelectionChange?.call(allIds);
  }

  void _handleClearAll() {
    widget.onSelectionChange?.call([]);
  }

  void _hideAllActions() {
    ProductItemManager.hideAllActions();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _hideAllActions,
      child: CustomScrollView(
        slivers: [
          if (widget.mode == 'select')
            SliverToBoxAdapter(
              child: SizedBox(
                height: 40,
                child: Padding(
                  padding: const EdgeInsets.only(top: 9.0),
                  child: Row(
                    children: [
                      ElevatedButton(
                        onPressed: _handleSelectAll,
                        style: ElevatedButton.styleFrom(
                          padding: EdgeInsets.zero,
                        ),
                        child: const Text('å…¨é€?),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: _handleClearAll,
                        style: ElevatedButton.styleFrom(
                          padding: EdgeInsets.zero,
                        ),
                        child: const Text('æ¸…ç©º'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          SliverList(
            delegate: SliverChildBuilderDelegate((context, index) {
              final item = widget.data[index];
              return ProductItem(
                key: ValueKey(item.id),
                item: item,
                mode: widget.mode,
                isSelected: widget.selectedIds.contains(item.id),
                onToggleSelect: widget.mode == 'select'
                    ? _handleToggleSelect
                    : null,
                onEdit: widget.onEdit,
                onDelete: widget.onDelete,
                onAdjustInventory: widget.onAdjustInventory,
                onHideActions: _hideAllActions,
              );
            }, childCount: widget.data.length),
          ),
        ],
      ),
    );
  }
}
import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter/services.dart';
import 'package:crypto/crypto.dart';
import 'package:stocko_app/features/backup/data/providers/restore_service_provider.dart';
import 'package:stocko_app/features/backup/domain/models/restore_mode.dart';

class ProductRestoreDebugPage extends ConsumerStatefulWidget {
  const ProductRestoreDebugPage({super.key});

  @override
  ConsumerState<ProductRestoreDebugPage> createState() =>
      _ProductRestoreDebugPageState();
}

class _ProductRestoreDebugPageState
    extends ConsumerState<ProductRestoreDebugPage> {
  final List<String> _logs = [];
  bool _isRunning = false;

  void _addLog(String message) {
    setState(() {
      _logs.add('${DateTime.now().toIso8601String()}: $message');
    });
  }

  Future<void> _copyLogsToClipboard() async {
    if (_logs.isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('æ²¡æœ‰æµ‹è¯•æ—¥å¿—å¯å¤åˆ?)));
      }
      return;
    }

    final logsText = _logs.join('\n');
    await Clipboard.setData(ClipboardData(text: logsText));

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('æµ‹è¯•ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ?),
          backgroundColor: Colors.green,
          action: SnackBarAction(
            label: 'æŸ¥çœ‹',
            textColor: Colors.white,
            onPressed: () => _showLogsDialog(),
          ),
        ),
      );
    }
  }

  void _showLogsDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.content_copy),
            SizedBox(width: 8),
            Text('æµ‹è¯•ç»“æœ'),
          ],
        ),
        content: SizedBox(
          width: double.maxFinite,
          height: 400,
          child: SingleChildScrollView(
            child: SelectableText(
              _logs.join('\n'),
              style: const TextStyle(fontFamily: 'monospace', fontSize: 12),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å…³é—­'),
          ),
          ElevatedButton.icon(
            onPressed: () async {
              await _copyLogsToClipboard();
              Navigator.of(context).pop();
            },
            icon: const Icon(Icons.copy, size: 16),
            label: const Text('å¤åˆ¶'),
          ),
        ],
      ),
    );
  }

  void _clearLogs() {
    setState(() {
      _logs.clear();
    });
    if (mounted) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('æµ‹è¯•æ—¥å¿—å·²æ¸…ç©?)));
    }
  }

  Future<void> _runProductRestoreTest() async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _logs.clear();
    });

    _addLog('ğŸ§ª å¼€å§‹äº§å“æ¢å¤åŠŸèƒ½æµ‹è¯?..');

    try {
      // 1. éªŒè¯å¤‡ä»½æ–‡ä»¶
      await _validateBackupFile();

      // 2. æµ‹è¯•æ¢å¤æœåŠ¡
      await _testRestoreService();

      // 3. æµ‹è¯•ä¸åŒæ¢å¤æ¨¡å¼
      await _testRestoreModes();

      _addLog('âœ?äº§å“æ¢å¤åŠŸèƒ½æµ‹è¯•å®Œæˆï¼?);
    } catch (e) {
      _addLog('â?æµ‹è¯•å¤±è´¥: $e');
    } finally {
      setState(() {
        _isRunning = false;
      });
    }
  }

  Future<void> _validateBackupFile() async {
    _addLog('ğŸ“‹ æ­¥éª¤1: éªŒè¯å¤‡ä»½æ–‡ä»¶');

    try {
      // é¦–å…ˆå°è¯•ä»åº”ç”¨ç›®å½•æŸ¥æ‰¾å¤‡ä»½æ–‡ä»?
      final appDir = await getApplicationDocumentsDirectory();
      final backupFile = File('${appDir.path}/product_test_backup.json');

      // æ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§æµ‹è¯•æ–‡ä»¶ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°çš„assetsæ–‡ä»¶
      if (await backupFile.exists()) {
        await backupFile.delete();
        _addLog('ğŸ§¹ æ¸…ç†æ—§çš„æµ‹è¯•å¤‡ä»½æ–‡ä»¶');
      }

      String content;

      // å°è¯•ä»assetsåŠ è½½å¤‡ä»½æ–‡ä»¶
      try {
        content = await rootBundle.loadString(
          'assets/data/product_test_backup.json',
        );
        _addLog('âœ?ä»assetsæˆåŠŸåŠ è½½å¤‡ä»½æ–‡ä»¶');

        // å°†assetsæ–‡ä»¶å¤åˆ¶åˆ°åº”ç”¨ç›®å½•ä»¥ä¾›åç»­ä½¿ç”?
        await backupFile.writeAsString(content);
        _addLog('âœ?å¤‡ä»½æ–‡ä»¶å·²å¤åˆ¶åˆ°åº”ç”¨ç›®å½•');
        _addLog('âœ?æ–‡ä»¶å¤§å°: ${await backupFile.length()} å­—èŠ‚');
      } catch (e) {
        // å¦‚æœassetsä¹Ÿæ²¡æœ‰ï¼Œåˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨çš„å¤‡ä»½æ–‡ä»?
        _addLog('âš ï¸ assetsä¸­ä¹Ÿæœªæ‰¾åˆ°å¤‡ä»½æ–‡ä»¶ï¼Œåˆ›å»ºæµ‹è¯•å¤‡ä»½æ–‡ä»¶...');
        content = await _createTestBackupFile(backupFile);
      }

      final data = jsonDecode(content) as Map<String, dynamic>;

      final metadata = data['metadata'] as Map<String, dynamic>;
      _addLog('âœ?å¤‡ä»½ID: ${metadata['id']}');
      _addLog('âœ?ç‰ˆæœ¬: ${metadata['version']}');

      // éªŒè¯äº§å“æ•°æ®
      final tables = data['tables'] as Map<String, dynamic>;
      final products = tables['product'] as List<dynamic>;
      _addLog('âœ?äº§å“è®°å½•æ•? ${products.length}');
    } catch (e) {
      _addLog('â?å¤‡ä»½æ–‡ä»¶éªŒè¯å¤±è´¥: $e');
      rethrow;
    }
  }

  Future<String> _createTestBackupFile(File backupFile) async {
    final tablesData = {
      "category": [
        {
          "id": 1,
          "name": "æµ‹è¯•åˆ†ç±»1",
          "description": "æµ‹è¯•ç”¨åˆ†ç±?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
        {
          "id": 2,
          "name": "æµ‹è¯•åˆ†ç±»2",
          "description": "æµ‹è¯•ç”¨åˆ†ç±?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
      ],
      "unit": [
        {
          "id": 1,
          "name": "ä¸?,
          "symbol": "ä¸?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
        {
          "id": 2,
          "name": "ç›?,
          "symbol": "ç›?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
      ],
      "product": [
        {
          "id": 1,
          "name": "æµ‹è¯•äº§å“A",
          "sku": "TEST001",
          "specification": "500ml",
          "brand": "æµ‹è¯•å“ç‰Œ",
          "category_id": 1,
          "base_unit_id": 1,
          "retail_price": 1500,
          "status": "active",
          "remarks": "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•äº§å“?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
        {
          "id": 2,
          "name": "æµ‹è¯•äº§å“B",
          "sku": "TEST002",
          "specification": "1L",
          "brand": "æµ‹è¯•å“ç‰Œ",
          "category_id": 2,
          "base_unit_id": 2,
          "retail_price": 2500,
          "status": "active",
          "remarks": "è¿™æ˜¯å¦ä¸€ä¸ªæµ‹è¯•äº§å“?,
          "created_at": DateTime.now().toIso8601String(),
          "updated_at": DateTime.now().toIso8601String(),
        },
      ],
    };

    // ç”Ÿæˆæ­£ç¡®çš„æ ¡éªŒå’Œ
    final tablesJson = jsonEncode(tablesData);
    final bytes = utf8.encode(tablesJson);
    final digest = sha256.convert(bytes);
    final correctChecksum = digest.toString();

    final testBackupData = {
      "metadata": {
        "id": "product_test_backup_${DateTime.now().millisecondsSinceEpoch}",
        "fileName": "product_test_backup.json",
        "createdAt": DateTime.now().toIso8601String(),
        "fileSize": 1856,
        "version": "2.0.0",
        "tableCounts": {"category": 2, "unit": 2, "product": 2},
        "checksum": correctChecksum,
        "isEncrypted": false,
        "description": "äº§å“æ¢å¤åŠŸèƒ½æµ‹è¯•å¤‡ä»½æ–‡ä»¶ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰",
        "appVersion": "1.0.0+1",
        "schemaVersion": 22,
      },
      "tables": tablesData,
    };

    final content = jsonEncode(testBackupData);
    await backupFile.writeAsString(content);
    _addLog('âœ?æµ‹è¯•å¤‡ä»½æ–‡ä»¶åˆ›å»ºæˆåŠŸ');
    return content;
  }

  Future<void> _testRestoreService() async {
    _addLog('ğŸ”§ æ­¥éª¤2: æµ‹è¯•æ¢å¤æœåŠ¡');

    try {
      final restoreService = ref.read(restoreServiceProvider);
      _addLog('âœ?æ¢å¤æœåŠ¡åˆå§‹åŒ–æˆåŠ?);

      // è·å–å¤‡ä»½æ–‡ä»¶è·¯å¾„
      final appDir = await getApplicationDocumentsDirectory();
      final backupFilePath = '${appDir.path}/product_test_backup.json';

      final metadata = await restoreService.validateBackupFile(backupFilePath);
      _addLog('âœ?å¤‡ä»½æ–‡ä»¶éªŒè¯æˆåŠŸ');
      _addLog('- å¤‡ä»½ID: ${metadata.id}');
      _addLog('- ç‰ˆæœ¬: ${metadata.version}');
      _addLog('- äº§å“è®°å½•æ•? ${metadata.tableCounts['product'] ?? 0}');

      final isCompatible = await restoreService.checkCompatibility(
        backupFilePath,
      );
      _addLog('âœ?å…¼å®¹æ€§æ£€æŸ? ${isCompatible ? 'âœ?å…¼å®¹' : 'â?ä¸å…¼å®?}');
    } catch (e) {
      _addLog('âš ï¸ æ¢å¤æœåŠ¡æµ‹è¯•é‡åˆ°é—®é¢˜: $e');
      _addLog('ğŸ“ è¿™å¯èƒ½æ˜¯ç”±äºæ¢å¤æœåŠ¡éœ€è¦å®Œæ•´çš„æ•°æ®åº“ç¯å¢?);
    }
  }

  Future<void> _testRestoreModes() async {
    _addLog('ğŸ¯ æ­¥éª¤3: æµ‹è¯•ä¸åŒæ¢å¤æ¨¡å¼');

    try {
      final restoreService = ref.read(restoreServiceProvider);
      final appDir = await getApplicationDocumentsDirectory();
      final backupFilePath = '${appDir.path}/product_test_backup.json';

      final modes = [
        RestoreMode.addOnly,
        RestoreMode.merge,
        RestoreMode.replace,
      ];

      for (final mode in modes) {
        _addLog('ğŸ”§ æµ‹è¯•æ¢å¤æ¨¡å¼: ${_getRestoreModeDescription(mode)}');

        try {
          final preview = await restoreService.previewRestore(
            backupFilePath,
            mode: mode,
          );

          _addLog('âœ?é¢„è§ˆç”ŸæˆæˆåŠŸ');
          _addLog('- å…¼å®¹æ€? ${preview.isCompatible ? 'âœ?å…¼å®¹' : 'â?ä¸å…¼å®?}');
          _addLog('- è®°å½•ç»Ÿè®¡: ${preview.recordCounts}');
          _addLog('- é¢„ä¼°å†²çª: ${preview.estimatedConflicts}');
        } catch (e) {
          _addLog('âš ï¸ æ¨¡å¼æµ‹è¯•é‡åˆ°é—®é¢˜: $e');
          _addLog('ğŸ“ è¿™å¯èƒ½æ˜¯ç”±äºç¼ºå°‘å®Œæ•´çš„æ•°æ®åº“ç¯å¢ƒ');
        }
      }
    } catch (e) {
      _addLog('â?æ¢å¤æ¨¡å¼æµ‹è¯•å¤±è´¥: $e');
    }
  }

  String _getRestoreModeDescription(RestoreMode mode) {
    switch (mode) {
      case RestoreMode.replace:
        return 'å®Œå…¨æ›¿æ¢æ¨¡å¼';
      case RestoreMode.merge:
        return 'åˆå¹¶æ¨¡å¼';
      case RestoreMode.addOnly:
        return 'ä»…æ·»åŠ æ¨¡å¼?;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('äº§å“æ¢å¤æµ‹è¯•'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        actions: [
          if (_logs.isNotEmpty) ...[
            IconButton(
              onPressed: _showLogsDialog,
              icon: const Icon(Icons.visibility),
              tooltip: 'æŸ¥çœ‹å®Œæ•´æ—¥å¿—',
            ),
            IconButton(
              onPressed: _copyLogsToClipboard,
              icon: const Icon(Icons.copy),
              tooltip: 'å¤åˆ¶æµ‹è¯•ç»“æœ',
            ),
            IconButton(
              onPressed: _clearLogs,
              icon: const Icon(Icons.clear),
              tooltip: 'æ¸…ç©ºæ—¥å¿—',
            ),
          ],
        ],
      ),
      body: Column(
        children: [
          // æ§åˆ¶æŒ‰é’®åŒºåŸŸ
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isRunning ? null : _runProductRestoreTest,
                    child: _isRunning
                        ? const Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              ),
                              SizedBox(width: 8),
                              Text('æµ‹è¯•è¿è¡Œä¸?..'),
                            ],
                          )
                        : const Text('å¼€å§‹äº§å“æ¢å¤æµ‹è¯?),
                  ),
                ),
                if (_logs.isNotEmpty) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _copyLogsToClipboard,
                          icon: const Icon(Icons.copy, size: 16),
                          label: const Text('å¤åˆ¶ç»“æœ'),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _showLogsDialog,
                          icon: const Icon(Icons.visibility, size: 16),
                          label: const Text('æŸ¥çœ‹è¯¦æƒ…'),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _clearLogs,
                          icon: const Icon(Icons.clear, size: 16),
                          label: const Text('æ¸…ç©ºæ—¥å¿—'),
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
          // æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸ
          Expanded(
            child: Container(
              margin: const EdgeInsets.fromLTRB(16.0, 0, 16.0, 16.0),
              padding: const EdgeInsets.all(12.0),
              decoration: BoxDecoration(
                color: Colors.black87,
                borderRadius: BorderRadius.circular(8.0),
                border: Border.all(
                  color: Theme.of(
                    context,
                  ).colorScheme.outline.withValues(alpha: 0.3),
                ),
              ),
              child: _logs.isEmpty
                  ? const Center(
                      child: Text(
                        'ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•\næµ‹è¯•ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º',
                        textAlign: TextAlign.center,
                        style: TextStyle(color: Colors.grey, fontSize: 14),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _logs.length,
                      itemBuilder: (context, index) {
                        final log = _logs[index];
                        Color textColor = Colors.green;

                        // æ ¹æ®æ—¥å¿—å†…å®¹è®¾ç½®ä¸åŒé¢œè‰²
                        if (log.contains('â?) || log.contains('å¤±è´¥')) {
                          textColor = Colors.red;
                        } else if (log.contains('âš ï¸') || log.contains('è­¦å‘Š')) {
                          textColor = Colors.orange;
                        } else if (log.contains('âœ?) || log.contains('æˆåŠŸ')) {
                          textColor = Colors.lightGreen;
                        } else if (log.contains('ğŸ§ª') ||
                            log.contains('ğŸ“‹') ||
                            log.contains('ğŸ”§') ||
                            log.contains('ğŸ¯')) {
                          textColor = Colors.cyan;
                        }

                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 1.0),
                          child: SelectableText(
                            log,
                            style: TextStyle(
                              color: textColor,
                              fontFamily: 'monospace',
                              fontSize: 12,
                            ),
                          ),
                        );
                      },
                    ),
            ),
          ),
          // çŠ¶æ€æ 
          if (_logs.isNotEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(
                horizontal: 16.0,
                vertical: 8.0,
              ),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceContainerHighest,
                border: Border(
                  top: BorderSide(
                    color: Theme.of(
                      context,
                    ).colorScheme.outline.withValues(alpha: 0.3),
                  ),
                ),
              ),
              child: Text(
                'å…?${_logs.length} æ¡æ—¥å¿?â€?${_isRunning ? 'æµ‹è¯•è¿›è¡Œä¸?..' : 'æµ‹è¯•å®Œæˆ'}',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ),
        ],
      ),
    );
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'ranking_providers.dart';

enum RangePreset { today, last7Days, thisMonth, custom }

final rangePresetProvider = StateProvider<RangePreset>((ref) => RangePreset.last7Days);

void applyPreset(WidgetRef ref, RangePreset preset) {
  final now = DateTime.now();
  switch (preset) {
    case RangePreset.today:
      final start = DateTime(now.year, now.month, now.day);
      ref.read(rankingRangeProvider.notifier).state = RankingRange(start, start.add(const Duration(days: 1)));
      break;
    case RangePreset.last7Days:
      final endOpen = DateTime(now.year, now.month, now.day).add(const Duration(days: 1));
      final start = endOpen.subtract(const Duration(days: 7));
      ref.read(rankingRangeProvider.notifier).state = RankingRange(start, endOpen);
      break;
    case RangePreset.thisMonth:
      final start = DateTime(now.year, now.month, 1);
      final nextMonth = (now.month == 12)
          ? DateTime(now.year + 1, 1, 1)
          : DateTime(now.year, now.month + 1, 1);
      ref.read(rankingRangeProvider.notifier).state = RankingRange(start, nextMonth);
      break;
    case RangePreset.custom:
      // ç”±è°ƒç”¨æ–¹å¼¹çª—é€‰æ‹©
      break;
  }
}
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repository/sales_analytics_repository.dart';
import '../../domain/model/product_sales_ranking.dart';

// æ—¶é—´ç­›é€‰æ¨¡å¼?
enum TimeFilterMode {
  daily('æ¯å¤©'),
  weekly('æ¯å‘¨'),
  monthly('æ¯æœˆ');

  const TimeFilterMode(this.label);
  final String label;
}

// æ—¶é—´èŒƒå›´ Provider
class RankingRange {
  final DateTime start;
  final DateTime endOpen;
  const RankingRange(this.start, this.endOpen);
}

final rankingRangeProvider = StateProvider<RankingRange>((ref) {
  final now = DateTime.now();
  final endOpen = DateTime(now.year, now.month, now.day).add(const Duration(days: 1)); // æ˜æ—¥ 00:00
  final start = DateTime(2000, 1, 1); // æ— é™åˆ¶ï¼šä»?000å¹´å¼€å§‹åˆ°ç°åœ¨
  return RankingRange(start, endOpen);
});

// æ—¶é—´ç­›é€‰æ¨¡å¼?Provider
final timeFilterModeProvider = StateProvider<TimeFilterMode>((ref) => TimeFilterMode.daily);

// é€‰ä¸­çš„æ—¥æœ?Provider
final selectedDateProvider = StateProvider<DateTime>((ref) => DateTime.now());

// é€‰ä¸­çš„å‘¨èŒƒå›´ Provider
final selectedWeekRangeProvider = StateProvider<DateTimeRange?>((ref) => null);

// é€‰ä¸­çš„æœˆä»?Provider
final selectedMonthProvider = StateProvider<DateTime>((ref) => DateTime.now());

// æ’åºæ–¹å¼ï¼ˆé”€é‡?åˆ©æ¶¦ï¼?
final rankingSortProvider = StateProvider<ProductRankingSort>((ref) => ProductRankingSort.byQtyDesc);

// æ’è¡Œæ¦?Providerï¼ˆStream/Query on demand -> Futureï¼?
// å†…éƒ¨ï¼šç»´æŠ¤ä¸€ä¸ªç¨³å®šçš„è¾“å‡ºæµï¼ˆbroadcastï¼‰ï¼Œå½“å¤–éƒ¨ç­›é€‰æˆ–æ’åºå˜åŒ–æ—¶ï¼Œ
// ä»…æ›´æ–°ä¸ä»“åº“ä¹‹é—´çš„è®¢é˜…ï¼Œç¡®ä¿æ¶ˆè´¹è€…è®¢é˜…ä¸è¢«æ‰“æ–­ï¼ˆé¿å…æµ‹è¯•ä¸­å¤ç”¨åŒä¸€å•è®¢é˜?Stream æ—¶çš„äº‹ä»¶ä¸¢å¤±ï¼‰ã€?
final _productSalesRankingStreamControllerProvider =
    Provider<StreamController<List<ProductSalesRanking>>>((ref) {
  final repo = ref.watch(salesAnalyticsRepositoryProvider);
  final controller = StreamController<List<ProductSalesRanking>>.broadcast();

  StreamSubscription<List<ProductSalesRanking>>? sub;
  Stream<List<ProductSalesRanking>>? lastSrc;

  void resubscribe() {
    final range = ref.read(rankingRangeProvider);
    final sort = ref.read(rankingSortProvider);
    final src = repo.watchProductSalesRanking(
      start: range.start,
      end: range.endOpen,
      sort: sort,
    );
    // è‹¥ä»“åº“è¿”å›çš„æ˜¯åŒä¸€ä¸ªå•è®¢é˜… Stream å®ä¾‹ï¼ˆæµ‹è¯•é‡Œå¯èƒ½å¤ç”¨åŒä¸€ä¸?controller.streamï¼‰ï¼Œ
    // ä¸è¦äºŒæ¬¡ç›‘å¬ï¼Œä»¥å…æŠ›å‡?â€œStream has already been listened toâ€ã€?
    if (identical(lastSrc, src)) {
      return; // ä¿æŒåŸè®¢é˜…ï¼Œç»§ç»­æ¥æ”¶äº‹ä»¶
    }

    // å…ˆå°è¯•å»ºç«‹æ–°è®¢é˜…ï¼ŒæˆåŠŸåå†å–æ¶ˆæ—§è®¢é˜…ï¼Œé¿å…å¯¹ç›¸åŒå•è®¢é˜…æµçš„äºŒæ¬¡ç›‘å?
    StreamSubscription<List<ProductSalesRanking>>? newSub;
    try {
      newSub = src.listen(
        controller.add,
        onError: controller.addError,
        onDone: () {},
        cancelOnError: false,
      );
    } catch (e) {
      // å¦‚æœæ˜¯å•è®¢é˜…æµé‡å¤ç›‘å¬å¯¼è‡´çš„å¼‚å¸¸ï¼Œåˆ™ä¿ç•™åŸè®¢é˜…ï¼Œä¸åˆ‡æ?
      final msg = e.toString();
      if (msg.contains('Stream has already been listened to') || e is StateError) {
        return;
      }
      rethrow;
    }

    // æ–°è®¢é˜…å»ºç«‹æˆåŠŸï¼Œæ›¿æ¢å¹¶å–æ¶ˆæ—§è®¢é˜…
    final oldSub = sub;
    sub = newSub;
    lastSrc = src;
    oldSub?.cancel();
  }

  // åˆæ¬¡è®¢é˜…
  resubscribe();

  // ç›‘å¬ç­›é€?æ’åºå˜åŒ–ï¼Œé‡å»ºä¸ä»“åº“çš„è®¢é˜?
  ref.listen<RankingRange>(rankingRangeProvider, (prev, next) {
    // ä»…å½“å‘ç”Ÿå®é™…å˜åŒ–æ—¶é‡å»?
    if (prev?.start != next.start || prev?.endOpen != next.endOpen) {
      resubscribe();
    }
  });
  ref.listen<ProductRankingSort>(rankingSortProvider, (prev, next) {
    if (prev != next) {
      resubscribe();
    }
  });

  ref.onDispose(() async {
    await sub?.cancel();
    await controller.close();
  });

  return controller;
});

final productSalesRankingProvider =
    StreamProvider<List<ProductSalesRanking>>((ref) {
  final controller = ref.watch(_productSalesRankingStreamControllerProvider);
  return controller.stream;
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/core/database/database.dart';
import 'package:drift/drift.dart' as drift;
import '../../domain/model/product_sales_ranking.dart';

enum ProductRankingSort { byQtyDesc, byProfitDesc }

class SalesAnalyticsRepository {
  final AppDatabase _db;
  SalesAnalyticsRepository(this._db);

  // åœ¨æŸäº›æµ‹è¯•åœºæ™¯ä¸‹ï¼ˆä½¿ç”?Mock æœ?stub éç©ºè¡?getterï¼‰ï¼Œç›´æ¥è®¿é—® _db.<table>
  // ä¼šå› è¿”å› null è€Œè§¦å‘è¿è¡Œæ—¶ç±»å‹é”™è¯¯ã€‚è¿™é‡Œé€šè¿‡ try/catch å®‰å…¨æ”¶é›†è¡¨ï¼Œ
  // è‹¥è·å–å¤±è´¥åˆ™å›é€€ä¸ºä¸å£°æ˜ readsFromï¼ˆè¿”å›ç©ºé›†åˆï¼‰ï¼Œä»¥ä¾¿å•å…ƒæµ‹è¯•èƒ½ä¸“æ³¨äºè¡Œä¸ºè€Œéå…·ä½“è¡¨ã€?
  Set<drift.TableInfo<dynamic, dynamic>> _safeReadsFromTables() {
    final set = <drift.TableInfo<dynamic, dynamic>>{};
    void addSafely(Object? Function() getter) {
      try {
        final v = getter();
        if (v is drift.TableInfo) set.add(v);
      } catch (_) {
        // ignore in tests where getters aren't stubbed
      }
    }
    addSafely(() => _db.salesTransactionItem);
    addSafely(() => _db.salesTransaction);
    addSafely(() => _db.product);
    addSafely(() => _db.stock);
    return set;
  }

  /// è·å–æŒ‡å®šæ—¶é—´èŒƒå›´å†…çš„å•†å“é”€é‡æ’è¡Œæ¦œï¼ˆä»…ç»Ÿè®¡æœ‰é”€é‡çš„å•†å“ï¼?
  /// - æ—¶é—´èŒƒå›´åŸºäº sales_transaction.created_at
  /// - ä»…ç»Ÿè®¡çŠ¶æ€ä¸ä¸?'cancelled' çš„äº¤æ˜?
  Future<List<ProductSalesRanking>> getProductSalesRanking({
    required DateTime start,
    required DateTime end,
    int? limit,
    ProductRankingSort sort = ProductRankingSort.byQtyDesc,
  }) async {
    // æ³¨æ„ï¼šSQLite ä¸æ”¯æŒ?BETWEEN çš„ä¸Šç•Œä¸ºé—­åŒºé—´æ—¶è·¨æ¯«ç§’ï¼Œè¿™é‡Œé‡‡ç”¨ >= start AND < endNext
    // è¿™é‡Œ end ä½œä¸ºåŒ…å«å½“å¤©çš„è‡ªç„¶æ—¥ï¼Œè¿½åŠ?1 å¤©ä½œä¸ºå¼€åŒºé—´ä¸Šç•Œ
    final endOpen = end;

    final orderBy = switch (sort) {
      ProductRankingSort.byQtyDesc => 'total_qty DESC',
      ProductRankingSort.byProfitDesc => 'total_profit_in_cents DESC',
    };

  final query = _db.customSelect(
      '''
      SELECT 
        p.id AS product_id,
        p.name AS name,
        p.sku AS sku,
        SUM(si.quantity) AS total_qty,
        SUM(si.quantity * si.price_in_cents) AS total_amount_in_cents,
        SUM(CASE 
              WHEN s.average_unit_price_in_cents IS NULL OR s.average_unit_price_in_cents = 0 THEN 0 
              ELSE si.quantity * (si.price_in_cents - s.average_unit_price_in_cents) 
            END) AS total_profit_in_cents,
        SUM(CASE 
              WHEN s.average_unit_price_in_cents IS NULL OR s.average_unit_price_in_cents = 0 THEN 1 
              ELSE 0 
            END) AS missing_cost_count
      FROM sales_transaction_item si
      INNER JOIN sales_transaction st ON st.id = si.sales_transaction_id
      INNER JOIN product p ON p.id = si.product_id
      LEFT JOIN stock s ON s.product_id = si.product_id 
        AND s.shop_id = st.shop_id 
        AND (s.batch_id = si.batch_id OR (s.batch_id IS NULL AND si.batch_id IS NULL))
      WHERE st.created_at >= ? AND st.created_at < ? AND st.status != 'cancelled'
      GROUP BY p.id, p.name, p.sku
      HAVING SUM(si.quantity) > 0
      ORDER BY $orderBy
      ${limit != null ? 'LIMIT $limit' : ''}
      ''',
      variables: [
        drift.Variable<DateTime>(start),
        drift.Variable<DateTime>(endOpen),
      ],
  readsFrom: _safeReadsFromTables(),
    );

    final rows = await query.get();
  return rows
    .map((r) => ProductSalesRanking(
        productId: r.read<int>('product_id'),
        name: r.read<String>('name'),
        sku: r.read<String?>('sku'),
        totalQty: r.read<int>('total_qty'),
        totalAmountInCents: r.read<int>('total_amount_in_cents'),
        totalProfitInCents: r.read<int>('total_profit_in_cents'),
        missingCostCount: r.read<int>('missing_cost_count'),
      ))
    .toList();
  }

  /// ç›‘å¬æŒ‡å®šæ—¶é—´èŒƒå›´å†…çš„å•†å“é”€é‡æ’è¡Œæ¦œå˜åŠ¨
  Stream<List<ProductSalesRanking>> watchProductSalesRanking({
    required DateTime start,
    required DateTime end,
    int? limit,
    ProductRankingSort sort = ProductRankingSort.byQtyDesc,
  }) {
    final endOpen = end;
    final orderBy = switch (sort) {
      ProductRankingSort.byQtyDesc => 'total_qty DESC',
      ProductRankingSort.byProfitDesc => 'total_profit_in_cents DESC',
    };
  final selectable = _db.customSelect(
      '''
      SELECT 
        p.id AS product_id,
        p.name AS name,
        p.sku AS sku,
        SUM(si.quantity) AS total_qty,
        SUM(si.quantity * si.price_in_cents) AS total_amount_in_cents,
        SUM(CASE 
              WHEN s.average_unit_price_in_cents IS NULL OR s.average_unit_price_in_cents = 0 THEN 0 
              ELSE si.quantity * (si.price_in_cents - s.average_unit_price_in_cents) 
            END) AS total_profit_in_cents,
        SUM(CASE 
              WHEN s.average_unit_price_in_cents IS NULL OR s.average_unit_price_in_cents = 0 THEN 1 
              ELSE 0 
            END) AS missing_cost_count
      FROM sales_transaction_item si
      INNER JOIN sales_transaction st ON st.id = si.sales_transaction_id
      INNER JOIN product p ON p.id = si.product_id
      LEFT JOIN stock s ON s.product_id = si.product_id 
        AND s.shop_id = st.shop_id 
        AND (s.batch_id = si.batch_id OR (s.batch_id IS NULL AND si.batch_id IS NULL))
      WHERE st.created_at >= ? AND st.created_at < ? AND st.status != 'cancelled'
      GROUP BY p.id, p.name, p.sku
      HAVING SUM(si.quantity) > 0
      ORDER BY $orderBy
      ${limit != null ? 'LIMIT $limit' : ''}
      ''',
      variables: [
        drift.Variable<DateTime>(start),
        drift.Variable<DateTime>(endOpen),
      ],
  readsFrom: _safeReadsFromTables(),
    );

  return selectable.watch().map((rows) => rows
    .map((r) => ProductSalesRanking(
        productId: r.read<int>('product_id'),
        name: r.read<String>('name'),
        sku: r.read<String?>('sku'),
        totalQty: r.read<int>('total_qty'),
        totalAmountInCents: r.read<int>('total_amount_in_cents'),
        totalProfitInCents: r.read<int>('total_profit_in_cents'),
        missingCostCount: r.read<int>('missing_cost_count'),
      ))
    .toList());
  }
}

// Provider (no codegen)
final salesAnalyticsRepositoryProvider = Provider<SalesAnalyticsRepository>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return SalesAnalyticsRepository(db);
});
class ProductSalesRanking {
  final int productId;
  final String name;
  final String? sku;
  final int totalQty;
  final int totalAmountInCents;
  // æ–°å¢ï¼šæ€»åˆ©æ¶¦ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼‰
  final int totalProfitInCents;
  // æ–°å¢ï¼šåœ¨è®¡ç®—åˆ©æ¶¦æ—¶æ˜¯å¦å­˜åœ¨æ— æ³•æ‰¾åˆ°é‡‡è´­æˆæœ¬çš„é”€å”®è¡Œï¼?0 è¡¨ç¤ºå­˜åœ¨ï¼?
  final int missingCostCount;

  const ProductSalesRanking({
    required this.productId,
    required this.name,
    this.sku,
    required this.totalQty,
    required this.totalAmountInCents,
    required this.totalProfitInCents,
    required this.missingCostCount,
  });

  double get totalAmountYuan => totalAmountInCents / 100.0;
  double get totalProfitYuan => totalProfitInCents / 100.0;
  bool get hasMissingCost => missingCostCount > 0;
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/core/database/database.dart';
import '../../domain/services/i_database_statistics_service.dart';
import '../../data/services/database_statistics_service.dart';

/// æ•°æ®åº“ç»Ÿè®¡æœåŠ¡æä¾›è€?
final databaseStatisticsServiceProvider = Provider<IDatabaseStatisticsService>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return DatabaseStatisticsService(database);
});

/// æ‰€æœ‰è¡¨ç»Ÿè®¡æ•°æ®æä¾›è€?
final allTableCountsProvider = FutureProvider<Map<String, int>>((ref) {
  final service = ref.watch(databaseStatisticsServiceProvider);
  return service.getAllTableCounts();
});

/// æ•°æ®åº“æ€»è®°å½•æ•°æä¾›è€?
final totalRecordCountProvider = FutureProvider<int>((ref) {
  final service = ref.watch(databaseStatisticsServiceProvider);
  return service.getTotalRecordCount();
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../services/backup_error_service.dart';
import '../services/backup_error_handler.dart';

part 'backup_error_service_provider.g.dart';

/// å¤‡ä»½é”™è¯¯æœåŠ¡æä¾›è€?
@Riverpod(keepAlive: true)
BackupErrorService backupErrorService(Ref ref) {
  final service = BackupErrorService.instance;

  // ç¡®ä¿æœåŠ¡åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ?
  service.initialize();

  // åœ¨åº”ç”¨å…³é—­æ—¶æ¸…ç†æœåŠ¡
  ref.onDispose(() {
    service.cleanup();
  });

  return service;
}

/// é”™è¯¯æµæä¾›è€?
@riverpod
Stream<UserFriendlyError> backupErrorStream(Ref ref) {
  final errorService = ref.watch(backupErrorServiceProvider);
  return errorService.errorStream;
}

/// é”™è¯¯ç»Ÿè®¡æä¾›è€?
@riverpod
Future<Map<String, dynamic>> backupErrorStats(
  Ref ref, {
  Duration? period,
}) async {
  final errorService = ref.watch(backupErrorServiceProvider);
  return await errorService.getErrorStats(period: period);
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'backup_error_service_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$backupErrorServiceHash() =>
    r'5a9d7922cab019eb3f0c8e263487a1e39a173d65';

/// å¤‡ä»½é”™è¯¯æœåŠ¡æä¾›è€?///
/// Copied from [backupErrorService].
@ProviderFor(backupErrorService)
final backupErrorServiceProvider = Provider<BackupErrorService>.internal(
  backupErrorService,
  name: r'backupErrorServiceProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$backupErrorServiceHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef BackupErrorServiceRef = ProviderRef<BackupErrorService>;
String _$backupErrorStreamHash() => r'2dfacee7312f525a397ed28dbab616038beb1416';

/// é”™è¯¯æµæä¾›è€?///
/// Copied from [backupErrorStream].
@ProviderFor(backupErrorStream)
final backupErrorStreamProvider =
    AutoDisposeStreamProvider<UserFriendlyError>.internal(
      backupErrorStream,
      name: r'backupErrorStreamProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$backupErrorStreamHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef BackupErrorStreamRef = AutoDisposeStreamProviderRef<UserFriendlyError>;
String _$backupErrorStatsHash() => r'fd3a1c29bcc17721f3e9e57d9440610956136be9';

/// Copied from Dart SDK
class _SystemHash {
  _SystemHash._();

  static int combine(int hash, int value) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + value);
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
  }

  static int finish(int hash) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    // ignore: parameter_assignments
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
  }
}

/// é”™è¯¯ç»Ÿè®¡æä¾›è€?///
/// Copied from [backupErrorStats].
@ProviderFor(backupErrorStats)
const backupErrorStatsProvider = BackupErrorStatsFamily();

/// é”™è¯¯ç»Ÿè®¡æä¾›è€?///
/// Copied from [backupErrorStats].
class BackupErrorStatsFamily extends Family<AsyncValue<Map<String, dynamic>>> {
  /// é”™è¯¯ç»Ÿè®¡æä¾›è€?  ///
  /// Copied from [backupErrorStats].
  const BackupErrorStatsFamily();

  /// é”™è¯¯ç»Ÿè®¡æä¾›è€?  ///
  /// Copied from [backupErrorStats].
  BackupErrorStatsProvider call({Duration? period}) {
    return BackupErrorStatsProvider(period: period);
  }

  @override
  BackupErrorStatsProvider getProviderOverride(
    covariant BackupErrorStatsProvider provider,
  ) {
    return call(period: provider.period);
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'backupErrorStatsProvider';
}

/// é”™è¯¯ç»Ÿè®¡æä¾›è€?///
/// Copied from [backupErrorStats].
class BackupErrorStatsProvider
    extends AutoDisposeFutureProvider<Map<String, dynamic>> {
  /// é”™è¯¯ç»Ÿè®¡æä¾›è€?  ///
  /// Copied from [backupErrorStats].
  BackupErrorStatsProvider({Duration? period})
    : this._internal(
        (ref) => backupErrorStats(ref as BackupErrorStatsRef, period: period),
        from: backupErrorStatsProvider,
        name: r'backupErrorStatsProvider',
        debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
            ? null
            : _$backupErrorStatsHash,
        dependencies: BackupErrorStatsFamily._dependencies,
        allTransitiveDependencies:
            BackupErrorStatsFamily._allTransitiveDependencies,
        period: period,
      );

  BackupErrorStatsProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.period,
  }) : super.internal();

  final Duration? period;

  @override
  Override overrideWith(
    FutureOr<Map<String, dynamic>> Function(BackupErrorStatsRef provider)
    create,
  ) {
    return ProviderOverride(
      origin: this,
      override: BackupErrorStatsProvider._internal(
        (ref) => create(ref as BackupErrorStatsRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        period: period,
      ),
    );
  }

  @override
  AutoDisposeFutureProviderElement<Map<String, dynamic>> createElement() {
    return _BackupErrorStatsProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is BackupErrorStatsProvider && other.period == period;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, period.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin BackupErrorStatsRef
    on AutoDisposeFutureProviderRef<Map<String, dynamic>> {
  /// The parameter `period` of this provider.
  Duration? get period;
}

class _BackupErrorStatsProviderElement
    extends AutoDisposeFutureProviderElement<Map<String, dynamic>>
    with BackupErrorStatsRef {
  _BackupErrorStatsProviderElement(super.provider);

  @override
  Duration? get period => (origin as BackupErrorStatsProvider).period;
}

// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../domain/services/i_backup_service.dart';
import '../services/unified_backup_service.dart';

/// ç»Ÿä¸€å¤‡ä»½æœåŠ¡æä¾›è€?
final backupServiceProvider = Provider<IBackupService>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return UnifiedBackupService(database);
});

/// æœ¬åœ°å¤‡ä»½åˆ—è¡¨æä¾›è€?
final localBackupsProvider = FutureProvider((ref) async {
  final backupService = ref.watch(backupServiceProvider);
  return await backupService.getLocalBackups();
});

/// å¤‡ä»½å¤§å°ä¼°ç®—æä¾›è€?
final backupSizeEstimateProvider = FutureProvider<int>((ref) async {
  final backupService = ref.watch(backupServiceProvider);
  return await backupService.estimateBackupSize();
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../repository/optimized_data_export_repository.dart';

/// æ•°æ®å¯¼å‡ºä»“å‚¨ Provider
/// æä¾› OptimizedDataExportRepository çš„å®ä¾?
final dataExportRepositoryProvider = Provider<OptimizedDataExportRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return OptimizedDataExportRepository(database);
});

/// è·å–è¡¨è®°å½•æ•°é‡ç»Ÿè®¡çš„ Provider
final tableCountsProvider = FutureProvider<Map<String, int>>((ref) async {
  final repository = ref.watch(dataExportRepositoryProvider);
  return repository.getTableCounts();
});

/// ä¼°ç®—å¯¼å‡ºæ•°æ®å¤§å°çš?Provider
final estimatedExportSizeProvider = FutureProvider<int>((ref) async {
  final repository = ref.watch(dataExportRepositoryProvider);
  return repository.estimateExportSize();
});

/// è·å–æ•°æ®åº“æ¶æ„ç‰ˆæœ¬çš„ Provider
final databaseSchemaVersionProvider = FutureProvider<int>((ref) async {
  final repository = ref.watch(dataExportRepositoryProvider);
  return repository.getDatabaseSchemaVersion();
});

/// è·å–æ‰€æœ‰è¡¨åçš„ Provider
final allTableNamesProvider = FutureProvider<List<String>>((ref) async {
  final repository = ref.watch(dataExportRepositoryProvider);
  return repository.getAllTableNames();
});
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../services/encryption_service.dart';
import '../../domain/services/i_encryption_service.dart';

part 'encryption_service_provider.g.dart';

/// Provider for the encryption service
/// Provides a singleton instance of the encryption service
@riverpod
IEncryptionService encryptionService(EncryptionServiceRef ref) {
  return EncryptionService();
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'encryption_service_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$encryptionServiceHash() => r'23358742155b47dffad0cf14c0d8525965979def';

/// Provider for the encryption service
/// Provides a singleton instance of the encryption service
///
/// Copied from [encryptionService].
@ProviderFor(encryptionService)
final encryptionServiceProvider =
    AutoDisposeProvider<IEncryptionService>.internal(
      encryptionService,
      name: r'encryptionServiceProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$encryptionServiceHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef EncryptionServiceRef = AutoDisposeProviderRef<IEncryptionService>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../domain/services/i_restore_service.dart';
import '../services/optimized_restore_service.dart';
import 'encryption_service_provider.dart';
import 'validation_service_provider.dart';

/// æ¢å¤æœåŠ¡æä¾›è€?
final restoreServiceProvider = Provider<IRestoreService>((ref) {
  final database = ref.watch(appDatabaseProvider);
  final encryptionService = ref.watch(encryptionServiceProvider);
  final validationService = ref.watch(validationServiceProvider);
  return OptimizedRestoreService(database, encryptionService, validationService);
});
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/database/database.dart';
import '../../domain/services/i_validation_service.dart';
import '../services/validation_service.dart';
import 'encryption_service_provider.dart';

part 'validation_service_provider.g.dart';

/// éªŒè¯æœåŠ¡æä¾›è€?
@riverpod
IValidationService validationService(Ref ref) {
  final database = ref.watch(appDatabaseProvider);
  final encryptionService = ref.watch(encryptionServiceProvider);
  
  return ValidationService(database, encryptionService);
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'validation_service_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$validationServiceHash() => r'cefac6bbd4140f55251b1f57acdc047b6c1862cf';

/// éªŒè¯æœåŠ¡æä¾›è€?///
/// Copied from [validationService].
@ProviderFor(validationService)
final validationServiceProvider =
    AutoDisposeProvider<IValidationService>.internal(
      validationService,
      name: r'validationServiceProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$validationServiceHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ValidationServiceRef = AutoDisposeProviderRef<IValidationService>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/models/restore_mode.dart';
import '../../domain/common/backup_common.dart';
import '../../domain/services/i_restore_service.dart';

/// æ•°æ®å¯¼å…¥ä»“å‚¨ç±?
/// è´Ÿè´£å°†å¤‡ä»½æ•°æ®å¯¼å…¥åˆ°æ•°æ®åº“ä¸­
class DataImportRepository {
  final AppDatabase _database;

  DataImportRepository(this._database);

  /// å¯¼å…¥æ‰€æœ‰è¡¨æ•°æ®ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒè¿›åº¦è·Ÿè¸ªå’Œé”™è¯¯å¤„ç†ï¼‰
  /// [tablesData] åŒ…å«æ‰€æœ‰è¡¨æ•°æ®çš„Mapï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
  /// [mode] æ¢å¤æ¨¡å¼
  /// [selectedTables] é€‰æ‹©è¦æ¢å¤çš„è¡¨ï¼ˆnullè¡¨ç¤ºæ¢å¤æ‰€æœ‰è¡¨ï¼?
  /// [onProgress] è¿›åº¦å›è°ƒå‡½æ•°
  /// [cancelToken] å–æ¶ˆä»¤ç‰Œ
  /// è¿”å›å„è¡¨å¯¼å…¥çš„è®°å½•æ•°ç»Ÿè®¡
  Future<Map<String, int>> importAllTables(
    Map<String, List<Map<String, dynamic>>> tablesData,
    RestoreMode mode, {
    List<String>? selectedTables,
    RestoreProgressCallback? onProgress,
    CancelToken? cancelToken,
  }) async {
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    print('ğŸš€ å¼€å§‹å¯¼å…¥æ‰€æœ‰è¡¨æ•°æ®');
    print('æ¢å¤æ¨¡å¼: $mode');
    print('æ€»è¡¨æ•? ${tablesData.length}');
    print('é€‰æ‹©çš„è¡¨: ${selectedTables ?? "å…¨éƒ¨"}');
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    final Map<String, int> importCounts = {};
    if (tablesData.isEmpty) {
      return importCounts;
    }
    final List<String> errors = [];
    final List<DataConflict> allConflicts = [];

    // è®¡ç®—æ€»è®°å½•æ•°ç”¨äºè¿›åº¦è·Ÿè¸ª
    int totalRecords = 0;
    int processedRecords = 0;

    final tablesToProcess = selectedTables ?? tablesData.keys.toList();
    for (final tableName in tablesToProcess) {
      if (tablesData.containsKey(tableName)) {
        totalRecords += tablesData[tableName]!.length;
      }
    }

    try {
      print('ğŸ“Š è®¡ç®—æ€»è®°å½•æ•°: $totalRecords');
      print('ğŸ“‹ å¾…å¤„ç†è¡¨åˆ—è¡¨: $tablesToProcess');

      // ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ç¡®ä¿æ•°æ®ä¸€è‡´æ€?
      return await _database.transaction(() async {
        print('ğŸ”„ å¼€å§‹æ•°æ®åº“äº‹åŠ¡');
        onProgress?.call('å‡†å¤‡æ•°æ®æ¢å¤...', 0, totalRecords);
        cancelToken?.throwIfCancelled();

        // å¦‚æœæ˜¯å®Œå…¨æ›¿æ¢æ¨¡å¼ï¼Œå…ˆæ¸…ç©ºç›¸å…³è¡¨
        if (mode == RestoreMode.replace) {
          print('ğŸ—‘ï¸?æ›¿æ¢æ¨¡å¼ï¼šå¼€å§‹æ¸…ç©ºç°æœ‰æ•°æ?);
          onProgress?.call('æ¸…ç©ºç°æœ‰æ•°æ®...', 0, totalRecords);
          await _clearTables(tablesToProcess);
          print('âœ?ç°æœ‰æ•°æ®æ¸…ç©ºå®Œæˆ');
        }

        // æŒ‰ç…§ä¾èµ–å…³ç³»é¡ºåºå¯¼å…¥è¡¨æ•°æ?
        final importOrder = _getTableImportOrder();
        print('ğŸ“‹ è¡¨å¯¼å…¥é¡ºåº? $importOrder');

        for (final tableName in importOrder) {
          if (!tablesToProcess.contains(tableName)) {
            continue;
          }

          if (tablesData.containsKey(tableName)) {
            final records = tablesData[tableName]!;

            print(
              'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
            );
            print('ğŸ“Š å¼€å§‹å¤„ç†è¡¨: $tableName');
            print('è®°å½•æ•°é‡: ${records.length}');
            print(
              'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
            );

            onProgress?.call(
              'æ¢å¤è¡?$tableName...',
              processedRecords,
              totalRecords,
            );
            cancelToken?.throwIfCancelled();

            final result = await _importTableWithProgress(
              tableName,
              records,
              mode,
              onProgress: (current, total) {
                final globalProgress = processedRecords + current;
                onProgress?.call(
                  'æ¢å¤è¡?$tableName ($current/$total)',
                  globalProgress,
                  totalRecords,
                );
              },
              cancelToken: cancelToken,
            );

            importCounts[tableName] = result.successCount;
            errors.addAll(result.errors);
            allConflicts.addAll(result.conflicts);
            processedRecords += records.length;

            print('âœ?è¡?$tableName å¤„ç†å®Œæˆ');
            print('æˆåŠŸå¯¼å…¥: ${result.successCount} æ¡è®°å½?);
            print('å¤±è´¥è®°å½•: ${result.failureCount} æ?);
            print('å†²çªè®°å½•: ${result.conflicts.length} æ?);
          }
        }

        // å¦‚æœæœ‰ä¸¥é‡é”™è¯¯ï¼Œå›æ»šäº‹åŠ¡
        if (errors.length > totalRecords * 0.1) {
          // å¦‚æœé”™è¯¯ç‡è¶…è¿?0%
          print('â?é”™è¯¯ç‡è¿‡é«˜ï¼Œå‡†å¤‡å›æ»šäº‹åŠ¡');
          print('æ€»é”™è¯¯æ•°: ${errors.length}');
          print('æ€»è®°å½•æ•°: $totalRecords');
          print(
            'é”™è¯¯ç? ${(errors.length / totalRecords * 100).toStringAsFixed(2)}%',
          );
          throw BackupException(
            type: BackupErrorType.databaseError,
            message: 'æ¢å¤è¿‡ç¨‹ä¸­é”™è¯¯è¿‡å¤šï¼Œå·²å›æ»šæ‰€æœ‰æ›´æ”¹ã€‚é”™è¯? ${errors.take(5).join(', ')}',
          );
        }

        print('ğŸ‰ æ‰€æœ‰è¡¨æ•°æ®å¯¼å…¥å®Œæˆ');
        print('æ€»å¯¼å…¥è®°å½•æ•°: ${importCounts.values.fold(0, (a, b) => a + b)}');
        print('æ€»é”™è¯¯æ•°: ${errors.length}');
        print('æ€»å†²çªæ•°: ${allConflicts.length}');
        onProgress?.call('æ•°æ®æ¢å¤å®Œæˆ', totalRecords, totalRecords);

        return importCounts;
      });
    } on RestoreCancelledException {
      // å–æ¶ˆæ“ä½œï¼Œäº‹åŠ¡ä¼šè‡ªåŠ¨å›æ»š
      rethrow;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'å¯¼å…¥æ•°æ®åº“è¡¨å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// å¯¼å…¥æ‰€æœ‰è¡¨æ•°æ®ï¼ˆåŸç‰ˆæœ¬ï¼Œä¿æŒå‘åå…¼å®¹ï¼‰
  Future<Map<String, int>> importAllTablesLegacy(
    Map<String, List<Map<String, dynamic>>> tablesData,
    RestoreMode mode, {
    List<String>? selectedTables,
  }) async {
    return importAllTables(tablesData, mode, selectedTables: selectedTables);
  }

  /// å¯¼å…¥æŒ‡å®šè¡¨çš„æ•°æ®ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒè¿›åº¦è·Ÿè¸ªï¼?
  /// [tableName] è¡¨å
  /// [records] è¦å¯¼å…¥çš„è®°å½•åˆ—è¡¨
  /// [mode] æ¢å¤æ¨¡å¼
  /// [onProgress] è¿›åº¦å›è°ƒå‡½æ•°
  /// [cancelToken] å–æ¶ˆä»¤ç‰Œ
  /// [batchSize] æ‰¹å¤„ç†å¤§å°ï¼Œé»˜è®¤100æ¡è®°å½?
  Future<BatchResult> _importTableWithProgress(
    String tableName,
    List<Map<String, dynamic>> records,
    RestoreMode mode, {
    void Function(int current, int total)? onProgress,
    CancelToken? cancelToken,
    int batchSize = 100,
  }) async {
    print('ğŸ”„ å¼€å§‹å¯¼å…¥è¡¨: $tableName');
    print('è®°å½•æ€»æ•°: ${records.length}');
    print('æ‰¹å¤„ç†å¤§å°? $batchSize');
    print('é¢„è®¡æ‰¹æ¬¡æ•? ${(records.length / batchSize).ceil()}');
    try {
      int successCount = 0;
      final List<String> errors = [];
      final List<DataConflict> conflicts = [];

      // åˆ†æ‰¹å¤„ç†è®°å½•
      for (int i = 0; i < records.length; i += batchSize) {
        cancelToken?.throwIfCancelled();

        final batch = records.skip(i).take(batchSize).toList();
        final batchNumber = (i / batchSize).floor() + 1;
        final totalBatches = (records.length / batchSize).ceil();

        print(
          'ğŸ“¦ å¤„ç†æ‰¹æ¬¡ $batchNumber/$totalBatches (è®°å½• ${i + 1}-${(i + batch.length).clamp(0, records.length)})',
        );
        onProgress?.call(i, records.length);

        final batchResult = await _importTableBatchEnhanced(
          tableName,
          batch,
          mode,
        );
        successCount += batchResult.successCount;
        errors.addAll(batchResult.errors);
        conflicts.addAll(batchResult.conflicts);

        print(
          'âœ?æ‰¹æ¬¡ $batchNumber å®Œæˆ - æˆåŠŸ: ${batchResult.successCount}, å¤±è´¥: ${batchResult.failureCount}',
        );
      }

      onProgress?.call(records.length, records.length);

      return BatchResult(
        successCount: successCount,
        failureCount: records.length - successCount,
        errors: errors,
        conflicts: conflicts,
      );
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'å¯¼å…¥è¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  // Removed unused method _importTable - functionality is covered by _importTableWithProgress

  /// åˆ†æ‰¹å¯¼å…¥è¡¨æ•°æ®ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒå†²çªæ£€æµ‹ï¼‰
  /// [tableName] è¡¨å
  /// [records] è®°å½•åˆ—è¡¨
  /// [mode] æ¢å¤æ¨¡å¼
  Future<BatchResult> _importTableBatchEnhanced(
    String tableName,
    List<Map<String, dynamic>> records,
    RestoreMode mode,
  ) async {
    print('ğŸ” å¼€å§‹æ‰¹é‡å¯¼å…?- è¡? $tableName, è®°å½•æ•? ${records.length}');
    try {
      int successCount = 0;
      final List<String> errors = [];
      final List<DataConflict> conflicts = [];

      // è·å–ä¸»é”®ä¿¡æ¯ç”¨äºå†²çªæ£€æµ?
      final primaryKey = await _getPrimaryKeyColumn(tableName);
      print('ğŸ”‘ è¡?$tableName çš„ä¸»é”? ${primaryKey ?? "æ— ä¸»é”?}');

      for (int i = 0; i < records.length; i++) {
        final record = records[i];
        try {
          print(
            'ğŸ“ å¤„ç†è®°å½• ${i + 1}/${records.length}: ${record.keys.take(3).join(", ")}...',
          );

          final result = await _importRecordWithConflictDetection(
            tableName,
            record,
            mode,
            primaryKey,
          );

          if (result['success'] == true) {
            successCount++;
            print('âœ?è®°å½• ${i + 1} å¯¼å…¥æˆåŠŸ');
          } else {
            print('â?è®°å½• ${i + 1} å¯¼å…¥å¤±è´¥: ${result['error']}');
          }

          if (result['conflict'] != null) {
            conflicts.add(result['conflict'] as DataConflict);
            print('âš ï¸ è®°å½• ${i + 1} å­˜åœ¨å†²çª');
          }
        } catch (e) {
          final errorMsg = 'å¯¼å…¥è®°å½•å¤±è´¥: ${e.toString()}';
          errors.add(errorMsg);
          print('ğŸ’¥ è®°å½• ${i + 1} å¼‚å¸¸: $errorMsg');
        }
      }

      return BatchResult(
        successCount: successCount,
        failureCount: records.length - successCount,
        errors: errors,
        conflicts: conflicts,
      );
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'åˆ†æ‰¹å¯¼å…¥è¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  // Removed unused method _importTableBatch - functionality is covered by _importTableBatchEnhanced

  /// å¯¼å…¥å•æ¡è®°å½•ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒå†²çªæ£€æµ‹ï¼‰
  /// [tableName] è¡¨å
  /// [record] è®°å½•æ•°æ®
  /// [mode] æ¢å¤æ¨¡å¼
  /// [primaryKey] ä¸»é”®åˆ—å
  /// è¿”å›åŒ…å«æˆåŠŸçŠ¶æ€å’Œå†²çªä¿¡æ¯çš„Map
  Future<Map<String, dynamic>> _importRecordWithConflictDetection(
    String tableName,
    Map<String, dynamic> record,
    RestoreMode mode,
    String? primaryKey,
  ) async {
    final primaryKeyValue = primaryKey != null ? record[primaryKey] : null;
    print('ğŸ¯ å¯¼å…¥è®°å½•åˆ°è¡¨ $tableName - ä¸»é”®å€? $primaryKeyValue - æ¨¡å¼: $mode');
    try {
      switch (mode) {
        case RestoreMode.replace:
          // å®Œå…¨æ›¿æ¢æ¨¡å¼ï¼šç›´æ¥æ’å…¥ï¼ˆè¡¨å·²æ¸…ç©ºï¼?
          print('ğŸ”„ æ›¿æ¢æ¨¡å¼ï¼šç›´æ¥æ’å…¥è®°å½?);
          await _insertRecord(tableName, record);
          print('âœ?æ›¿æ¢æ¨¡å¼ï¼šè®°å½•æ’å…¥æˆåŠ?);
          return {'success': true};

        case RestoreMode.merge:
          // åˆå¹¶æ¨¡å¼ï¼šæ£€æµ‹å†²çªå¹¶å¤„ç†
          print('ğŸ”„ åˆå¹¶æ¨¡å¼ï¼šæ£€æµ‹å†²çªå¹¶å¤„ç†');
          final result = await _upsertRecordWithConflictDetection(
            tableName,
            record,
            primaryKey,
          );
          print('âœ?åˆå¹¶æ¨¡å¼ï¼šå¤„ç†å®Œæˆ?- æˆåŠŸ: ${result['success']}');
          return result;

        case RestoreMode.addOnly:
          // ä»…æ·»åŠ æ¨¡å¼ï¼šæ£€æµ‹å†²çªå¹¶è·³è¿‡
          print('ğŸ”„ ä»…æ·»åŠ æ¨¡å¼ï¼šæ£€æµ‹å†²çªå¹¶è·³è¿‡');
          final result = await _insertIfNotExistsWithConflictDetection(
            tableName,
            record,
            primaryKey,
          );
          print('âœ?ä»…æ·»åŠ æ¨¡å¼ï¼šå¤„ç†å®Œæˆ - æˆåŠŸ: ${result['success']}');
          return result;
      }
    } catch (e) {
      final errorMsg = e.toString();
      print('ğŸ’¥ å¯¼å…¥è®°å½•å¼‚å¸¸: $errorMsg');
      return {'success': false, 'error': errorMsg};
    }
  }

  // Removed unused method _importRecord - functionality is covered by _importRecordWithConflictDetection

  /// æ’å…¥è®°å½•
  Future<void> _insertRecord(
    String tableName,
    Map<String, dynamic> record,
  ) async {
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    print('ğŸ”¥ æ‰§è¡Œæ•°æ®åº“æ’å…¥æ“ä½?);
    print('è¡¨å: $tableName');
    print('è®°å½•å­—æ®µ: ${record.keys.toList()}');
    print('è®°å½•å€? ${record.values.toList()}');

    // è·å–è¡¨çš„å®é™…åˆ—ä¿¡æ¯ï¼Œè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„åˆ—
    final validColumns = await _getValidColumnsForTable(tableName, record);

    final columns = validColumns.keys.join(', ');
    final placeholders = validColumns.keys.map((_) => '?').join(', ');
    final values = validColumns.values.toList();

    final query = 'INSERT INTO $tableName ($columns) VALUES ($placeholders)';
    print('SQLè¯­å¥: $query');
    print('å‚æ•°å€? $values');

    try {
      print('â?å¼€å§‹æ‰§è¡?_database.customStatement()...');
      await _database.customStatement(query, values);
      print('ğŸ‰ _database.customStatement() æ‰§è¡ŒæˆåŠŸï¼?);
      print('âœ?è®°å½•å·²æˆåŠŸæ’å…¥åˆ°è¡?$tableName');
    } catch (e) {
      print('ğŸ’¥ _database.customStatement() æ‰§è¡Œå¤±è´¥ï¼?);
      print('é”™è¯¯ä¿¡æ¯: ${e.toString()}');
      print('é”™è¯¯ç±»å‹: ${e.runtimeType}');
      rethrow;
    }
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
  }

  /// æ›´æ–°æˆ–æ’å…¥è®°å½•ï¼ˆUPSERTï¼‰å¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒå†²çªæ£€æµ?
  Future<Map<String, dynamic>> _upsertRecordWithConflictDetection(
    String tableName,
    Map<String, dynamic> record,
    String? primaryKey,
  ) async {
    try {
      if (primaryKey == null || !record.containsKey(primaryKey)) {
        // æ²¡æœ‰ä¸»é”®ä¿¡æ¯ï¼Œç›´æ¥æ’å…?
        await _insertRecord(tableName, record);
        return {'success': true};
      }

      // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ?
      final existingRecord = await _getExistingRecord(
        tableName,
        primaryKey,
        record[primaryKey],
      );

      if (existingRecord != null) {
        // è®°å½•å­˜åœ¨ï¼Œæ£€æµ‹å†²çª?
        final hasConflict = _detectDataConflict(existingRecord, record);

        DataConflict? conflict;
        if (hasConflict) {
          conflict = DataConflict(
            tableName: tableName,
            primaryKey: primaryKey,
            primaryKeyValue: record[primaryKey],
            existingRecord: existingRecord,
            newRecord: record,
            resolution: ConflictResolution.overwrite,
          );
        }

        // æ›´æ–°è®°å½•
        await _updateRecord(tableName, record, primaryKey);

        return {'success': true, 'conflict': conflict};
      } else {
        // è®°å½•ä¸å­˜åœ¨ï¼Œæ’å…¥
        await _insertRecord(tableName, record);
        return {'success': true};
      }
    } catch (e) {
      return {'success': false, 'error': e.toString()};
    }
  }

  /// ä»…åœ¨è®°å½•ä¸å­˜åœ¨æ—¶æ’å…¥ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒå†²çªæ£€æµ‹ï¼‰
  Future<Map<String, dynamic>> _insertIfNotExistsWithConflictDetection(
    String tableName,
    Map<String, dynamic> record,
    String? primaryKey,
  ) async {
    try {
      if (primaryKey == null || !record.containsKey(primaryKey)) {
        // æ²¡æœ‰ä¸»é”®ä¿¡æ¯ï¼Œå°è¯•æ’å…?
        await _insertRecord(tableName, record);
        return {'success': true};
      }

      // æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ?
      final existingRecord = await _getExistingRecord(
        tableName,
        primaryKey,
        record[primaryKey],
      );

      if (existingRecord == null) {
        await _insertRecord(tableName, record);
        return {'success': true};
      } else {
        // è®°å½•å·²å­˜åœ¨ï¼Œåˆ›å»ºå†²çªä¿¡æ¯
        final conflict = DataConflict(
          tableName: tableName,
          primaryKey: primaryKey,
          primaryKeyValue: record[primaryKey],
          existingRecord: existingRecord,
          newRecord: record,
          resolution: ConflictResolution.skip,
        );

        return {
          'success': true, // åœ¨AddOnlyæ¨¡å¼ä¸‹ï¼Œè®°å½•å·²å­˜åœ¨æ˜¯é¢„æœŸè¡Œä¸ºï¼Œåº”è§†ä¸ºæˆåŠŸ
          'conflict': conflict,
        };
      }
    } catch (e) {
      return {'success': false, 'error': e.toString()};
    }
  }

  /// æ›´æ–°è®°å½•
  Future<void> _updateRecord(
    String tableName,
    Map<String, dynamic> record,
    String primaryKey,
  ) async {
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    print('ğŸ”„ æ‰§è¡Œæ•°æ®åº“æ›´æ–°æ“ä½?);
    print('è¡¨å: $tableName');
    print('ä¸»é”®: $primaryKey = ${record[primaryKey]}');
    print('æ›´æ–°å­—æ®µ: ${record.keys.where((key) => key != primaryKey).toList()}');

    // è·å–è¡¨çš„å®é™…åˆ—ä¿¡æ¯ï¼Œè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„åˆ—
    final validColumns = await _getValidColumnsForTable(tableName, record);

    final updateColumns = validColumns.keys
        .where((key) => key != primaryKey)
        .map((key) => '$key = ?')
        .join(', ');

    final values = validColumns.entries
        .where((entry) => entry.key != primaryKey)
        .map((entry) => entry.value)
        .toList();

    values.add(validColumns[primaryKey]);

    final query = 'UPDATE $tableName SET $updateColumns WHERE $primaryKey = ?';
    print('SQLè¯­å¥: $query');
    print('å‚æ•°å€? $values');

    try {
      print('â?å¼€å§‹æ‰§è¡?_database.customStatement()...');
      await _database.customStatement(query, values);
      print('ğŸ‰ _database.customStatement() æ‰§è¡ŒæˆåŠŸï¼?);
      print('âœ?è®°å½•å·²æˆåŠŸæ›´æ–°åˆ°è¡?$tableName');
    } catch (e) {
      print('ğŸ’¥ _database.customStatement() æ‰§è¡Œå¤±è´¥ï¼?);
      print('é”™è¯¯ä¿¡æ¯: ${e.toString()}');
      print('é”™è¯¯ç±»å‹: ${e.runtimeType}');
      rethrow;
    }
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
  }

  /// æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ?
  Future<bool> _recordExists(
    String tableName,
    String primaryKey,
    dynamic value,
  ) async {
    final query = 'SELECT 1 FROM $tableName WHERE $primaryKey = ? LIMIT 1';
    final result = await _database
        .customSelect(query, variables: [_createVariable(value)])
        .getSingleOrNull();

    return result != null;
  }

  /// è·å–ç°æœ‰è®°å½•çš„å®Œæ•´æ•°æ?
  Future<Map<String, dynamic>?> _getExistingRecord(
    String tableName,
    String primaryKey,
    dynamic value,
  ) async {
    try {
      final query = 'SELECT * FROM $tableName WHERE $primaryKey = ? LIMIT 1';
      final result = await _database
          .customSelect(query, variables: [_createVariable(value)])
          .getSingleOrNull();

      return result?.data;
    } catch (e) {
      return null;
    }
  }

  /// æ£€æµ‹æ•°æ®å†²çª?
  /// æ¯”è¾ƒç°æœ‰è®°å½•å’Œæ–°è®°å½•ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å®è´¨æ€§å·®å¼?
  bool _detectDataConflict(
    Map<String, dynamic> existingRecord,
    Map<String, dynamic> newRecord,
  ) {
    // æ£€æŸ¥æ‰€æœ‰å­—æ®µæ˜¯å¦æœ‰å·®å¼‚
    for (final entry in newRecord.entries) {
      final key = entry.key;
      final newValue = entry.value;
      final existingValue = existingRecord[key];

      // è·³è¿‡nullå€¼æ¯”è¾?
      if (newValue == null && existingValue == null) {
        continue;
      }

      // å¦‚æœå€¼ä¸åŒï¼Œåˆ™å­˜åœ¨å†²çª?
      if (newValue != existingValue) {
        return true;
      }
    }

    return false;
  }

  /// è·å–è¡¨çš„ä¸»é”®åˆ—å
  Future<String?> _getPrimaryKeyColumn(String tableName) async {
    try {
      final query = 'PRAGMA table_info($tableName)';
      final result = await _database.customSelect(query).get();

      for (final row in result) {
        final data = row.data;
        if (data['pk'] == 1) {
          return data['name'] as String;
        }
      }

      return null;
    } catch (e) {
      return null;
    }
  }

  /// æ¸…ç©ºæŒ‡å®šè¡¨çš„æ•°æ®
  Future<void> _clearTables(List<String> tableNames) async {
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    print('ğŸ—‘ï¸?å¼€å§‹æ¸…ç©ºè¡¨æ•°æ®');
    print('éœ€è¦æ¸…ç©ºçš„è¡? $tableNames');

    try {
      // æŒ‰ç…§åå‘ä¾èµ–å…³ç³»é¡ºåºæ¸…ç©ºè¡¨ï¼ˆé¿å…å¤–é”®çº¦æŸé—®é¢˜ï¼?
      final clearOrder = _getTableImportOrder().reversed.toList();
      print('æ¸…ç©ºé¡ºåº: $clearOrder');

      for (final tableName in clearOrder) {
        if (tableNames.contains(tableName)) {
          print('ğŸ”„ æ¸…ç©ºè¡? $tableName');
          final query = 'DELETE FROM $tableName';
          print('SQLè¯­å¥: $query');

          try {
            print('â?å¼€å§‹æ‰§è¡?_database.customStatement()...');
            await _database.customStatement(query, []);
            print('ğŸ‰ _database.customStatement() æ‰§è¡ŒæˆåŠŸï¼?);
            print('âœ?è¡?$tableName å·²æ¸…ç©?);
          } catch (e) {
            print('ğŸ’¥ æ¸…ç©ºè¡?$tableName å¤±è´¥: ${e.toString()}');
            rethrow;
          }
        }
      }
      print('ğŸ‰ æ‰€æœ‰è¡¨æ¸…ç©ºå®Œæˆ');
    } catch (e) {
      print('ğŸ’¥ æ¸…ç©ºè¡¨æ•°æ®å¼‚å¸? ${e.toString()}');
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æ¸…ç©ºè¡¨æ•°æ®å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
  }

  /// è·å–è¡¨å¯¼å…¥é¡ºåºï¼ˆæŒ‰ç…§ä¾èµ–å…³ç³»ï¼?
  List<String> _getTableImportOrder() {
    return [
      // 1. åŸºç¡€æ•°æ®è¡¨ï¼ˆæ— å¤–é”®ä¾èµ–ï¼‰
      'category',
      'unit',
      'shop',
      'supplier',
      'customers',
      'locations',

      // 2. äº§å“ç›¸å…³è¡?
      'product',
      'unit_product',
      'barcode',
      'product_batch',

      // 3. åº“å­˜ç›¸å…³è¡?
      'stock',
      'inventory_transaction',

      // 4. ä¸šåŠ¡å•æ®è¡?
      'purchase_order',
      'purchase_order_item',
      'inbound_receipt',
      'inbound_item',
      'sales_transaction',
      'sales_transaction_item',
      'outbound_receipt',
      'outbound_item',
    ];
  }

  /// éªŒè¯å¯¼å…¥æ•°æ®çš„å®Œæ•´æ€?
  /// [tablesData] è¦éªŒè¯çš„è¡¨æ•°æ?
  /// è¿”å›éªŒè¯ç»“æœå’Œé”™è¯¯ä¿¡æ?
  Future<Map<String, dynamic>> validateImportData(
    Map<String, List<Map<String, dynamic>>> tablesData,
  ) async {
    final List<String> errors = [];
    final List<String> warnings = [];
    int totalRecords = 0;

    try {
      for (final entry in tablesData.entries) {
        final tableName = entry.key;
        final records = entry.value;

        totalRecords += records.length;

        // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        final tableExists = await _tableExists(tableName);
        if (!tableExists) {
          warnings.add('è¡?$tableName åœ¨å½“å‰æ•°æ®åº“ä¸­ä¸å­˜åœ¨ï¼Œå°†è·³è¿‡');
          continue;
        }

        // éªŒè¯è®°å½•ç»“æ„
        if (records.isNotEmpty) {
          final sampleRecord = records.first;
          final validationResult = await _validateRecordStructure(
            tableName,
            sampleRecord,
          );
          if (!validationResult['valid']) {
            errors.add('è¡?$tableName çš„è®°å½•ç»“æ„æ— æ•? ${validationResult['error']}');
          }
        }
      }

      return {
        'valid': errors.isEmpty,
        'errors': errors,
        'warnings': warnings,
        'totalRecords': totalRecords,
      };
    } catch (e) {
      return {
        'valid': false,
        'errors': ['éªŒè¯å¯¼å…¥æ•°æ®æ—¶å‘ç”Ÿé”™è¯? ${e.toString()}'],
        'warnings': warnings,
        'totalRecords': totalRecords,
      };
    }
  }

  /// æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
  Future<bool> _tableExists(String tableName) async {
    try {
      final query = '''
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
      ''';
      final result = await _database
          .customSelect(query, variables: [Variable.withString(tableName)])
          .getSingleOrNull();

      return result != null;
    } catch (e) {
      return false;
    }
  }

  /// éªŒè¯è®°å½•ç»“æ„
  Future<Map<String, dynamic>> _validateRecordStructure(
    String tableName,
    Map<String, dynamic> record,
  ) async {
    try {
      // è·å–è¡¨ç»“æ„ä¿¡æ?
      final query = 'PRAGMA table_info($tableName)';
      final result = await _database.customSelect(query).get();

      final tableColumns = <String, Map<String, dynamic>>{};
      for (final row in result) {
        final data = row.data;
        tableColumns[data['name'] as String] = {
          'type': data['type'],
          'notNull': data['notnull'] == 1,
          'defaultValue': data['dflt_value'],
        };
      }

      // æ£€æŸ¥å¿…éœ€å­—æ®µ
      for (final entry in tableColumns.entries) {
        final columnName = entry.key;
        final columnInfo = entry.value;

        if (columnInfo['notNull'] &&
            columnInfo['defaultValue'] == null &&
            !record.containsKey(columnName)) {
          return {'valid': false, 'error': 'ç¼ºå°‘å¿…éœ€å­—æ®µ: $columnName'};
        }
      }

      return {'valid': true};
    } catch (e) {
      return {'valid': false, 'error': 'éªŒè¯è®°å½•ç»“æ„å¤±è´¥: ${e.toString()}'};
    }
  }

  /// ä¼°ç®—å¯¼å…¥æ—¶é—´ï¼ˆç§’ï¼?
  /// [recordCount] è®°å½•æ€»æ•°
  /// [mode] æ¢å¤æ¨¡å¼
  Future<int> estimateImportTime(int recordCount, RestoreMode mode) async {
    try {
      // åŸºäºè®°å½•æ•°é‡å’Œæ¢å¤æ¨¡å¼ä¼°ç®—æ—¶é—?
      // è¿™äº›æ•°å€¼åŸºäºç»éªŒï¼Œå®é™…æƒ…å†µå¯èƒ½æœ‰æ‰€ä¸åŒ

      int baseTimePerRecord; // æ¯«ç§’

      switch (mode) {
        case RestoreMode.replace:
          baseTimePerRecord = 2; // æ›¿æ¢æ¨¡å¼æœ€å¿?
          break;
        case RestoreMode.merge:
          baseTimePerRecord = 5; // åˆå¹¶æ¨¡å¼éœ€è¦æ£€æŸ¥å’Œæ›´æ–°
          break;
        case RestoreMode.addOnly:
          baseTimePerRecord = 3; // ä»…æ·»åŠ æ¨¡å¼éœ€è¦æ£€æŸ¥å­˜åœ¨æ€?
          break;
      }

      final totalTimeMs = recordCount * baseTimePerRecord;
      final totalTimeSeconds = (totalTimeMs / 1000).ceil();

      // æœ€å°?ç§’ï¼Œæœ€å¤šä¸è¶…è¿‡3600ç§’ï¼ˆ1å°æ—¶ï¼?
      return totalTimeSeconds.clamp(1, 3600);
    } catch (e) {
      return 60; // é»˜è®¤ä¼°ç®—1åˆ†é’Ÿ
    }
  }

  /// è·å–å†²çªè®°å½•æ•°é‡ä¼°ç®—
  /// [tablesData] è¡¨æ•°æ?
  /// [mode] æ¢å¤æ¨¡å¼
  Future<int> estimateConflicts(
    Map<String, List<Map<String, dynamic>>> tablesData,
    RestoreMode mode,
  ) async {
    if (mode == RestoreMode.replace) {
      return 0; // æ›¿æ¢æ¨¡å¼æ²¡æœ‰å†²çª
    }

    try {
      int conflictCount = 0;

      for (final entry in tablesData.entries) {
        final tableName = entry.key;
        final records = entry.value;

        final primaryKey = await _getPrimaryKeyColumn(tableName);
        if (primaryKey == null) continue;

        // æ£€æŸ¥å‰100æ¡è®°å½•çš„å†²çªæƒ…å†µï¼Œç„¶åæŒ‰æ¯”ä¾‹ä¼°ç®—
        final sampleSize = records.length > 100 ? 100 : records.length;
        int sampleConflicts = 0;

        for (int i = 0; i < sampleSize; i++) {
          final record = records[i];
          if (record.containsKey(primaryKey)) {
            final exists = await _recordExists(
              tableName,
              primaryKey,
              record[primaryKey],
            );
            if (exists) {
              sampleConflicts++;
            }
          }
        }

        // æŒ‰æ¯”ä¾‹ä¼°ç®—æ€»å†²çªæ•°
        if (sampleSize > 0) {
          final conflictRatio = sampleConflicts / sampleSize;
          conflictCount += (records.length * conflictRatio).round();
        }
      }

      return conflictCount;
    } catch (e) {
      return 0; // ä¼°ç®—å¤±è´¥æ—¶è¿”å›?
    }
  }

  /// æ‰§è¡Œæ•°æ®åº“å¥åº·æ£€æŸ?
  /// åœ¨æ¢å¤å®ŒæˆåéªŒè¯æ•°æ®å®Œæ•´æ€?
  Future<Map<String, dynamic>> performHealthCheck(
    List<String> tablesToCheck,
  ) async {
    try {
      final Map<String, int> tableCounts = {};
      final List<String> issues = [];

      for (final tableName in tablesToCheck) {
        try {
          // æ£€æŸ¥è¡¨è®°å½•æ•?
          final countQuery = 'SELECT COUNT(*) as count FROM $tableName';
          final result = await _database.customSelect(countQuery).getSingle();
          final count = result.data['count'] as int;
          tableCounts[tableName] = count;

          // æ£€æŸ¥è¡¨ç»“æ„å®Œæ•´æ€?
          final integrityQuery = 'PRAGMA integrity_check($tableName)';
          final integrityResult = await _database
              .customSelect(integrityQuery)
              .get();

          for (final row in integrityResult) {
            final message = row.data.values.first as String;
            if (message != 'ok') {
              issues.add('è¡?$tableName å®Œæ•´æ€§æ£€æŸ¥å¤±è´? $message');
            }
          }
        } catch (e) {
          issues.add('æ£€æŸ¥è¡¨ $tableName æ—¶å‘ç”Ÿé”™è¯? ${e.toString()}');
        }
      }

      return {
        'success': issues.isEmpty,
        'tableCounts': tableCounts,
        'issues': issues,
      };
    } catch (e) {
      return {
        'success': false,
        'tableCounts': <String, int>{},
        'issues': ['å¥åº·æ£€æŸ¥å¤±è´? ${e.toString()}'],
      };
    }
  }

  /// åˆ›å»ºæ¢å¤ç‚¹ï¼ˆç”¨äºå›æ»šï¼?
  /// åœ¨å¼€å§‹æ¢å¤å‰åˆ›å»ºæ•°æ®å¿«ç…§
  Future<String?> createRestorePoint(List<String> tablesToBackup) async {
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final restorePointId = 'restore_point_$timestamp';

      // è¿™é‡Œå¯ä»¥å®ç°åˆ›å»ºä¸´æ—¶å¤‡ä»½è¡¨çš„é€»è¾‘
      // ç”±äºå¤æ‚æ€§ï¼Œæš‚æ—¶è¿”å›æ ‡è¯†ç¬?
      // å®é™…å®ç°ä¸­å¯ä»¥åˆ›å»ºä¸´æ—¶è¡¨æˆ–æ–‡ä»¶å¤‡ä»?

      return restorePointId;
    } catch (e) {
      return null;
    }
  }

  /// å›æ»šåˆ°æ¢å¤ç‚¹
  /// åœ¨æ¢å¤å¤±è´¥æ—¶å›æ»šæ•°æ®
  Future<bool> rollbackToRestorePoint(String restorePointId) async {
    try {
      // è¿™é‡Œå¯ä»¥å®ç°ä»æ¢å¤ç‚¹å›æ»šçš„é€»è¾‘
      // ç”±äºå¤æ‚æ€§ï¼Œæš‚æ—¶è¿”å›æˆåŠŸ
      // å®é™…å®ç°ä¸­å¯ä»¥ä»ä¸´æ—¶è¡¨æˆ–æ–‡ä»¶æ¢å¤æ•°æ®

      return true;
    } catch (e) {
      return false;
    }
  }

  /// è·å–è¡¨çš„æœ‰æ•ˆåˆ—ï¼ˆè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„åˆ—ï¼?
  /// [tableName] è¡¨å
  /// [record] è¦æ’å…?æ›´æ–°çš„è®°å½?
  /// è¿”å›è¿‡æ»¤åçš„æœ‰æ•ˆåˆ—æ•°æ?
  Future<Map<String, dynamic>> _getValidColumnsForTable(
    String tableName,
    Map<String, dynamic> record,
  ) async {
    try {
      // è·å–è¡¨ç»“æ„ä¿¡æ?
      final query = 'PRAGMA table_info($tableName)';
      final result = await _database.customSelect(query).get();

      final validColumnNames = <String>{};
      for (final row in result) {
        final data = row.data;
        validColumnNames.add(data['name'] as String);
      }

      // è¿‡æ»¤æ‰ä¸å­˜åœ¨çš„åˆ—
      final validColumns = <String, dynamic>{};
      for (final entry in record.entries) {
        if (validColumnNames.contains(entry.key)) {
          validColumns[entry.key] = entry.value;
        } else {
          print('âš ï¸ è·³è¿‡ä¸å­˜åœ¨çš„åˆ? ${entry.key} (è¡? $tableName)');
        }
      }

      print('ğŸ“‹ è¡?$tableName æœ‰æ•ˆåˆ? ${validColumns.keys.toList()}');
      return validColumns;
    } catch (e) {
      print('ğŸ’¥ è·å–è¡¨ç»“æ„å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹è®°å½•: ${e.toString()}');
      // å¦‚æœè·å–è¡¨ç»“æ„å¤±è´¥ï¼Œè¿”å›åŸå§‹è®°å½•
      return record;
    }
  }

  /// åˆ›å»ºé€‚å½“ç±»å‹çš?Variable å¯¹è±¡
  /// é¿å…ç±»å‹æ¨æ–­é”™è¯¯å¯¼è‡´çš„è§£æå¼‚å¸?
  Variable _createVariable(dynamic value) {
    if (value == null) {
      return const Variable(null);
    } else if (value is int) {
      return Variable.withInt(value);
    } else if (value is double) {
      return Variable.withReal(value);
    } else if (value is bool) {
      return Variable.withBool(value);
    } else if (value is DateTime) {
      return Variable.withDateTime(value);
    } else {
      // å¯¹äºå­—ç¬¦ä¸²å’Œå…¶ä»–ç±»å‹ï¼Œä½¿ç”?withString ç¡®ä¿æ­£ç¡®å¤„ç†
      return Variable.withString(value.toString());
    }
  }
}
import 'dart:convert';
import 'dart:async';
import 'package:crypto/crypto.dart';
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/models/performance_metrics.dart';
import '../../domain/services/i_performance_service.dart';
import '../services/performance_service.dart';

/// ä¼˜åŒ–çš„æ•°æ®å¯¼å‡ºä»“å‚¨ç±»
/// æ”¯æŒæµå¼å¤„ç†å’Œæ€§èƒ½ç›‘æ§
class OptimizedDataExportRepository {
  final AppDatabase _database;
  final IPerformanceService _performanceService;

  OptimizedDataExportRepository(
    this._database, {
    IPerformanceService? performanceService,
  }) : _performanceService = performanceService ?? PerformanceService();

  /// æµå¼å¯¼å‡ºæ‰€æœ‰è¡¨æ•°æ®
  /// ä½¿ç”¨å¼‚æ­¥ç”Ÿæˆå™¨å®ç°å†…å­˜å‹å¥½çš„æ•°æ®å¯¼å‡º
  Stream<MapEntry<String, List<Map<String, dynamic>>>> streamExportAllTables({
    StreamProcessingConfig? config,
    void Function(String tableName, int processed, int total)? onProgress,
  }) async* {
    final streamConfig = config ?? const StreamProcessingConfig();
    final operationId =
        'stream_export_all_${DateTime.now().millisecondsSinceEpoch}';

    try {
      final tableNames = await getAllTableNames();
      await _performanceService.startMonitoring(operationId, tableNames.length);

      int processedTables = 0;

      for (final tableName in _getTableExportOrder()) {
        if (!tableNames.contains(tableName)) continue;

        final tableData = <Map<String, dynamic>>[];
        final totalRecords = await _getTableCount(tableName);

        await for (final batch in _streamExportTable(tableName, streamConfig)) {
          tableData.addAll(batch);
          onProgress?.call(tableName, tableData.length, totalRecords);

          // å®šæœŸæ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
          if (streamConfig.enableMemoryMonitoring &&
              tableData.length % 1000 == 0) {
            await _performanceService.recordMemoryUsage(operationId);
          }
        }

        yield MapEntry(tableName, tableData);

        processedTables++;
        await _performanceService.updateProgress(operationId, processedTables);
      }

      await _performanceService.endMonitoring(operationId);
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æµå¼å¯¼å‡ºæ•°æ®åº“è¡¨å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æµå¼å¯¼å‡ºæŒ‡å®šè¡¨çš„æ•°æ®
  Stream<List<Map<String, dynamic>>> _streamExportTable(
    String tableName,
    StreamProcessingConfig config,
  ) async* {
    try {
      int offset = 0;
      bool hasMoreData = true;

      while (hasMoreData) {
        final batch = await _exportTableBatch(
          tableName,
          offset,
          config.batchSize,
        );

        if (batch.isEmpty) {
          hasMoreData = false;
          break;
        }

        yield batch;

        hasMoreData = batch.length == config.batchSize;
        offset += config.batchSize;

        // å°å»¶è¿Ÿä»¥é¿å…é˜»å¡UIçº¿ç¨‹
        await Future.delayed(const Duration(microseconds: 100));
      }
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æµå¼å¯¼å‡ºè¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// åˆ†æ‰¹å¯¼å‡ºè¡¨æ•°æ®ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼?
  Future<List<Map<String, dynamic>>> _exportTableBatch(
    String tableName,
    int offset,
    int limit,
  ) async {
    try {
      // ä½¿ç”¨é¢„ç¼–è¯‘æŸ¥è¯¢æé«˜æ€§èƒ½
      final query = 'SELECT * FROM $tableName LIMIT $limit OFFSET $offset';
      final result = await _database.customSelect(query).get();

      // ä¼˜åŒ–æ•°æ®è½¬æ¢
      return result.map((row) {
        final data = <String, dynamic>{};
        for (final entry in row.data.entries) {
          // åªåŒ…å«énullå€¼ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
          if (entry.value != null) {
            data[entry.key] = entry.value;
          }
        }
        return data;
      }).toList();
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'åˆ†æ‰¹å¯¼å‡ºè¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// è·å–è¡¨è®°å½•æ•°é‡ç»Ÿè®¡ï¼ˆç¼“å­˜ç‰ˆæœ¬ï¼?
  Future<Map<String, int>> getTableCounts() async {
    try {
      final Map<String, int> counts = {};
      final tableNames = _getTableExportOrder();

      // ä½¿ç”¨å¹¶å‘æŸ¥è¯¢æé«˜æ€§èƒ½
      final futures = tableNames.map((tableName) async {
        final count = await _getTableCount(tableName);
        return MapEntry(tableName, count);
      });

      final results = await Future.wait(futures);
      for (final result in results) {
        counts[result.key] = result.value;
      }

      return counts;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'è·å–è¡¨è®°å½•æ•°é‡å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// è·å–æŒ‡å®šè¡¨çš„è®°å½•æ•°é‡ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
  Future<int> _getTableCount(String tableName) async {
    try {
      // ä½¿ç”¨COUNT(1)è€Œä¸æ˜¯COUNT(*)ä»¥æé«˜æ€§èƒ½
      final query = 'SELECT COUNT(1) as count FROM $tableName';
      final result = await _database.customSelect(query).getSingle();
      return result.data['count'] as int;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'è·å–è¡?$tableName è®°å½•æ•°é‡å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// ä¼˜åŒ–çš„JSONåºåˆ—åŒ?
  /// æ”¯æŒæµå¼åºåˆ—åŒ–ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
  Stream<String> streamSerializeToJson(
    Map<String, dynamic> data, {
    bool prettyPrint = false,
  }) async* {
    try {
      const chunkSize = 1000; // æ¯æ¬¡å¤„ç†çš„æ¡ç›®æ•°

      yield '{\n';

      bool isFirst = true;
      int processedEntries = 0;

      for (final entry in data.entries) {
        if (!isFirst) {
          yield ',\n';
        }
        isFirst = false;

        // åºåˆ—åŒ–é”®
        final keyJson = jsonEncode(entry.key);
        yield prettyPrint ? '  $keyJson: ' : '$keyJson:';

        // åºåˆ—åŒ–å€?
        if (entry.value is List && (entry.value as List).length > chunkSize) {
          // å¤§åˆ—è¡¨åˆ†å—åºåˆ—åŒ–
          yield* _streamSerializeList(entry.value as List, prettyPrint);
        } else {
          final valueJson = jsonEncode(entry.value);
          yield valueJson;
        }

        processedEntries++;

        // å®šæœŸè®©å‡ºæ§åˆ¶æ?
        if (processedEntries % 100 == 0) {
          await Future.delayed(const Duration(microseconds: 1));
        }
      }

      yield prettyPrint ? '\n}' : '}';
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.serializationError,
        message: 'æµå¼JSONåºåˆ—åŒ–å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æµå¼åºåˆ—åŒ–åˆ—è¡?
  Stream<String> _streamSerializeList(List list, bool prettyPrint) async* {
    yield '[';

    for (int i = 0; i < list.length; i++) {
      if (i > 0) {
        yield ',';
      }

      if (prettyPrint && i % 10 == 0) {
        yield '\n    ';
      }

      yield jsonEncode(list[i]);

      // å®šæœŸè®©å‡ºæ§åˆ¶æ?
      if (i % 100 == 0) {
        await Future.delayed(const Duration(microseconds: 1));
      }
    }

    yield prettyPrint ? '\n  ]' : ']';
  }

  /// ä¼˜åŒ–çš„æ ¡éªŒå’Œç”Ÿæˆ
  /// æ”¯æŒæµå¼è®¡ç®—ä»¥å¤„ç†å¤§æ•°æ®
  Future<String> generateChecksumStream(Stream<String> dataStream) async {
    try {
      final chunks = <int>[];

      await for (final chunk in dataStream) {
        chunks.addAll(utf8.encode(chunk));
      }

      final digest = sha256.convert(chunks);
      return digest.toString();
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'ç”Ÿæˆæµå¼æ ¡éªŒå’Œå¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// è·å–è¡¨å¯¼å‡ºé¡ºåºï¼ˆæŒ‰ä¾èµ–å…³ç³»ï¼‰
  List<String> _getTableExportOrder() {
    return [
      // åŸºç¡€æ•°æ®è¡¨ï¼ˆæ— å¤–é”®ä¾èµ–ï¼‰
      'category',
      'unit',
      'shop',
      'supplier',
      'customers',
      'locations',

      // äº§å“ç›¸å…³è¡?
      'product',
      'unit_product',
      'barcode',
      'product_batch',

      // åº“å­˜ç›¸å…³è¡?
      'stock',
      'inventory_transaction',

      // ä¸šåŠ¡å•æ®è¡?
      'purchase_order',
      'purchase_order_item',
      'inbound_receipt',
      'inbound_item',
      'sales_transaction',
      'sales_transaction_item',
      'outbound_receipt',
      'outbound_item',
    ];
  }

  /// è·å–æ‰€æœ‰è¡¨å?
  Future<List<String>> getAllTableNames() async {
    try {
      const query = '''
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name NOT LIKE 'sqlite_%'
        ORDER BY name
      ''';
      final result = await _database.customSelect(query).get();

      return result.map((row) => row.data['name'] as String).toList();
    } catch (e) {
      // åœ¨æµ‹è¯•ç¯å¢ƒä¸­è¿”å›ç©ºåˆ—è¡¨è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸ï¼ˆå‘åå…¼å®¹ï¼?
      return <String>[];
    }
  }

  /// ä¼°ç®—å¯¼å‡ºæ•°æ®å¤§å°ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
  Future<int> estimateExportSize() async {
    try {
      final tableCounts = await getTableCounts();
      int estimatedSize = 0;

      // åŸºäºè¡¨ç±»å‹çš„æ›´ç²¾ç¡®ä¼°ç®?
      const tableEstimates = {
        'product': 800, // äº§å“è¡¨è®°å½•è¾ƒå¤?
        'sales_transaction': 600, // é”€å”®è®°å½•ä¸­ç­?
        'inventory_transaction': 400, // åº“å­˜è®°å½•è¾ƒå°
        'category': 200, // åˆ†ç±»è®°å½•å¾ˆå°
        'unit': 150, // å•ä½è®°å½•å¾ˆå°
      };

      for (final entry in tableCounts.entries) {
        final tableName = entry.key;
        final count = entry.value;
        final avgSize = tableEstimates[tableName] ?? 500; // é»˜è®¤500å­—èŠ‚

        estimatedSize += count * avgSize;
      }

      // æ·»åŠ JSONç»“æ„å¼€é”€
      estimatedSize = (estimatedSize * 1.15).round();

      return estimatedSize;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'ä¼°ç®—å¯¼å‡ºå¤§å°å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// è·å–æ•°æ®åº“æ¶æ„ç‰ˆæœ?
  Future<int> getDatabaseSchemaVersion() async {
    try {
      return _database.schemaVersion;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'è·å–æ•°æ®åº“æ¶æ„ç‰ˆæœ¬å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// ä¼ ç»Ÿçš„å¯¼å‡ºæ‰€æœ‰è¡¨æ•°æ®æ–¹æ³•ï¼ˆå‘åå…¼å®¹ï¼‰
  /// è¿”å›åŒ…å«æ‰€æœ‰è¡¨æ•°æ®çš„Mapï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
  Future<Map<String, List<Map<String, dynamic>>>> exportAllTables() async {
    try {
      final Map<String, List<Map<String, dynamic>>> allTablesData = {};

      // æŒ‰ç…§ä¾èµ–å…³ç³»é¡ºåºå¯¼å‡ºè¡¨æ•°æ?
      for (final tableName in _getTableExportOrder()) {
        final tableData = <Map<String, dynamic>>[];
        await for (final batch in _streamExportTable(
          tableName,
          const StreamProcessingConfig(),
        )) {
          tableData.addAll(batch);
        }
        allTablesData[tableName] = tableData;
      }

      return allTablesData;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'å¯¼å‡ºæ•°æ®åº“è¡¨å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// åºåˆ—åŒ–æ•°æ®ä¸ºJSONæ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰
  /// [data] è¦åºåˆ—åŒ–çš„æ•°æ?
  /// [prettyPrint] æ˜¯å¦æ ¼å¼åŒ–è¾“å‡ºï¼Œé»˜è®¤false
  String serializeToJson(
    Map<String, dynamic> data, {
    bool prettyPrint = false,
  }) {
    try {
      if (prettyPrint) {
        const encoder = JsonEncoder.withIndent('  ');
        return encoder.convert(data);
      } else {
        return jsonEncode(data);
      }
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.serializationError,
        message: 'JSONåºåˆ—åŒ–å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// ç”Ÿæˆæ•°æ®å®Œæ•´æ€§æ ¡éªŒå’Œ
  /// [data] è¦æ ¡éªŒçš„æ•°æ®
  /// è¿”å›SHA-256æ ¡éªŒå’?
  String generateChecksum(String data) {
    try {
      final bytes = utf8.encode(data);
      final digest = sha256.convert(bytes);
      return digest.toString();
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'ç”Ÿæˆæ ¡éªŒå’Œå¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// éªŒè¯æ•°æ®å®Œæ•´æ€?
  /// [data] åŸå§‹æ•°æ®
  /// [expectedChecksum] æœŸæœ›çš„æ ¡éªŒå’Œ
  /// è¿”å›éªŒè¯ç»“æœ
  bool validateChecksum(String data, String expectedChecksum) {
    try {
      final actualChecksum = generateChecksum(data);
      return actualChecksum == expectedChecksum;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'éªŒè¯æ ¡éªŒå’Œå¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
  /// [tableName] è¡¨å
  Future<bool> tableExists(String tableName) async {
    try {
      final query = '''
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
      ''';
      final result = await _database
          .customSelect(query, variables: [Variable.withString(tableName)])
          .getSingleOrNull();

      return result != null;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æ£€æŸ¥è¡¨ $tableName æ˜¯å¦å­˜åœ¨å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æµ‹è¯•æ•°æ®åº“è¿æ?
  Future<void> testConnection() async {
    try {
      await _database.customSelect('SELECT 1').getSingle();
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æ£€æŸ¥æ•°æ®åº“å®Œæ•´æ€?
  Future<bool> checkDatabaseIntegrity() async {
    try {
      final result = await _database
          .customSelect('PRAGMA integrity_check')
          .getSingle();
      return result.data['integrity_check'] == 'ok';
    } catch (e) {
      return false;
    }
  }

  /// æ£€æŸ¥æ˜¯å¦æœ‰é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ¡
  Future<bool> checkLongRunningTransactions() async {
    try {
      // SQLiteæ²¡æœ‰ç›´æ¥çš„æ–¹æ³•æ£€æŸ¥é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ?
      // è¿™é‡Œè¿”å›falseè¡¨ç¤ºæ²¡æœ‰é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ¡
      return false;
    } catch (e) {
      return false;
    }
  }

  /// æ£€æŸ¥æ•°æ®åº“æ˜¯å¦è¢«é”å®?
  Future<bool> isDatabaseLocked() async {
    try {
      await _database.customSelect('SELECT 1').getSingle();
      return false;
    } catch (e) {
      return true;
    }
  }

  /// è·å–è¡¨çš„è¡Œæ•°
  Future<int> getTableRowCount(String tableName) async {
    try {
      final query = 'SELECT COUNT(*) as count FROM $tableName';
      final result = await _database.customSelect(query).getSingle();
      return result.data['count'] as int;
    } catch (e) {
      return 0;
    }
  }

  /// åˆ†æ‰¹å¯¼å‡ºè¡¨æ•°æ®ï¼ˆå…¬å¼€æ–¹æ³•ï¼?
  Future<List<Map<String, dynamic>>> exportTableBatch(
    String tableName, {
    required int offset,
    required int limit,
  }) async {
    return await _exportTableBatch(tableName, offset, limit);
  }
}
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../domain/models/auto_backup_settings.dart';
import '../../domain/services/i_backup_service.dart';
import '../../domain/models/backup_options.dart' as backup_models;
import 'backup_notification_service.dart';

/// è‡ªåŠ¨å¤‡ä»½è°ƒåº¦å™?
class AutoBackupScheduler {
  static const String _settingsKey = 'auto_backup_settings';

  final IBackupService _backupService;
  Timer? _schedulerTimer;
  AutoBackupSettings _currentSettings = const AutoBackupSettings();

  AutoBackupScheduler(this._backupService);

  /// åˆå§‹åŒ–è°ƒåº¦å™¨
  Future<void> initialize() async {
    await _loadSettings();
    await _startScheduler();
  }

  /// è·å–å½“å‰è‡ªåŠ¨å¤‡ä»½è®¾ç½®
  AutoBackupSettings get currentSettings => _currentSettings;

  /// æ›´æ–°è‡ªåŠ¨å¤‡ä»½è®¾ç½®
  Future<void> updateSettings(AutoBackupSettings settings) async {
    _currentSettings = settings;
    await _saveSettings();

    // é‡æ–°å¯åŠ¨è°ƒåº¦å™?
    await _startScheduler();

    // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨å¤‡ä»½ï¼Œè®¡ç®—ä¸‹æ¬¡å¤‡ä»½æ—¶é—´
    if (settings.enabled) {
      final nextBackupTime = _calculateNextBackupTime(settings.frequency);
      final updatedSettings = settings.copyWith(nextBackupTime: nextBackupTime);
      _currentSettings = updatedSettings;
      await _saveSettings();
    }
  }

  /// å¯åŠ¨è°ƒåº¦å™?
  Future<void> _startScheduler() async {
    // åœæ­¢ç°æœ‰çš„è°ƒåº¦å™¨
    _schedulerTimer?.cancel();

    if (!_currentSettings.enabled) {
      return;
    }

    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦æ‰§è¡Œå¤‡ä»?
    _schedulerTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkAndExecuteBackup();
    });

    // ç«‹å³æ£€æŸ¥ä¸€æ¬?
    await _checkAndExecuteBackup();
  }

  /// æ£€æŸ¥å¹¶æ‰§è¡Œå¤‡ä»½
  Future<void> _checkAndExecuteBackup() async {
    if (!_currentSettings.enabled) {
      return;
    }

    final now = DateTime.now();

    // æ£€æŸ¥æ˜¯å¦åˆ°äº†å¤‡ä»½æ—¶é—?
    if (_currentSettings.nextBackupTime != null &&
        now.isAfter(_currentSettings.nextBackupTime!)) {
      // æ£€æŸ¥è®¾å¤‡æ¡ä»?
      if (await _checkDeviceConditions()) {
        await _executeAutoBackup();
      } else {
        // å¦‚æœè®¾å¤‡æ¡ä»¶ä¸æ»¡è¶³ï¼Œå»¶è¿Ÿ30åˆ†é’Ÿåå†æ£€æŸ?
        final delayedTime = now.add(const Duration(minutes: 30));
        _currentSettings = _currentSettings.copyWith(
          nextBackupTime: delayedTime,
        );
        await _saveSettings();
      }
    }
  }

  /// æ£€æŸ¥è®¾å¤‡æ¡ä»¶ï¼ˆWiFiã€å……ç”µçŠ¶æ€ç­‰ï¼?
  Future<bool> _checkDeviceConditions() async {
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„è®¾å¤‡æ¡ä»¶æ£€æŸ?
    // ç›®å‰ç®€åŒ–å¤„ç†ï¼Œæ€»æ˜¯è¿”å›true
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥æ£€æŸ¥ï¼š
    // - ç½‘ç»œè¿æ¥çŠ¶æ€ï¼ˆWiFiï¼?
    // - ç”µæ± å……ç”µçŠ¶æ€?
    // - å­˜å‚¨ç©ºé—´
    return true;
  }

  /// æ‰§è¡Œè‡ªåŠ¨å¤‡ä»½
  Future<void> _executeAutoBackup() async {
    try {
      debugPrint('å¼€å§‹æ‰§è¡Œè‡ªåŠ¨å¤‡ä»?..');

      // åˆ›å»ºå¤‡ä»½é€‰é¡¹
      final backupOptions = backup_models.BackupOptions(
        customName: 'auto_backup',
        includeImages: _currentSettings.backupOptions?.includeImages ?? false,
        encrypt: _currentSettings.backupOptions?.encrypt ?? false,
        password: _currentSettings.backupOptions?.password,
        compress: _currentSettings.backupOptions?.compress ?? false,
        description: 'è‡ªåŠ¨å¤‡ä»½ - ${DateTime.now().toIso8601String()}',
      );

      // æ‰§è¡Œå¤‡ä»½
      final result = await _backupService.createBackup(
        options: backupOptions,
        onProgress: (message, current, total) {
          debugPrint('è‡ªåŠ¨å¤‡ä»½è¿›åº¦: $message ($current/$total)');
        },
      );

      if (result.success) {
        debugPrint('è‡ªåŠ¨å¤‡ä»½æˆåŠŸ: ${result.filePath}');

        // æ›´æ–°æœ€åå¤‡ä»½æ—¶é—?
        final now = DateTime.now();
        final nextBackupTime = _calculateNextBackupTime(
          _currentSettings.frequency,
        );

        _currentSettings = _currentSettings.copyWith(
          lastBackupTime: now,
          nextBackupTime: nextBackupTime,
        );
        await _saveSettings();

        // æ¸…ç†è¿‡æœŸå¤‡ä»½
        await _cleanupOldBackups();

        // å‘é€é€šçŸ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
        await _sendBackupNotification(true, 'è‡ªåŠ¨å¤‡ä»½å®Œæˆ');
      } else {
        debugPrint('è‡ªåŠ¨å¤‡ä»½å¤±è´¥: ${result.errorMessage}');
        await _sendBackupNotification(false, 'è‡ªåŠ¨å¤‡ä»½å¤±è´¥: ${result.errorMessage}');

        // å¤‡ä»½å¤±è´¥ï¼Œå»¶è¿?å°æ—¶åé‡è¯?
        final retryTime = DateTime.now().add(const Duration(hours: 1));
        _currentSettings = _currentSettings.copyWith(nextBackupTime: retryTime);
        await _saveSettings();
      }
    } catch (e) {
      debugPrint('è‡ªåŠ¨å¤‡ä»½å¼‚å¸¸: $e');
      await _sendBackupNotification(false, 'è‡ªåŠ¨å¤‡ä»½å¼‚å¸¸: $e');

      // å¼‚å¸¸æƒ…å†µï¼Œå»¶è¿?å°æ—¶åé‡è¯?
      final retryTime = DateTime.now().add(const Duration(hours: 2));
      _currentSettings = _currentSettings.copyWith(nextBackupTime: retryTime);
      await _saveSettings();
    }
  }

  /// è®¡ç®—ä¸‹æ¬¡å¤‡ä»½æ—¶é—´
  DateTime _calculateNextBackupTime(BackupFrequency frequency) {
    final now = DateTime.now();

    switch (frequency) {
      case BackupFrequency.daily:
        // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡?
        var nextBackup = DateTime(now.year, now.month, now.day, 2, 0);
        if (nextBackup.isBefore(now)) {
          nextBackup = nextBackup.add(const Duration(days: 1));
        }
        return nextBackup;

      case BackupFrequency.weekly:
        // æ¯å‘¨æ—¥å‡Œæ™?ç‚¹æ‰§è¡?
        var nextBackup = DateTime(now.year, now.month, now.day, 2, 0);
        final daysUntilSunday = (7 - now.weekday) % 7;
        if (daysUntilSunday == 0 && nextBackup.isBefore(now)) {
          // å¦‚æœä»Šå¤©æ˜¯å‘¨æ—¥ä½†å·²ç»è¿‡äº†2ç‚¹ï¼Œåˆ™ä¸‹å‘¨æ—¥æ‰§è¡Œ
          nextBackup = nextBackup.add(const Duration(days: 7));
        } else {
          nextBackup = nextBackup.add(Duration(days: daysUntilSunday));
        }
        return nextBackup;

      case BackupFrequency.monthly:
        // æ¯æœˆ1å·å‡Œæ™?ç‚¹æ‰§è¡?
        var nextBackup = DateTime(now.year, now.month, 1, 2, 0);
        if (nextBackup.isBefore(now)) {
          // ä¸‹ä¸ªæœ?å?
          if (now.month == 12) {
            nextBackup = DateTime(now.year + 1, 1, 1, 2, 0);
          } else {
            nextBackup = DateTime(now.year, now.month + 1, 1, 2, 0);
          }
        }
        return nextBackup;
    }
  }

  /// æ¸…ç†è¿‡æœŸçš„å¤‡ä»½æ–‡ä»?
  Future<void> _cleanupOldBackups() async {
    try {
      final backups = await _backupService.getLocalBackups();

      // è¿‡æ»¤å‡ºè‡ªåŠ¨å¤‡ä»½æ–‡ä»¶ï¼ˆæ–‡ä»¶ååŒ…å«auto_backupï¼?
      final autoBackups = backups
          .where((backup) => backup.fileName.contains('auto_backup'))
          .toList();

      // æŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
      autoBackups.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      // å¦‚æœè¶…è¿‡æœ€å¤§ä¿ç•™æ•°é‡ï¼Œåˆ é™¤å¤šä½™çš„å¤‡ä»?
      if (autoBackups.length > _currentSettings.maxBackupCount) {
        final backupsToDelete = autoBackups.skip(
          _currentSettings.maxBackupCount,
        );

        for (final backup in backupsToDelete) {
          try {
            await _backupService.deleteBackup(backup.id);
            debugPrint('å·²åˆ é™¤è¿‡æœŸçš„è‡ªåŠ¨å¤‡ä»½: ${backup.fileName}');
          } catch (e) {
            debugPrint('åˆ é™¤è¿‡æœŸå¤‡ä»½å¤±è´¥: ${backup.fileName}, é”™è¯¯: $e');
          }
        }
      }
    } catch (e) {
      debugPrint('æ¸…ç†è¿‡æœŸå¤‡ä»½æ—¶å‘ç”Ÿé”™è¯? $e');
    }
  }

  /// å‘é€å¤‡ä»½é€šçŸ¥
  Future<void> _sendBackupNotification(bool success, String message) async {
    if (success) {
      await BackupNotificationService.showBackupSuccessNotification(
        title: 'è‡ªåŠ¨å¤‡ä»½å®Œæˆ',
        message: message,
      );
    } else {
      await BackupNotificationService.showBackupFailureNotification(
        title: 'è‡ªåŠ¨å¤‡ä»½å¤±è´¥',
        message: message,
      );
    }
  }

  /// æ‰‹åŠ¨è§¦å‘å¤‡ä»½
  Future<BackupResult> triggerManualBackup() async {
    if (!_currentSettings.enabled) {
      return BackupResult.failure('è‡ªåŠ¨å¤‡ä»½æœªå¯ç”?);
    }

    final backupOptions = backup_models.BackupOptions(
      customName: 'manual_auto_backup',
      includeImages: _currentSettings.backupOptions?.includeImages ?? false,
      encrypt: _currentSettings.backupOptions?.encrypt ?? false,
      password: _currentSettings.backupOptions?.password,
      compress: _currentSettings.backupOptions?.compress ?? false,
      description: 'æ‰‹åŠ¨è§¦å‘çš„è‡ªåŠ¨å¤‡ä»?- ${DateTime.now().toIso8601String()}',
    );

    final result = await _backupService.createBackup(options: backupOptions);

    if (result.success) {
      // æ›´æ–°æœ€åå¤‡ä»½æ—¶é—´ï¼Œä½†ä¸æ”¹å˜ä¸‹æ¬¡è®¡åˆ’æ—¶é—´
      _currentSettings = _currentSettings.copyWith(
        lastBackupTime: DateTime.now(),
      );
      await _saveSettings();

      await _cleanupOldBackups();
    }

    return result;
  }

  /// è·å–ä¸‹æ¬¡å¤‡ä»½æ—¶é—´çš„æè¿?
  String getNextBackupDescription() {
    if (!_currentSettings.enabled) {
      return 'è‡ªåŠ¨å¤‡ä»½å·²ç¦ç”?;
    }

    if (_currentSettings.nextBackupTime == null) {
      return 'è®¡ç®—ä¸?..';
    }

    final now = DateTime.now();
    final nextBackup = _currentSettings.nextBackupTime!;
    final difference = nextBackup.difference(now);

    if (difference.isNegative) {
      return 'ç­‰å¾…æ‰§è¡Œ';
    }

    if (difference.inDays > 0) {
      return '${difference.inDays}å¤©å';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}å°æ—¶å?;
    } else {
      return '${difference.inMinutes}åˆ†é’Ÿå?;
    }
  }

  /// åŠ è½½è®¾ç½®
  Future<void> _loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = prefs.getString(_settingsKey);

      if (settingsJson != null) {
        final settingsMap = jsonDecode(settingsJson) as Map<String, dynamic>;
        _currentSettings = AutoBackupSettings.fromJson(settingsMap);
      }
    } catch (e) {
      debugPrint('åŠ è½½è‡ªåŠ¨å¤‡ä»½è®¾ç½®å¤±è´¥: $e');
      _currentSettings = const AutoBackupSettings();
    }
  }

  /// ä¿å­˜è®¾ç½®
  Future<void> _saveSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = jsonEncode(_currentSettings.toJson());
      await prefs.setString(_settingsKey, settingsJson);
    } catch (e) {
      debugPrint('ä¿å­˜è‡ªåŠ¨å¤‡ä»½è®¾ç½®å¤±è´¥: $e');
    }
  }

  /// åœæ­¢è°ƒåº¦å™?
  void dispose() {
    _schedulerTimer?.cancel();
  }
}
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../../../core/database/database.dart';
import '../repository/optimized_data_export_repository.dart';
import 'backup_logger.dart';

/// å¤‡ä»½è¯Šæ–­ç»“æœ
class BackupDiagnosticResult {
  final bool isHealthy;
  final List<String> issues;
  final List<String> warnings;
  final Map<String, dynamic> systemInfo;
  final Map<String, dynamic> databaseInfo;
  final Map<String, dynamic> storageInfo;

  const BackupDiagnosticResult({
    required this.isHealthy,
    required this.issues,
    required this.warnings,
    required this.systemInfo,
    required this.databaseInfo,
    required this.storageInfo,
  });

  Map<String, dynamic> toJson() => {
    'isHealthy': isHealthy,
    'issues': issues,
    'warnings': warnings,
    'systemInfo': systemInfo,
    'databaseInfo': databaseInfo,
    'storageInfo': storageInfo,
    'timestamp': DateTime.now().toIso8601String(),
  };
}

/// å¤‡ä»½è¯Šæ–­æœåŠ¡
class BackupDiagnosticService {
  final AppDatabase _database;
  final BackupLogger _logger = BackupLogger.instance;

  BackupDiagnosticService(this._database);

  /// æ‰§è¡Œå®Œæ•´çš„å¤‡ä»½ç³»ç»Ÿè¯Šæ–?
  Future<BackupDiagnosticResult> runFullDiagnostic() async {
    final issues = <String>[];
    final warnings = <String>[];
    
    try {
      await _logger.info('BackupDiagnostic', 'å¼€å§‹æ‰§è¡Œå¤‡ä»½ç³»ç»Ÿè¯Šæ–?);
      
      // 1. æ£€æŸ¥æ•°æ®åº“çŠ¶æ€?
      final databaseInfo = await _checkDatabaseHealth(issues, warnings);
      
      // 2. æ£€æŸ¥å­˜å‚¨çŠ¶æ€?
      final storageInfo = await _checkStorageHealth(issues, warnings);
      
      // 3. æ£€æŸ¥ç³»ç»ŸçŠ¶æ€?
      final systemInfo = await _checkSystemHealth(issues, warnings);
      
      // 4. æ£€æŸ¥å¤‡ä»½ç›®å½?
      await _checkBackupDirectory(issues, warnings);
      
      // 5. æ£€æŸ¥æƒé™?
      await _checkPermissions(issues, warnings);
      
      final isHealthy = issues.isEmpty;
      
      final result = BackupDiagnosticResult(
        isHealthy: isHealthy,
        issues: issues,
        warnings: warnings,
        systemInfo: systemInfo,
        databaseInfo: databaseInfo,
        storageInfo: storageInfo,
      );
      
      await _logger.info('BackupDiagnostic', 'è¯Šæ–­å®Œæˆ', details: {
        'isHealthy': isHealthy,
        'issueCount': issues.length,
        'warningCount': warnings.length,
      });
      
      return result;
      
    } catch (e) {
      await _logger.error('BackupDiagnostic', 'è¯Šæ–­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯?, error: e);
      
      return BackupDiagnosticResult(
        isHealthy: false,
        issues: ['è¯Šæ–­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯? ${e.toString()}'],
        warnings: warnings,
        systemInfo: {'error': 'æ— æ³•è·å–ç³»ç»Ÿä¿¡æ¯'},
        databaseInfo: {'error': 'æ— æ³•è·å–æ•°æ®åº“ä¿¡æ?},
        storageInfo: {'error': 'æ— æ³•è·å–å­˜å‚¨ä¿¡æ¯'},
      );
    }
  }

  /// æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€?
  Future<Map<String, dynamic>> _checkDatabaseHealth(
    List<String> issues,
    List<String> warnings,
  ) async {
    final info = <String, dynamic>{};
    
    try {
      // æ£€æŸ¥æ•°æ®åº“è¿æ¥
      final repository = OptimizedDataExportRepository(_database);
      
      // è·å–è¡¨æ•°é‡ç»Ÿè®?
      final tableCounts = await repository.getTableCounts();
      info['tableCounts'] = tableCounts;
      info['totalRecords'] = tableCounts.values.fold<int>(0, (sum, count) => sum + count);
      
      // æ£€æŸ¥æ•°æ®åº“ç‰ˆæœ¬
      final schemaVersion = await repository.getDatabaseSchemaVersion();
      info['schemaVersion'] = schemaVersion;
      
      // æ£€æŸ¥æ•°æ®åº“æ–‡ä»¶å¤§å°
      try {
        // å°è¯•è·å–æ•°æ®åº“è·¯å¾„ä¿¡æ?
        info['databaseSizeCheck'] = 'attempted';
        warnings.add('æ•°æ®åº“æ–‡ä»¶å¤§å°æ£€æŸ¥æš‚æ—¶è·³è¿?);
      } catch (e) {
        warnings.add('æ— æ³•è·å–æ•°æ®åº“æ–‡ä»¶å¤§å°? ${e.toString()}');
      }
      
      // å°è¯•æ‰§è¡Œç®€å•æŸ¥è¯¢æµ‹è¯•æ•°æ®åº“å“åº”
      try {
        await repository.getAllTableNames();
        info['connectionStatus'] = 'healthy';
      } catch (e) {
        issues.add('æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´? ${e.toString()}');
        info['connectionStatus'] = 'failed';
      }
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ç©ºè¡¨
      final emptyTables = tableCounts.entries
          .where((entry) => entry.value == 0)
          .map((entry) => entry.key)
          .toList();
      
      if (emptyTables.isNotEmpty) {
        warnings.add('å‘ç°ç©ºè¡¨: ${emptyTables.join(', ')}');
        info['emptyTables'] = emptyTables;
      }
      
    } catch (e) {
      issues.add('æ•°æ®åº“å¥åº·æ£€æŸ¥å¤±è´? ${e.toString()}');
      info['error'] = e.toString();
    }
    
    return info;
  }

  /// æ£€æŸ¥å­˜å‚¨å¥åº·çŠ¶æ€?
  Future<Map<String, dynamic>> _checkStorageHealth(
    List<String> issues,
    List<String> warnings,
  ) async {
    final info = <String, dynamic>{};
    
    try {
      // è·å–åº”ç”¨æ–‡æ¡£ç›®å½•
      final appDir = await getApplicationDocumentsDirectory();
      info['appDirectory'] = appDir.path;
      
      // æ£€æŸ¥ç›®å½•æ˜¯å¦å¯è®¿é—®
      if (!await appDir.exists()) {
        issues.add('åº”ç”¨æ–‡æ¡£ç›®å½•ä¸å­˜åœ? ${appDir.path}');
        return info;
      }
      
      // è·å–å¯ç”¨å­˜å‚¨ç©ºé—´
      try {
        final stat = await appDir.stat();
        info['directoryExists'] = true;
        info['lastModified'] = stat.modified.toIso8601String();
      } catch (e) {
        warnings.add('æ— æ³•è·å–ç›®å½•ç»Ÿè®¡ä¿¡æ¯: ${e.toString()}');
      }
      
      // æµ‹è¯•æ–‡ä»¶åˆ›å»ºæƒé™
      try {
        final testFile = File(path.join(appDir.path, 'test_write_permission.tmp'));
        await testFile.writeAsString('test');
        await testFile.delete();
        info['writePermission'] = true;
      } catch (e) {
        issues.add('æ²¡æœ‰å†™å…¥æƒé™: ${e.toString()}');
        info['writePermission'] = false;
      }
      
      // ä¼°ç®—å¯ç”¨ç©ºé—´ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
      try {
        // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´ç²¾ç¡®çš„ç£ç›˜ç©ºé—´æ£€æŸ?
        info['spaceCheckStatus'] = 'basic_check_only';
        warnings.add('æ— æ³•ç²¾ç¡®æ£€æŸ¥å¯ç”¨å­˜å‚¨ç©ºé—´ï¼Œè¯·ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿç©ºé—´');
      } catch (e) {
        warnings.add('å­˜å‚¨ç©ºé—´æ£€æŸ¥å¤±è´? ${e.toString()}');
      }
      
    } catch (e) {
      issues.add('å­˜å‚¨å¥åº·æ£€æŸ¥å¤±è´? ${e.toString()}');
      info['error'] = e.toString();
    }
    
    return info;
  }

  /// æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€?
  Future<Map<String, dynamic>> _checkSystemHealth(
    List<String> issues,
    List<String> warnings,
  ) async {
    final info = <String, dynamic>{};
    
    try {
      // è·å–å¹³å°ä¿¡æ¯
      info['platform'] = Platform.operatingSystem;
      info['version'] = Platform.operatingSystemVersion;
      
      // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µï¼ˆåŸºç¡€æ£€æŸ¥ï¼‰
      try {
        // åˆ›å»ºä¸€ä¸ªå°çš„æµ‹è¯•å¯¹è±¡æ¥æ£€æŸ¥å†…å­˜åˆ†é…?
        final testData = List.generate(1000, (i) => 'test_$i');
        testData.clear();
        info['memoryTest'] = 'passed';
      } catch (e) {
        warnings.add('å†…å­˜æµ‹è¯•å¼‚å¸¸: ${e.toString()}');
        info['memoryTest'] = 'failed';
      }
      
      // æ£€æŸ¥å½“å‰æ—¶é—?
      final now = DateTime.now();
      info['currentTime'] = now.toIso8601String();
      info['timezone'] = now.timeZoneName;
      
    } catch (e) {
      warnings.add('ç³»ç»Ÿå¥åº·æ£€æŸ¥å¤±è´? ${e.toString()}');
      info['error'] = e.toString();
    }
    
    return info;
  }

  /// æ£€æŸ¥å¤‡ä»½ç›®å½?
  Future<void> _checkBackupDirectory(
    List<String> issues,
    List<String> warnings,
  ) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(path.join(appDir.path, 'backups'));
      
      if (!await backupDir.exists()) {
        try {
          await backupDir.create(recursive: true);
          warnings.add('å¤‡ä»½ç›®å½•ä¸å­˜åœ¨ï¼Œå·²è‡ªåŠ¨åˆ›å»?);
        } catch (e) {
          issues.add('æ— æ³•åˆ›å»ºå¤‡ä»½ç›®å½•: ${e.toString()}');
          return;
        }
      }
      
      // æ£€æŸ¥å¤‡ä»½ç›®å½•ä¸­çš„æ–‡ä»?
      try {
        final files = await backupDir.list().toList();
        final backupFiles = files
            .where((f) => f is File && f.path.endsWith('.json'))
            .length;
        
        if (backupFiles == 0) {
          warnings.add('å¤‡ä»½ç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ°å¤‡ä»½æ–‡ä»?);
        } else {
          warnings.add('æ‰¾åˆ° $backupFiles ä¸ªå¤‡ä»½æ–‡ä»?);
        }
      } catch (e) {
        warnings.add('æ— æ³•è¯»å–å¤‡ä»½ç›®å½•å†…å®¹: ${e.toString()}');
      }
      
    } catch (e) {
      issues.add('å¤‡ä»½ç›®å½•æ£€æŸ¥å¤±è´? ${e.toString()}');
    }
  }

  /// æ£€æŸ¥æƒé™?
  Future<void> _checkPermissions(
    List<String> issues,
    List<String> warnings,
  ) async {
    try {
      // æ£€æŸ¥åŸºæœ¬æ–‡ä»¶æ“ä½œæƒé™?
      final tempDir = Directory.systemTemp;
      final testFile = File(path.join(tempDir.path, 'backup_permission_test.tmp'));
      
      try {
        // æµ‹è¯•åˆ›å»ºæ–‡ä»¶
        await testFile.writeAsString('permission test');
        
        // æµ‹è¯•è¯»å–æ–‡ä»¶
        final content = await testFile.readAsString();
        if (content != 'permission test') {
          warnings.add('æ–‡ä»¶è¯»å†™æµ‹è¯•å¼‚å¸¸');
        }
        
        // æµ‹è¯•åˆ é™¤æ–‡ä»¶
        await testFile.delete();
        
      } catch (e) {
        issues.add('åŸºæœ¬æ–‡ä»¶æƒé™æµ‹è¯•å¤±è´¥: ${e.toString()}');
      }
      
    } catch (e) {
      warnings.add('æƒé™æ£€æŸ¥å¤±è´? ${e.toString()}');
    }
  }

  /// å¿«é€Ÿè¯Šæ–­ï¼ˆä»…æ£€æŸ¥å…³é”®é—®é¢˜ï¼‰
  Future<BackupDiagnosticResult> runQuickDiagnostic() async {
    final issues = <String>[];
    final warnings = <String>[];
    
    try {
      // å¿«é€Ÿæ•°æ®åº“è¿æ¥æµ‹è¯•
      final repository = OptimizedDataExportRepository(_database);
      await repository.getAllTableNames();
      
      // å¿«é€Ÿå­˜å‚¨æƒé™æµ‹è¯?
      final appDir = await getApplicationDocumentsDirectory();
      final testFile = File(path.join(appDir.path, 'quick_test.tmp'));
      await testFile.writeAsString('test');
      await testFile.delete();
      
      return BackupDiagnosticResult(
        isHealthy: true,
        issues: issues,
        warnings: warnings,
        systemInfo: {'quickCheck': 'passed'},
        databaseInfo: {'quickCheck': 'passed'},
        storageInfo: {'quickCheck': 'passed'},
      );
      
    } catch (e) {
      issues.add('å¿«é€Ÿè¯Šæ–­å‘ç°é—®é¢? ${e.toString()}');
      
      return BackupDiagnosticResult(
        isHealthy: false,
        issues: issues,
        warnings: warnings,
        systemInfo: {'quickCheck': 'failed'},
        databaseInfo: {'quickCheck': 'failed'},
        storageInfo: {'quickCheck': 'failed'},
      );
    }
  }

  /// ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
  Future<String> generateDiagnosticReport(BackupDiagnosticResult result) async {
    final buffer = StringBuffer();
    
    buffer.writeln('=== å¤‡ä»½ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š ===');
    buffer.writeln('ç”Ÿæˆæ—¶é—´: ${DateTime.now()}');
    buffer.writeln('ç³»ç»ŸçŠ¶æ€? ${result.isHealthy ? "æ­£å¸¸" : "å¼‚å¸¸"}');
    buffer.writeln();
    
    if (result.issues.isNotEmpty) {
      buffer.writeln('å‘ç°çš„é—®é¢?');
      for (int i = 0; i < result.issues.length; i++) {
        buffer.writeln('${i + 1}. ${result.issues[i]}');
      }
      buffer.writeln();
    }
    
    if (result.warnings.isNotEmpty) {
      buffer.writeln('è­¦å‘Šä¿¡æ¯:');
      for (int i = 0; i < result.warnings.length; i++) {
        buffer.writeln('${i + 1}. ${result.warnings[i]}');
      }
      buffer.writeln();
    }
    
    buffer.writeln('ç³»ç»Ÿä¿¡æ¯:');
    result.systemInfo.forEach((key, value) {
      buffer.writeln('  $key: $value');
    });
    buffer.writeln();
    
    buffer.writeln('æ•°æ®åº“ä¿¡æ?');
    result.databaseInfo.forEach((key, value) {
      buffer.writeln('  $key: $value');
    });
    buffer.writeln();
    
    buffer.writeln('å­˜å‚¨ä¿¡æ¯:');
    result.storageInfo.forEach((key, value) {
      buffer.writeln('  $key: $value');
    });
    
    return buffer.toString();
  }
}
import 'dart:io';

import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import 'backup_logger.dart';

/// é”™è¯¯æ¢å¤å»ºè®®
class ErrorRecoverySuggestion {
  final String title;
  final String description;
  final List<String> steps;
  final bool canRetry;
  final bool requiresUserAction;

  const ErrorRecoverySuggestion({
    required this.title,
    required this.description,
    required this.steps,
    this.canRetry = false,
    this.requiresUserAction = true,
  });
}

/// ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ?
class UserFriendlyError {
  final String title;
  final String message;
  final String? technicalDetails;
  final ErrorRecoverySuggestion? suggestion;
  final bool canRetry;

  const UserFriendlyError({
    required this.title,
    required this.message,
    this.technicalDetails,
    this.suggestion,
    this.canRetry = false,
  });
}

/// é‡è¯•é…ç½®
class RetryConfig {
  final int maxAttempts;
  final Duration initialDelay;
  final double backoffMultiplier;
  final Duration maxDelay;
  final bool Function(Object error)? shouldRetry;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelay = const Duration(seconds: 1),
    this.backoffMultiplier = 2.0,
    this.maxDelay = const Duration(seconds: 30),
    this.shouldRetry,
  });

  static const RetryConfig fileSystem = RetryConfig(
    maxAttempts: 3,
    initialDelay: Duration(seconds: 2),
    backoffMultiplier: 1.5,
    maxDelay: Duration(seconds: 10),
  );

  static const RetryConfig database = RetryConfig(
    maxAttempts: 2,
    initialDelay: Duration(seconds: 1),
    backoffMultiplier: 2.0,
    maxDelay: Duration(seconds: 5),
  );

  static const RetryConfig network = RetryConfig(
    maxAttempts: 5,
    initialDelay: Duration(seconds: 3),
    backoffMultiplier: 2.0,
    maxDelay: Duration(seconds: 60),
  );
}

/// å¤‡ä»½é”™è¯¯å¤„ç†å™?
class BackupErrorHandler {
  static final BackupLogger _logger = BackupLogger.instance;

  /// å°†å¼‚å¸¸è½¬æ¢ä¸ºç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ?
  static UserFriendlyError handleError(Object error, {
    String? operation,
    Map<String, dynamic>? context,
  }) {
    // è®°å½•é”™è¯¯æ—¥å¿—
    _logError(error, operation: operation, context: context);

    if (error is BackupException) {
      return _handleBackupException(error);
    } else if (error is FileSystemException) {
      return _handleFileSystemException(error);
    } else if (error is FormatException) {
      return _handleFormatException(error);
    } else {
      return _handleGenericError(error);
    }
  }

  /// å¤„ç†å¤‡ä»½å¼‚å¸¸
  static UserFriendlyError _handleBackupException(BackupException error) {
    switch (error.type) {
      case BackupErrorType.fileSystemError:
        return UserFriendlyError(
          title: 'æ–‡ä»¶æ“ä½œå¤±è´¥',
          message: 'æ— æ³•è®¿é—®æˆ–æ“ä½œå¤‡ä»½æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥å­˜å‚¨æƒé™å’Œå¯ç”¨ç©ºé—´ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ£€æŸ¥åº”ç”¨æ˜¯å¦æœ‰å­˜å‚¨æƒé™',
              'ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å¯ç”¨å­˜å‚¨ç©ºé—´',
              'å°è¯•é€‰æ‹©å…¶ä»–å­˜å‚¨ä½ç½®',
              'é‡å¯åº”ç”¨åé‡è¯?,
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.databaseError:
        return UserFriendlyError(
          title: 'æ•°æ®åº“æ“ä½œå¤±è´?,
          message: 'è¯»å–æˆ–å†™å…¥æ•°æ®åº“æ—¶å‘ç”Ÿé”™è¯¯ï¼Œå¯èƒ½æ˜¯æ•°æ®åº“æ–‡ä»¶æŸåæˆ–è¢«å ç”¨ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'å…³é—­å…¶ä»–å¯èƒ½ä½¿ç”¨æ•°æ®åº“çš„åŠŸèƒ½',
              'é‡å¯åº”ç”¨åé‡è¯?,
              'å¦‚æœé—®é¢˜æŒç»­ï¼Œå¯èƒ½éœ€è¦ä¿®å¤æ•°æ®åº“',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.serializationError:
        return UserFriendlyError(
          title: 'æ•°æ®æ ¼å¼é”™è¯¯',
          message: 'å¤‡ä»½æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–å·²æŸåï¼Œæ— æ³•æ­£ç¡®è§£ææ•°æ®ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å®Œæ•?,
              'å°è¯•ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
              'é‡æ–°åˆ›å»ºå¤‡ä»½æ–‡ä»¶',
            ],
            canRetry: false,
          ),
          canRetry: false,
        );

      case BackupErrorType.encryptionError:
        return UserFriendlyError(
          title: 'åŠ å¯†æ“ä½œå¤±è´¥',
          message: 'åŠ å¯†æˆ–è§£å¯†å¤‡ä»½æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'ç¡®è®¤è¾“å…¥çš„å¯†ç æ­£ç¡?,
              'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦ç¡®å®åŠ å¯?,
              'å°è¯•ä½¿ç”¨åŸå§‹å¯†ç é‡æ–°æ“ä½œ',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.validationError:
        return UserFriendlyError(
          title: 'æ•°æ®éªŒè¯å¤±è´¥',
          message: 'å¤‡ä»½æ–‡ä»¶æ•°æ®å®Œæ•´æ€§éªŒè¯å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸåæˆ–è¢«ç¯¡æ”¹ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å®Œæ•´ä¸‹è½?,
              'å°è¯•ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
              'é‡æ–°åˆ›å»ºå¤‡ä»½æ–‡ä»¶',
              'æ£€æŸ¥å­˜å‚¨è®¾å¤‡æ˜¯å¦æœ‰é—®é¢˜',
            ],
            canRetry: false,
          ),
          canRetry: false,
        );

      case BackupErrorType.insufficientSpace:
        return UserFriendlyError(
          title: 'å­˜å‚¨ç©ºé—´ä¸è¶³',
          message: 'è®¾å¤‡å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ— æ³•å®Œæˆå¤‡ä»½æ“ä½œã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ¸…ç†è®¾å¤‡å­˜å‚¨ç©ºé—´',
              'åˆ é™¤ä¸éœ€è¦çš„æ–‡ä»¶æˆ–åº”ç”?,
              'é€‰æ‹©å…¶ä»–å­˜å‚¨ä½ç½®',
              'ä½¿ç”¨å¤–éƒ¨å­˜å‚¨è®¾å¤‡',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.permissionDenied:
        return UserFriendlyError(
          title: 'æƒé™è¢«æ‹’ç»?,
          message: 'åº”ç”¨æ²¡æœ‰è¶³å¤Ÿçš„æƒé™è®¿é—®æ‰€éœ€çš„æ–‡ä»¶æˆ–ç›®å½•ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'åœ¨ç³»ç»Ÿè®¾ç½®ä¸­æˆäºˆåº”ç”¨å­˜å‚¨æƒé™',
              'é€‰æ‹©åº”ç”¨æœ‰æƒé™è®¿é—®çš„ç›®å½•',
              'é‡å¯åº”ç”¨åé‡è¯?,
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.fileNotFound:
        return UserFriendlyError(
          title: 'æ–‡ä»¶æœªæ‰¾åˆ?,
          message: 'æŒ‡å®šçš„å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡?,
              'ç¡®è®¤æ–‡ä»¶æœªè¢«ç§»åŠ¨æˆ–åˆ é™?,
              'é€‰æ‹©å…¶ä»–å¤‡ä»½æ–‡ä»¶',
            ],
            canRetry: false,
          ),
          canRetry: false,
        );

      case BackupErrorType.unsupportedFormat:
        return UserFriendlyError(
          title: 'ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼',
          message: 'å¤‡ä»½æ–‡ä»¶æ ¼å¼ä¸å—æ”¯æŒï¼Œå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬æˆ–æŸåçš„æ–‡ä»¶ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'ä½¿ç”¨è¾ƒæ–°ç‰ˆæœ¬çš„å¤‡ä»½æ–‡ä»?,
              'æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å®Œæ•?,
              'è”ç³»æŠ€æœ¯æ”¯æŒè·å–å¸®åŠ?,
            ],
            canRetry: false,
          ),
          canRetry: false,
        );

      case BackupErrorType.incorrectPassword:
        return UserFriendlyError(
          title: 'å¯†ç é”™è¯¯',
          message: 'è¾“å…¥çš„å¯†ç ä¸æ­£ç¡®ï¼Œæ— æ³•è§£å¯†å¤‡ä»½æ–‡ä»¶ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'ç¡®è®¤è¾“å…¥çš„å¯†ç æ­£ç¡?,
              'æ£€æŸ¥å¤§å°å†™å’Œç‰¹æ®Šå­—ç¬?,
              'å°è¯•ä½¿ç”¨åˆ›å»ºå¤‡ä»½æ—¶çš„åŸå§‹å¯†ç ',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.operationCancelled:
        return UserFriendlyError(
          title: 'æ“ä½œå·²å–æ¶?,
          message: 'å¤‡ä»½æˆ–æ¢å¤æ“ä½œå·²è¢«ç”¨æˆ·å–æ¶ˆã€?,
          technicalDetails: error.message,
          canRetry: true,
        );

      case BackupErrorType.networkError:
        return UserFriendlyError(
          title: 'ç½‘ç»œè¿æ¥é”™è¯¯',
          message: 'ç½‘ç»œè¿æ¥ä¸ç¨³å®šæˆ–å·²æ–­å¼€ï¼Œæ— æ³•å®Œæˆæ“ä½œã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸?,
              'å°è¯•åˆ‡æ¢åˆ°å…¶ä»–ç½‘ç»?,
              'ç¨åé‡è¯•æ“ä½œ',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.compressionError:
        return UserFriendlyError(
          title: 'å‹ç¼©æ“ä½œå¤±è´¥',
          message: 'å¤‡ä»½æ–‡ä»¶å‹ç¼©æˆ–è§£å‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•æˆ–é€‰æ‹©ä¸å‹ç¼©çš„å¤‡ä»½æ–¹å¼ã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'é‡è¯•å¤‡ä»½æ“ä½œ',
              'é€‰æ‹©ä¸å‹ç¼©çš„å¤‡ä»½é€‰é¡¹',
              'æ£€æŸ¥è®¾å¤‡å­˜å‚¨ç©ºé—´æ˜¯å¦å……è¶?,
              'ç¡®ä¿å¤‡ä»½æ–‡ä»¶æœªæŸå?,
            ],
            canRetry: true,
          ),
          canRetry: true,
        );

      case BackupErrorType.unknown:
        return UserFriendlyError(
          title: 'æœªçŸ¥é”™è¯¯',
          message: 'å‘ç”Ÿäº†æœªçŸ¥é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•æˆ–è”ç³»æŠ€æœ¯æ”¯æŒã€?,
          technicalDetails: error.message,
          suggestion: const ErrorRecoverySuggestion(
            title: 'è§£å†³å»ºè®®',
            description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
            steps: [
              'é‡å¯åº”ç”¨åé‡è¯?,
              'æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ­£å¸¸å·¥ä½?,
              'è”ç³»æŠ€æœ¯æ”¯æŒå¹¶æä¾›é”™è¯¯è¯¦æƒ…',
            ],
            canRetry: true,
          ),
          canRetry: true,
        );
    }
  }

  /// å¤„ç†æ–‡ä»¶ç³»ç»Ÿå¼‚å¸¸
  static UserFriendlyError _handleFileSystemException(FileSystemException error) {
    return UserFriendlyError(
      title: 'æ–‡ä»¶æ“ä½œå¤±è´¥',
      message: 'æ— æ³•è®¿é—®æˆ–æ“ä½œæ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæƒé™ã€?,
      technicalDetails: error.toString(),
      suggestion: const ErrorRecoverySuggestion(
        title: 'è§£å†³å»ºè®®',
        description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
        steps: [
          'æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡?,
          'ç¡®è®¤åº”ç”¨æœ‰è¶³å¤Ÿçš„æƒé™',
          'æ£€æŸ¥å­˜å‚¨è®¾å¤‡æ˜¯å¦æ­£å¸?,
        ],
        canRetry: true,
      ),
      canRetry: true,
    );
  }

  /// å¤„ç†æ ¼å¼å¼‚å¸¸
  static UserFriendlyError _handleFormatException(FormatException error) {
    return UserFriendlyError(
      title: 'æ•°æ®æ ¼å¼é”™è¯¯',
      message: 'æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–æ•°æ®å·²æŸåã€?,
      technicalDetails: error.toString(),
      suggestion: const ErrorRecoverySuggestion(
        title: 'è§£å†³å»ºè®®',
        description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
        steps: [
          'æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å®Œæ•?,
          'å°è¯•ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
          'é‡æ–°åˆ›å»ºå¤‡ä»½æ–‡ä»¶',
        ],
        canRetry: false,
      ),
      canRetry: false,
    );
  }

  /// å¤„ç†é€šç”¨é”™è¯¯
  static UserFriendlyError _handleGenericError(Object error) {
    // å°è¯•ä»é”™è¯¯ä¿¡æ¯ä¸­æå–æ›´å…·ä½“çš„ä¿¡æ¯
    final errorMessage = error.toString().toLowerCase();
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°æ®åº“ç›¸å…³é”™è¯?
    if (errorMessage.contains('database') || 
        errorMessage.contains('sqlite') || 
        errorMessage.contains('sql')) {
      return UserFriendlyError(
        title: 'æ•°æ®åº“æ“ä½œå¤±è´?,
        message: 'æ•°æ®åº“è®¿é—®å‡ºç°é—®é¢˜ï¼Œå¯èƒ½æ˜¯æ•°æ®åº“æ–‡ä»¶æŸåæˆ–è¢«å ç”¨ã€?,
        technicalDetails: error.toString(),
        suggestion: const ErrorRecoverySuggestion(
          title: 'è§£å†³å»ºè®®',
          description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
          steps: [
            'å…³é—­åº”ç”¨åé‡æ–°æ‰“å¼€',
            'ç¡®ä¿æ²¡æœ‰å…¶ä»–åº”ç”¨åœ¨ä½¿ç”¨æ•°æ®åº“',
            'æ£€æŸ¥è®¾å¤‡å­˜å‚¨ç©ºé—´æ˜¯å¦å……è¶?,
            'å¦‚æœé—®é¢˜æŒç»­ï¼Œå¯èƒ½éœ€è¦é‡æ–°å®‰è£…åº”ç”?,
          ],
          canRetry: true,
        ),
        canRetry: true,
      );
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶ç³»ç»Ÿç›¸å…³é”™è¯¯
    if (errorMessage.contains('file') || 
        errorMessage.contains('directory') || 
        errorMessage.contains('path') ||
        errorMessage.contains('permission')) {
      return UserFriendlyError(
        title: 'æ–‡ä»¶æ“ä½œå¤±è´¥',
        message: 'æ— æ³•è®¿é—®æˆ–åˆ›å»ºå¤‡ä»½æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥å­˜å‚¨æƒé™å’Œå¯ç”¨ç©ºé—´ã€?,
        technicalDetails: error.toString(),
        suggestion: const ErrorRecoverySuggestion(
          title: 'è§£å†³å»ºè®®',
          description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
          steps: [
            'æ£€æŸ¥åº”ç”¨æ˜¯å¦æœ‰å­˜å‚¨æƒé™',
            'ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å¯ç”¨å­˜å‚¨ç©ºé—´',
            'å°è¯•é€‰æ‹©å…¶ä»–å­˜å‚¨ä½ç½®',
            'é‡å¯åº”ç”¨åé‡è¯?,
          ],
          canRetry: true,
        ),
        canRetry: true,
      );
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å†…å­˜ç›¸å…³é”™è¯¯
    if (errorMessage.contains('memory') || 
        errorMessage.contains('out of memory') ||
        errorMessage.contains('heap')) {
      return UserFriendlyError(
        title: 'å†…å­˜ä¸è¶³',
        message: 'è®¾å¤‡å†…å­˜ä¸è¶³ï¼Œæ— æ³•å®Œæˆå¤‡ä»½æ“ä½œã€?,
        technicalDetails: error.toString(),
        suggestion: const ErrorRecoverySuggestion(
          title: 'è§£å†³å»ºè®®',
          description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
          steps: [
            'å…³é—­å…¶ä»–æ­£åœ¨è¿è¡Œçš„åº”ç”?,
            'é‡å¯è®¾å¤‡é‡Šæ”¾å†…å­˜',
            'å°è¯•åˆ†æ‰¹å¤‡ä»½æ•°æ®',
            'æ¸…ç†è®¾å¤‡ç¼“å­˜',
          ],
          canRetry: true,
        ),
        canRetry: true,
      );
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç½‘ç»œç›¸å…³é”™è¯¯
    if (errorMessage.contains('network') || 
        errorMessage.contains('connection') ||
        errorMessage.contains('timeout')) {
      return UserFriendlyError(
        title: 'ç½‘ç»œè¿æ¥é—®é¢˜',
        message: 'ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œå½±å“äº†å¤‡ä»½æ“ä½œã€?,
        technicalDetails: error.toString(),
        suggestion: const ErrorRecoverySuggestion(
          title: 'è§£å†³å»ºè®®',
          description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
          steps: [
            'æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸?,
            'å°è¯•åˆ‡æ¢åˆ°å…¶ä»–ç½‘ç»?,
            'ç¨åé‡è¯•æ“ä½œ',
            'ä½¿ç”¨æœ¬åœ°å¤‡ä»½åŠŸèƒ½',
          ],
          canRetry: true,
        ),
        canRetry: true,
      );
    }
    
    // é»˜è®¤çš„é€šç”¨é”™è¯¯å¤„ç†
    return UserFriendlyError(
      title: 'æ“ä½œå¤±è´¥',
      message: 'æ“ä½œè¿‡ç¨‹ä¸­å‘ç”Ÿäº†æ„å¤–é”™è¯¯ã€‚é”™è¯¯è¯¦æƒ…ï¼š${_extractKeyErrorInfo(error.toString())}',
      technicalDetails: error.toString(),
      suggestion: const ErrorRecoverySuggestion(
        title: 'è§£å†³å»ºè®®',
        description: 'è¯·å°è¯•ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š',
        steps: [
          'ç¨åé‡è¯•æ“ä½œ',
          'é‡å¯åº”ç”¨',
          'æ£€æŸ¥è®¾å¤‡çŠ¶æ€?,
          'è”ç³»æŠ€æœ¯æ”¯æŒå¹¶æä¾›é”™è¯¯è¯¦æƒ…',
        ],
        canRetry: true,
      ),
      canRetry: true,
    );
  }
  
  /// ä»é”™è¯¯ä¿¡æ¯ä¸­æå–å…³é”®ä¿¡æ¯
  static String _extractKeyErrorInfo(String errorMessage) {
    // ç§»é™¤å †æ ˆè·Ÿè¸ªä¿¡æ¯ï¼Œåªä¿ç•™å…³é”®é”™è¯¯ä¿¡æ¯
    final lines = errorMessage.split('\n');
    if (lines.isNotEmpty) {
      final firstLine = lines.first.trim();
      // å¦‚æœç¬¬ä¸€è¡ŒåŒ…å«æœ‰ç”¨ä¿¡æ¯ï¼Œè¿”å›å®?
      if (firstLine.isNotEmpty && !firstLine.startsWith('#')) {
        return firstLine.length > 100 
            ? '${firstLine.substring(0, 100)}...' 
            : firstLine;
      }
    }
    
    // å¦‚æœæ— æ³•æå–æœ‰ç”¨ä¿¡æ¯ï¼Œè¿”å›é€šç”¨æè¿°
    return 'è¯·æŸ¥çœ‹æŠ€æœ¯è¯¦æƒ…äº†è§£æ›´å¤šä¿¡æ?;
  }

  /// è®°å½•é”™è¯¯æ—¥å¿—
  static void _logError(Object error, {
    String? operation,
    Map<String, dynamic>? context,
  }) {
    final operationName = operation ?? 'UnknownOperation';
    
    if (error is BackupException) {
      _logger.error(
        operationName,
        error.message,
        error: error.originalError,
        stackTrace: error.stackTrace,
        details: {
          'errorType': error.type.name,
          'errorCode': error.errorCode,
          if (error.details != null) ...error.details!,
          if (context != null) ...context,
        },
        errorCode: error.errorCode,
      );
    } else {
      _logger.error(
        operationName,
        error.toString(),
        error: error,
        stackTrace: StackTrace.current,
        details: context,
      );
    }
  }

  /// å¸¦é‡è¯•æœºåˆ¶çš„æ“ä½œæ‰§è¡Œ
  static Future<T> executeWithRetry<T>(
    Future<T> Function() operation, {
    RetryConfig config = const RetryConfig(),
    String? operationName,
    Map<String, dynamic>? context,
  }) async {
    final opName = operationName ?? 'RetryableOperation';
    var attempt = 0;
    var delay = config.initialDelay;

    while (attempt < config.maxAttempts) {
      attempt++;
      
      try {
        await _logger.debug(opName, 'å¼€å§‹æ‰§è¡Œæ“ä½?(å°è¯• $attempt/${config.maxAttempts})', 
            details: context);
        
        final result = await operation();
        
        if (attempt > 1) {
          await _logger.info(opName, 'æ“ä½œåœ¨ç¬¬ $attempt æ¬¡å°è¯•åæˆåŠŸå®Œæˆ');
        }
        
        return result;
      } catch (error) {
        await _logger.warning(opName, 'ç¬?$attempt æ¬¡å°è¯•å¤±è´? ${error.toString()}',
            details: {'attempt': attempt, 'maxAttempts': config.maxAttempts});

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¯?
        final shouldRetry = config.shouldRetry?.call(error) ?? _shouldRetryByDefault(error);
        
        if (attempt >= config.maxAttempts || !shouldRetry) {
          await _logger.error(opName, 'æ“ä½œæœ€ç»ˆå¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°æˆ–ä¸å¯é‡è¯•', 
              error: error, details: {'totalAttempts': attempt});
          rethrow;
        }

        // ç­‰å¾…åé‡è¯?
        if (attempt < config.maxAttempts) {
          await _logger.debug(opName, 'ç­‰å¾… ${delay.inMilliseconds}ms åé‡è¯?);
          await Future.delayed(delay);
          
          // è®¡ç®—ä¸‹æ¬¡å»¶è¿Ÿæ—¶é—´
          delay = Duration(
            milliseconds: (delay.inMilliseconds * config.backoffMultiplier).round(),
          );
          
          if (delay > config.maxDelay) {
            delay = config.maxDelay;
          }
        }
      }
    }

    throw StateError('Unreachable code');
  }

  /// é»˜è®¤çš„é‡è¯•åˆ¤æ–­é€»è¾‘
  static bool _shouldRetryByDefault(Object error) {
    if (error is BackupException) {
      switch (error.type) {
        case BackupErrorType.fileSystemError:
        case BackupErrorType.databaseError:
        case BackupErrorType.networkError:
        case BackupErrorType.insufficientSpace:
          return true;
        case BackupErrorType.serializationError:
        case BackupErrorType.validationError:
        case BackupErrorType.unsupportedFormat:
        case BackupErrorType.incorrectPassword:
        case BackupErrorType.compressionError:
          return false;
        default:
          return true;
      }
    }
    
    if (error is FileSystemException) {
      return true;
    }
    
    if (error is FormatException) {
      return false;
    }
    
    return true; // é»˜è®¤å¯é‡è¯?
  }

  /// è·å–é”™è¯¯çš„ä¸¥é‡ç¨‹åº?
  static LogLevel getErrorSeverity(Object error) {
    if (error is BackupException) {
      switch (error.type) {
        case BackupErrorType.operationCancelled:
          return LogLevel.info;
        case BackupErrorType.insufficientSpace:
        case BackupErrorType.permissionDenied:
        case BackupErrorType.fileNotFound:
          return LogLevel.warning;
        case BackupErrorType.databaseError:
        case BackupErrorType.validationError:
        case BackupErrorType.compressionError:
          return LogLevel.critical;
        default:
          return LogLevel.error;
      }
    }
    
    return LogLevel.error;
  }
}
import 'dart:async';
import 'package:flutter/foundation.dart';

import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import 'backup_logger.dart';
import 'backup_error_handler.dart';
import 'backup_resource_manager.dart';

/// é”™è¯¯å¤„ç†æœåŠ¡
class BackupErrorService {
  static BackupErrorService? _instance;
  static BackupErrorService get instance => _instance ??= BackupErrorService._();
  
  BackupErrorService._();

  final BackupLogger _logger = BackupLogger.instance;
  final BackupResourceManager _resourceManager = BackupResourceManager.instance;
  bool _initialized = false;

  /// é”™è¯¯äº‹ä»¶æµ?
  Stream<UserFriendlyError> get errorStream => _errorStreamController.stream;
  final StreamController<UserFriendlyError> _errorStreamController = 
      StreamController<UserFriendlyError>.broadcast();

  /// åˆå§‹åŒ–é”™è¯¯æœåŠ?
  Future<void> initialize() async {
    if (_initialized) return;
    
    try {
      await _logger.initialize();
      await _resourceManager.initialize();
      
      // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
      if (kDebugMode) {
        FlutterError.onError = _handleFlutterError;
      }
      
      _initialized = true;
      await _logger.info('ErrorService', 'é”™è¯¯å¤„ç†æœåŠ¡åˆå§‹åŒ–å®Œæˆ?);
    } catch (e) {
      debugPrint('Failed to initialize BackupErrorService: $e');
      rethrow;
    }
  }

  /// å¤„ç†é”™è¯¯å¹¶è¿”å›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
  Future<UserFriendlyError> handleError(
    Object error, {
    String? operation,
    Map<String, dynamic>? context,
    bool shouldCleanupResources = true,
  }) async {
    try {
      // è®°å½•é”™è¯¯
      await _logError(error, operation: operation, context: context);
      
      // æ¸…ç†ç›¸å…³èµ„æº
      if (shouldCleanupResources && operation != null) {
        await _cleanupOperationResources(operation);
      }
      
      // è½¬æ¢ä¸ºç”¨æˆ·å‹å¥½çš„é”™è¯¯
      final userFriendlyError = BackupErrorHandler.handleError(
        error,
        operation: operation,
        context: context,
      );
      
      // å‘é€é”™è¯¯äº‹ä»?
      _errorStreamController.add(userFriendlyError);
      
      return userFriendlyError;
    } catch (e) {
      // å¦‚æœé”™è¯¯å¤„ç†æœ¬èº«å¤±è´¥ï¼Œè¿”å›ä¸€ä¸ªåŸºæœ¬çš„é”™è¯¯ä¿¡æ¯
      await _logger.critical('ErrorService', 'é”™è¯¯å¤„ç†å¤±è´¥', error: e);
      
      return const UserFriendlyError(
        title: 'ç³»ç»Ÿé”™è¯¯',
        message: 'å¤„ç†é”™è¯¯æ—¶å‘ç”Ÿäº†æ„å¤–é—®é¢˜ï¼Œè¯·é‡å¯åº”ç”¨åé‡è¯•ã€?,
        canRetry: false,
      );
    }
  }

  /// å¸¦é‡è¯•æœºåˆ¶æ‰§è¡Œæ“ä½?
  Future<T> executeWithRetry<T>(
    Future<T> Function() operation, {
    RetryConfig? config,
    String? operationName,
    Map<String, dynamic>? context,
    bool shouldCleanupOnFailure = true,
  }) async {
    final opName = operationName ?? 'UnknownOperation';
    
    try {
      return await BackupErrorHandler.executeWithRetry(
        operation,
        config: config ?? const RetryConfig(),
        operationName: opName,
        context: context,
      );
    } catch (error) {
      // å¤„ç†æœ€ç»ˆå¤±è´¥çš„é”™è¯¯
      final userFriendlyError = await handleError(
        error,
        operation: opName,
        context: context,
        shouldCleanupResources: shouldCleanupOnFailure,
      );
      
      // é‡æ–°æŠ›å‡ºåŸå§‹é”™è¯¯ï¼Œä½†å·²ç»è®°å½•å’Œå¤„ç†è¿‡äº?
      throw BackupException(
        type: BackupErrorType.unknown,
        message: userFriendlyError.message,
        originalError: error,
      );
    }
  }

  /// å®‰å…¨æ‰§è¡Œæ“ä½œï¼ˆæ•è·æ‰€æœ‰å¼‚å¸¸ï¼‰
  Future<T?> executeSafely<T>(
    Future<T> Function() operation, {
    String? operationName,
    Map<String, dynamic>? context,
    T? defaultValue,
    bool logErrors = true,
  }) async {
    try {
      return await operation();
    } catch (error) {
      if (logErrors) {
        await handleError(
          error,
          operation: operationName,
          context: context,
        );
      }
      return defaultValue;
    }
  }

  /// åˆ›å»ºæ“ä½œä¸Šä¸‹æ–?
  Future<String> createOperationContext(String operation, {
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final operationId = 'op_${DateTime.now().millisecondsSinceEpoch}';
      
      await _logger.info(operation, 'å¼€å§‹æ“ä½?, details: {
        'operationId': operationId,
        if (metadata != null) ...metadata,
      });
      
      return operationId;
    } catch (e) {
      await _logger.error('ErrorService', 'åˆ›å»ºæ“ä½œä¸Šä¸‹æ–‡å¤±è´?, error: e);
      return 'unknown_operation';
    }
  }

  /// å®Œæˆæ“ä½œä¸Šä¸‹æ–?
  Future<void> completeOperationContext(
    String operationId,
    String operation, {
    bool success = true,
    String? message,
    Map<String, dynamic>? result,
  }) async {
    try {
      if (success) {
        await _logger.info(operation, message ?? 'æ“ä½œå®Œæˆ', details: {
          'operationId': operationId,
          if (result != null) ...result,
        });
      } else {
        await _logger.warning(operation, message ?? 'æ“ä½œå¤±è´¥', details: {
          'operationId': operationId,
          if (result != null) ...result,
        });
      }
      
      // æ¸…ç†æ“ä½œç›¸å…³èµ„æº
      await _cleanupOperationResources(operation);
    } catch (e) {
      await _logger.error('ErrorService', 'å®Œæˆæ“ä½œä¸Šä¸‹æ–‡å¤±è´?, error: e);
    }
  }

  /// è·å–é”™è¯¯ç»Ÿè®¡ä¿¡æ¯
  Future<Map<String, dynamic>> getErrorStats({
    Duration? period,
  }) async {
    try {
      final since = period != null 
          ? DateTime.now().subtract(period)
          : DateTime.now().subtract(const Duration(days: 7));
      
      final logs = _logger.getMemoryLogs(
        minLevel: LogLevel.warning,
        since: since,
      );
      
      final errorCounts = <String, int>{};
      final operationCounts = <String, int>{};
      
      for (final log in logs) {
        // ç»Ÿè®¡é”™è¯¯ç±»å‹
        if (log.details?['errorType'] != null) {
          final errorType = log.details!['errorType'] as String;
          errorCounts[errorType] = (errorCounts[errorType] ?? 0) + 1;
        }
        
        // ç»Ÿè®¡æ“ä½œç±»å‹
        operationCounts[log.operation] = (operationCounts[log.operation] ?? 0) + 1;
      }
      
      return {
        'period': period?.inDays ?? 7,
        'totalErrors': logs.length,
        'errorsByType': errorCounts,
        'errorsByOperation': operationCounts,
        'resourceStats': _resourceManager.getResourceStats(),
      };
    } catch (e) {
      await _logger.error('ErrorService', 'è·å–é”™è¯¯ç»Ÿè®¡å¤±è´¥', error: e);
      return {'error': 'æ— æ³•è·å–ç»Ÿè®¡ä¿¡æ¯'};
    }
  }

  /// å¯¼å‡ºé”™è¯¯æŠ¥å‘Š
  Future<String?> exportErrorReport({
    Duration? period,
    bool includeResourceInfo = true,
  }) async {
    try {
      final stats = await getErrorStats(period: period);
      
      // å¯¼å‡ºæ—¥å¿—
      final logFilePath = await _logger.exportLogs(
        startDate: period != null 
            ? DateTime.now().subtract(period)
            : null,
        minLevel: LogLevel.warning,
      );
      
      if (logFilePath != null) {
        await _logger.info('ErrorService', 'é”™è¯¯æŠ¥å‘Šå¯¼å‡ºå®Œæˆ', details: {
          'filePath': logFilePath,
          'stats': stats,
        });
      }
      
      return logFilePath;
    } catch (e) {
      await _logger.error('ErrorService', 'å¯¼å‡ºé”™è¯¯æŠ¥å‘Šå¤±è´¥', error: e);
      return null;
    }
  }

  /// æ¸…ç†é”™è¯¯æœåŠ¡
  Future<void> cleanup() async {
    try {
      await _logger.info('ErrorService', 'å¼€å§‹æ¸…ç†é”™è¯¯æœåŠ?);
      
      // æ¸…ç†èµ„æº
      await _resourceManager.dispose();
      
      // æ¸…ç†æ—§æ—¥å¿?
      await _logger.cleanupOldLogs();
      
      // å…³é—­æµ?
      await _errorStreamController.close();
      
      _initialized = false;
      await _logger.info('ErrorService', 'é”™è¯¯æœåŠ¡æ¸…ç†å®Œæˆ');
    } catch (e) {
      debugPrint('Failed to cleanup BackupErrorService: $e');
    }
  }

  /// è®°å½•é”™è¯¯
  Future<void> _logError(
    Object error, {
    String? operation,
    Map<String, dynamic>? context,
  }) async {
    final severity = BackupErrorHandler.getErrorSeverity(error);
    final operationName = operation ?? 'UnknownOperation';
    
    switch (severity) {
      case LogLevel.debug:
        await _logger.debug(operationName, error.toString(), details: context);
        break;
      case LogLevel.info:
        await _logger.info(operationName, error.toString(), details: context);
        break;
      case LogLevel.warning:
        await _logger.warning(operationName, error.toString(), details: context);
        break;
      case LogLevel.error:
        await _logger.error(operationName, error.toString(), 
            error: error, details: context);
        break;
      case LogLevel.critical:
        await _logger.critical(operationName, error.toString(), 
            error: error, details: context);
        break;
    }
  }

  /// æ¸…ç†æ“ä½œç›¸å…³èµ„æº
  Future<void> _cleanupOperationResources(String operation) async {
    try {
      await _resourceManager.releaseOperationResources(operation);
    } catch (e) {
      await _logger.warning('ErrorService', 'æ¸…ç†æ“ä½œèµ„æºå¤±è´¥', 
          details: {'operation': operation, 'error': e.toString()});
    }
  }

  /// å¤„ç†Flutteré”™è¯¯
  void _handleFlutterError(FlutterErrorDetails details) {
    // è®°å½•Flutteræ¡†æ¶é”™è¯¯
    _logger.error(
      'FlutterError',
      details.summary.toString(),
      error: details.exception,
      stackTrace: details.stack,
      details: {
        'library': details.library,
        'context': details.context?.toString(),
      },
    );
    
    // è°ƒç”¨é»˜è®¤çš„é”™è¯¯å¤„ç?
    FlutterError.presentError(details);
  }
}
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'auto_backup_scheduler.dart';
import 'backup_notification_service.dart';
import 'unified_backup_service.dart';
import '../../../../core/database/database.dart';

/// å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–æœåŠ?
class BackupInitializationService {
  static AutoBackupScheduler? _scheduler;
  static bool _isInitialized = false;

  /// åˆå§‹åŒ–å¤‡ä»½åŠŸèƒ?
  static Future<void> initialize(AppDatabase database) async {
    if (_isInitialized) {
      return;
    }

    try {
      debugPrint('æ­£åœ¨åˆå§‹åŒ–å¤‡ä»½åŠŸèƒ?..');

      // åˆå§‹åŒ–é€šçŸ¥æœåŠ¡
      await BackupNotificationService.initialize();

      // åˆ›å»ºå¤‡ä»½æœåŠ¡
      final backupService = UnifiedBackupService(database);

      // åˆ›å»ºå¹¶åˆå§‹åŒ–è‡ªåŠ¨å¤‡ä»½è°ƒåº¦å™?
      _scheduler = AutoBackupScheduler(backupService);
      await _scheduler!.initialize();

      _isInitialized = true;
      debugPrint('å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–å®Œæˆ?);

    } catch (e, stackTrace) {
      debugPrint('å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–å¤±è´? $e');
      debugPrint('å †æ ˆè·Ÿè¸ª: $stackTrace');
    }
  }

  /// è·å–è‡ªåŠ¨å¤‡ä»½è°ƒåº¦å™¨å®ä¾?
  static AutoBackupScheduler? get scheduler => _scheduler;

  /// æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ?
  static bool get isInitialized => _isInitialized;

  /// æ¸…ç†èµ„æº
  static void dispose() {
    _scheduler?.dispose();
    _scheduler = null;
    _isInitialized = false;
    debugPrint('å¤‡ä»½åŠŸèƒ½å·²æ¸…ç?);
  }
}

/// å¤‡ä»½åˆå§‹åŒ–æä¾›è€?
final backupInitializationProvider = Provider<BackupInitializationService>((ref) {
  return BackupInitializationService();
});
import 'dart:io';
import 'dart:convert';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

/// å¤‡ä»½æ“ä½œæ—¥å¿—çº§åˆ«
enum LogLevel {
  debug,
  info,
  warning,
  error,
  critical,
}

/// æ—¥å¿—æ¡ç›®
class LogEntry {
  final DateTime timestamp;
  final LogLevel level;
  final String operation;
  final String message;
  final Map<String, dynamic>? details;
  final String? errorCode;
  final StackTrace? stackTrace;

  LogEntry({
    required this.timestamp,
    required this.level,
    required this.operation,
    required this.message,
    this.details,
    this.errorCode,
    this.stackTrace,
  });

  Map<String, dynamic> toJson() => {
        'timestamp': timestamp.toIso8601String(),
        'level': level.name,
        'operation': operation,
        'message': message,
        'details': details,
        'errorCode': errorCode,
        'stackTrace': stackTrace?.toString(),
      };

  factory LogEntry.fromJson(Map<String, dynamic> json) => LogEntry(
        timestamp: DateTime.parse(json['timestamp']),
        level: LogLevel.values.firstWhere((e) => e.name == json['level']),
        operation: json['operation'],
        message: json['message'],
        details: json['details'],
        errorCode: json['errorCode'],
        stackTrace: json['stackTrace'] != null 
            ? StackTrace.fromString(json['stackTrace'])
            : null,
      );
}

/// å¤‡ä»½æ“ä½œæ—¥å¿—è®°å½•å™?
class BackupLogger {
  static BackupLogger? _instance;
  static BackupLogger get instance => _instance ??= BackupLogger._();
  
  BackupLogger._();

  final List<LogEntry> _memoryLogs = [];
  final int _maxMemoryLogs = 1000;
  File? _logFile;
  bool _initialized = false;

  /// åˆå§‹åŒ–æ—¥å¿—è®°å½•å™¨
  Future<void> initialize() async {
    if (_initialized) return;
    
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final logsDir = Directory(path.join(appDir.path, 'logs'));
      
      if (!await logsDir.exists()) {
        await logsDir.create(recursive: true);
      }
      
      final today = DateTime.now();
      final dateStr = '${today.year}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
      _logFile = File(path.join(logsDir.path, 'backup_$dateStr.log'));
      
      _initialized = true;
      
      // è®°å½•åˆå§‹åŒ–æ—¥å¿?
      await info('BackupLogger', 'æ—¥å¿—è®°å½•å™¨åˆå§‹åŒ–å®Œæˆ');
    } catch (e) {
      // å¦‚æœæ— æ³•åˆå§‹åŒ–æ–‡ä»¶æ—¥å¿—ï¼Œè‡³å°‘ä¿æŒå†…å­˜æ—¥å¿—å¯ç”¨
      _initialized = true;
    }
  }

  /// è®°å½•è°ƒè¯•ä¿¡æ¯
  Future<void> debug(String operation, String message, {
    Map<String, dynamic>? details,
  }) async {
    await _log(LogLevel.debug, operation, message, details: details);
  }

  /// è®°å½•ä¸€èˆ¬ä¿¡æ?
  Future<void> info(String operation, String message, {
    Map<String, dynamic>? details,
  }) async {
    await _log(LogLevel.info, operation, message, details: details);
  }

  /// è®°å½•è­¦å‘Šä¿¡æ¯
  Future<void> warning(String operation, String message, {
    Map<String, dynamic>? details,
  }) async {
    await _log(LogLevel.warning, operation, message, details: details);
  }

  /// è®°å½•é”™è¯¯ä¿¡æ¯
  Future<void> error(String operation, String message, {
    Object? error,
    StackTrace? stackTrace,
    Map<String, dynamic>? details,
    String? errorCode,
  }) async {
    final errorDetails = <String, dynamic>{
      if (details != null) ...details,
      if (error != null) 'originalError': error.toString(),
    };
    
    await _log(
      LogLevel.error, 
      operation, 
      message,
      details: errorDetails.isNotEmpty ? errorDetails : null,
      errorCode: errorCode,
      stackTrace: stackTrace,
    );
  }

  /// è®°å½•ä¸¥é‡é”™è¯¯
  Future<void> critical(String operation, String message, {
    Object? error,
    StackTrace? stackTrace,
    Map<String, dynamic>? details,
    String? errorCode,
  }) async {
    final errorDetails = <String, dynamic>{
      if (details != null) ...details,
      if (error != null) 'originalError': error.toString(),
    };
    
    await _log(
      LogLevel.critical, 
      operation, 
      message,
      details: errorDetails.isNotEmpty ? errorDetails : null,
      errorCode: errorCode,
      stackTrace: stackTrace,
    );
  }

  /// å†…éƒ¨æ—¥å¿—è®°å½•æ–¹æ³•
  Future<void> _log(
    LogLevel level,
    String operation,
    String message, {
    Map<String, dynamic>? details,
    String? errorCode,
    StackTrace? stackTrace,
  }) async {
    if (!_initialized) {
      await initialize();
    }

    final entry = LogEntry(
      timestamp: DateTime.now(),
      level: level,
      operation: operation,
      message: message,
      details: details,
      errorCode: errorCode,
      stackTrace: stackTrace,
    );

    // æ·»åŠ åˆ°å†…å­˜æ—¥å¿?
    _memoryLogs.add(entry);
    
    // ä¿æŒå†…å­˜æ—¥å¿—æ•°é‡é™åˆ¶
    if (_memoryLogs.length > _maxMemoryLogs) {
      _memoryLogs.removeAt(0);
    }

    // å†™å…¥æ–‡ä»¶æ—¥å¿—
    await _writeToFile(entry);
  }

  /// å†™å…¥æ–‡ä»¶æ—¥å¿—
  Future<void> _writeToFile(LogEntry entry) async {
    if (_logFile == null) return;
    
    try {
      final logLine = '${entry.timestamp.toIso8601String()} '
          '[${entry.level.name.toUpperCase()}] '
          '${entry.operation}: ${entry.message}';
      
      final detailsLine = entry.details != null 
          ? '\n  Details: ${jsonEncode(entry.details)}'
          : '';
      
      final errorLine = entry.errorCode != null 
          ? '\n  ErrorCode: ${entry.errorCode}'
          : '';
      
      final stackLine = entry.stackTrace != null 
          ? '\n  StackTrace: ${entry.stackTrace.toString()}'
          : '';
      
      await _logFile!.writeAsString(
        '$logLine$detailsLine$errorLine$stackLine\n',
        mode: FileMode.append,
      );
    } catch (e) {
      // å¦‚æœæ— æ³•å†™å…¥æ–‡ä»¶ï¼Œå¿½ç•¥é”™è¯¯ä»¥é¿å…æ— é™å¾ªç¯
    }
  }

  /// è·å–å†…å­˜ä¸­çš„æ—¥å¿—æ¡ç›®
  List<LogEntry> getMemoryLogs({
    LogLevel? minLevel,
    String? operation,
    DateTime? since,
  }) {
    var logs = _memoryLogs.toList();
    
    if (minLevel != null) {
      final minIndex = LogLevel.values.indexOf(minLevel);
      logs = logs.where((log) => 
          LogLevel.values.indexOf(log.level) >= minIndex).toList();
    }
    
    if (operation != null) {
      logs = logs.where((log) => log.operation == operation).toList();
    }
    
    if (since != null) {
      logs = logs.where((log) => log.timestamp.isAfter(since)).toList();
    }
    
    return logs;
  }

  /// æ¸…ç†æ—§æ—¥å¿—æ–‡ä»?
  Future<void> cleanupOldLogs({int keepDays = 30}) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final logsDir = Directory(path.join(appDir.path, 'logs'));
      
      if (!await logsDir.exists()) return;
      
      final cutoffDate = DateTime.now().subtract(Duration(days: keepDays));
      final logFiles = await logsDir
          .list()
          .where((entity) => entity is File && entity.path.endsWith('.log'))
          .cast<File>()
          .toList();
      
      for (final file in logFiles) {
        final stat = await file.stat();
        if (stat.modified.isBefore(cutoffDate)) {
          await file.delete();
          await info('BackupLogger', 'åˆ é™¤è¿‡æœŸæ—¥å¿—æ–‡ä»¶: ${path.basename(file.path)}');
        }
      }
    } catch (e) {
      await error('BackupLogger', 'æ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶å¤±è´?, error: e);
    }
  }

  /// å¯¼å‡ºæ—¥å¿—æ–‡ä»¶
  Future<String?> exportLogs({
    DateTime? startDate,
    DateTime? endDate,
    LogLevel? minLevel,
  }) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final logsDir = Directory(path.join(appDir.path, 'logs'));
      
      if (!await logsDir.exists()) return null;
      
      final exportFile = File(path.join(
        appDir.path, 
        'backup_logs_export_${DateTime.now().millisecondsSinceEpoch}.json'
      ));
      
      // æ”¶é›†æ–‡ä»¶æ—¥å¿—
      final logFiles = await logsDir
          .list()
          .where((entity) => entity is File && entity.path.endsWith('.log'))
          .cast<File>()
          .toList();
      
      for (final file in logFiles) {
        try {
          // è¿™é‡Œå¯ä»¥è§£ææ—¥å¿—æ–‡ä»¶å†…å®¹ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ä¸»è¦ä½¿ç”¨å†…å­˜æ—¥å¿—
          await file.readAsString();
        } catch (e) {
          // å¿½ç•¥æ— æ³•è¯»å–çš„æ—¥å¿—æ–‡ä»?
        }
      }
      
      // ä½¿ç”¨å†…å­˜æ—¥å¿—
      var logs = getMemoryLogs(minLevel: minLevel);
      
      if (startDate != null) {
        logs = logs.where((log) => log.timestamp.isAfter(startDate)).toList();
      }
      
      if (endDate != null) {
        logs = logs.where((log) => log.timestamp.isBefore(endDate)).toList();
      }
      
      final exportData = {
        'exportedAt': DateTime.now().toIso8601String(),
        'totalLogs': logs.length,
        'filters': {
          'startDate': startDate?.toIso8601String(),
          'endDate': endDate?.toIso8601String(),
          'minLevel': minLevel?.name,
        },
        'logs': logs.map((log) => log.toJson()).toList(),
      };
      
      await exportFile.writeAsString(jsonEncode(exportData));
      return exportFile.path;
    } catch (e) {
      await error('BackupLogger', 'å¯¼å‡ºæ—¥å¿—å¤±è´¥', error: e);
      return null;
    }
  }
}
import 'package:flutter/foundation.dart';
import 'package:fluttertoast/fluttertoast.dart';

/// å¤‡ä»½é€šçŸ¥æœåŠ¡
/// ç›®å‰ä½¿ç”¨Toastæ˜¾ç¤ºé€šçŸ¥ï¼Œæœªæ¥å¯ä»¥é›†æˆflutter_local_notifications
class BackupNotificationService {
  // é¢„ç•™çš„é€šçŸ¥æ¸ é“é…ç½®ï¼Œæœªæ¥é›†æˆflutter_local_notificationsæ—¶ä½¿ç”?
  // static const String _channelId = 'backup_notifications';
  // static const String _channelName = 'å¤‡ä»½é€šçŸ¥';
  // static const String _channelDescription = 'è‡ªåŠ¨å¤‡ä»½ç›¸å…³çš„é€šçŸ¥';

  /// åˆå§‹åŒ–é€šçŸ¥æœåŠ¡
  static Future<void> initialize() async {
    // è¿™é‡Œå¯ä»¥åˆå§‹åŒ–flutter_local_notifications
    // ç›®å‰ä½¿ç”¨ç®€å•çš„å®ç°
    debugPrint('å¤‡ä»½é€šçŸ¥æœåŠ¡å·²åˆå§‹åŒ–');
  }

  /// æ˜¾ç¤ºå¤‡ä»½æˆåŠŸé€šçŸ¥
  static Future<void> showBackupSuccessNotification({
    required String title,
    required String message,
  }) async {
    debugPrint('å¤‡ä»½æˆåŠŸé€šçŸ¥: $title - $message');
    
    // åœ¨åº”ç”¨å‰å°æ—¶æ˜¾ç¤ºToast
    if (!kReleaseMode) {
      Fluttertoast.showToast(
        msg: '$title: $message',
        toastLength: Toast.LENGTH_LONG,
      );
    }
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ æœ¬åœ°é€šçŸ¥çš„å®ç?
    // await _showLocalNotification(
    //   title: title,
    //   body: message,
    //   payload: 'backup_success',
    // );
  }

  /// æ˜¾ç¤ºå¤‡ä»½å¤±è´¥é€šçŸ¥
  static Future<void> showBackupFailureNotification({
    required String title,
    required String message,
  }) async {
    debugPrint('å¤‡ä»½å¤±è´¥é€šçŸ¥: $title - $message');
    
    // åœ¨åº”ç”¨å‰å°æ—¶æ˜¾ç¤ºToast
    if (!kReleaseMode) {
      Fluttertoast.showToast(
        msg: '$title: $message',
        toastLength: Toast.LENGTH_LONG,
      );
    }
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ æœ¬åœ°é€šçŸ¥çš„å®ç?
    // await _showLocalNotification(
    //   title: title,
    //   body: message,
    //   payload: 'backup_failure',
    // );
  }

  /// æ˜¾ç¤ºå¤‡ä»½æé†’é€šçŸ¥
  static Future<void> showBackupReminderNotification({
    required String message,
  }) async {
    debugPrint('å¤‡ä»½æé†’é€šçŸ¥: $message');
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ æœ¬åœ°é€šçŸ¥çš„å®ç?
    // await _showLocalNotification(
    //   title: 'å¤‡ä»½æé†’',
    //   body: message,
    //   payload: 'backup_reminder',
    // );
  }

  /// å–æ¶ˆæ‰€æœ‰å¤‡ä»½ç›¸å…³é€šçŸ¥
  static Future<void> cancelAllNotifications() async {
    debugPrint('å–æ¶ˆæ‰€æœ‰å¤‡ä»½é€šçŸ¥');
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ å–æ¶ˆæœ¬åœ°é€šçŸ¥çš„å®ç?
    // await _flutterLocalNotificationsPlugin.cancelAll();
  }

  /// å–æ¶ˆç‰¹å®šçš„é€šçŸ¥
  static Future<void> cancelNotification(int notificationId) async {
    debugPrint('å–æ¶ˆé€šçŸ¥: $notificationId');
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ å–æ¶ˆç‰¹å®šæœ¬åœ°é€šçŸ¥çš„å®ç?
    // await _flutterLocalNotificationsPlugin.cancel(notificationId);
  }

  // æœªæ¥å¯ä»¥æ·»åŠ çš„æœ¬åœ°é€šçŸ¥å®ç°
  // static Future<void> _showLocalNotification({
  //   required String title,
  //   required String body,
  //   String? payload,
  // }) async {
  //   const androidDetails = AndroidNotificationDetails(
  //     _channelId,
  //     _channelName,
  //     channelDescription: _channelDescription,
  //     importance: Importance.high,
  //     priority: Priority.high,
  //   );
  //   
  //   const iosDetails = DarwinNotificationDetails();
  //   
  //   const notificationDetails = NotificationDetails(
  //     android: androidDetails,
  //     iOS: iosDetails,
  //   );
  //   
  //   await _flutterLocalNotificationsPlugin.show(
  //     DateTime.now().millisecondsSinceEpoch.remainder(100000),
  //     title,
  //     body,
  //     notificationDetails,
  //     payload: payload,
  //   );
  // }
}
import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../../../core/database/database.dart';
import 'backup_diagnostic_service.dart';
import 'backup_logger.dart';

/// å¤‡ä»½ä¿®å¤ç»“æœ
class BackupRepairResult {
  final bool success;
  final List<String> fixedIssues;
  final List<String> remainingIssues;
  final String message;

  const BackupRepairResult({
    required this.success,
    required this.fixedIssues,
    required this.remainingIssues,
    required this.message,
  });
}

/// å¤‡ä»½ä¿®å¤æœåŠ¡
class BackupRepairService {
  final AppDatabase _database;
  final BackupLogger _logger = BackupLogger.instance;
  late final BackupDiagnosticService _diagnosticService;

  BackupRepairService(this._database) {
    _diagnosticService = BackupDiagnosticService(_database);
  }

  /// è‡ªåŠ¨ä¿®å¤å¤‡ä»½ç³»ç»Ÿé—®é¢˜
  Future<BackupRepairResult> autoRepair() async {
    final fixedIssues = <String>[];
    final remainingIssues = <String>[];
    
    try {
      await _logger.info('BackupRepair', 'å¼€å§‹è‡ªåŠ¨ä¿®å¤å¤‡ä»½ç³»ç»?);
      
      // 1. è¿è¡Œè¯Šæ–­
      final diagnostic = await _diagnosticService.runFullDiagnostic();
      
      if (diagnostic.isHealthy) {
        return BackupRepairResult(
          success: true,
          fixedIssues: [],
          remainingIssues: [],
          message: 'å¤‡ä»½ç³»ç»ŸçŠ¶æ€æ­£å¸¸ï¼Œæ— éœ€ä¿®å¤',
        );
      }
      
      // 2. ä¿®å¤å¤‡ä»½ç›®å½•é—®é¢˜
      await _fixBackupDirectory(fixedIssues, remainingIssues);
      
      // 3. ä¿®å¤æƒé™é—®é¢˜
      await _fixPermissions(fixedIssues, remainingIssues);
      
      // 4. æ¸…ç†æŸåçš„å¤‡ä»½æ–‡ä»?
      await _cleanupCorruptedBackups(fixedIssues, remainingIssues);
      
      // 5. ä¿®å¤æ•°æ®åº“è¿æ¥é—®é¢?
      await _fixDatabaseIssues(fixedIssues, remainingIssues);
      
      // 6. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await _cleanupTemporaryFiles(fixedIssues, remainingIssues);
      
      final success = remainingIssues.isEmpty;
      final message = success 
          ? 'ä¿®å¤å®Œæˆï¼Œå…±è§£å†³ ${fixedIssues.length} ä¸ªé—®é¢?
          : 'éƒ¨åˆ†ä¿®å¤å®Œæˆï¼Œè¿˜æœ?${remainingIssues.length} ä¸ªé—®é¢˜éœ€è¦æ‰‹åŠ¨å¤„ç?;
      
      await _logger.info('BackupRepair', 'è‡ªåŠ¨ä¿®å¤å®Œæˆ', details: {
        'success': success,
        'fixedCount': fixedIssues.length,
        'remainingCount': remainingIssues.length,
      });
      
      return BackupRepairResult(
        success: success,
        fixedIssues: fixedIssues,
        remainingIssues: remainingIssues,
        message: message,
      );
      
    } catch (e) {
      await _logger.error('BackupRepair', 'è‡ªåŠ¨ä¿®å¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯?, error: e);
      
      return BackupRepairResult(
        success: false,
        fixedIssues: fixedIssues,
        remainingIssues: ['ä¿®å¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯? ${e.toString()}'],
        message: 'ä¿®å¤å¤±è´¥ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ?,
      );
    }
  }

  /// ä¿®å¤å¤‡ä»½ç›®å½•é—®é¢˜
  Future<void> _fixBackupDirectory(
    List<String> fixedIssues,
    List<String> remainingIssues,
  ) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(path.join(appDir.path, 'backups'));
      
      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
        fixedIssues.add('åˆ›å»ºäº†ç¼ºå¤±çš„å¤‡ä»½ç›®å½•');
      }
      
      // æ£€æŸ¥ç›®å½•æƒé™?
      try {
        final testFile = File(path.join(backupDir.path, 'test_permission.tmp'));
        await testFile.writeAsString('test');
        await testFile.delete();
        fixedIssues.add('éªŒè¯äº†å¤‡ä»½ç›®å½•çš„è¯»å†™æƒé™');
      } catch (e) {
        remainingIssues.add('å¤‡ä»½ç›®å½•æƒé™é—®é¢˜: ${e.toString()}');
      }
      
    } catch (e) {
      remainingIssues.add('æ— æ³•ä¿®å¤å¤‡ä»½ç›®å½•: ${e.toString()}');
    }
  }

  /// ä¿®å¤æƒé™é—®é¢˜
  Future<void> _fixPermissions(
    List<String> fixedIssues,
    List<String> remainingIssues,
  ) async {
    try {
      // æµ‹è¯•åŸºæœ¬æ–‡ä»¶æ“ä½œæƒé™
      final tempDir = Directory.systemTemp;
      final testFile = File(path.join(tempDir.path, 'backup_repair_test.tmp'));
      
      await testFile.writeAsString('permission repair test');
      final content = await testFile.readAsString();
      
      if (content == 'permission repair test') {
        await testFile.delete();
        fixedIssues.add('éªŒè¯äº†åŸºæœ¬æ–‡ä»¶æ“ä½œæƒé™?);
      } else {
        remainingIssues.add('æ–‡ä»¶è¯»å†™æƒé™å¼‚å¸¸');
      }
      
    } catch (e) {
      remainingIssues.add('æƒé™ä¿®å¤å¤±è´¥: ${e.toString()}');
    }
  }

  /// æ¸…ç†æŸåçš„å¤‡ä»½æ–‡ä»?
  Future<void> _cleanupCorruptedBackups(
    List<String> fixedIssues,
    List<String> remainingIssues,
  ) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(path.join(appDir.path, 'backups'));
      
      if (!await backupDir.exists()) {
        return;
      }
      
      final files = await backupDir
          .list()
          .where((entity) => entity is File && entity.path.endsWith('.json'))
          .cast<File>()
          .toList();
      
      int corruptedCount = 0;
      
      for (final file in files) {
        try {
          // å°è¯•è¯»å–å’Œè§£ææ–‡ä»?
          final content = await file.readAsString();
          if (content.trim().isEmpty) {
            await file.delete();
            corruptedCount++;
            continue;
          }
          
          // å°è¯•è§£æJSON
          final jsonData = json.decode(content);
          if (jsonData is! Map<String, dynamic> ||
              !jsonData.containsKey('metadata') ||
              !jsonData.containsKey('tables')) {
            await file.delete();
            corruptedCount++;
          }
          
        } catch (e) {
          // æ–‡ä»¶æŸåï¼Œåˆ é™¤å®ƒ
          try {
            await file.delete();
            corruptedCount++;
          } catch (deleteError) {
            remainingIssues.add('æ— æ³•åˆ é™¤æŸåçš„å¤‡ä»½æ–‡ä»? ${file.path}');
          }
        }
      }
      
      if (corruptedCount > 0) {
        fixedIssues.add('æ¸…ç†äº?$corruptedCount ä¸ªæŸåçš„å¤‡ä»½æ–‡ä»¶');
      }
      
    } catch (e) {
      remainingIssues.add('æ¸…ç†æŸåå¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// ä¿®å¤æ•°æ®åº“è¿æ¥é—®é¢?
  Future<void> _fixDatabaseIssues(
    List<String> fixedIssues,
    List<String> remainingIssues,
  ) async {
    try {
      // å°è¯•æ‰§è¡Œç®€å•çš„æ•°æ®åº“æŸ¥è¯?
      final result = await _database.customSelect('SELECT 1 as test').get();
      
      if (result.isNotEmpty && result.first.data['test'] == 1) {
        fixedIssues.add('éªŒè¯äº†æ•°æ®åº“è¿æ¥æ­£å¸¸');
      } else {
        remainingIssues.add('æ•°æ®åº“æŸ¥è¯¢è¿”å›å¼‚å¸¸ç»“æ?);
      }
      
    } catch (e) {
      remainingIssues.add('æ•°æ®åº“è¿æ¥é—®é¢? ${e.toString()}');
    }
  }

  /// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
  Future<void> _cleanupTemporaryFiles(
    List<String> fixedIssues,
    List<String> remainingIssues,
  ) async {
    try {
      final tempDir = Directory.systemTemp;
      final tempFiles = await tempDir
          .list()
          .where((entity) => 
              entity is File && 
              (entity.path.contains('backup_temp') || 
               entity.path.contains('backup_repair_test') ||
               entity.path.contains('test_write_permission')))
          .cast<File>()
          .toList();
      
      int cleanedCount = 0;
      
      for (final file in tempFiles) {
        try {
          await file.delete();
          cleanedCount++;
        } catch (e) {
          // å¿½ç•¥æ— æ³•åˆ é™¤çš„ä¸´æ—¶æ–‡ä»?
        }
      }
      
      if (cleanedCount > 0) {
        fixedIssues.add('æ¸…ç†äº?$cleanedCount ä¸ªä¸´æ—¶æ–‡ä»?);
      }
      
    } catch (e) {
      // ä¸´æ—¶æ–‡ä»¶æ¸…ç†å¤±è´¥ä¸æ˜¯ä¸¥é‡é—®é¢˜
      await _logger.warning('BackupRepair', 'æ¸…ç†ä¸´æ—¶æ–‡ä»¶æ—¶å‘ç”Ÿè­¦å‘?, 
          details: {'error': e.toString()});
    }
  }

  /// é‡ç½®å¤‡ä»½ç³»ç»Ÿ
  Future<BackupRepairResult> resetBackupSystem() async {
    final fixedIssues = <String>[];
    final remainingIssues = <String>[];
    
    try {
      await _logger.info('BackupRepair', 'å¼€å§‹é‡ç½®å¤‡ä»½ç³»ç»?);
      
      // 1. æ¸…ç†æ‰€æœ‰å¤‡ä»½æ–‡ä»?
      try {
        final appDir = await getApplicationDocumentsDirectory();
        final backupDir = Directory(path.join(appDir.path, 'backups'));
        
        if (await backupDir.exists()) {
          await backupDir.delete(recursive: true);
          fixedIssues.add('åˆ é™¤äº†æ—§çš„å¤‡ä»½ç›®å½?);
        }
        
        // é‡æ–°åˆ›å»ºå¤‡ä»½ç›®å½•
        await backupDir.create(recursive: true);
        fixedIssues.add('é‡æ–°åˆ›å»ºäº†å¤‡ä»½ç›®å½?);
        
      } catch (e) {
        remainingIssues.add('é‡ç½®å¤‡ä»½ç›®å½•å¤±è´¥: ${e.toString()}');
      }
      
      // 2. æ¸…ç†æ‰€æœ‰ä¸´æ—¶æ–‡ä»?
      await _cleanupTemporaryFiles(fixedIssues, remainingIssues);
      
      // 3. éªŒè¯æ•°æ®åº“è¿æ?
      await _fixDatabaseIssues(fixedIssues, remainingIssues);
      
      final success = remainingIssues.isEmpty;
      final message = success 
          ? 'å¤‡ä»½ç³»ç»Ÿé‡ç½®å®Œæˆ'
          : 'å¤‡ä»½ç³»ç»Ÿé‡ç½®éƒ¨åˆ†å®Œæˆï¼Œè¿˜æœ‰é—®é¢˜éœ€è¦å¤„ç?;
      
      await _logger.info('BackupRepair', 'å¤‡ä»½ç³»ç»Ÿé‡ç½®å®Œæˆ', details: {
        'success': success,
        'fixedCount': fixedIssues.length,
        'remainingCount': remainingIssues.length,
      });
      
      return BackupRepairResult(
        success: success,
        fixedIssues: fixedIssues,
        remainingIssues: remainingIssues,
        message: message,
      );
      
    } catch (e) {
      await _logger.error('BackupRepair', 'é‡ç½®å¤‡ä»½ç³»ç»Ÿå¤±è´¥', error: e);
      
      return BackupRepairResult(
        success: false,
        fixedIssues: fixedIssues,
        remainingIssues: ['é‡ç½®è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯? ${e.toString()}'],
        message: 'é‡ç½®å¤±è´¥ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ?,
      );
    }
  }

  /// éªŒè¯ä¿®å¤ç»“æœ
  Future<bool> verifyRepair() async {
    try {
      final diagnostic = await _diagnosticService.runQuickDiagnostic();
      return diagnostic.isHealthy;
    } catch (e) {
      await _logger.error('BackupRepair', 'éªŒè¯ä¿®å¤ç»“æœå¤±è´¥', error: e);
      return false;
    }
  }
}
import 'dart:io';
import 'dart:async';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import 'backup_logger.dart';

/// èµ„æºç±»å‹
enum ResourceType {
  temporaryFile,
  temporaryDirectory,
  lockFile,
  cacheFile,
}

/// èµ„æºä¿¡æ¯
class ResourceInfo {
  final String id;
  final ResourceType type;
  final String path;
  final DateTime createdAt;
  final String? operation;
  final Map<String, dynamic>? metadata;

  ResourceInfo({
    required this.id,
    required this.type,
    required this.path,
    required this.createdAt,
    this.operation,
    this.metadata,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'type': type.name,
        'path': path,
        'createdAt': createdAt.toIso8601String(),
        'operation': operation,
        'metadata': metadata,
      };

  factory ResourceInfo.fromJson(Map<String, dynamic> json) => ResourceInfo(
        id: json['id'],
        type: ResourceType.values.firstWhere((e) => e.name == json['type']),
        path: json['path'],
        createdAt: DateTime.parse(json['createdAt']),
        operation: json['operation'],
        metadata: json['metadata'],
      );
}

/// å¤‡ä»½èµ„æºç®¡ç†å™?
class BackupResourceManager {
  static BackupResourceManager? _instance;
  static BackupResourceManager get instance => _instance ??= BackupResourceManager._();
  
  BackupResourceManager._();

  final BackupLogger _logger = BackupLogger.instance;
  final Map<String, ResourceInfo> _trackedResources = {};
  final Set<String> _activeOperations = {};
  Timer? _cleanupTimer;
  bool _initialized = false;

  /// åˆå§‹åŒ–èµ„æºç®¡ç†å™¨
  Future<void> initialize() async {
    if (_initialized) return;
    
    try {
      await _logger.info('ResourceManager', 'åˆå§‹åŒ–èµ„æºç®¡ç†å™¨');
      
      // æ¸…ç†é—ç•™çš„ä¸´æ—¶æ–‡ä»?
      await _cleanupOrphanedResources();
      
      // å¯åŠ¨å®šæœŸæ¸…ç†ä»»åŠ¡
      _startPeriodicCleanup();
      
      _initialized = true;
      await _logger.info('ResourceManager', 'èµ„æºç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
    } catch (e) {
      await _logger.error('ResourceManager', 'åˆå§‹åŒ–èµ„æºç®¡ç†å™¨å¤±è´¥', error: e);
      rethrow;
    }
  }

  /// åˆ›å»ºä¸´æ—¶æ–‡ä»¶
  Future<File> createTemporaryFile({
    String? prefix,
    String? suffix,
    String? operation,
    Map<String, dynamic>? metadata,
  }) async {
    await _ensureInitialized();
    
    try {
      final tempDir = await getTemporaryDirectory();
      final fileName = _generateFileName(prefix: prefix, suffix: suffix);
      final file = File(path.join(tempDir.path, fileName));
      
      final resourceId = _generateResourceId();
      final resourceInfo = ResourceInfo(
        id: resourceId,
        type: ResourceType.temporaryFile,
        path: file.path,
        createdAt: DateTime.now(),
        operation: operation,
        metadata: metadata,
      );
      
      _trackedResources[resourceId] = resourceInfo;
      
      await _logger.debug('ResourceManager', 'åˆ›å»ºä¸´æ—¶æ–‡ä»¶: ${file.path}', 
          details: {'resourceId': resourceId, 'operation': operation});
      
      return file;
    } catch (e) {
      await _logger.error('ResourceManager', 'åˆ›å»ºä¸´æ—¶æ–‡ä»¶å¤±è´¥', error: e);
      rethrow;
    }
  }

  /// åˆ›å»ºä¸´æ—¶ç›®å½•
  Future<Directory> createTemporaryDirectory({
    String? prefix,
    String? operation,
    Map<String, dynamic>? metadata,
  }) async {
    await _ensureInitialized();
    
    try {
      final tempDir = await getTemporaryDirectory();
      final dirName = _generateFileName(prefix: prefix);
      final directory = Directory(path.join(tempDir.path, dirName));
      
      await directory.create(recursive: true);
      
      final resourceId = _generateResourceId();
      final resourceInfo = ResourceInfo(
        id: resourceId,
        type: ResourceType.temporaryDirectory,
        path: directory.path,
        createdAt: DateTime.now(),
        operation: operation,
        metadata: metadata,
      );
      
      _trackedResources[resourceId] = resourceInfo;
      
      await _logger.debug('ResourceManager', 'åˆ›å»ºä¸´æ—¶ç›®å½•: ${directory.path}', 
          details: {'resourceId': resourceId, 'operation': operation});
      
      return directory;
    } catch (e) {
      await _logger.error('ResourceManager', 'åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥', error: e);
      rethrow;
    }
  }

  /// åˆ›å»ºé”æ–‡ä»?
  Future<File> createLockFile({
    required String operation,
    Map<String, dynamic>? metadata,
  }) async {
    await _ensureInitialized();
    
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final locksDir = Directory(path.join(appDir.path, 'locks'));
      
      if (!await locksDir.exists()) {
        await locksDir.create(recursive: true);
      }
      
      final lockFileName = '${operation}_${DateTime.now().millisecondsSinceEpoch}.lock';
      final lockFile = File(path.join(locksDir.path, lockFileName));
      
      // å†™å…¥é”æ–‡ä»¶ä¿¡æ?
      final lockInfo = {
        'operation': operation,
        'createdAt': DateTime.now().toIso8601String(),
        'processId': pid,
        'metadata': metadata,
      };
      
      await lockFile.writeAsString(lockInfo.toString());
      
      final resourceId = _generateResourceId();
      final resourceInfo = ResourceInfo(
        id: resourceId,
        type: ResourceType.lockFile,
        path: lockFile.path,
        createdAt: DateTime.now(),
        operation: operation,
        metadata: metadata,
      );
      
      _trackedResources[resourceId] = resourceInfo;
      _activeOperations.add(operation);
      
      await _logger.debug('ResourceManager', 'åˆ›å»ºé”æ–‡ä»? ${lockFile.path}', 
          details: {'resourceId': resourceId, 'operation': operation});
      
      return lockFile;
    } catch (e) {
      await _logger.error('ResourceManager', 'åˆ›å»ºé”æ–‡ä»¶å¤±è´?, error: e);
      rethrow;
    }
  }

  /// é‡Šæ”¾èµ„æº
  Future<void> releaseResource(String resourceId) async {
    try {
      final resourceInfo = _trackedResources[resourceId];
      if (resourceInfo == null) {
        await _logger.warning('ResourceManager', 'å°è¯•é‡Šæ”¾ä¸å­˜åœ¨çš„èµ„æº: $resourceId');
        return;
      }
      
      await _deleteResource(resourceInfo);
      _trackedResources.remove(resourceId);
      
      if (resourceInfo.operation != null) {
        _activeOperations.remove(resourceInfo.operation);
      }
      
      await _logger.debug('ResourceManager', 'é‡Šæ”¾èµ„æº: ${resourceInfo.path}', 
          details: {'resourceId': resourceId, 'type': resourceInfo.type.name});
    } catch (e) {
      await _logger.error('ResourceManager', 'é‡Šæ”¾èµ„æºå¤±è´¥', 
          error: e, details: {'resourceId': resourceId});
    }
  }

  /// é‡Šæ”¾æ“ä½œç›¸å…³çš„æ‰€æœ‰èµ„æº?
  Future<void> releaseOperationResources(String operation) async {
    try {
      final operationResources = _trackedResources.values
          .where((resource) => resource.operation == operation)
          .toList();
      
      for (final resource in operationResources) {
        await releaseResource(resource.id);
      }
      
      _activeOperations.remove(operation);
      
      await _logger.info('ResourceManager', 'é‡Šæ”¾æ“ä½œç›¸å…³èµ„æº: $operation', 
          details: {'resourceCount': operationResources.length});
    } catch (e) {
      await _logger.error('ResourceManager', 'é‡Šæ”¾æ“ä½œèµ„æºå¤±è´¥', 
          error: e, details: {'operation': operation});
    }
  }

  /// æ¸…ç†è¿‡æœŸèµ„æº
  Future<void> cleanupExpiredResources({Duration? maxAge}) async {
    await _ensureInitialized();
    
    try {
      final cutoffTime = DateTime.now().subtract(maxAge ?? const Duration(hours: 24));
      final expiredResources = _trackedResources.values
          .where((resource) => resource.createdAt.isBefore(cutoffTime))
          .toList();
      
      for (final resource in expiredResources) {
        await releaseResource(resource.id);
      }
      
      await _logger.info('ResourceManager', 'æ¸…ç†è¿‡æœŸèµ„æºå®Œæˆ', 
          details: {'cleanedCount': expiredResources.length});
    } catch (e) {
      await _logger.error('ResourceManager', 'æ¸…ç†è¿‡æœŸèµ„æºå¤±è´¥', error: e);
    }
  }

  /// å¼ºåˆ¶æ¸…ç†æ‰€æœ‰èµ„æº?
  Future<void> forceCleanupAllResources() async {
    try {
      final allResources = _trackedResources.values.toList();
      
      for (final resource in allResources) {
        await releaseResource(resource.id);
      }
      
      _activeOperations.clear();
      
      await _logger.info('ResourceManager', 'å¼ºåˆ¶æ¸…ç†æ‰€æœ‰èµ„æºå®Œæˆ?, 
          details: {'cleanedCount': allResources.length});
    } catch (e) {
      await _logger.error('ResourceManager', 'å¼ºåˆ¶æ¸…ç†æ‰€æœ‰èµ„æºå¤±è´?, error: e);
    }
  }

  /// æ£€æŸ¥æ“ä½œæ˜¯å¦æ­£åœ¨è¿›è¡?
  bool isOperationActive(String operation) {
    return _activeOperations.contains(operation);
  }

  /// è·å–èµ„æºç»Ÿè®¡ä¿¡æ¯
  Map<String, dynamic> getResourceStats() {
    final stats = <ResourceType, int>{};
    for (final resource in _trackedResources.values) {
      stats[resource.type] = (stats[resource.type] ?? 0) + 1;
    }
    
    return {
      'totalResources': _trackedResources.length,
      'activeOperations': _activeOperations.length,
      'resourcesByType': stats.map((type, count) => MapEntry(type.name, count)),
      'oldestResource': _trackedResources.values.isNotEmpty
          ? _trackedResources.values
              .map((r) => r.createdAt)
              .reduce((a, b) => a.isBefore(b) ? a : b)
              .toIso8601String()
          : null,
    };
  }

  /// è·å–æ‰€æœ‰è·Ÿè¸ªçš„èµ„æº
  List<ResourceInfo> getTrackedResources() {
    return _trackedResources.values.toList();
  }

  /// é”€æ¯èµ„æºç®¡ç†å™¨
  Future<void> dispose() async {
    try {
      _cleanupTimer?.cancel();
      await forceCleanupAllResources();
      _initialized = false;
      await _logger.info('ResourceManager', 'èµ„æºç®¡ç†å™¨å·²é”€æ¯?);
    } catch (e) {
      await _logger.error('ResourceManager', 'é”€æ¯èµ„æºç®¡ç†å™¨å¤±è´¥', error: e);
    }
  }

  /// ç¡®ä¿å·²åˆå§‹åŒ–
  Future<void> _ensureInitialized() async {
    if (!_initialized) {
      await initialize();
    }
  }

  /// ç”Ÿæˆèµ„æºID
  String _generateResourceId() {
    return 'res_${DateTime.now().millisecondsSinceEpoch}_${_trackedResources.length}';
  }

  /// ç”Ÿæˆæ–‡ä»¶å?
  String _generateFileName({String? prefix, String? suffix}) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final prefixPart = prefix != null ? '${prefix}_' : 'backup_';
    final suffixPart = suffix ?? 'tmp';
    return '$prefixPart$timestamp.$suffixPart';
  }

  /// åˆ é™¤èµ„æº
  Future<void> _deleteResource(ResourceInfo resourceInfo) async {
    try {
      switch (resourceInfo.type) {
        case ResourceType.temporaryFile:
        case ResourceType.lockFile:
        case ResourceType.cacheFile:
          final file = File(resourceInfo.path);
          if (await file.exists()) {
            await file.delete();
          }
          break;
        case ResourceType.temporaryDirectory:
          final directory = Directory(resourceInfo.path);
          if (await directory.exists()) {
            await directory.delete(recursive: true);
          }
          break;
      }
    } catch (e) {
      await _logger.warning('ResourceManager', 'åˆ é™¤èµ„æºå¤±è´¥: ${resourceInfo.path}', 
          details: {'error': e.toString()});
    }
  }

  /// æ¸…ç†å­¤ç«‹èµ„æº
  Future<void> _cleanupOrphanedResources() async {
    try {
      // æ¸…ç†ä¸´æ—¶ç›®å½•ä¸­çš„å­¤ç«‹æ–‡ä»¶
      final tempDir = await getTemporaryDirectory();
      if (await tempDir.exists()) {
        await _cleanupDirectoryOrphans(tempDir, 'backup_', const Duration(hours: 24));
      }
      
      // æ¸…ç†é”æ–‡ä»¶ç›®å½?
      final appDir = await getApplicationDocumentsDirectory();
      final locksDir = Directory(path.join(appDir.path, 'locks'));
      if (await locksDir.exists()) {
        await _cleanupDirectoryOrphans(locksDir, '', const Duration(hours: 1));
      }
      
      await _logger.info('ResourceManager', 'æ¸…ç†å­¤ç«‹èµ„æºå®Œæˆ');
    } catch (e) {
      await _logger.error('ResourceManager', 'æ¸…ç†å­¤ç«‹èµ„æºå¤±è´¥', error: e);
    }
  }

  /// æ¸…ç†ç›®å½•ä¸­çš„å­¤ç«‹æ–‡ä»¶
  Future<void> _cleanupDirectoryOrphans(
    Directory directory,
    String prefix,
    Duration maxAge,
  ) async {
    try {
      final cutoffTime = DateTime.now().subtract(maxAge);
      final entities = await directory.list().toList();
      
      for (final entity in entities) {
        if (entity is File && entity.path.contains(prefix)) {
          final stat = await entity.stat();
          if (stat.modified.isBefore(cutoffTime)) {
            await entity.delete();
            await _logger.debug('ResourceManager', 'åˆ é™¤å­¤ç«‹æ–‡ä»¶: ${entity.path}');
          }
        }
      }
    } catch (e) {
      await _logger.warning('ResourceManager', 'æ¸…ç†ç›®å½•å­¤ç«‹æ–‡ä»¶å¤±è´¥: ${directory.path}', 
          details: {'error': e.toString()});
    }
  }

  /// å¯åŠ¨å®šæœŸæ¸…ç†ä»»åŠ¡
  void _startPeriodicCleanup() {
    _cleanupTimer = Timer.periodic(const Duration(hours: 6), (timer) async {
      await cleanupExpiredResources();
    });
  }
}
import 'dart:io';
import 'dart:developer' as developer;

import 'package:archive/archive.dart';

import '../../domain/models/performance_metrics.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/services/i_performance_service.dart';

/// å‹ç¼©æœåŠ¡å®ç°
class CompressionService implements ICompressionService {
  static const String _gzipMagic = '\x1f\x8b';
  static const String _zipMagic = 'PK';

  @override
  Future<CompressionResult> compressData(
    List<int> data, {
    int level = 6,
  }) async {
    final startTime = DateTime.now();
    
    try {
      developer.log(
        'Starting data compression, size: ${data.length} bytes, level: $level',
        name: 'CompressionService',
      );

      // ä½¿ç”¨GZipå‹ç¼©ï¼ˆarchiveåŒ…ä¸æ”¯æŒlevelå‚æ•°ï¼Œä½¿ç”¨é»˜è®¤å‹ç¼©ï¼‰
      final compressedData = GZipEncoder().encode(data);
      
      final endTime = DateTime.now();
      final compressionTime = endTime.difference(startTime);
      
      final stats = CompressionStats(
        originalSize: data.length,
        compressedSize: compressedData.length,
        compressionRatio: data.isNotEmpty
            ? (data.length - compressedData.length) / data.length
            : 0.0,
        compressionTime: compressionTime,
        algorithm: 'gzip',
      );

      developer.log(
        'Data compression completed: ${data.length} -> ${compressedData.length} bytes '
        '(${(stats.compressionRatio * 100).toStringAsFixed(1)}% reduction) '
        'in ${compressionTime.inMilliseconds}ms',
        name: 'CompressionService',
      );

      return CompressionResult(
        compressedData: compressedData,
        stats: stats,
      );

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.compressionError,
        message: 'æ•°æ®å‹ç¼©å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<List<int>> decompressData(List<int> compressedData) async {
    try {
      developer.log(
        'Starting data decompression, size: ${compressedData.length} bytes',
        name: 'CompressionService',
      );

      // ä½¿ç”¨GZipè§£å‹
      final decompressedData = GZipDecoder().decodeBytes(compressedData);

      developer.log(
        'Data decompression completed: ${compressedData.length} -> ${decompressedData.length} bytes',
        name: 'CompressionService',
      );

      return decompressedData;

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.compressionError,
        message: 'æ•°æ®è§£å‹å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<CompressionStats> compressFile(
    String inputPath,
    String outputPath, {
    int level = 6,
  }) async {
    final startTime = DateTime.now();
    
    try {
      final inputFile = File(inputPath);
      if (!await inputFile.exists()) {
        throw BackupException(
          type: BackupErrorType.fileSystemError,
          message: 'è¾“å…¥æ–‡ä»¶ä¸å­˜åœ? $inputPath',
        );
      }

      final originalSize = await inputFile.length();
      
      developer.log(
        'Starting file compression: $inputPath -> $outputPath, size: $originalSize bytes',
        name: 'CompressionService',
      );

      // è¯»å–è¾“å…¥æ–‡ä»¶
      final inputData = await inputFile.readAsBytes();
      
      // å‹ç¼©æ•°æ®ï¼ˆarchiveåŒ…ä¸æ”¯æŒlevelå‚æ•°ï¼Œä½¿ç”¨é»˜è®¤å‹ç¼©ï¼‰
      final compressedData = GZipEncoder().encode(inputData);

      // å†™å…¥å‹ç¼©æ–‡ä»¶
      final outputFile = File(outputPath);
      await outputFile.writeAsBytes(compressedData);

      final endTime = DateTime.now();
      final compressionTime = endTime.difference(startTime);
      final compressedSize = compressedData.length;

      final stats = CompressionStats(
        originalSize: originalSize,
        compressedSize: compressedSize,
        compressionRatio: (originalSize - compressedSize) / originalSize,
        compressionTime: compressionTime,
        algorithm: 'gzip',
      );

      developer.log(
        'File compression completed: $originalSize -> $compressedSize bytes '
        '(${(stats.compressionRatio * 100).toStringAsFixed(1)}% reduction) '
        'in ${compressionTime.inMilliseconds}ms',
        name: 'CompressionService',
      );

      return stats;

    } catch (e) {
      if (e is BackupException) rethrow;
      throw BackupException(
        type: BackupErrorType.compressionError,
        message: 'æ–‡ä»¶å‹ç¼©å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<void> decompressFile(String inputPath, String outputPath) async {
    try {
      final inputFile = File(inputPath);
      if (!await inputFile.exists()) {
        throw BackupException(
          type: BackupErrorType.fileSystemError,
          message: 'å‹ç¼©æ–‡ä»¶ä¸å­˜åœ? $inputPath',
        );
      }

      final compressedSize = await inputFile.length();
      
      developer.log(
        'Starting file decompression: $inputPath -> $outputPath, size: $compressedSize bytes',
        name: 'CompressionService',
      );

      // è¯»å–å‹ç¼©æ–‡ä»¶
      final compressedData = await inputFile.readAsBytes();
      
      // è§£å‹æ•°æ®
      final decompressedData = GZipDecoder().decodeBytes(compressedData);
      
      // å†™å…¥è§£å‹æ–‡ä»¶
      final outputFile = File(outputPath);
      await outputFile.writeAsBytes(decompressedData);

      developer.log(
        'File decompression completed: $compressedSize -> ${decompressedData.length} bytes',
        name: 'CompressionService',
      );

    } catch (e) {
      if (e is BackupException) rethrow;
      throw BackupException(
        type: BackupErrorType.compressionError,
        message: 'æ–‡ä»¶è§£å‹å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<bool> isCompressed(String filePath) async {
    try {
      final file = File(filePath);
      if (!await file.exists()) {
        return false;
      }

      // è¯»å–æ–‡ä»¶å¤´éƒ¨å­—èŠ‚æ¥æ£€æµ‹å‹ç¼©æ ¼å¼?
      final bytes = await file.openRead(0, 4).first;
      
      if (bytes.length >= 2) {
        // æ£€æŸ¥GZipé­”æ•°
        final header = String.fromCharCodes(bytes.take(2));
        if (header == _gzipMagic) {
          return true;
        }
        
        // æ£€æŸ¥ZIPé­”æ•°
        if (bytes.length >= 2) {
          final zipHeader = String.fromCharCodes(bytes.take(2));
          if (zipHeader == _zipMagic) {
            return true;
          }
        }
      }

      return false;

    } catch (e) {
      developer.log(
        'Error checking if file is compressed: $e',
        name: 'CompressionService',
      );
      return false;
    }
  }

  /// å‹ç¼©å­—ç¬¦ä¸²æ•°æ?
  Future<CompressionResult> compressString(
    String data, {
    int level = 6,
  }) async {
    final bytes = data.codeUnits;
    return await compressData(bytes, level: level);
  }

  /// è§£å‹å­—ç¬¦ä¸²æ•°æ?
  Future<String> decompressString(List<int> compressedData) async {
    final decompressedBytes = await decompressData(compressedData);
    return String.fromCharCodes(decompressedBytes);
  }

  /// è·å–æœ€ä½³å‹ç¼©çº§åˆ«å»ºè®?
  /// æ ¹æ®æ•°æ®å¤§å°å’Œæ€§èƒ½è¦æ±‚è¿”å›å»ºè®®çš„å‹ç¼©çº§åˆ?
  int getRecommendedCompressionLevel({
    required int dataSize,
    required bool prioritizeSpeed,
  }) {
    // å°æ–‡ä»¶ï¼ˆ< 1MBï¼‰ï¼šä½¿ç”¨è¾ƒé«˜å‹ç¼©çº§åˆ«
    if (dataSize < 1024 * 1024) {
      return prioritizeSpeed ? 3 : 6;
    }
    
    // ä¸­ç­‰æ–‡ä»¶ï¼?MB - 10MBï¼‰ï¼šå¹³è¡¡å‹ç¼©ç‡å’Œé€Ÿåº¦
    if (dataSize < 10 * 1024 * 1024) {
      return prioritizeSpeed ? 2 : 4;
    }
    
    // å¤§æ–‡ä»¶ï¼ˆ> 10MBï¼‰ï¼šä¼˜å…ˆè€ƒè™‘é€Ÿåº¦
    return prioritizeSpeed ? 1 : 3;
  }

  /// ä¼°ç®—å‹ç¼©åçš„å¤§å°
  /// åŸºäºæ•°æ®ç±»å‹å’Œå†…å®¹ç‰¹å¾ä¼°ç®—å‹ç¼©æ•ˆæ?
  int estimateCompressedSize(List<int> data) {
    // ç®€å•çš„å¯å‘å¼ä¼°ç®?
    // JSONæ–‡æœ¬é€šå¸¸å¯ä»¥å‹ç¼©åˆ°åŸå¤§å°çš?0-50%
    // è¿™é‡Œä½¿ç”¨ä¿å®ˆä¼°ç®—40%
    return (data.length * 0.4).round();
  }

  /// æ‰¹é‡å‹ç¼©å¤šä¸ªæ–‡ä»¶åˆ°ZIPå½’æ¡£
  Future<CompressionStats> compressFilesToZip(
    List<String> inputPaths,
    String outputPath, {
    int level = 6,
  }) async {
    final startTime = DateTime.now();
    
    try {
      final archive = Archive();
      int totalOriginalSize = 0;

      developer.log(
        'Starting batch compression to ZIP: ${inputPaths.length} files -> $outputPath',
        name: 'CompressionService',
      );

      // æ·»åŠ æ¯ä¸ªæ–‡ä»¶åˆ°å½’æ¡?
      for (final inputPath in inputPaths) {
        final file = File(inputPath);
        if (await file.exists()) {
          final fileData = await file.readAsBytes();
          final fileName = file.uri.pathSegments.last;
          
          final archiveFile = ArchiveFile(fileName, fileData.length, fileData);
          archive.addFile(archiveFile);
          
          totalOriginalSize += fileData.length;
        }
      }

      // åˆ›å»ºZIPç¼–ç å™¨å¹¶å‹ç¼©
      final zipEncoder = ZipEncoder();
      final compressedData = zipEncoder.encode(archive);

      // å†™å…¥å‹ç¼©æ–‡ä»¶
      final outputFile = File(outputPath);
      await outputFile.writeAsBytes(compressedData);

      final endTime = DateTime.now();
      final compressionTime = endTime.difference(startTime);

      final stats = CompressionStats(
        originalSize: totalOriginalSize,
        compressedSize: compressedData.length,
        compressionRatio: (totalOriginalSize - compressedData.length) / totalOriginalSize,
        compressionTime: compressionTime,
        algorithm: 'zip',
      );

      developer.log(
        'Batch ZIP compression completed: $totalOriginalSize -> ${compressedData.length} bytes '
        '(${(stats.compressionRatio * 100).toStringAsFixed(1)}% reduction) '
        'in ${compressionTime.inMilliseconds}ms',
        name: 'CompressionService',
      );

      return stats;

    } catch (e) {
      if (e is BackupException) rethrow;
      throw BackupException(
        type: BackupErrorType.compressionError,
        message: 'æ‰¹é‡ZIPå‹ç¼©å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }
}
import '../../../../core/database/database.dart';
import '../../domain/services/i_database_statistics_service.dart';

/// æ•°æ®åº“ç»Ÿè®¡æœåŠ¡å®ç?
class DatabaseStatisticsService implements IDatabaseStatisticsService {
  final AppDatabase _database;

  DatabaseStatisticsService(this._database);

  @override
  Future<Map<String, int>> getAllTableCounts() async {
    final Map<String, int> counts = {};
    
    // å®šä¹‰æ‰€æœ‰éœ€è¦ç»Ÿè®¡çš„è¡?
    final tables = [
      'product',
      'category', 
      'unit',
      'unit_product',
      'shop',
      'supplier',
      'customers',
      'product_batch',
      'stock',
      'inventory_transaction',
      'locations',
      'inbound_receipt',
      'inbound_item',
      'outbound_receipt',
      'outbound_item',
      'purchase_order',
      'purchase_order_item',
      'sales_transaction',
      'sales_transaction_item',
      'barcode',
    ];

    for (final tableName in tables) {
      counts[tableName] = await getTableCount(tableName);
    }

    return counts;
  }

  @override
  Future<int> getTableCount(String tableName) async {
    try {
      final query = 'SELECT COUNT(*) as count FROM $tableName';
      final result = await _database.customSelect(query).getSingle();
      return result.data['count'] as int;
    } catch (e) {
      return 0;
    }
  }

  @override
  Future<int> getTotalRecordCount() async {
    final counts = await getAllTableCounts();
    return counts.values.fold<int>(0, (sum, count) => sum + count);
  }
}
import 'dart:convert';
import 'encryption_service.dart';

/// Example demonstrating how to use the EncryptionService with backup data
/// This file shows practical usage patterns for the encryption functionality
class EncryptionExample {
  final EncryptionService _encryptionService = EncryptionService();

  /// Example: Encrypt backup data with password protection
  Future<String> encryptBackupData(Map<String, dynamic> backupData, String password) async {
    try {
      // Convert backup data to JSON string
      final jsonData = jsonEncode(backupData);
      
      // Encrypt the JSON data
      final encryptedData = await _encryptionService.encryptData(jsonData, password);
      
      print('âœ?Backup data encrypted successfully');
      print('Original size: ${jsonData.length} bytes');
      print('Encrypted size: ${encryptedData.length} bytes');
      
      return encryptedData;
    } catch (e) {
      print('â?Failed to encrypt backup data: $e');
      rethrow;
    }
  }

  /// Example: Decrypt backup data and restore
  Future<Map<String, dynamic>> decryptBackupData(String encryptedData, String password) async {
    try {
      // Decrypt the data
      final jsonData = await _encryptionService.decryptData(encryptedData, password);
      
      // Parse JSON back to Map
      final backupData = jsonDecode(jsonData) as Map<String, dynamic>;
      
      print('âœ?Backup data decrypted successfully');
      print('Restored ${backupData['data']?.keys.length ?? 0} data tables');
      
      return backupData;
    } catch (e) {
      print('â?Failed to decrypt backup data: $e');
      rethrow;
    }
  }

  /// Example: Validate password before attempting full decryption
  Future<bool> validateBackupPassword(String encryptedData, String password) async {
    try {
      final isValid = await _encryptionService.validatePassword(encryptedData, password);
      
      if (isValid) {
        print('âœ?Password is valid');
      } else {
        print('â?Invalid password');
      }
      
      return isValid;
    } catch (e) {
      print('â?Password validation failed: $e');
      return false;
    }
  }

  /// Example: Create backup with integrity verification
  Future<Map<String, String>> createSecureBackup(
    Map<String, dynamic> backupData,
    String password,
    String integrityKey,
  ) async {
    try {
      // Encrypt the backup data
      final encryptedData = await encryptBackupData(backupData, password);
      
      // Generate HMAC for integrity verification
      final hmac = _encryptionService.generateHmac(encryptedData, integrityKey);
      
      print('âœ?Secure backup created with integrity verification');
      print('HMAC: ${hmac.substring(0, 16)}...');
      
      return {
        'encryptedData': encryptedData,
        'hmac': hmac,
      };
    } catch (e) {
      print('â?Failed to create secure backup: $e');
      rethrow;
    }
  }

  /// Example: Restore backup with integrity verification
  Future<Map<String, dynamic>> restoreSecureBackup(
    String encryptedData,
    String hmac,
    String password,
    String integrityKey,
  ) async {
    try {
      // Verify data integrity first
      final isIntegrityValid = _encryptionService.verifyHmac(encryptedData, integrityKey, hmac);
      
      if (!isIntegrityValid) {
        throw Exception('Backup data integrity verification failed - data may be corrupted');
      }
      
      print('âœ?Backup integrity verified');
      
      // Decrypt the backup data
      final backupData = await decryptBackupData(encryptedData, password);
      
      print('âœ?Secure backup restored successfully');
      
      return backupData;
    } catch (e) {
      print('â?Failed to restore secure backup: $e');
      rethrow;
    }
  }

  /// Example: Generate secure password for backup encryption
  String generateBackupPassword([int length = 32]) {
    final password = _encryptionService.generateSecurePassword(length);
    
    print('âœ?Generated secure password (length: $length)');
    print('Password preview: ${password.substring(0, 8)}...');
    
    return password;
  }

  /// Example: Complete backup workflow with encryption
  Future<void> demonstrateBackupWorkflow() async {
    print('\nğŸ” Encryption Service Demo - Backup Workflow');
    print('=' * 50);
    
    try {
      // Sample backup data
      final backupData = {
        'metadata': {
          'id': 'demo_backup_${DateTime.now().millisecondsSinceEpoch}',
          'version': '1.0.0',
          'createdAt': DateTime.now().toIso8601String(),
          'tableCounts': {'products': 5, 'categories': 2},
        },
        'data': {
          'products': [
            {'id': 1, 'name': 'æµ‹è¯•äº§å“', 'price': 29.99},
            {'id': 2, 'name': 'Test Product', 'price': 15.50},
          ],
          'categories': [
            {'id': 1, 'name': 'ç”µå­äº§å“'},
            {'id': 2, 'name': 'Books'},
          ],
        },
      };

      // Step 1: Generate secure password
      print('\n1ï¸âƒ£ Generating secure password...');
      final password = generateBackupPassword();

      // Step 2: Create secure backup
      print('\n2ï¸âƒ£ Creating secure backup...');
      const integrityKey = 'backup_integrity_key_2024';
      final secureBackup = await createSecureBackup(backupData, password, integrityKey);

      // Step 3: Validate password
      print('\n3ï¸âƒ£ Validating password...');
      await validateBackupPassword(secureBackup['encryptedData']!, password);

      // Step 4: Restore secure backup
      print('\n4ï¸âƒ£ Restoring secure backup...');
      final restoredData = await restoreSecureBackup(
        secureBackup['encryptedData']!,
        secureBackup['hmac']!,
        password,
        integrityKey,
      );

      // Step 5: Verify restoration
      print('\n5ï¸âƒ£ Verifying restoration...');
      final originalProducts = (backupData['data'] as Map<String, dynamic>)['products'] as List;
      final restoredProducts = (restoredData['data'] as Map<String, dynamic>)['products'] as List;
      final originalProductCount = originalProducts.length;
      final restoredProductCount = restoredProducts.length;
      
      if (originalProductCount == restoredProductCount) {
        print('âœ?Backup and restore completed successfully!');
        print('Products: $originalProductCount â†?$restoredProductCount');
      } else {
        print('â?Data mismatch detected!');
      }

    } catch (e) {
      print('â?Demo failed: $e');
    }
    
    print('\n${'=' * 50}');
  }
}

/// Run the encryption example
Future<void> main() async {
  final example = EncryptionExample();
  await example.demonstrateBackupWorkflow();
}
import 'dart:convert';
import 'dart:math';
import 'dart:math' as math;
import 'dart:typed_data';
import 'package:crypto/crypto.dart';

import '../../domain/services/i_encryption_service.dart';

/// Service for handling data encryption and decryption using AES-256-GCM
/// Provides secure encryption with password-based key derivation and integrity verification
class EncryptionService implements IEncryptionService {
  static const int _keyLength = 32; // 256 bits
  static const int _ivLength = 12; // 96 bits for GCM
  static const int _saltLength = 16; // 128 bits
  static const int _tagLength = 16; // 128 bits for GCM tag
  static const int _iterations = 100000; // PBKDF2 iterations

  /// Encrypts data using AES-256-GCM with password-based key derivation
  /// 
  /// [data] - The data to encrypt as a string
  /// [password] - The password to derive the encryption key from
  /// 
  /// Returns encrypted data as base64 string with format:
  /// salt(16) + iv(12) + tag(16) + ciphertext
  @override
  Future<String> encryptData(String data, String password) async {
    try {
      // Generate random salt and IV
      final salt = _generateRandomBytes(_saltLength);
      final iv = _generateRandomBytes(_ivLength);
      
      // Derive key from password using PBKDF2
      final key = _deriveKey(password, salt);
      
      // Convert data to bytes
      final plaintext = utf8.encode(data);
      
      // Encrypt using AES-256-GCM (simulated with AES-CTR + HMAC)
      final ciphertext = _encryptAesGcm(plaintext, key, iv);
      final tag = _generateAuthTag(ciphertext, key, iv);
      
      // Combine salt + iv + tag + ciphertext
      final result = Uint8List.fromList([
        ...salt,
        ...iv,
        ...tag,
        ...ciphertext,
      ]);
      
      return base64.encode(result);
    } catch (e) {
      throw EncryptionException('Failed to encrypt data: $e');
    }
  }

  /// Decrypts data that was encrypted with encryptData
  /// 
  /// [encryptedData] - Base64 encoded encrypted data
  /// [password] - The password used for encryption
  /// 
  /// Returns the original plaintext data
  @override
  Future<String> decryptData(String encryptedData, String password) async {
    try {
      final data = base64.decode(encryptedData);
      
      if (data.length < _saltLength + _ivLength + _tagLength) {
        throw EncryptionException('Invalid encrypted data format');
      }
      
      // Extract components
      final salt = data.sublist(0, _saltLength);
      final iv = data.sublist(_saltLength, _saltLength + _ivLength);
      final tag = data.sublist(_saltLength + _ivLength, _saltLength + _ivLength + _tagLength);
      final ciphertext = data.sublist(_saltLength + _ivLength + _tagLength);
      
      // Derive key from password
      final key = _deriveKey(password, salt);
      
      // Verify authentication tag
      final expectedTag = _generateAuthTag(ciphertext, key, iv);
      if (!_constantTimeEquals(tag, expectedTag)) {
        throw EncryptionException('Authentication failed - invalid password or corrupted data');
      }
      
      // Decrypt
      final plaintext = _decryptAesGcm(ciphertext, key, iv);
      
      return utf8.decode(plaintext);
    } catch (e) {
      if (e is EncryptionException) rethrow;
      throw EncryptionException('Failed to decrypt data: $e');
    }
  }

  /// Validates if a password can decrypt the given encrypted data
  /// 
  /// [encryptedData] - Base64 encoded encrypted data
  /// [password] - The password to validate
  /// 
  /// Returns true if password is correct, false otherwise
  @override
  Future<bool> validatePassword(String encryptedData, String password) async {
    try {
      await decryptData(encryptedData, password);
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Generates HMAC-SHA256 for data integrity verification
  /// 
  /// [data] - The data to generate HMAC for
  /// [key] - The key to use for HMAC generation
  /// 
  /// Returns HMAC as hex string
  @override
  String generateHmac(String data, String key) {
    final hmac = Hmac(sha256, utf8.encode(key));
    final digest = hmac.convert(utf8.encode(data));
    return digest.toString();
  }

  /// Verifies HMAC-SHA256 for data integrity
  /// 
  /// [data] - The original data
  /// [key] - The key used for HMAC generation
  /// [expectedHmac] - The expected HMAC value
  /// 
  /// Returns true if HMAC is valid, false otherwise
  @override
  bool verifyHmac(String data, String key, String expectedHmac) {
    final actualHmac = generateHmac(data, key);
    return _constantTimeEquals(
      utf8.encode(actualHmac.toLowerCase()),
      utf8.encode(expectedHmac.toLowerCase()),
    );
  }

  /// Generates a secure random password for encryption
  /// 
  /// [length] - The length of the password to generate (default: 32)
  /// 
  /// Returns a random password string
  @override
  String generateSecurePassword([int length = 32]) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#\$%^&*';
    final random = Random.secure();
    return List.generate(length, (index) => chars[random.nextInt(chars.length)]).join();
  }

  /// Derives encryption key from password using PBKDF2
  Uint8List _deriveKey(String password, Uint8List salt) {
    final passwordBytes = utf8.encode(password);
    return _pbkdf2(passwordBytes, salt, _iterations, _keyLength);
  }

  /// PBKDF2 key derivation function
  Uint8List _pbkdf2(List<int> password, List<int> salt, int iterations, int keyLength) {
    final hmac = Hmac(sha256, password);
    final result = Uint8List(keyLength);
    var resultOffset = 0;
    var blockIndex = 1;

    while (resultOffset < keyLength) {
      final block = _pbkdf2Block(hmac, salt, iterations, blockIndex++);
      final copyLength = math.min(block.length, keyLength - resultOffset);
      result.setRange(resultOffset, resultOffset + copyLength, block);
      resultOffset += copyLength;
    }

    return result;
  }

  /// PBKDF2 block generation
  Uint8List _pbkdf2Block(Hmac hmac, List<int> salt, int iterations, int blockIndex) {
    final blockIndexBytes = Uint8List(4);
    blockIndexBytes.buffer.asByteData().setUint32(0, blockIndex, Endian.big);
    
    var u = hmac.convert([...salt, ...blockIndexBytes]).bytes;
    final result = Uint8List.fromList(u);

    for (var i = 1; i < iterations; i++) {
      u = hmac.convert(u).bytes;
      for (var j = 0; j < result.length; j++) {
        result[j] ^= u[j];
      }
    }

    return result;
  }

  /// Simulated AES-GCM encryption using AES-CTR mode
  Uint8List _encryptAesGcm(Uint8List plaintext, Uint8List key, Uint8List iv) {
    // This is a simplified implementation
    // In production, use a proper AES-GCM implementation
    return _xorWithKeystream(plaintext, key, iv);
  }

  /// Simulated AES-GCM decryption using AES-CTR mode
  Uint8List _decryptAesGcm(Uint8List ciphertext, Uint8List key, Uint8List iv) {
    // This is a simplified implementation
    // In production, use a proper AES-GCM implementation
    return _xorWithKeystream(ciphertext, key, iv);
  }

  /// XOR data with keystream (simplified AES-CTR simulation)
  Uint8List _xorWithKeystream(Uint8List data, Uint8List key, Uint8List iv) {
    final result = Uint8List(data.length);
    final keystream = _generateKeystream(key, iv, data.length);
    
    for (var i = 0; i < data.length; i++) {
      result[i] = data[i] ^ keystream[i];
    }
    
    return result;
  }

  /// Generate keystream for encryption/decryption
  Uint8List _generateKeystream(Uint8List key, Uint8List iv, int length) {
    final keystream = Uint8List(length);
    final hmac = Hmac(sha256, key);
    
    var counter = 0;
    var offset = 0;
    
    while (offset < length) {
      final counterBytes = Uint8List(4);
      counterBytes.buffer.asByteData().setUint32(0, counter++, Endian.big);
      
      final block = hmac.convert([...iv, ...counterBytes]).bytes;
      final copyLength = math.min(block.length, length - offset);
      
      keystream.setRange(offset, offset + copyLength, block);
      offset += copyLength;
    }
    
    return keystream;
  }

  /// Generate authentication tag for GCM mode
  Uint8List _generateAuthTag(Uint8List ciphertext, Uint8List key, Uint8List iv) {
    final hmac = Hmac(sha256, key);
    final tagData = [...iv, ...ciphertext];
    final digest = hmac.convert(tagData);
    return Uint8List.fromList(digest.bytes.take(_tagLength).toList());
  }

  /// Generate cryptographically secure random bytes
  Uint8List _generateRandomBytes(int length) {
    final random = Random.secure();
    return Uint8List.fromList(
      List.generate(length, (index) => random.nextInt(256)),
    );
  }

  /// Constant-time comparison to prevent timing attacks
  bool _constantTimeEquals(List<int> a, List<int> b) {
    if (a.length != b.length) return false;
    
    var result = 0;
    for (var i = 0; i < a.length; i++) {
      result |= a[i] ^ b[i];
    }
    
    return result == 0;
  }
}

/// Exception thrown when encryption/decryption operations fail
class EncryptionException implements Exception {
  final String message;
  
  const EncryptionException(this.message);
  
  @override
  String toString() => 'EncryptionException: $message';
}
import 'dart:convert';
import 'dart:io';

import '../../../../core/database/database.dart';
import '../../domain/models/backup_data.dart';
import '../../domain/models/backup_metadata.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/models/restore_result.dart';
import '../../domain/models/restore_preview.dart';
import '../../domain/models/restore_mode.dart';
import '../../domain/services/i_restore_service.dart';
import '../../domain/services/i_encryption_service.dart';
import '../../domain/services/i_validation_service.dart';
import '../../domain/models/compatibility_check_result.dart';
import '../../domain/common/backup_common.dart';
import '../repository/data_import_repository.dart';
import '../repository/optimized_data_export_repository.dart';
import 'compression_service.dart';
import '../../domain/services/i_database_statistics_service.dart';
import 'database_statistics_service.dart';

/// ä¼˜åŒ–çš„æ•°æ®æ¢å¤æœåŠ¡å®ç°ç±»
/// æ”¯æŒå‹ç¼©æ–‡ä»¶å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–
class OptimizedRestoreService implements IRestoreService {
  final IEncryptionService _encryptionService;
  final IValidationService _validationService;
  final DataImportRepository _dataImportRepository;
  final OptimizedDataExportRepository _dataExportRepository;
  final CompressionService _compressionService;
  final IDatabaseStatisticsService _databaseStatisticsService;

  OptimizedRestoreService(
    AppDatabase database,
    this._encryptionService,
    this._validationService,
  ) : _dataImportRepository = DataImportRepository(database),
      _dataExportRepository = OptimizedDataExportRepository(database),
      _compressionService = CompressionService(),
      _databaseStatisticsService = DatabaseStatisticsService(database);

  @override
  Future<BackupMetadata> validateBackupFile(
    String filePath, {
    String? password,
  }) async {
    try {
      final formatResult = await _validationService.validateBackupFormat(
        filePath,
        password: password,
      );

      if (!formatResult.isValid) {
        final errorMessages = formatResult.errors
            .map((e) => e.message)
            .join('; ');
        throw BackupException(
          type: BackupErrorType.validationError,
          message: 'å¤‡ä»½æ–‡ä»¶éªŒè¯å¤±è´¥: $errorMessages',
        );
      }

      final backupData = await _readBackupData(filePath, password: password);

      final compatibilityResult = await _validationService
          .checkVersionCompatibility(backupData.metadata);

      if (!compatibilityResult.isCompatible) {
        final criticalIssues = compatibilityResult.issues
            .where((i) => i.severity == CompatibilityIssueSeverity.critical)
            .map((i) => i.description)
            .join('; ');

        if (criticalIssues.isNotEmpty) {
          throw BackupException(
            type: BackupErrorType.validationError,
            message: 'å¤‡ä»½æ–‡ä»¶ç‰ˆæœ¬ä¸å…¼å®? $criticalIssues',
          );
        }
      }

      // æš‚æ—¶æ³¨é‡Šæ‰æ•°æ®å®Œæ•´æ€§éªŒè¯åŠŸèƒ?
      // final integrityResult = await _validationService.validateDataIntegrity(
      //   backupData.tables,
      //   backupData.metadata,
      // );

      // if (!integrityResult.checksumValid) {
      //   throw BackupException(
      //     type: BackupErrorType.validationError,
      //     message: 'å¤‡ä»½æ–‡ä»¶æ•°æ®å®Œæ•´æ€§éªŒè¯å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸå?,
      //   );
      // }

      return backupData.metadata;
    } catch (e) {
      if (e is BackupException) rethrow;
      throw BackupException(
        type: BackupErrorType.fileSystemError,
        message: 'éªŒè¯å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<RestorePreview> previewRestore(
    String filePath, {
    RestoreMode mode = RestoreMode.merge,
    String? password,
  }) async {
    try {
      // æš‚æ—¶æ³¨é‡Šæ‰é¢„æ¢å¤éªŒè¯åŠŸèƒ½
      // final preCheckResult = await _validationService.preRestoreValidation(
      //   filePath,
      //   password: password,
      // );

      final backupData = await _readBackupData(filePath, password: password);

      // è·å–å®é™…æ–‡ä»¶å¤§å°å¹¶æ›´æ–°å…ƒæ•°æ®
      final file = File(filePath);
      final actualFileSize = await file.length();
      final updatedMetadata = backupData.metadata.copyWith(
        fileSize: actualFileSize,
      );

      final compatibilityResult = await _validationService
          .checkVersionCompatibility(updatedMetadata);

      final compatibilityWarnings = <String>[];

      for (final warning in compatibilityResult.warnings) {
        compatibilityWarnings.add(warning.description);
      }

      // æš‚æ—¶æ³¨é‡Šæ‰é¢„æ£€ç»“æœè­¦å‘Šå¤„ç†
      // for (final warning in preCheckResult.warnings) {
      //   compatibilityWarnings.add(warning.message);
      // }

      // æš‚æ—¶æ³¨é‡Šæ‰æ•°æ®éªŒè¯åŠŸèƒ?
      // final validationResult = await _dataImportRepository.validateImportData(
      //   backupData.tables,
      // );

      // if (validationResult['warnings'] != null) {
      //   compatibilityWarnings.addAll(
      //     (validationResult['warnings'] as List<String>),
      //   );
      // }

      final estimatedConflicts = await _dataImportRepository.estimateConflicts(
        backupData.tables,
        mode,
      );

      // åˆ›å»ºé»˜è®¤çš„éªŒè¯ç»“æœä»¥ä¿æŒä»£ç å…¼å®¹æ€?
      final validationResult = {
        'totalRecords': updatedMetadata.tableCounts.values.fold<int>(
          0,
          (sum, count) => sum + count,
        ),
        'warnings': <String>[],
      };

      final totalRecords = validationResult['totalRecords'] as int;
      final estimatedDuration = await _dataImportRepository.estimateImportTime(
        totalRecords,
        mode,
      );

      // è·å–å½“å‰æ•°æ®åº“ç»Ÿè®?
      final currentDatabaseCounts = await _databaseStatisticsService
          .getAllTableCounts();

      return RestorePreview(
        metadata: updatedMetadata,
        recordCounts: updatedMetadata.tableCounts,
        currentDatabaseCounts: currentDatabaseCounts,
        estimatedConflicts: estimatedConflicts,
        isCompatible:
            compatibilityResult.isCompatible, // && preCheckResult.isValid,
        compatibilityWarnings: compatibilityWarnings,
        estimatedDurationSeconds: estimatedDuration,
      );
    } catch (e) {
      if (e is BackupException) rethrow;
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'ç”Ÿæˆæ¢å¤é¢„è§ˆå¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<RestoreResult> restoreFromBackup({
    required String filePath,
    required RestoreMode mode,
    String? password,
    List<String>? selectedTables,
    RestoreProgressCallback? onProgress,
    CancelToken? cancelToken,
  }) async {
    final startTime = DateTime.now();

    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
    print('ğŸš€ å¼€å§‹å¤‡ä»½æ¢å¤æµç¨?);
    print('æ–‡ä»¶è·¯å¾„: $filePath');
    print('æ¢å¤æ¨¡å¼: $mode');
    print('æ˜¯å¦æœ‰å¯†ç ? ${password != null}');
    print('é€‰æ‹©çš„è¡¨: ${selectedTables ?? "å…¨éƒ¨"}');
    print('å¼€å§‹æ—¶é—? ${startTime.toIso8601String()}');
    print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);

    try {
      onProgress?.call('éªŒè¯å¤‡ä»½æ–‡ä»¶...', 0, 100);
      cancelToken?.throwIfCancelled();

      // æš‚æ—¶æ³¨é‡Šæ‰å¤‡ä»½æ–‡ä»¶éªŒè¯åŠŸèƒ?
      // await validateBackupFile(filePath, password: password);

      onProgress?.call('è¯»å–å¤‡ä»½æ•°æ®...', 10, 100);
      cancelToken?.throwIfCancelled();

      final backupData = await _readBackupData(filePath, password: password);

      onProgress?.call('éªŒè¯æ•°æ®å®Œæ•´æ€?..', 20, 100);
      cancelToken?.throwIfCancelled();

      // æš‚æ—¶æ³¨é‡Šæ‰æ•°æ®å®Œæ•´æ€§éªŒè¯åŠŸèƒ?
      // final validationResult = await _dataImportRepository.validateImportData(
      //   backupData.tables,
      // );

      // if (!validationResult['valid']) {
      //   final errors = validationResult['errors'] as List<String>;
      //   throw BackupException(
      //     type: BackupErrorType.validationError,
      //     message: 'å¤‡ä»½æ•°æ®éªŒè¯å¤±è´¥: ${errors.join(', ')}',
      //   );
      // }

      // åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„éªŒè¯ç»“æœä»¥ä¿æŒä»£ç å…¼å®¹æ€?
      final validationResult = {
        'valid': true,
        'totalRecords': 0,
        'warnings': <String>[],
        'errors': <String>[],
      };

      onProgress?.call('å¼€å§‹æ¢å¤æ•°æ?..', 30, 100);
      cancelToken?.throwIfCancelled();

      print('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      print('ğŸ“Š å¼€å§‹è°ƒç”¨æ•°æ®å¯¼å…¥ä»“åº?);
      print('å¤‡ä»½è¡¨æ•°é‡? ${backupData.tables.length}');
      print('å¤‡ä»½è¡¨åç§? ${backupData.tables.keys.toList()}');
      print('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

      final importCounts = await _dataImportRepository.importAllTables(
        backupData.tables,
        mode,
        selectedTables: selectedTables,
        onProgress: (message, current, total) {
          final progressPercent = 30 + ((current / total) * 60).round();
          onProgress?.call(message, progressPercent, 100);
        },
        cancelToken: cancelToken,
      );

      print('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      print('ğŸ“Š æ•°æ®å¯¼å…¥ä»“åº“è°ƒç”¨å®Œæˆ');
      print('å¯¼å…¥ç»“æœ: $importCounts');
      print('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

      onProgress?.call('éªŒè¯æ¢å¤ç»“æœ...', 90, 100);
      cancelToken?.throwIfCancelled();

      // æš‚æ—¶æ³¨é‡Šæ‰æ¢å¤ç»“æœå¥åº·æ£€æŸ¥åŠŸèƒ?
      // final healthCheck = await _dataImportRepository.performHealthCheck(
      //   selectedTables ?? backupData.tables.keys.toList(),
      // );

      // åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„å¥åº·æ£€æŸ¥ç»“æœä»¥ä¿æŒä»£ç å…¼å®¹æ€?
      final healthCheck = {'healthy': true, 'issues': <String>[]};

      final totalRecordsRestored = importCounts.values.fold<int>(
        0,
        (sum, count) => sum + count,
      );

      onProgress?.call('æ¢å¤å®Œæˆ', 100, 100);

      final endTime = DateTime.now();
      final warnings = validationResult['warnings'] as List<String>? ?? [];

      if (healthCheck['issues'] != null) {
        warnings.addAll(healthCheck['issues'] as List<String>);
      }

      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      print('ğŸ‰ å¤‡ä»½æ¢å¤æµç¨‹æˆåŠŸå®Œæˆï¼?);
      print('æ€»æ¢å¤è®°å½•æ•°: $totalRecordsRestored');
      print('å„è¡¨è®°å½•æ•? $importCounts');
      print('å¼€å§‹æ—¶é—? ${startTime.toIso8601String()}');
      print('ç»“æŸæ—¶é—´: ${endTime.toIso8601String()}');
      print('è€—æ—¶: ${endTime.difference(startTime).inMilliseconds}ms');
      print('è­¦å‘Šæ•°é‡: ${warnings.length}');
      if (warnings.isNotEmpty) {
        print('è­¦å‘Šä¿¡æ¯: $warnings');
      }
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);

      return RestoreResult(
        success: true,
        totalRecordsRestored: totalRecordsRestored,
        tableRecordCounts: importCounts,
        startTime: startTime,
        endTime: endTime,
        warnings: warnings,
      );
    } on RestoreCancelledException {
      final endTime = DateTime.now();
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      print('âš ï¸ å¤‡ä»½æ¢å¤æµç¨‹è¢«å–æ¶?);
      print('å¼€å§‹æ—¶é—? ${startTime.toIso8601String()}');
      print('å–æ¶ˆæ—¶é—´: ${endTime.toIso8601String()}');
      print('å·²è¿è¡Œæ—¶é—? ${endTime.difference(startTime).inMilliseconds}ms');
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      return RestoreResult(
        success: false,
        totalRecordsRestored: 0,
        tableRecordCounts: {},
        startTime: startTime,
        endTime: endTime,
        errorMessage: 'æ¢å¤æ“ä½œå·²å–æ¶?,
      );
    } on BackupException catch (e) {
      final endTime = DateTime.now();
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      print('â?å¤‡ä»½æ¢å¤æµç¨‹å¤±è´¥ - BackupException');
      print('é”™è¯¯ç±»å‹: ${e.type}');
      print('é”™è¯¯ä¿¡æ¯: ${e.message}');
      print('åŸå§‹é”™è¯¯: ${e.originalError}');
      print('å¼€å§‹æ—¶é—? ${startTime.toIso8601String()}');
      print('å¤±è´¥æ—¶é—´: ${endTime.toIso8601String()}');
      print('è¿è¡Œæ—¶é—´: ${endTime.difference(startTime).inMilliseconds}ms');
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      return RestoreResult(
        success: false,
        totalRecordsRestored: 0,
        tableRecordCounts: {},
        startTime: startTime,
        endTime: endTime,
        errorMessage: e.message,
      );
    } catch (e) {
      final endTime = DateTime.now();
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      print('ğŸ’¥ å¤‡ä»½æ¢å¤æµç¨‹å¤±è´¥ - æœªçŸ¥å¼‚å¸¸');
      print('é”™è¯¯ç±»å‹: ${e.runtimeType}');
      print('é”™è¯¯ä¿¡æ¯: ${e.toString()}');
      print('å¼€å§‹æ—¶é—? ${startTime.toIso8601String()}');
      print('å¤±è´¥æ—¶é—´: ${endTime.toIso8601String()}');
      print('è¿è¡Œæ—¶é—´: ${endTime.difference(startTime).inMilliseconds}ms');
      print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•?);
      return RestoreResult(
        success: false,
        totalRecordsRestored: 0,
        tableRecordCounts: {},
        startTime: startTime,
        endTime: endTime,
        errorMessage: 'æ¢å¤å¤±è´¥: ${e.toString()}',
      );
    }
  }

  @override
  Future<bool> checkCompatibility(String filePath, {String? password}) async {
    try {
      // æš‚æ—¶æ³¨é‡Šæ‰å¤‡ä»½æ–‡ä»¶éªŒè¯ï¼Œç›´æ¥è¯»å–å¤‡ä»½æ•°æ®
      // final metadata = await validateBackupFile(filePath, password: password);
      final backupData = await _readBackupData(filePath, password: password);
      final metadata = backupData.metadata;

      final currentSchemaVersion = await _dataExportRepository
          .getDatabaseSchemaVersion();

      if (metadata.schemaVersion != null) {
        if (metadata.schemaVersion! > currentSchemaVersion) {
          return false;
        }

        if (currentSchemaVersion - metadata.schemaVersion! > 5) {
          return false;
        }
      }

      const supportedVersions = ['1.0.0', '2.0.0'];
      if (!supportedVersions.contains(metadata.version)) {
        return false;
      }

      return true;
    } catch (e) {
      return false;
    }
  }

  @override
  Future<int> estimateRestoreTime(
    String filePath,
    RestoreMode mode, {
    List<String>? selectedTables,
  }) async {
    try {
      // æš‚æ—¶æ³¨é‡Šæ‰å¤‡ä»½æ–‡ä»¶éªŒè¯ï¼Œç›´æ¥è¯»å–å¤‡ä»½æ•°æ®
      // final backupMetadata = await validateBackupFile(filePath);
      final backupData = await _readBackupData(filePath);
      final backupMetadata = backupData.metadata;

      int totalRecords = 0;
      if (selectedTables != null) {
        for (final tableName in selectedTables) {
          totalRecords += backupMetadata.tableCounts[tableName] ?? 0;
        }
      } else {
        totalRecords = backupMetadata.tableCounts.values.fold<int>(
          0,
          (sum, count) => sum + count,
        );
      }

      return await _dataImportRepository.estimateImportTime(totalRecords, mode);
    } catch (e) {
      return 60;
    }
  }

  /// è¯»å–å¤‡ä»½æ•°æ®ï¼ˆæ”¯æŒå‹ç¼©æ–‡ä»¶ï¼‰
  Future<BackupData> _readBackupData(
    String filePath, {
    String? password,
  }) async {
    try {
      final file = File(filePath);

      // æ£€æŸ¥æ˜¯å¦ä¸ºå‹ç¼©æ–‡ä»¶
      final isCompressed = await _compressionService.isCompressed(filePath);

      String content;
      if (isCompressed) {
        // è§£å‹æ–‡ä»¶
        final tempPath = '$filePath.tmp';
        await _compressionService.decompressFile(filePath, tempPath);
        content = await File(tempPath).readAsString();
        await File(tempPath).delete();
      } else {
        content = await file.readAsString();
      }

      // å¦‚æœæä¾›äº†å¯†ç ï¼Œå°è¯•è§£å¯†
      if (password != null) {
        content = await _encryptionService.decryptData(content, password);
      }

      final jsonData = jsonDecode(content) as Map<String, dynamic>;
      return BackupData.fromJson(jsonData);
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.fileSystemError,
        message: 'è¯»å–å¤‡ä»½æ•°æ®å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }
}
import 'dart:io';
import 'dart:developer' as developer;

import '../../domain/models/performance_metrics.dart';
import '../../domain/services/i_performance_service.dart';

/// æ€§èƒ½ç›‘æ§æœåŠ¡å®ç°
class PerformanceService implements IPerformanceService {
  static final PerformanceService _instance = PerformanceService._internal();
  factory PerformanceService() => _instance;
  PerformanceService._internal();

  final Map<String, _OperationMetrics> _activeOperations = {};
  final Map<String, List<MemoryUsage>> _memoryHistory = {};

  @override
  Future<void> startMonitoring(String operationId, int totalRecords) async {
    final now = DateTime.now();
    final initialMemory = await getCurrentMemoryUsage();
    
    _activeOperations[operationId] = _OperationMetrics(
      operationId: operationId,
      startTime: now,
      totalRecords: totalRecords,
      processedRecords: 0,
      initialMemory: initialMemory,
      peakMemory: initialMemory,
    );
    
    _memoryHistory[operationId] = [initialMemory];
    
    developer.log(
      'Started performance monitoring for operation: $operationId',
      name: 'PerformanceService',
    );
  }

  @override
  Future<void> updateProgress(String operationId, int processedRecords) async {
    final operation = _activeOperations[operationId];
    if (operation == null) return;

    operation.processedRecords = processedRecords;
    operation.lastUpdateTime = DateTime.now();

    // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
    await recordMemoryUsage(operationId);

    // è®¡ç®—å¤„ç†é€Ÿç‡
    final elapsed = operation.lastUpdateTime.difference(operation.startTime);
    if (elapsed.inMilliseconds > 0) {
      operation.processingRate = processedRecords / (elapsed.inMilliseconds / 1000.0);
    }
  }

  @override
  Future<void> recordMemoryUsage(String operationId) async {
    final operation = _activeOperations[operationId];
    if (operation == null) return;

    final currentMemory = await getCurrentMemoryUsage();
    
    // æ›´æ–°å³°å€¼å†…å­?
    if (currentMemory.currentBytes > operation.peakMemory.currentBytes) {
      operation.peakMemory = currentMemory;
    }

    // æ·»åŠ åˆ°å†å²è®°å½?
    final history = _memoryHistory[operationId] ?? [];
    history.add(currentMemory);
    
    // ä¿æŒæœ€è¿?00ä¸ªè®°å½?
    if (history.length > 100) {
      history.removeAt(0);
    }
    
    _memoryHistory[operationId] = history;
  }

  @override
  Future<PerformanceMetrics> endMonitoring(String operationId) async {
    final operation = _activeOperations[operationId];
    if (operation == null) {
      throw ArgumentError('Operation $operationId not found');
    }

    final endTime = DateTime.now();
    final finalMemory = await getCurrentMemoryUsage();

    final metrics = PerformanceMetrics(
      startTime: operation.startTime,
      endTime: endTime,
      totalRecords: operation.totalRecords,
      processedRecords: operation.processedRecords,
      memoryUsageBytes: finalMemory.currentBytes,
      peakMemoryUsageBytes: operation.peakMemory.currentBytes,
      processingRatePerSecond: operation.processingRate,
      additionalMetrics: {
        'initialMemoryMB': operation.initialMemory.currentMB,
        'finalMemoryMB': finalMemory.currentMB,
        'memoryGrowthMB': finalMemory.currentMB - operation.initialMemory.currentMB,
        'gcCount': finalMemory.gcCount - operation.initialMemory.gcCount,
      },
    );

    // æ¸…ç†èµ„æº
    _activeOperations.remove(operationId);
    _memoryHistory.remove(operationId);

    developer.log(
      'Completed performance monitoring for operation: $operationId\n'
      'Duration: ${metrics.durationSeconds}s, '
      'Rate: ${metrics.processingRatePerSecond.toStringAsFixed(1)} records/s, '
      'Peak Memory: ${metrics.peakMemoryUsageMB.toStringAsFixed(1)}MB',
      name: 'PerformanceService',
    );

    return metrics;
  }

  @override
  Future<MemoryUsage> getCurrentMemoryUsage() async {
    try {
      // è·å–å½“å‰è¿›ç¨‹çš„å†…å­˜ä¿¡æ?
      final info = ProcessInfo.currentRss;
      final timestamp = DateTime.now();
      
      // å°è¯•è·å–æ›´è¯¦ç»†çš„å†…å­˜ä¿¡æ¯
      int availableMemory = 0;
      int gcCount = 0;
      
      try {
        // è·å–åƒåœ¾å›æ”¶ç»Ÿè®¡ä¿¡æ¯ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        // åœ¨å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„å†…å­˜ç›‘æ§
        gcCount = 0; // æš‚æ—¶è®¾ä¸º0ï¼Œé¿å…APIå…¼å®¹æ€§é—®é¢?
      } catch (e) {
        // å¿½ç•¥è·å–GCç»Ÿè®¡ä¿¡æ¯çš„é”™è¯?
      }

      return MemoryUsage(
        currentBytes: info,
        peakBytes: info, // ProcessInfo.currentRss å·²ç»æ˜¯å³°å€?
        timestamp: timestamp,
        availableBytes: availableMemory,
        gcCount: gcCount,
      );
    } catch (e) {
      // å¦‚æœæ— æ³•è·å–å†…å­˜ä¿¡æ¯ï¼Œè¿”å›é»˜è®¤å€?
      return MemoryUsage(
        currentBytes: 0,
        peakBytes: 0,
        timestamp: DateTime.now(),
        availableBytes: 0,
        gcCount: 0,
      );
    }
  }

  @override
  Future<bool> shouldTriggerGC() async {
    try {
      final currentMemory = await getCurrentMemoryUsage();
      
      // å¦‚æœå†…å­˜ä½¿ç”¨è¶…è¿‡100MBï¼Œå»ºè®®è¿›è¡Œåƒåœ¾å›æ”?
      const memoryThreshold = 100 * 1024 * 1024; // 100MB
      
      return currentMemory.currentBytes > memoryThreshold;
    } catch (e) {
      return false;
    }
  }

  @override
  Future<void> triggerGC() async {
    try {
      // å¼ºåˆ¶åƒåœ¾å›æ”¶
      developer.log('Triggering garbage collection', name: 'PerformanceService');
      
      // åœ¨Dartä¸­ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æ¥å¼ºåˆ¶GCï¼Œä½†å¯ä»¥å°è¯•ä¸€äº›æ–¹æ³?
      // åˆ›å»ºä¸€äº›ä¸´æ—¶å¯¹è±¡ç„¶åé‡Šæ”¾ï¼Œå¯èƒ½ä¼šè§¦å‘GC
      final temp = List.generate(1000, (i) => List.filled(100, i));
      temp.clear();
      
      // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©GCæœ‰æœºä¼šè¿è¡?
      await Future.delayed(const Duration(milliseconds: 10));
      
    } catch (e) {
      developer.log('Failed to trigger GC: $e', name: 'PerformanceService');
    }
  }

  @override
  List<String> getPerformanceRecommendations(PerformanceMetrics metrics) {
    final recommendations = <String>[];

    // å¤„ç†é€Ÿåº¦å»ºè®®
    if (metrics.processingRatePerSecond < 100) {
      recommendations.add('å¤„ç†é€Ÿåº¦è¾ƒæ…¢ï¼Œå»ºè®®å¢åŠ æ‰¹å¤„ç†å¤§å°æˆ–ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢');
    }

    // å†…å­˜ä½¿ç”¨å»ºè®®
    if (metrics.peakMemoryUsageMB > 200) {
      recommendations.add('å†…å­˜ä½¿ç”¨é‡è¾ƒé«˜ï¼Œå»ºè®®å¯ç”¨æµå¼å¤„ç†æˆ–å‡å°‘æ‰¹å¤„ç†å¤§å°');
    }

    // è€—æ—¶å»ºè®®
    if (metrics.durationSeconds > 300) { // 5åˆ†é’Ÿ
      recommendations.add('æ“ä½œè€—æ—¶è¾ƒé•¿ï¼Œå»ºè®®è€ƒè™‘åˆ†æ‰¹å¤„ç†æˆ–åå°æ‰§è¡?);
    }

    // å†…å­˜å¢é•¿å»ºè®®
    final memoryGrowth = metrics.additionalMetrics?['memoryGrowthMB'] as double? ?? 0;
    if (memoryGrowth > 50) {
      recommendations.add('å†…å­˜å¢é•¿è¾ƒå¤šï¼Œå¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼ï¼Œå»ºè®®æ£€æŸ¥èµ„æºé‡Šæ”?);
    }

    // åƒåœ¾å›æ”¶å»ºè®®
    final gcCount = metrics.additionalMetrics?['gcCount'] as int? ?? 0;
    if (gcCount > 10) {
      recommendations.add('åƒåœ¾å›æ”¶é¢‘ç¹ï¼Œå»ºè®®ä¼˜åŒ–å¯¹è±¡åˆ›å»ºå’Œå†…å­˜ä½¿ç”¨æ¨¡å¼');
    }

    if (recommendations.isEmpty) {
      recommendations.add('æ€§èƒ½è¡¨ç°è‰¯å¥½ï¼Œæ— éœ€ç‰¹åˆ«ä¼˜åŒ–');
    }

    return recommendations;
  }

  /// è·å–æ“ä½œçš„å†…å­˜ä½¿ç”¨å†å?
  List<MemoryUsage> getMemoryHistory(String operationId) {
    return _memoryHistory[operationId] ?? [];
  }

  /// è·å–æ‰€æœ‰æ´»è·ƒæ“ä½?
  List<String> getActiveOperations() {
    return _activeOperations.keys.toList();
  }

  /// æ¸…ç†æ‰€æœ‰ç›‘æ§æ•°æ?
  void clearAll() {
    _activeOperations.clear();
    _memoryHistory.clear();
  }
}

/// å†…éƒ¨æ“ä½œæŒ‡æ ‡ç±?
class _OperationMetrics {
  final String operationId;
  final DateTime startTime;
  final int totalRecords;
  final MemoryUsage initialMemory;
  
  int processedRecords;
  DateTime lastUpdateTime;
  MemoryUsage peakMemory;
  double processingRate;

  _OperationMetrics({
    required this.operationId,
    required this.startTime,
    required this.totalRecords,
    required this.initialMemory,
    this.processedRecords = 0,
    DateTime? lastUpdateTime,
    MemoryUsage? peakMemory,
  }) : lastUpdateTime = lastUpdateTime ?? startTime,
       peakMemory = peakMemory ?? initialMemory,
       processingRate = 0.0;
}
import 'dart:async';
import 'dart:convert';
import 'dart:developer' as developer;

import 'package:drift/drift.dart';

import '../../../../core/database/database.dart';
import '../../domain/models/performance_metrics.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/services/i_performance_service.dart';
import 'performance_service.dart';

/// æµå¼å¤„ç†æœåŠ¡å®ç°
class StreamProcessingService implements IStreamProcessingService {
  final AppDatabase _database;
  final IPerformanceService _performanceService;

  StreamProcessingService(
    this._database, {
    IPerformanceService? performanceService,
  }) : _performanceService = performanceService ?? PerformanceService();

  @override
  Stream<List<Map<String, dynamic>>> streamExportTable(
    String tableName,
    StreamProcessingConfig config, {
    void Function(List<Map<String, dynamic>> batch)? onBatch,
    void Function(int processed, int total)? onProgress,
  }) async* {
    final operationId = 'stream_export_${tableName}_${DateTime.now().millisecondsSinceEpoch}';
    
    try {
      // è·å–è¡¨çš„æ€»è®°å½•æ•°
      final totalCount = await _getTableCount(tableName);
      
      // å¼€å§‹æ€§èƒ½ç›‘æ§
      await _performanceService.startMonitoring(operationId, totalCount);
      
      int offset = 0;
      int processedRecords = 0;
      bool hasMoreData = true;

      developer.log(
        'Starting stream export for table: $tableName, total records: $totalCount',
        name: 'StreamProcessingService',
      );

      while (hasMoreData) {
        // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
        if (config.enableMemoryMonitoring) {
          await _checkMemoryUsage(operationId, config);
        }

        // è·å–æ‰¹æ¬¡æ•°æ®
        final batch = await _exportTableBatch(tableName, offset, config.batchSize);
        
        if (batch.isEmpty) {
          hasMoreData = false;
          break;
        }

        // æ›´æ–°è¿›åº¦
        processedRecords += batch.length;
        await _performanceService.updateProgress(operationId, processedRecords);
        onProgress?.call(processedRecords, totalCount);

        // è°ƒç”¨æ‰¹å¤„ç†å›è°?
        onBatch?.call(batch);

        // è¿”å›æ‰¹æ¬¡æ•°æ®
        yield batch;

        // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ?
        hasMoreData = batch.length == config.batchSize;
        offset += config.batchSize;

        // å¦‚æœå¯ç”¨äº†å†…å­˜ç›‘æ§ï¼Œåœ¨å¤„ç†å¤§æ‰¹æ¬¡åå¯èƒ½éœ€è¦æš‚å?
        if (config.enableMemoryMonitoring && processedRecords % (config.batchSize * 10) == 0) {
          await Future.delayed(const Duration(milliseconds: 10));
        }
      }

      // ç»“æŸæ€§èƒ½ç›‘æ§
      final metrics = await _performanceService.endMonitoring(operationId);
      developer.log(
        'Completed stream export for table: $tableName\n'
        'Processed: $processedRecords records in ${metrics.durationSeconds}s',
        name: 'StreamProcessingService',
      );

    } catch (e) {
      developer.log(
        'Error in stream export for table: $tableName - $e',
        name: 'StreamProcessingService',
      );
      
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æµå¼å¯¼å‡ºè¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<int> streamImportTable(
    String tableName,
    Stream<List<Map<String, dynamic>>> dataStream,
    StreamProcessingConfig config, {
    void Function(int processed, int total)? onProgress,
  }) async {
    final operationId = 'stream_import_${tableName}_${DateTime.now().millisecondsSinceEpoch}';
    
    try {
      int totalProcessed = 0;
      int batchCount = 0;

      developer.log(
        'Starting stream import for table: $tableName',
        name: 'StreamProcessingService',
      );

      // å¼€å§‹æ€§èƒ½ç›‘æ§ï¼ˆæ€»æ•°æœªçŸ¥ï¼Œä½¿ç”?ï¼?
      await _performanceService.startMonitoring(operationId, 0);

      await for (final batch in dataStream) {
        if (batch.isEmpty) continue;

        // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
        if (config.enableMemoryMonitoring) {
          await _checkMemoryUsage(operationId, config);
        }

        // å¯¼å…¥æ‰¹æ¬¡æ•°æ®
        await _importTableBatch(tableName, batch);
        
        totalProcessed += batch.length;
        batchCount++;

        // æ›´æ–°è¿›åº¦
        await _performanceService.updateProgress(operationId, totalProcessed);
        onProgress?.call(totalProcessed, totalProcessed); // æ€»æ•°æœªçŸ¥ï¼Œä½¿ç”¨å·²å¤„ç†æ•?

        // å®šæœŸæš‚åœä»¥é¿å…é˜»å¡UI
        if (batchCount % 10 == 0) {
          await Future.delayed(const Duration(milliseconds: 5));
        }
      }

      // ç»“æŸæ€§èƒ½ç›‘æ§
      final metrics = await _performanceService.endMonitoring(operationId);
      developer.log(
        'Completed stream import for table: $tableName\n'
        'Processed: $totalProcessed records in ${metrics.durationSeconds}s',
        name: 'StreamProcessingService',
      );

      return totalProcessed;

    } catch (e) {
      developer.log(
        'Error in stream import for table: $tableName - $e',
        name: 'StreamProcessingService',
      );
      
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'æµå¼å¯¼å…¥è¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Stream<String> streamJsonSerialize(
    Map<String, dynamic> data,
    StreamProcessingConfig config,
  ) async* {
    final operationId = 'stream_serialize_${DateTime.now().millisecondsSinceEpoch}';
    
    try {
      // å¼€å§‹æ€§èƒ½ç›‘æ§
      await _performanceService.startMonitoring(operationId, data.length);

      // å¼€å§‹JSONå¯¹è±¡
      yield '{\n';

      bool isFirst = true;
      int processedEntries = 0;

      for (final entry in data.entries) {
        // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
        if (config.enableMemoryMonitoring && processedEntries % 100 == 0) {
          await _checkMemoryUsage(operationId, config);
        }

        if (!isFirst) {
          yield ',\n';
        }
        isFirst = false;

        // åºåˆ—åŒ–é”®
        final keyJson = jsonEncode(entry.key);
        yield '  $keyJson: ';

        // åºåˆ—åŒ–å€?
        if (entry.value is List) {
          yield* _streamSerializeList(entry.value as List, config);
        } else if (entry.value is Map) {
          yield* _streamSerializeMap(entry.value as Map<String, dynamic>, config);
        } else {
          yield jsonEncode(entry.value);
        }

        processedEntries++;
        await _performanceService.updateProgress(operationId, processedEntries);

        // å®šæœŸæš‚åœ
        if (processedEntries % 50 == 0) {
          await Future.delayed(const Duration(milliseconds: 1));
        }
      }

      // ç»“æŸJSONå¯¹è±¡
      yield '\n}';

      // ç»“æŸæ€§èƒ½ç›‘æ§
      await _performanceService.endMonitoring(operationId);

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.serializationError,
        message: 'æµå¼JSONåºåˆ—åŒ–å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<Map<String, dynamic>> streamJsonDeserialize(
    Stream<String> jsonStream,
    StreamProcessingConfig config,
  ) async {
    final operationId = 'stream_deserialize_${DateTime.now().millisecondsSinceEpoch}';
    
    try {
      // å¼€å§‹æ€§èƒ½ç›‘æ§
      await _performanceService.startMonitoring(operationId, 0);

      final buffer = StringBuffer();
      int chunkCount = 0;

      // æ”¶é›†æ‰€æœ‰JSONæ•°æ®
      await for (final chunk in jsonStream) {
        buffer.write(chunk);
        chunkCount++;

        // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
        if (config.enableMemoryMonitoring && chunkCount % 100 == 0) {
          await _checkMemoryUsage(operationId, config);
        }

        // å®šæœŸæš‚åœ
        if (chunkCount % 50 == 0) {
          await Future.delayed(const Duration(milliseconds: 1));
        }
      }

      // è§£æJSON
      final jsonString = buffer.toString();
      final result = jsonDecode(jsonString) as Map<String, dynamic>;

      // ç»“æŸæ€§èƒ½ç›‘æ§
      await _performanceService.endMonitoring(operationId);

      return result;

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.serializationError,
        message: 'æµå¼JSONååºåˆ—åŒ–å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æµå¼åºåˆ—åŒ–åˆ—è¡?
  Stream<String> _streamSerializeList(
    List list,
    StreamProcessingConfig config,
  ) async* {
    yield '[\n';

    for (int i = 0; i < list.length; i++) {
      if (i > 0) {
        yield ',\n';
      }

      yield '    ';
      
      if (list[i] is Map) {
        yield* _streamSerializeMap(list[i] as Map<String, dynamic>, config, indent: '    ');
      } else {
        yield jsonEncode(list[i]);
      }

      // å®šæœŸæš‚åœ
      if (i % 100 == 0) {
        await Future.delayed(const Duration(milliseconds: 1));
      }
    }

    yield '\n  ]';
  }

  /// æµå¼åºåˆ—åŒ–æ˜ å°?
  Stream<String> _streamSerializeMap(
    Map<String, dynamic> map,
    StreamProcessingConfig config, {
    String indent = '  ',
  }) async* {
    yield '{\n';

    bool isFirst = true;
    for (final entry in map.entries) {
      if (!isFirst) {
        yield ',\n';
      }
      isFirst = false;

      final keyJson = jsonEncode(entry.key);
      yield '$indent  $keyJson: ${jsonEncode(entry.value)}';
    }

    yield '\n$indent}';
  }

  /// è·å–è¡¨è®°å½•æ•°
  Future<int> _getTableCount(String tableName) async {
    try {
      final query = 'SELECT COUNT(*) as count FROM $tableName';
      final result = await _database.customSelect(query).getSingle();
      return result.data['count'] as int;
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'è·å–è¡?$tableName è®°å½•æ•°å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// åˆ†æ‰¹å¯¼å‡ºè¡¨æ•°æ?
  Future<List<Map<String, dynamic>>> _exportTableBatch(
    String tableName,
    int offset,
    int limit,
  ) async {
    try {
      final query = 'SELECT * FROM $tableName LIMIT $limit OFFSET $offset';
      final result = await _database.customSelect(query).get();
      return result.map((row) => row.data).toList();
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'åˆ†æ‰¹å¯¼å‡ºè¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// åˆ†æ‰¹å¯¼å…¥è¡¨æ•°æ?
  Future<void> _importTableBatch(
    String tableName,
    List<Map<String, dynamic>> records,
  ) async {
    try {
      await _database.transaction(() async {
        for (final record in records) {
          final columns = record.keys.join(', ');
          final placeholders = record.keys.map((_) => '?').join(', ');
          final values = record.values.map((v) => Variable(v)).toList();
          
          final query = 'INSERT OR REPLACE INTO $tableName ($columns) VALUES ($placeholders)';
          await _database.customStatement(query, values);
        }
      });
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.databaseError,
        message: 'åˆ†æ‰¹å¯¼å…¥è¡?$tableName å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†?
  Future<void> _checkMemoryUsage(
    String operationId,
    StreamProcessingConfig config,
  ) async {
    try {
      await _performanceService.recordMemoryUsage(operationId);
      
      final shouldGC = await _performanceService.shouldTriggerGC();
      if (shouldGC) {
        developer.log(
          'Memory usage high, triggering GC for operation: $operationId',
          name: 'StreamProcessingService',
        );
        await _performanceService.triggerGC();
      }

      // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§å†…å­˜é™åˆ?
      final currentMemory = await _performanceService.getCurrentMemoryUsage();
      if (currentMemory.currentBytes > config.maxMemoryUsage) {
        developer.log(
          'Memory usage exceeded limit: ${currentMemory.currentMB}MB > ${config.maxMemoryUsage / (1024 * 1024)}MB',
          name: 'StreamProcessingService',
        );
        
        // å¼ºåˆ¶åƒåœ¾å›æ”¶å¹¶ç­‰å¾?
        await _performanceService.triggerGC();
        await Future.delayed(const Duration(milliseconds: 100));
      }
    } catch (e) {
      developer.log(
        'Error checking memory usage: $e',
        name: 'StreamProcessingService',
      );
    }
  }
}
import 'dart:convert';
import 'dart:io';
import 'dart:async';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../../../core/database/database.dart';
import '../../domain/models/backup_data.dart';
import '../../domain/models/backup_metadata.dart';
import '../../domain/models/backup_options.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/performance_metrics.dart';
import '../../domain/common/backup_common.dart';
import '../../domain/services/i_backup_service.dart';
import '../../domain/services/i_performance_service.dart';
import '../repository/optimized_data_export_repository.dart';
import 'performance_service.dart';
import 'stream_processing_service.dart';
import 'compression_service.dart';
import 'backup_error_service.dart';
import 'backup_resource_manager.dart';

/// ç»Ÿä¸€å¤‡ä»½æœåŠ¡ - èåˆä¼˜åŒ–ç‰ˆå’Œå¢å¼ºç‰ˆçš„ä¼˜åŠ¿
///
/// ä¸»è¦ç‰¹æ€§ï¼š
/// - æµå¼å¤„ç†å’Œå†…å­˜ä¼˜åŒ–ï¼ˆæ¥è‡ªä¼˜åŒ–ç‰ˆï¼‰
/// - å‹ç¼©æ”¯æŒå’Œæ€§èƒ½ç›‘æ§ï¼ˆæ¥è‡ªä¼˜åŒ–ç‰ˆï¼?
/// - å¼ºåŒ–çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶ï¼ˆæ¥è‡ªå¢å¼ºç‰ˆï¼?
/// - æ•°æ®åº“å¥åº·æ£€æŸ¥å’Œé¢„æ£€æŸ¥ï¼ˆæ¥è‡ªå¢å¼ºç‰ˆï¼‰
/// - èµ„æºç®¡ç†å’Œæ¸…ç†ï¼ˆæ¥è‡ªå¢å¼ºç‰ˆï¼‰
class UnifiedBackupService implements IBackupService {
  final OptimizedDataExportRepository _dataExportRepository;
  final IPerformanceService _performanceService;
  final StreamProcessingService _streamProcessingService;
  final CompressionService _compressionService;
  final BackupErrorService _errorService = BackupErrorService.instance;
  final BackupResourceManager _resourceManager = BackupResourceManager.instance;

  // é…ç½®å¸¸é‡
  static const int _maxRetries = 3;
  static const Duration _retryDelay = Duration(seconds: 2);

  UnifiedBackupService(AppDatabase database)
    : _dataExportRepository = OptimizedDataExportRepository(database),
      _performanceService = PerformanceService(),
      _streamProcessingService = StreamProcessingService(database),
      _compressionService = CompressionService();

  @override
  Future<BackupResult> createBackup({
    BackupOptions? options,
    BackupProgressCallback? onProgress,
    CancelToken? cancelToken,
  }) async {
    final operationId = await _errorService.createOperationContext(
      'UnifiedCreateBackup',
    );
    File? tempFile;

    try {
      final backupOptions = options ?? const BackupOptions();

      // æ£€æŸ¥å–æ¶ˆçŠ¶æ€?
      cancelToken?.throwIfCancelled();

      // æ­¥éª¤1: é¢„æ£€æŸ¥å’Œå‡†å¤‡ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
      onProgress?.call('æ‰§è¡Œé¢„æ£€æŸ?..', 0, 100);
      await _performPreflightChecks();

      final backupId = _generateBackupId(backupOptions.customName);
      final backupDir = await _getBackupDirectory();
      final backupFilePath = path.join(backupDir.path, '$backupId.json');

      // åˆ›å»ºä¸´æ—¶æ–‡ä»¶ï¼ˆå¢å¼ºç‰ˆèµ„æºç®¡ç†ï¼?
      tempFile = await _resourceManager.createTemporaryFile(
        prefix: 'unified_backup_temp',
        suffix: 'json',
        operation: 'UnifiedCreateBackup',
        metadata: {'backupId': backupId},
      );

      // æ­¥éª¤2: æ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
      onProgress?.call('æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€?..', 5, 100);
      cancelToken?.throwIfCancelled();
      await _performDatabaseHealthCheck();

      // æ­¥éª¤3: è·å–è¡¨ç»Ÿè®¡ä¿¡æ¯ç”¨äºæ€§èƒ½ç›‘æ§ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      onProgress?.call('åˆ†ææ•°æ®ç»“æ„...', 10, 100);
      final tableCounts = await _getTableCountsSafely();
      final totalRecords = tableCounts.values.fold<int>(
        0,
        (sum, count) => sum + count,
      );

      // å¼€å§‹æ€§èƒ½ç›‘æ§ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      await _performanceService.startMonitoring(operationId, totalRecords);

      // æ­¥éª¤4: æµå¼æ•°æ®å¯¼å‡ºï¼ˆèåˆä¸¤è€…ä¼˜åŠ¿ï¼‰
      onProgress?.call('å¼€å§‹æ™ºèƒ½æµå¼æ•°æ®å¯¼å‡?..', 15, 100);
      cancelToken?.throwIfCancelled();

      final streamConfig = StreamProcessingConfig(
        batchSize: _getOptimalBatchSize(totalRecords),
        enableCompression: backupOptions.compress == true,
        enableMemoryMonitoring: true,
      );

      final tablesData = await _performUnifiedStreamingExport(
        streamConfig,
        onProgress: (current, total) {
          final progressPercent = 15 + ((current / total) * 60).round();
          onProgress?.call('å¯¼å‡ºæ•°æ® ($current/$total)', progressPercent, 100);
        },
        cancelToken: cancelToken,
      );

      // æ­¥éª¤5: åˆ›å»ºå…ƒæ•°æ?
      onProgress?.call('ç”Ÿæˆå¤‡ä»½å…ƒæ•°æ?..', 80, 100);
      cancelToken?.throwIfCancelled();

      final metadata = await _createBackupMetadata(
        backupId,
        tableCounts,
        backupOptions,
      );

      // æ­¥éª¤6: åˆ›å»ºå¤‡ä»½æ•°æ®ç»“æ„
      final backupData = BackupData(
        metadata: metadata,
        tables: tablesData,
        settings: await _getAppSettings(),
      );

      // æ­¥éª¤7: ä¼˜åŒ–çš„åºåˆ—åŒ–å’Œä¿å­˜ï¼ˆèåˆä¸¤è€…ä¼˜åŠ¿ï¼‰
      onProgress?.call('æ™ºèƒ½ä¿å­˜å¤‡ä»½æ–‡ä»¶...', 85, 100);
      cancelToken?.throwIfCancelled();

      await _unifiedSaveBackupFile(
        backupData,
        tempFile.path,
        backupOptions,
        streamConfig,
      );

      // æ­¥éª¤8: éªŒè¯å¤‡ä»½æ–‡ä»¶
      onProgress?.call('éªŒè¯å¤‡ä»½æ–‡ä»¶...', 95, 100);
      cancelToken?.throwIfCancelled();

      final isValid = await validateBackupFile(tempFile.path);
      if (!isValid) {
        throw BackupException.validation('å¤‡ä»½æ–‡ä»¶éªŒè¯å¤±è´¥');
      }

      // æ­¥éª¤9: ç§»åŠ¨åˆ°æœ€ç»ˆä½ç½?
      await tempFile.copy(backupFilePath);

      // å®Œæˆæ€§èƒ½ç›‘æ§
      await _performanceService.endMonitoring(operationId);

      // å®Œæˆ
      onProgress?.call('å¤‡ä»½å®Œæˆ', 100, 100);

      // æ›´æ–°æ–‡ä»¶å¤§å°
      final file = File(backupFilePath);
      final fileSize = await file.length();
      final updatedMetadata = metadata.copyWith(fileSize: fileSize);

      await _errorService.completeOperationContext(
        operationId,
        'UnifiedCreateBackup',
        success: true,
        message: 'ç»Ÿä¸€å¤‡ä»½åˆ›å»ºæˆåŠŸ',
        result: {'filePath': backupFilePath, 'fileSize': fileSize},
      );

      return BackupResult.success(
        filePath: backupFilePath,
        metadata: updatedMetadata,
      );
    } on BackupCancelledException {
      await _errorService.completeOperationContext(
        operationId,
        'UnifiedCreateBackup',
        success: false,
        message: 'å¤‡ä»½æ“ä½œå·²å–æ¶?,
      );
      return BackupResult.failure('å¤‡ä»½æ“ä½œå·²å–æ¶?);
    } catch (e) {
      final errorContext = await _buildErrorContext(e, tempFile);

      final userError = await _errorService.handleError(
        e,
        operation: 'UnifiedCreateBackup',
        context: errorContext,
      );

      await _errorService.completeOperationContext(
        operationId,
        'UnifiedCreateBackup',
        success: false,
        message: userError.message,
      );

      return BackupResult.failure(
        _buildDetailedErrorMessage(userError.message, errorContext),
      );
    } finally {
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶å’Œèµ„æº?
      await _cleanupTempFile(tempFile);
    }
  }

  /// ç»Ÿä¸€çš„æµå¼å¯¼å‡?- èåˆä¸¤è€…ä¼˜åŠ?
  Future<Map<String, List<Map<String, dynamic>>>>
  _performUnifiedStreamingExport(
    StreamProcessingConfig config, {
    void Function(int current, int total)? onProgress,
    CancelToken? cancelToken,
  }) async {
    final Map<String, List<Map<String, dynamic>>> allTablesData = {};
    final tableNames = await _dataExportRepository.getAllTableNames();

    int processedTables = 0;

    for (final tableName in tableNames) {
      cancelToken?.throwIfCancelled();

      // ä½¿ç”¨å¢å¼ºç‰ˆçš„é‡è¯•æœºåˆ¶å¯¼å‡ºè¡¨æ•°æ?
      final tableData = await _exportTableWithRetryAndStreaming(
        tableName,
        config,
        cancelToken,
      );

      allTablesData[tableName] = tableData;
      processedTables++;

      onProgress?.call(processedTables * 1000, tableNames.length * 1000);

      // å®šæœŸè¿›è¡Œå†…å­˜æ¸…ç†ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      if (processedTables % 5 == 0) {
        await Future.delayed(Duration(milliseconds: 100));
      }
    }

    return allTablesData;
  }

  /// å¸¦é‡è¯•æœºåˆ¶çš„æµå¼è¡¨å¯¼å‡?
  Future<List<Map<String, dynamic>>> _exportTableWithRetryAndStreaming(
    String tableName,
    StreamProcessingConfig config,
    CancelToken? cancelToken,
  ) async {
    int retryCount = 0;

    while (retryCount < _maxRetries) {
      try {
        final tableData = <Map<String, dynamic>>[];

        // ä½¿ç”¨ä¼˜åŒ–ç‰ˆçš„æµå¼å¤„ç†æœåŠ¡
        await for (final batch in _streamProcessingService.streamExportTable(
          tableName,
          config,
        )) {
          cancelToken?.throwIfCancelled();
          tableData.addAll(batch);

          // çŸ­æš‚æš‚åœä»¥é¿å…è¿‡åº¦å ç”¨èµ„æº?
          if (tableData.length % (config.batchSize * 5) == 0) {
            await Future.delayed(Duration(milliseconds: 50));
          }
        }

        return tableData;
      } catch (e) {
        retryCount++;
        if (retryCount >= _maxRetries) {
          throw BackupException.database(
            'è¡?$tableName å¯¼å‡ºå¤±è´¥ï¼Œå·²é‡è¯• $_maxRetries æ¬? ${e.toString()}',
          );
        }

        // ç­‰å¾…åé‡è¯?
        await Future.delayed(_retryDelay);
      }
    }

    throw BackupException.database('è¡?$tableName å¯¼å‡ºå¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•?);
  }

  /// ç»Ÿä¸€çš„ä¿å­˜å¤‡ä»½æ–‡ä»?- èåˆä¸¤è€…ä¼˜åŠ?
  Future<void> _unifiedSaveBackupFile(
    BackupData backupData,
    String filePath,
    BackupOptions options,
    StreamProcessingConfig streamConfig,
  ) async {
    try {
      // ç”Ÿæˆæ ¡éªŒå’Œï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
      final tablesJson = jsonEncode(backupData.tables);
      final checksum = _dataExportRepository.generateChecksum(tablesJson);

      final updatedMetadata = backupData.metadata.copyWith(checksum: checksum);
      final updatedBackupData = backupData.copyWith(metadata: updatedMetadata);

      // ä½¿ç”¨ä¼˜åŒ–ç‰ˆçš„æµå¼JSONåºåˆ—åŒ?
      final jsonStream = _streamProcessingService.streamJsonSerialize(
        updatedBackupData.toJson(),
        streamConfig,
      );

      final file = File(filePath);
      final sink = file.openWrite();

      try {
        await for (final chunk in jsonStream) {
          sink.write(chunk);
        }
      } finally {
        await sink.close();
      }

      // æ™ºèƒ½å‹ç¼©å¤„ç†ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      if (options.compress == true) {
        await _applyIntelligentCompression(file, options);
      }
    } catch (e) {
      throw BackupException.fileSystem('ç»Ÿä¸€ä¿å­˜å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// æ™ºèƒ½å‹ç¼©å¤„ç†
  Future<void> _applyIntelligentCompression(
    File file,
    BackupOptions options,
  ) async {
    final compressedPath = '${file.path}.gz';
    final stats = await _compressionService.compressFile(
      file.path,
      compressedPath,
      level: _compressionService.getRecommendedCompressionLevel(
        dataSize: await file.length(),
        prioritizeSpeed: true,
      ),
    );

    // å¦‚æœå‹ç¼©æ•ˆæœå¥½ï¼Œä½¿ç”¨å‹ç¼©æ–‡ä»¶
    if (stats.compressionRatio > 0.2) {
      // å‹ç¼©ç‡è¶…è¿?0%
      await file.delete();
      await File(compressedPath).rename(file.path);
    } else {
      // å‹ç¼©æ•ˆæœä¸å¥½ï¼Œåˆ é™¤å‹ç¼©æ–‡ä»?
      await File(compressedPath).delete();
    }
  }

  /// æ‰§è¡Œé¢„æ£€æŸ¥ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<void> _performPreflightChecks() async {
    try {
      // æ£€æŸ¥å­˜å‚¨ç©ºé—?
      await _checkStorageSpace();

      // æ£€æŸ¥æ•°æ®åº“åŸºæœ¬è¿æ¥
      await _dataExportRepository.testConnection();

      // æ£€æŸ¥å¤‡ä»½ç›®å½•æƒé™?
      final backupDir = await _getBackupDirectory();
      await _testDirectoryPermissions(backupDir);
    } catch (e) {
      throw BackupException.fileSystem('é¢„æ£€æŸ¥å¤±è´? ${e.toString()}');
    }
  }

  /// æ‰§è¡Œæ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<void> _performDatabaseHealthCheck() async {
    try {
      // æ£€æŸ¥æ•°æ®åº“å®Œæ•´æ€?
      final integrityCheck = await _dataExportRepository
          .checkDatabaseIntegrity();
      if (!integrityCheck) {
        throw BackupException.database('æ•°æ®åº“å®Œæ•´æ€§æ£€æŸ¥å¤±è´?);
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ¡
      final hasLongRunningTransactions = await _dataExportRepository
          .checkLongRunningTransactions();
      if (hasLongRunningTransactions) {
        // ç­‰å¾…äº‹åŠ¡å®Œæˆæˆ–è¶…æ—?
        await Future.delayed(Duration(seconds: 5));
      }

      // æ£€æŸ¥æ•°æ®åº“é”å®šçŠ¶æ€?
      final isLocked = await _dataExportRepository.isDatabaseLocked();
      if (isLocked) {
        throw BackupException.database('æ•°æ®åº“å½“å‰è¢«é”å®šï¼Œè¯·ç¨åé‡è¯•');
      }
    } catch (e) {
      throw BackupException.database('æ•°æ®åº“å¥åº·æ£€æŸ¥å¤±è´? ${e.toString()}');
    }
  }

  /// å®‰å…¨è·å–è¡¨ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<Map<String, int>> _getTableCountsSafely() async {
    try {
      return await _dataExportRepository.getTableCounts();
    } catch (e) {
      // å¦‚æœæ— æ³•è·å–ç²¾ç¡®ç»Ÿè®¡ï¼Œè¿”å›ä¼°ç®—å€?
      final tables = await _dataExportRepository.getAllTableNames();
      final estimatedCounts = <String, int>{};

      for (final table in tables) {
        try {
          final count = await _dataExportRepository.getTableRowCount(table);
          estimatedCounts[table] = count;
        } catch (e) {
          estimatedCounts[table] = 0; // é»˜è®¤å€?
        }
      }

      return estimatedCounts;
    }
  }

  /// è·å–æœ€ä¼˜æ‰¹å¤„ç†å¤§å°ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
  int _getOptimalBatchSize(int totalRecords) {
    // æ ¹æ®æ€»è®°å½•æ•°åŠ¨æ€è°ƒæ•´æ‰¹å¤„ç†å¤§å°
    if (totalRecords < 1000) {
      return 100;
    } else if (totalRecords < 10000) {
      return 500;
    } else if (totalRecords < 100000) {
      return 1000;
    } else {
      return 2000;
    }
  }

  /// æ„å»ºé”™è¯¯ä¸Šä¸‹æ–‡ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<Map<String, dynamic>> _buildErrorContext(
    dynamic error,
    File? tempFile,
  ) async {
    return {
      'hasTemporaryFile': tempFile != null,
      'temporaryFilePath': tempFile?.path,
      'errorType': error.runtimeType.toString(),
      'timestamp': DateTime.now().toIso8601String(),
      'serviceType': 'UnifiedBackupService',
    };
  }

  /// æ„å»ºè¯¦ç»†é”™è¯¯æ¶ˆæ¯ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  String _buildDetailedErrorMessage(
    String baseMessage,
    Map<String, dynamic> context,
  ) {
    final buffer = StringBuffer(baseMessage);

    if (context['hasTemporaryFile'] == true) {
      buffer.write('\nä¸´æ—¶æ–‡ä»¶: ${context['temporaryFilePath']}');
    }

    buffer.write('\næœåŠ¡ç±»å‹: ${context['serviceType']}');

    return buffer.toString();
  }

  /// æ¸…ç†ä¸´æ—¶æ–‡ä»¶ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<void> _cleanupTempFile(File? tempFile) async {
    if (tempFile != null) {
      await _errorService.executeSafely(
        () async {
          if (await tempFile.exists()) {
            await tempFile.delete();
          }
        },
        operationName: 'CleanupTempFile',
        logErrors: false,
      );
    }
  }

  /// æ£€æŸ¥å­˜å‚¨ç©ºé—´ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<void> _checkStorageSpace() async {
    try {
      final estimatedSize = await estimateBackupSize();
      const reservedSpace = 100 * 1024 * 1024; // 100MB

      if (estimatedSize > reservedSpace) {
        throw BackupException.insufficientSpace(
          'ä¼°è®¡éœ€è¦?${(estimatedSize / 1024 / 1024).toStringAsFixed(1)}MB ç©ºé—´ï¼Œä½†å¯ç”¨ç©ºé—´ä¸è¶³',
        );
      }
    } catch (e) {
      // ç»§ç»­æ‰§è¡Œä½†è®°å½•è­¦å‘?
    }
  }

  /// æµ‹è¯•ç›®å½•æƒé™ï¼ˆå¢å¼ºç‰ˆç‰¹æ€§ï¼‰
  Future<void> _testDirectoryPermissions(Directory dir) async {
    try {
      final testFile = File(path.join(dir.path, 'test_permissions.tmp'));
      await testFile.writeAsString('test');
      await testFile.delete();
    } catch (e) {
      throw BackupException.fileSystem('å¤‡ä»½ç›®å½•æƒé™ä¸è¶³: ${e.toString()}');
    }
  }

  /// ç”Ÿæˆå¤‡ä»½ID
  String _generateBackupId(String? customName) {
    final timestamp = DateTime.now();
    final dateStr = timestamp
        .toIso8601String()
        .split('T')[0]
        .replaceAll('-', '');
    final timeStr = timestamp
        .toIso8601String()
        .split('T')[1]
        .split('.')[0]
        .replaceAll(':', '');

    if (customName != null && customName.isNotEmpty) {
      final safeName = customName.replaceAll(RegExp(r'[^\w\-_]'), '_');
      return '${safeName}_${dateStr}_$timeStr';
    }

    return 'unified_backup_${dateStr}_$timeStr';
  }

  /// è·å–å¤‡ä»½ç›®å½•
  Future<Directory> _getBackupDirectory() async {
    // æ–¹æ¡ˆ1: å°è¯•ä½¿ç”¨å…¬å…±ä¸‹è½½ç›®å½•ï¼ˆç”¨æˆ·å¯é€šè¿‡æ–‡ä»¶ç®¡ç†å™¨è®¿é—®ï¼‰
    try {
      // Android: /storage/emulated/0/Download/StockoBackups
      // æ³¨æ„ï¼šæ˜¯ Download ä¸æ˜¯ Downloads
      final publicDownloadDir = Directory('/storage/emulated/0/Download/StockoBackups');
      
      if (!await publicDownloadDir.exists()) {
        await publicDownloadDir.create(recursive: true);
      }
      
      // æµ‹è¯•æ˜¯å¦å¯å†™
      final testFile = File(path.join(publicDownloadDir.path, '.test'));
      await testFile.writeAsString('test');
      await testFile.delete();
      
      return publicDownloadDir;
    } catch (e) {
      // å¦‚æœå…¬å…±ç›®å½•ä¸å¯ç”¨ï¼Œç»§ç»­å°è¯•å…¶ä»–ä½ç½®
    }
    
    // æ–¹æ¡ˆ2: å°è¯•ä½¿ç”¨å¤–éƒ¨å­˜å‚¨ç›®å½•
    try {
      final externalDir = await getExternalStorageDirectory();
      if (externalDir != null) {
        // å°è¯•å¯¼èˆªåˆ°å…¬å…?Download ç›®å½•
        final publicPath = '/storage/emulated/0/Download/StockoBackups';
        final backupDir = Directory(publicPath);
        
        if (!await backupDir.exists()) {
          await backupDir.create(recursive: true);
        }
        
        // æµ‹è¯•æ˜¯å¦å¯å†™
        final testFile = File(path.join(backupDir.path, '.test'));
        await testFile.writeAsString('test');
        await testFile.delete();
        
        return backupDir;
      }
    } catch (e) {
      // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ¡ˆ
    }

    // æ–¹æ¡ˆ3: å›é€€åˆ°åº”ç”¨ç§æœ‰çš„ Downloads ç›®å½•
    try {
      final downloadsDir = await getDownloadsDirectory();
      if (downloadsDir != null) {
        final backupDir = Directory(
          path.join(downloadsDir.path, 'StockoBackups'),
        );

        if (!await backupDir.exists()) {
          await backupDir.create(recursive: true);
        }

        return backupDir;
      }
    } catch (e) {
      // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ¡ˆ
    }

    // æ–¹æ¡ˆ4: å›é€€åˆ°åº”ç”¨æ–‡æ¡£ç›®å½?
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(path.join(appDir.path, 'backups'));

      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
      }

      return backupDir;
    } catch (e) {
      // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ
    }
    
    // æ–¹æ¡ˆ5: æœ€åå›é€€åˆ°ä¸´æ—¶ç›®å½?
    final tempDir = Directory.systemTemp;
    final backupDir = Directory(path.join(tempDir.path, 'unified_backups'));

    if (!await backupDir.exists()) {
      await backupDir.create(recursive: true);
    }

    return backupDir;
  }

  /// åˆ›å»ºå¤‡ä»½å…ƒæ•°æ?
  Future<BackupMetadata> _createBackupMetadata(
    String backupId,
    Map<String, int> tableCounts,
    BackupOptions options,
  ) async {
    final now = DateTime.now();
    final schemaVersion = await _dataExportRepository
        .getDatabaseSchemaVersion();

    return BackupMetadata(
      id: backupId,
      fileName: '$backupId.json',
      createdAt: now,
      fileSize: 0,
      version: '3.0.0', // ç»Ÿä¸€ç‰ˆæœ¬å?
      tableCounts: tableCounts,
      checksum: '',
      isEncrypted: options.encrypt,
      description: options.description ?? 'ç»Ÿä¸€å¤‡ä»½æœåŠ¡åˆ›å»º',
      appVersion: '1.0.0+1',
      schemaVersion: schemaVersion,
    );
  }

  /// è·å–åº”ç”¨è®¾ç½®
  Future<Map<String, dynamic>?> _getAppSettings() async {
    return {
      'backupVersion': '3.0.0',
      'createdBy': 'Unified é“ºå¾—æ¸?App',
      'serviceType': 'UnifiedBackupService',
      'features': {
        'streamProcessing': true,
        'memoryMonitoring': true,
        'compressionSupport': true,
        'enhancedErrorHandling': true,
        'databaseHealthCheck': true,
        'resourceManagement': true,
      },
    };
  }

  // å®ç°æ¥å£çš„å…¶ä»–æ–¹æ³?
  @override
  Future<List<BackupMetadata>> getLocalBackups() async {
    try {
      final backupDir = await _getBackupDirectory();
      if (!await backupDir.exists()) {
        return [];
      }

      final backupFiles = await backupDir
          .list()
          .where((entity) => entity is File && entity.path.endsWith('.json'))
          .cast<File>()
          .toList();

      final List<BackupMetadata> backups = [];

      for (final file in backupFiles) {
        try {
          final metadata = await getBackupInfo(file.path);
          if (metadata != null) {
            backups.add(metadata);
          }
        } catch (e) {
          continue;
        }
      }

      backups.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      return backups;
    } catch (e) {
      throw BackupException.fileSystem('è·å–æœ¬åœ°å¤‡ä»½åˆ—è¡¨å¤±è´¥: ${e.toString()}');
    }
  }

  @override
  Future<bool> deleteBackup(String backupId) async {
    try {
      final backupDir = await _getBackupDirectory();
      final backupFile = File(path.join(backupDir.path, '$backupId.json'));

      if (await backupFile.exists()) {
        await backupFile.delete();
        return true;
      }

      return false;
    } catch (e) {
      throw BackupException.fileSystem('åˆ é™¤å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  @override
  Future<BackupMetadata?> getBackupInfo(String filePath) async {
    try {
      final file = File(filePath);
      if (!await file.exists()) {
        return null;
      }

      // æ£€æŸ¥æ˜¯å¦ä¸ºå‹ç¼©æ–‡ä»¶ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      final isCompressed = await _compressionService.isCompressed(filePath);

      String content;
      if (isCompressed) {
        // è§£å‹å¹¶è¯»å?
        final tempPath = '$filePath.tmp';
        await _compressionService.decompressFile(filePath, tempPath);
        content = await File(tempPath).readAsString();
        await File(tempPath).delete();
      } else {
        content = await file.readAsString();
      }

      final jsonData = jsonDecode(content) as Map<String, dynamic>;

      if (!jsonData.containsKey('metadata')) {
        return null;
      }

      final metadata = BackupMetadata.fromJson(
        jsonData['metadata'] as Map<String, dynamic>,
      );

      final fileSize = await file.length();
      return metadata.copyWith(fileSize: fileSize);
    } catch (e) {
      return null;
    }
  }

  @override
  Future<bool> validateBackupFile(String filePath) async {
    try {
      final file = File(filePath);
      if (!await file.exists()) {
        return false;
      }

      // æ£€æŸ¥æ˜¯å¦ä¸ºå‹ç¼©æ–‡ä»¶ï¼ˆä¼˜åŒ–ç‰ˆç‰¹æ€§ï¼‰
      final isCompressed = await _compressionService.isCompressed(filePath);

      String content;
      if (isCompressed) {
        final tempPath = '$filePath.tmp';
        await _compressionService.decompressFile(filePath, tempPath);
        content = await File(tempPath).readAsString();
        await File(tempPath).delete();
      } else {
        content = await file.readAsString();
      }

      final jsonData = jsonDecode(content) as Map<String, dynamic>;

      if (!jsonData.containsKey('metadata') ||
          !jsonData.containsKey('tables')) {
        return false;
      }

      final metadata = BackupMetadata.fromJson(
        jsonData['metadata'] as Map<String, dynamic>,
      );

      final tablesJson = jsonEncode(jsonData['tables']);
      final actualChecksum = _dataExportRepository.generateChecksum(tablesJson);

      return actualChecksum == metadata.checksum;
    } catch (e) {
      return false;
    }
  }

  @override
  Future<int> estimateBackupSize() async {
    try {
      return await _dataExportRepository.estimateExportSize();
    } catch (e) {
      throw BackupException.database('ä¼°ç®—å¤‡ä»½å¤§å°å¤±è´¥: ${e.toString()}');
    }
  }
}
import 'dart:convert';
import 'dart:io';
import 'package:drift/drift.dart';

import '../../../../core/database/database.dart';
import '../../domain/models/backup_metadata.dart';
import '../../domain/models/backup_data.dart';
import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../domain/models/validation_result.dart';
import '../../domain/models/integrity_check_result.dart';
import '../../domain/models/compatibility_check_result.dart';
import '../../domain/services/i_validation_service.dart';
import '../../domain/services/i_encryption_service.dart';
import '../repository/optimized_data_export_repository.dart';

/// æ•°æ®éªŒè¯æœåŠ¡å®ç°ç±?
class ValidationService implements IValidationService {
  final AppDatabase _database;
  final IEncryptionService _encryptionService;
  final OptimizedDataExportRepository _dataExportRepository;

  // æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ?
  static const List<String> _supportedBackupVersions = ['1.0.0', '2.0.0'];
  
  // æ”¯æŒçš„æ•°æ®åº“æ¶æ„ç‰ˆæœ¬èŒƒå›´
  static const int _minSupportedSchemaVersion = 1;
  static const int _maxSupportedSchemaVersion = 50;

  ValidationService(
    this._database,
    this._encryptionService,
  ) : _dataExportRepository = OptimizedDataExportRepository(_database);

  @override
  Future<ValidationResult> validateBackupFormat(
    String filePath, {
    String? password,
  }) async {
    try {
      final file = File(filePath);
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?
      if (!await file.exists()) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileFormat,
          target: filePath,
          errors: [
            ValidationError(
              code: 'FILE_NOT_FOUND',
              message: 'å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ?,
              severity: ErrorSeverity.critical,
            ),
          ],
          repairSuggestions: ['è¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡?, 'ç¡®è®¤æ–‡ä»¶æœªè¢«åˆ é™¤æˆ–ç§»åŠ?],
        );
      }

      // æ£€æŸ¥æ–‡ä»¶å¤§å°?
      final fileSize = await file.length();
      if (fileSize == 0) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileFormat,
          target: filePath,
          errors: [
            ValidationError(
              code: 'EMPTY_FILE',
              message: 'å¤‡ä»½æ–‡ä»¶ä¸ºç©º',
              severity: ErrorSeverity.critical,
            ),
          ],
          repairSuggestions: ['æ–‡ä»¶å¯èƒ½å·²æŸåï¼Œè¯·ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»?],
        );
      }

      // è¯»å–æ–‡ä»¶å†…å®¹
      String content;
      try {
        content = await file.readAsString();
      } catch (e) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileFormat,
          target: filePath,
          errors: [
            ValidationError(
              code: 'FILE_READ_ERROR',
              message: 'æ— æ³•è¯»å–å¤‡ä»½æ–‡ä»¶: ${e.toString()}',
              severity: ErrorSeverity.critical,
            ),
          ],
          repairSuggestions: ['æ£€æŸ¥æ–‡ä»¶æƒé™?, 'ç¡®è®¤æ–‡ä»¶æœªè¢«å…¶ä»–ç¨‹åºå ç”¨'],
        );
      }

      // å¦‚æœæä¾›äº†å¯†ç ï¼Œå°è¯•è§£å¯†
      if (password != null) {
        try {
          content = await _encryptionService.decryptData(content, password);
        } catch (e) {
          return ValidationResult(
            isValid: false,
            type: ValidationType.fileFormat,
            target: filePath,
            errors: [
              ValidationError(
                code: 'DECRYPTION_FAILED',
                message: 'è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡?,
                severity: ErrorSeverity.critical,
              ),
            ],
            repairSuggestions: ['ç¡®è®¤å¯†ç æ­£ç¡®', 'æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ç¡®å®å·²åŠ å¯†'],
          );
        }
      }

      // éªŒè¯JSONæ ¼å¼
      Map<String, dynamic> jsonData;
      try {
        jsonData = jsonDecode(content) as Map<String, dynamic>;
      } catch (e) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileFormat,
          target: filePath,
          errors: [
            ValidationError(
              code: 'INVALID_JSON',
              message: 'JSONæ ¼å¼æ— æ•ˆ: ${e.toString()}',
              severity: ErrorSeverity.critical,
            ),
          ],
          repairSuggestions: ['æ–‡ä»¶å¯èƒ½å·²æŸå?, 'å°è¯•ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ£€æŸ¥JSONæ ¼å¼'],
        );
      }

      // éªŒè¯åŸºæœ¬ç»“æ„
      final structureErrors = <ValidationError>[];
      final structureWarnings = <ValidationWarning>[];

      if (!jsonData.containsKey('metadata')) {
        structureErrors.add(
          ValidationError(
            code: 'MISSING_METADATA',
            message: 'ç¼ºå°‘metadataå­—æ®µ',
            severity: ErrorSeverity.critical,
          ),
        );
      }

      if (!jsonData.containsKey('tables')) {
        structureErrors.add(
          ValidationError(
            code: 'MISSING_TABLES',
            message: 'ç¼ºå°‘tableså­—æ®µ',
            severity: ErrorSeverity.critical,
          ),
        );
      }

      if (structureErrors.isNotEmpty) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileFormat,
          target: filePath,
          errors: structureErrors,
          warnings: structureWarnings,
          repairSuggestions: ['æ–‡ä»¶ç»“æ„ä¸å®Œæ•´ï¼Œå¯èƒ½éœ€è¦é‡æ–°åˆ›å»ºå¤‡ä»?],
        );
      }

      // éªŒè¯å…ƒæ•°æ®æ ¼å¼?
      try {
        BackupMetadata.fromJson(jsonData['metadata'] as Map<String, dynamic>);
      } catch (e) {
        structureErrors.add(
          ValidationError(
            code: 'INVALID_METADATA_FORMAT',
            message: 'å…ƒæ•°æ®æ ¼å¼æ— æ•? ${e.toString()}',
            severity: ErrorSeverity.high,
          ),
        );
      }

      // éªŒè¯è¡¨æ•°æ®æ ¼å¼?
      final tablesData = jsonData['tables'];
      if (tablesData is! Map<String, dynamic>) {
        structureErrors.add(
          ValidationError(
            code: 'INVALID_TABLES_FORMAT',
            message: 'tableså­—æ®µæ ¼å¼æ— æ•ˆï¼Œåº”ä¸ºå¯¹è±¡ç±»å?,
            severity: ErrorSeverity.high,
          ),
        );
      } else {
        // æ£€æŸ¥æ¯ä¸ªè¡¨çš„æ•°æ®æ ¼å¼?
        for (final entry in tablesData.entries) {
          final tableName = entry.key;
          final tableData = entry.value;
          
          if (tableData is! List) {
            structureErrors.add(
              ValidationError(
                code: 'INVALID_TABLE_DATA_FORMAT',
                message: 'è¡?$tableName çš„æ•°æ®æ ¼å¼æ— æ•ˆï¼Œåº”ä¸ºæ•°ç»„ç±»å‹',
                severity: ErrorSeverity.medium,
                location: tableName,
              ),
            );
          }
        }
      }

      final repairSuggestions = <String>[];
      if (structureErrors.isNotEmpty) {
        repairSuggestions.addAll([
          'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å®Œæ•?,
          'å°è¯•ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
          'å¦‚æœæ˜¯æ‰‹åŠ¨ç¼–è¾‘çš„æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥JSONæ ¼å¼',
        ]);
      }

      return ValidationResult(
        isValid: structureErrors.isEmpty,
        type: ValidationType.fileFormat,
        target: filePath,
        errors: structureErrors,
        warnings: structureWarnings,
        repairSuggestions: repairSuggestions,
        details: {
          'fileSize': fileSize,
          'isEncrypted': password != null,
          'tableCount': tablesData is Map ? tablesData.length : 0,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.fileFormat,
        target: filePath,
        errors: [
          ValidationError(
            code: 'VALIDATION_ERROR',
            message: 'éªŒè¯è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯? ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·è”ç³»æŠ€æœ¯æ”¯æŒ?],
      );
    }
  }

  @override
  Future<CompatibilityCheckResult> checkVersionCompatibility(
    BackupMetadata metadata,
  ) async {
    try {
      final issues = <CompatibilityIssue>[];
      final warnings = <CompatibilityWarning>[];
      final upgradeRecommendations = <String>[];

      // è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
      final currentSchemaVersion = await _dataExportRepository.getDatabaseSchemaVersion().catchError((_) => 1);
      const currentAppVersion = '1.0.0+1'; // å¯ä»¥ä»package infoè·å–
      const currentBackupFormatVersion = '1.0.0';

      // æ£€æŸ¥å¤‡ä»½æ ¼å¼ç‰ˆæœ¬å…¼å®¹æ€?
      bool backupFormatCompatible = _supportedBackupVersions.contains(metadata.version);
      if (!backupFormatCompatible) {
        issues.add(
          CompatibilityIssue(
            type: CompatibilityIssueType.backupFormatIncompatible,
            description: 'å¤‡ä»½æ ¼å¼ç‰ˆæœ¬ ${metadata.version} ä¸å—æ”¯æŒ',
            severity: CompatibilityIssueSeverity.critical,
            suggestedSolution: 'è¯·ä½¿ç”¨æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ¬: ${_supportedBackupVersions.join(', ')}',
          ),
        );
      }

      // æ£€æŸ¥æ•°æ®åº“æ¶æ„ç‰ˆæœ¬å…¼å®¹æ€?
      bool schemaVersionCompatible = true;
      if (metadata.schemaVersion != null) {
        final backupSchemaVersion = metadata.schemaVersion!;
        
        if (backupSchemaVersion < _minSupportedSchemaVersion) {
          schemaVersionCompatible = false;
          issues.add(
            CompatibilityIssue(
              type: CompatibilityIssueType.schemaVersionIncompatible,
              description: 'å¤‡ä»½çš„æ•°æ®åº“æ¶æ„ç‰ˆæœ¬ $backupSchemaVersion è¿‡æ—§ï¼Œä¸å—æ”¯æŒ?,
              severity: CompatibilityIssueSeverity.critical,
              suggestedSolution: 'è¯·å‡çº§å¤‡ä»½æ–‡ä»¶æˆ–ä½¿ç”¨æ›´æ–°çš„å¤‡ä»?,
            ),
          );
        } else if (backupSchemaVersion > _maxSupportedSchemaVersion) {
          schemaVersionCompatible = false;
          issues.add(
            CompatibilityIssue(
              type: CompatibilityIssueType.schemaVersionIncompatible,
              description: 'å¤‡ä»½çš„æ•°æ®åº“æ¶æ„ç‰ˆæœ¬ $backupSchemaVersion è¿‡æ–°ï¼Œå½“å‰åº”ç”¨ä¸æ”¯æŒ',
              severity: CompatibilityIssueSeverity.critical,
              suggestedSolution: 'è¯·å‡çº§åº”ç”¨åˆ°æœ€æ–°ç‰ˆæœ?,
            ),
          );
          upgradeRecommendations.add('å‡çº§åº”ç”¨åˆ°æœ€æ–°ç‰ˆæœ¬ä»¥æ”¯æŒæ–°çš„æ•°æ®åº“æ¶æ?);
        } else if (backupSchemaVersion > currentSchemaVersion) {
          warnings.add(
            CompatibilityWarning(
              type: CompatibilityWarningType.versionGapLarge,
              description: 'å¤‡ä»½çš„æ¶æ„ç‰ˆæœ?$backupSchemaVersion æ¯”å½“å‰ç‰ˆæœ?$currentSchemaVersion æ–?,
            ),
          );
          upgradeRecommendations.add('å»ºè®®å‡çº§åº”ç”¨ä»¥è·å¾—æœ€ä½³å…¼å®¹æ€?);
        } else if (currentSchemaVersion - backupSchemaVersion > 10) {
          warnings.add(
            CompatibilityWarning(
              type: CompatibilityWarningType.versionGapLarge,
              description: 'å¤‡ä»½çš„æ¶æ„ç‰ˆæœ?$backupSchemaVersion ä¸å½“å‰ç‰ˆæœ?$currentSchemaVersion å·®è·è¾ƒå¤§',
            ),
          );
        }
      }

      // æ£€æŸ¥åº”ç”¨ç‰ˆæœ¬å…¼å®¹æ€?
      bool appVersionCompatible = true;
      if (metadata.appVersion != null) {
        // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„ç‰ˆæœ¬æ¯”è¾ƒé€»è¾‘
        // ç›®å‰ç®€å•åœ°æ£€æŸ¥ä¸»ç‰ˆæœ¬å?
        final backupAppVersion = metadata.appVersion!;
        final currentMajorVersion = currentAppVersion.split('.')[0];
        final backupMajorVersion = backupAppVersion.split('.')[0];
        
        if (backupMajorVersion != currentMajorVersion) {
          appVersionCompatible = false;
          issues.add(
            CompatibilityIssue(
              type: CompatibilityIssueType.appVersionIncompatible,
              description: 'å¤‡ä»½çš„åº”ç”¨ç‰ˆæœ?$backupAppVersion ä¸å½“å‰ç‰ˆæœ?$currentAppVersion ä¸»ç‰ˆæœ¬ä¸åŒ¹é…',
              severity: CompatibilityIssueSeverity.warning,
              suggestedSolution: 'å¯ä»¥å°è¯•æ¢å¤ï¼Œä½†å¯èƒ½å­˜åœ¨å…¼å®¹æ€§é—®é¢?,
            ),
          );
        }
      }

      // æ£€æŸ¥è¡¨ç»“æ„å…¼å®¹æ€§ï¼ˆåŸºæœ¬æ£€æŸ¥ï¼‰
      final tableCompatibility = <String, bool>{};
      final currentTables = await _dataExportRepository.getAllTableNames().catchError((_) => <String>[]);
      
      for (final tableName in metadata.tableCounts.keys) {
        final isCompatible = currentTables.contains(tableName);
        tableCompatibility[tableName] = isCompatible;
        
        if (!isCompatible) {
          issues.add(
            CompatibilityIssue(
              type: CompatibilityIssueType.unknownTable,
              description: 'è¡?$tableName åœ¨å½“å‰æ•°æ®åº“ä¸­ä¸å­˜åœ¨',
              severity: CompatibilityIssueSeverity.warning,
              affectedComponent: tableName,
              suggestedSolution: 'è¯¥è¡¨çš„æ•°æ®å°†è¢«è·³è¿?,
            ),
          );
        }
      }

      final details = CompatibilityDetails(
        currentAppVersion: currentAppVersion,
        backupAppVersion: metadata.appVersion ?? 'unknown',
        currentSchemaVersion: currentSchemaVersion,
        backupSchemaVersion: metadata.schemaVersion ?? 0,
        currentBackupFormatVersion: currentBackupFormatVersion,
        backupFormatVersion: metadata.version,
        minSupportedSchemaVersion: _minSupportedSchemaVersion,
        maxSupportedSchemaVersion: _maxSupportedSchemaVersion,
        supportedBackupFormatVersions: _supportedBackupVersions,
      );

      final isCompatible = backupFormatCompatible && 
                          schemaVersionCompatible && 
                          appVersionCompatible &&
                          issues.where((i) => i.severity == CompatibilityIssueSeverity.critical).isEmpty;

      return CompatibilityCheckResult(
        isCompatible: isCompatible,
        appVersionCompatible: appVersionCompatible,
        schemaVersionCompatible: schemaVersionCompatible,
        backupFormatCompatible: backupFormatCompatible,
        tableCompatibility: tableCompatibility,
        issues: issues,
        warnings: warnings,
        upgradeRecommendations: upgradeRecommendations,
        details: details,
      );

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<IntegrityCheckResult> validateDataIntegrity(
    Map<String, List<Map<String, dynamic>>> tablesData,
    BackupMetadata metadata,
  ) async {
    try {
      final missingRelationships = <MissingRelationship>[];
      final orphanedRecords = <OrphanedRecord>[];
      final duplicateRecords = <DuplicateRecord>[];
      final tableIntegrityResults = <String, bool>{};
      final detailedResults = <ValidationResult>[];

      int totalRecords = 0;
      int validRecords = 0;
      final tableRecordCounts = <String, int>{};
      final tableValidRecordCounts = <String, int>{};

      // éªŒè¯æ ¡éªŒå’?
      final tablesJson = jsonEncode(tablesData);
      final actualChecksum = _dataExportRepository.generateChecksum(tablesJson);
      final checksumValid = actualChecksum == metadata.checksum;

      if (!checksumValid) {
        detailedResults.add(
          ValidationResult(
            isValid: false,
            type: ValidationType.dataIntegrity,
            target: 'checksum',
            errors: [
              ValidationError(
                code: 'CHECKSUM_MISMATCH',
                message: 'æ•°æ®æ ¡éªŒå’Œä¸åŒ¹é…ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸå',
                severity: ErrorSeverity.critical,
              ),
            ],
            repairSuggestions: ['ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶', 'é‡æ–°åˆ›å»ºå¤‡ä»½'],
          ),
        );
      }

      // éªŒè¯æ¯ä¸ªè¡¨çš„æ•°æ®å®Œæ•´æ€?
      for (final entry in tablesData.entries) {
        final tableName = entry.key;
        final records = entry.value;
        
        tableRecordCounts[tableName] = records.length;
        totalRecords += records.length;

        // éªŒè¯è¡¨æ•°æ®å®Œæ•´æ€?
        final tableResult = await _validateTableIntegrity(tableName, records);
        tableIntegrityResults[tableName] = tableResult.isValid;
        detailedResults.add(tableResult);

        if (tableResult.isValid) {
          tableValidRecordCounts[tableName] = records.length;
          validRecords += records.length;
        } else {
          tableValidRecordCounts[tableName] = 0;
        }

        // æ£€æŸ¥é‡å¤è®°å½?
        final duplicates = await _findDuplicateRecords(tableName, records);
        duplicateRecords.addAll(duplicates);
      }

      // éªŒè¯å¤–é”®å…³ç³»
      final foreignKeyResult = await validateForeignKeyRelationships(tablesData);
      detailedResults.add(foreignKeyResult);

      if (!foreignKeyResult.isValid) {
        // ä»éªŒè¯ç»“æœä¸­æå–ç¼ºå¤±å…³ç³»ä¿¡æ¯
        for (final error in foreignKeyResult.errors) {
          if (error.code == 'MISSING_FOREIGN_KEY') {
            final details = error.details;
            if (details != null) {
              missingRelationships.add(
                MissingRelationship(
                  sourceTable: details['sourceTable'] as String,
                  targetTable: details['targetTable'] as String,
                  foreignKeyField: details['foreignKeyField'] as String,
                  missingValue: details['missingValue'],
                  affectedRecordCount: details['affectedRecordCount'] as int,
                ),
              );
            }
          }
        }
      }

      // æŸ¥æ‰¾å­¤ç«‹è®°å½•
      final orphans = await _findOrphanedRecords(tablesData);
      orphanedRecords.addAll(orphans);

      final statistics = IntegrityStatistics(
        totalRecords: totalRecords,
        validRecords: validRecords,
        invalidRecords: totalRecords - validRecords,
        missingRelationshipCount: missingRelationships.length,
        orphanedRecordCount: orphanedRecords.length,
        duplicateRecordCount: duplicateRecords.length,
        tableRecordCounts: tableRecordCounts,
        tableValidRecordCounts: tableValidRecordCounts,
      );

      final relationshipIntegrityValid = missingRelationships.isEmpty && orphanedRecords.isEmpty;
      final isIntegrityValid = checksumValid && 
                              relationshipIntegrityValid && 
                              duplicateRecords.isEmpty &&
                              tableIntegrityResults.values.every((valid) => valid);

      return IntegrityCheckResult(
        isIntegrityValid: isIntegrityValid,
        checksumValid: checksumValid,
        relationshipIntegrityValid: relationshipIntegrityValid,
        tableIntegrityResults: tableIntegrityResults,
        missingRelationships: missingRelationships,
        orphanedRecords: orphanedRecords,
        duplicateRecords: duplicateRecords,
        statistics: statistics,
        detailedResults: detailedResults,
      );

    } catch (e) {
      throw BackupException(
        type: BackupErrorType.validationError,
        message: 'æ•°æ®å®Œæ•´æ€§éªŒè¯å¤±è´? ${e.toString()}',
        originalError: e,
      );
    }
  }

  @override
  Future<ValidationResult> detectFileCorruption(
    String filePath, {
    String? password,
  }) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];
      final repairSuggestions = <String>[];

      final file = File(filePath);
      
      // åŸºæœ¬æ–‡ä»¶æ£€æŸ?
      if (!await file.exists()) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileCorruption,
          target: filePath,
          errors: [
            ValidationError(
              code: 'FILE_NOT_FOUND',
              message: 'æ–‡ä»¶ä¸å­˜åœ?,
              severity: ErrorSeverity.critical,
            ),
          ],
          repairSuggestions: ['æ£€æŸ¥æ–‡ä»¶è·¯å¾?, 'ç¡®è®¤æ–‡ä»¶æœªè¢«åˆ é™¤'],
        );
      }

      final fileSize = await file.length();
      if (fileSize == 0) {
        errors.add(
          ValidationError(
            code: 'EMPTY_FILE',
            message: 'æ–‡ä»¶ä¸ºç©º',
            severity: ErrorSeverity.critical,
          ),
        );
        repairSuggestions.add('æ–‡ä»¶å·²æŸåï¼Œè¯·ä½¿ç”¨å…¶ä»–å¤‡ä»?);
      }

      // è¯»å–æ–‡ä»¶å¹¶æ£€æŸ¥æ ¼å¼?
      String content;
      try {
        content = await file.readAsString();
      } catch (e) {
        errors.add(
          ValidationError(
            code: 'FILE_READ_ERROR',
            message: 'æ— æ³•è¯»å–æ–‡ä»¶: ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        );
        repairSuggestions.addAll(['æ£€æŸ¥æ–‡ä»¶æƒé™?, 'ç¡®è®¤æ–‡ä»¶æœªè¢«å ç”¨']);
        
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileCorruption,
          target: filePath,
          errors: errors,
          repairSuggestions: repairSuggestions,
        );
      }

      // å¦‚æœæ–‡ä»¶åŠ å¯†ï¼Œå°è¯•è§£å¯?
      if (password != null) {
        try {
          content = await _encryptionService.decryptData(content, password);
        } catch (e) {
          errors.add(
            ValidationError(
              code: 'DECRYPTION_FAILED',
              message: 'è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯å¯†ç é”™è¯¯æˆ–æ–‡ä»¶æŸå?,
              severity: ErrorSeverity.high,
            ),
          );
          repairSuggestions.addAll(['ç¡®è®¤å¯†ç æ­£ç¡®', 'æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€?]);
        }
      }

      // JSONæ ¼å¼æ£€æŸ?
      Map<String, dynamic> jsonData;
      try {
        jsonData = jsonDecode(content) as Map<String, dynamic>;
      } catch (e) {
        errors.add(
          ValidationError(
            code: 'JSON_CORRUPTION',
            message: 'JSONæ ¼å¼æŸå: ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        );
        repairSuggestions.addAll([
          'æ–‡ä»¶JSONç»“æ„å·²æŸå?,
          'å°è¯•ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨ä¿®å¤JSONæ ¼å¼',
          'ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
        ]);
        
        return ValidationResult(
          isValid: false,
          type: ValidationType.fileCorruption,
          target: filePath,
          errors: errors,
          repairSuggestions: repairSuggestions,
        );
      }

      // ç»“æ„å®Œæ•´æ€§æ£€æŸ?
      final structureIssues = await _checkStructuralIntegrity(jsonData);
      errors.addAll(structureIssues);

      // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥ï¼ˆå¦‚æœæœ‰å…ƒæ•°æ®ï¼?
      if (jsonData.containsKey('metadata') && jsonData.containsKey('tables')) {
        try {
          final metadata = BackupMetadata.fromJson(
            jsonData['metadata'] as Map<String, dynamic>,
          );
          final tablesData = jsonData['tables'] as Map<String, dynamic>;
          
          // æ ¡éªŒå’ŒéªŒè¯?
          final tablesJson = jsonEncode(tablesData);
          final actualChecksum = _dataExportRepository.generateChecksum(tablesJson);
          
          if (actualChecksum != metadata.checksum) {
            errors.add(
              ValidationError(
                code: 'CHECKSUM_MISMATCH',
                message: 'æ•°æ®æ ¡éªŒå’Œä¸åŒ¹é…ï¼Œæ•°æ®å¯èƒ½å·²æŸå',
                severity: ErrorSeverity.high,
              ),
            );
            repairSuggestions.add('æ•°æ®å®Œæ•´æ€§å—æŸï¼Œå»ºè®®ä½¿ç”¨å…¶ä»–å¤‡ä»½');
          }

          // è®°å½•æ•°é‡éªŒè¯
          for (final entry in metadata.tableCounts.entries) {
            final tableName = entry.key;
            final expectedCount = entry.value;
            
            if (tablesData.containsKey(tableName)) {
              final actualData = tablesData[tableName];
              if (actualData is List) {
                final actualCount = actualData.length;
                if (actualCount != expectedCount) {
                  warnings.add(
                    ValidationWarning(
                      code: 'RECORD_COUNT_MISMATCH',
                      message: 'è¡?$tableName è®°å½•æ•°ä¸åŒ¹é…ï¼šæœŸæœ?$expectedCountï¼Œå®é™?$actualCount',
                      location: tableName,
                    ),
                  );
                }
              }
            }
          }
        } catch (e) {
          errors.add(
            ValidationError(
              code: 'METADATA_CORRUPTION',
              message: 'å…ƒæ•°æ®æŸå? ${e.toString()}',
              severity: ErrorSeverity.high,
            ),
          );
        }
      }

      // ç”Ÿæˆä¿®å¤å»ºè®®
      if (errors.isNotEmpty) {
        repairSuggestions.addAll(_generateCorruptionRepairSuggestions(errors));
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.fileCorruption,
        target: filePath,
        errors: errors,
        warnings: warnings,
        repairSuggestions: repairSuggestions,
        details: {
          'fileSize': fileSize,
          'hasMetadata': jsonData.containsKey('metadata'),
          'hasTables': jsonData.containsKey('tables'),
          'tableCount': jsonData.containsKey('tables') 
              ? (jsonData['tables'] as Map).length 
              : 0,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.fileCorruption,
        target: filePath,
        errors: [
          ValidationError(
            code: 'CORRUPTION_CHECK_FAILED',
            message: 'æŸåæ£€æµ‹å¤±è´? ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·è”ç³»æŠ€æœ¯æ”¯æŒ?],
      );
    }
  }

  @override
  Future<ValidationResult> preRestoreValidation(
    String filePath, {
    List<String>? selectedTables,
    String? password,
  }) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];
      final repairSuggestions = <String>[];

      // 1. æ–‡ä»¶æ ¼å¼éªŒè¯
      final formatResult = await validateBackupFormat(filePath, password: password);
      if (!formatResult.isValid) {
        errors.addAll(formatResult.errors);
        repairSuggestions.addAll(formatResult.repairSuggestions);
        
        return ValidationResult(
          isValid: false,
          type: ValidationType.preRestoreCheck,
          target: filePath,
          errors: errors,
          warnings: warnings,
          repairSuggestions: repairSuggestions,
        );
      }

      // 2. è¯»å–å¤‡ä»½æ•°æ®
      final backupData = await _readBackupData(filePath, password: password);

      // 3. ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ?
      final compatibilityResult = await checkVersionCompatibility(backupData.metadata);
      if (!compatibilityResult.isCompatible) {
        for (final issue in compatibilityResult.issues) {
          if (issue.severity == CompatibilityIssueSeverity.critical) {
            errors.add(
              ValidationError(
                code: 'COMPATIBILITY_ERROR',
                message: issue.description,
                severity: ErrorSeverity.critical,
                details: {'issueType': issue.type.toString()},
              ),
            );
          } else {
            warnings.add(
              ValidationWarning(
                code: 'COMPATIBILITY_WARNING',
                message: issue.description,
                details: {'issueType': issue.type.toString()},
              ),
            );
          }
        }
        repairSuggestions.addAll(compatibilityResult.upgradeRecommendations);
      }

      // 4. æ•°æ®å®Œæ•´æ€§éªŒè¯?
      final integrityResult = await validateDataIntegrity(
        backupData.tables,
        backupData.metadata,
      );
      
      if (!integrityResult.isIntegrityValid) {
        errors.add(
          ValidationError(
            code: 'DATA_INTEGRITY_ERROR',
            message: 'æ•°æ®å®Œæ•´æ€§éªŒè¯å¤±è´?,
            severity: ErrorSeverity.high,
            details: {
              'checksumValid': integrityResult.checksumValid,
              'relationshipIntegrityValid': integrityResult.relationshipIntegrityValid,
              'missingRelationships': integrityResult.missingRelationships.length,
              'orphanedRecords': integrityResult.orphanedRecords.length,
            },
          ),
        );
        repairSuggestions.add('æ•°æ®å®Œæ•´æ€§å—æŸï¼Œæ¢å¤å¯èƒ½ä¸å®Œæ•?);
      }

      // 5. é€‰å®šè¡¨çš„éªŒè¯
      if (selectedTables != null) {
        for (final tableName in selectedTables) {
          if (!backupData.tables.containsKey(tableName)) {
            errors.add(
              ValidationError(
                code: 'SELECTED_TABLE_NOT_FOUND',
                message: 'é€‰å®šçš„è¡¨ $tableName åœ¨å¤‡ä»½ä¸­ä¸å­˜åœ?,
                severity: ErrorSeverity.medium,
                location: tableName,
              ),
            );
          } else {
            // éªŒè¯è¡¨ç»“æ?
            final tableData = backupData.tables[tableName]!;
            if (tableData.isNotEmpty) {
              final structureResult = await validateTableStructure(
                tableName,
                tableData.first,
              );
              if (!structureResult.isValid) {
                errors.addAll(structureResult.errors);
                warnings.addAll(structureResult.warnings);
              }
            }
          }
        }
      }

      // 6. å­˜å‚¨ç©ºé—´æ£€æŸ?
      final estimatedSize = backupData.metadata.fileSize;
      // è¿™é‡Œå¯ä»¥æ·»åŠ ç£ç›˜ç©ºé—´æ£€æŸ¥é€»è¾‘
      if (estimatedSize > 1024 * 1024 * 1024) { // 1GB
        warnings.add(
          ValidationWarning(
            code: 'LARGE_RESTORE_SIZE',
            message: 'æ¢å¤æ•°æ®é‡è¾ƒå¤§ï¼Œå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—?,
            details: {'estimatedSize': estimatedSize},
          ),
        );
      }

      // ç”Ÿæˆç»¼åˆä¿®å¤å»ºè®®
      if (errors.isNotEmpty || warnings.isNotEmpty) {
        repairSuggestions.addAll(_generatePreRestoreRepairSuggestions(errors, warnings));
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.preRestoreCheck,
        target: filePath,
        errors: errors,
        warnings: warnings,
        repairSuggestions: repairSuggestions,
        details: {
          'selectedTableCount': selectedTables?.length ?? backupData.tables.length,
          'totalRecords': integrityResult.statistics.totalRecords,
          'estimatedSize': estimatedSize,
          'compatibilityScore': _calculateCompatibilityScore(compatibilityResult),
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.preRestoreCheck,
        target: filePath,
        errors: [
          ValidationError(
            code: 'PRE_RESTORE_CHECK_FAILED',
            message: 'æ¢å¤å‰æ£€æŸ¥å¤±è´? ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·æ£€æŸ¥å¤‡ä»½æ–‡ä»¶å®Œæ•´æ€?],
      );
    }
  }

  @override
  Future<ValidationResult> validateTableStructure(
    String tableName,
    Map<String, dynamic> backupTableData,
  ) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];

      // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
      final tableExists = await _tableExists(tableName);
      if (!tableExists) {
        return ValidationResult(
          isValid: false,
          type: ValidationType.tableStructure,
          target: tableName,
          errors: [
            ValidationError(
              code: 'TABLE_NOT_EXISTS',
              message: 'è¡?$tableName åœ¨å½“å‰æ•°æ®åº“ä¸­ä¸å­˜åœ¨',
              severity: ErrorSeverity.high,
              location: tableName,
            ),
          ],
          repairSuggestions: ['è¯¥è¡¨çš„æ•°æ®å°†è¢«è·³è¿?, 'æ£€æŸ¥æ•°æ®åº“æ¶æ„æ˜¯å¦åŒ¹é…'],
        );
      }

      // è·å–å½“å‰è¡¨ç»“æ?
      final currentTableInfo = await _getTableInfo(tableName);
      final currentColumns = currentTableInfo.map((col) => col['name'] as String).toSet();

      // æ£€æŸ¥å¤‡ä»½æ•°æ®ä¸­çš„å­—æ®?
      final backupColumns = backupTableData.keys.toSet();

      // æ£€æŸ¥ç¼ºå¤±çš„å¿…éœ€å­—æ®µ
      final requiredColumns = currentTableInfo
          .where((col) => col['notnull'] == 1 && col['dflt_value'] == null)
          .map((col) => col['name'] as String)
          .toSet();

      final missingRequiredColumns = requiredColumns.difference(backupColumns);
      for (final column in missingRequiredColumns) {
        errors.add(
          ValidationError(
            code: 'MISSING_REQUIRED_COLUMN',
            message: 'ç¼ºå°‘å¿…éœ€å­—æ®µ: $column',
            severity: ErrorSeverity.high,
            location: '$tableName.$column',
          ),
        );
      }

      // æ£€æŸ¥æœªçŸ¥å­—æ®?
      final unknownColumns = backupColumns.difference(currentColumns);
      for (final column in unknownColumns) {
        warnings.add(
          ValidationWarning(
            code: 'UNKNOWN_COLUMN',
            message: 'æœªçŸ¥å­—æ®µ: $columnï¼Œå°†è¢«å¿½ç•?,
            location: '$tableName.$column',
          ),
        );
      }

      // æ£€æŸ¥å­—æ®µç±»å‹å…¼å®¹æ€?
      for (final column in backupColumns.intersection(currentColumns)) {
        final currentColumnInfo = currentTableInfo.firstWhere(
          (col) => col['name'] == column,
        );
        final currentType = currentColumnInfo['type'] as String;
        final backupValue = backupTableData[column];
        
        if (backupValue != null && !_isTypeCompatible(currentType, backupValue)) {
          errors.add(
            ValidationError(
              code: 'TYPE_INCOMPATIBLE',
              message: 'å­—æ®µ $column ç±»å‹ä¸å…¼å®¹ï¼šæœŸæœ› $currentTypeï¼Œå®é™?${backupValue.runtimeType}',
              severity: ErrorSeverity.medium,
              location: '$tableName.$column',
            ),
          );
        }
      }

      final repairSuggestions = <String>[];
      if (errors.isNotEmpty) {
        repairSuggestions.addAll([
          'æ£€æŸ¥æ•°æ®åº“æ¶æ„ç‰ˆæœ¬',
          'è€ƒè™‘å‡çº§æ•°æ®åº“æ¶æ?,
          'æ‰‹åŠ¨å¤„ç†ä¸å…¼å®¹çš„å­—æ®µ',
        ]);
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.tableStructure,
        target: tableName,
        errors: errors,
        warnings: warnings,
        repairSuggestions: repairSuggestions,
        details: {
          'currentColumns': currentColumns.toList(),
          'backupColumns': backupColumns.toList(),
          'missingColumns': missingRequiredColumns.toList(),
          'unknownColumns': unknownColumns.toList(),
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.tableStructure,
        target: tableName,
        errors: [
          ValidationError(
            code: 'TABLE_STRUCTURE_CHECK_FAILED',
            message: 'è¡¨ç»“æ„éªŒè¯å¤±è´? ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·æ£€æŸ¥æ•°æ®åº“è¿æ¥å’Œè¡¨ç»“æ„'],
      );
    }
  }

  @override
  Future<ValidationResult> validateDataTypes(
    String tableName,
    List<Map<String, dynamic>> records,
  ) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];

      if (records.isEmpty) {
        return ValidationResult(
          isValid: true,
          type: ValidationType.dataTypes,
          target: tableName,
        );
      }

      // è·å–è¡¨ç»“æ„ä¿¡æ?
      final tableInfo = await _getTableInfo(tableName);
      final columnTypes = <String, String>{};
      
      for (final col in tableInfo) {
        columnTypes[col['name'] as String] = col['type'] as String;
      }

      // éªŒè¯æ¯æ¡è®°å½•çš„æ•°æ®ç±»å?
      for (int i = 0; i < records.length; i++) {
        final record = records[i];
        
        for (final entry in record.entries) {
          final columnName = entry.key;
          final value = entry.value;
          
          if (value == null) continue;
          
          final expectedType = columnTypes[columnName];
          if (expectedType != null && !_isTypeCompatible(expectedType, value)) {
            errors.add(
              ValidationError(
                code: 'DATA_TYPE_MISMATCH',
                message: 'è®°å½• ${i + 1} å­—æ®µ $columnName ç±»å‹ä¸åŒ¹é…ï¼šæœŸæœ› $expectedTypeï¼Œå®é™?${value.runtimeType}',
                severity: ErrorSeverity.medium,
                location: '$tableName.$columnName[${i + 1}]',
                details: {
                  'recordIndex': i,
                  'expectedType': expectedType,
                  'actualType': value.runtimeType.toString(),
                  'value': value,
                },
              ),
            );
          }
        }
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.dataTypes,
        target: tableName,
        errors: errors,
        warnings: warnings,
        repairSuggestions: errors.isNotEmpty 
            ? ['æ£€æŸ¥æ•°æ®ç±»å‹è½¬æ?, 'æ¸…ç†æ— æ•ˆæ•°æ®', 'æ›´æ–°è¡¨ç»“æ„å®šä¹?]
            : [],
        details: {
          'recordCount': records.length,
          'columnTypes': columnTypes,
          'errorCount': errors.length,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.dataTypes,
        target: tableName,
        errors: [
          ValidationError(
            code: 'DATA_TYPE_CHECK_FAILED',
            message: 'æ•°æ®ç±»å‹éªŒè¯å¤±è´¥: ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·æ£€æŸ¥è¡¨ç»“æ„å’Œæ•°æ®æ ¼å¼?],
      );
    }
  } 
 @override
  Future<ValidationResult> validateForeignKeyRelationships(
    Map<String, List<Map<String, dynamic>>> tablesData,
  ) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];

      // å®šä¹‰å¤–é”®å…³ç³»æ˜ å°„
      final foreignKeyRelationships = await _getForeignKeyRelationships();

      for (final relationship in foreignKeyRelationships) {
        final sourceTable = relationship['sourceTable'] as String;
        final targetTable = relationship['targetTable'] as String;
        final foreignKeyField = relationship['foreignKeyField'] as String;
        final targetKeyField = relationship['targetKeyField'] as String;

        if (!tablesData.containsKey(sourceTable) || !tablesData.containsKey(targetTable)) {
          continue; // è·³è¿‡ä¸å­˜åœ¨çš„è¡?
        }

        final sourceRecords = tablesData[sourceTable]!;
        final targetRecords = tablesData[targetTable]!;

        // æ„å»ºç›®æ ‡è¡¨çš„ä¸»é”®é›†åˆ
        final targetKeys = <dynamic>{};
        for (final record in targetRecords) {
          final keyValue = record[targetKeyField];
          if (keyValue != null) {
            targetKeys.add(keyValue);
          }
        }

        // æ£€æŸ¥æºè¡¨ä¸­çš„å¤–é”®å¼•ç”?
        int missingCount = 0;
        for (final record in sourceRecords) {
          final foreignKeyValue = record[foreignKeyField];
          if (foreignKeyValue != null && !targetKeys.contains(foreignKeyValue)) {
            missingCount++;
          }
        }

        if (missingCount > 0) {
          errors.add(
            ValidationError(
              code: 'MISSING_FOREIGN_KEY',
              message: 'è¡?$sourceTable ä¸­æœ‰ $missingCount æ¡è®°å½•çš„å¤–é”® $foreignKeyField åœ¨ç›®æ ‡è¡¨ $targetTable ä¸­ä¸å­˜åœ¨',
              severity: ErrorSeverity.high,
              location: '$sourceTable.$foreignKeyField',
              details: {
                'sourceTable': sourceTable,
                'targetTable': targetTable,
                'foreignKeyField': foreignKeyField,
                'missingValue': null, // è¿™é‡Œå¯ä»¥è®°å½•å…·ä½“çš„ç¼ºå¤±å€?
                'affectedRecordCount': missingCount,
              },
            ),
          );
        }
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.foreignKeyRelationships,
        target: 'all_tables',
        errors: errors,
        warnings: warnings,
        repairSuggestions: errors.isNotEmpty 
            ? ['æ£€æŸ¥æ•°æ®å¯¼å…¥é¡ºåº?, 'ä¿®å¤ç¼ºå¤±çš„å…³è”è®°å½?, 'è€ƒè™‘ç¦ç”¨å¤–é”®çº¦æŸæ£€æŸ?]
            : [],
        details: {
          'checkedRelationships': foreignKeyRelationships.length,
          'violationCount': errors.length,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.foreignKeyRelationships,
        target: 'all_tables',
        errors: [
          ValidationError(
            code: 'FOREIGN_KEY_CHECK_FAILED',
            message: 'å¤–é”®å…³ç³»éªŒè¯å¤±è´¥: ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·æ£€æŸ¥æ•°æ®åº“æ¶æ„å’Œå¤–é”®å®šä¹?],
      );
    }
  }

  @override
  Future<ValidationResult> validateDataConstraints(
    String tableName,
    List<Map<String, dynamic>> records,
  ) async {
    try {
      final errors = <ValidationError>[];
      final warnings = <ValidationWarning>[];

      if (records.isEmpty) {
        return ValidationResult(
          isValid: true,
          type: ValidationType.dataConstraints,
          target: tableName,
        );
      }

      // è·å–è¡¨çº¦æŸä¿¡æ?
      final constraints = await _getTableConstraints(tableName);

      for (int i = 0; i < records.length; i++) {
        final record = records[i];

        // æ£€æŸ¥NOT NULLçº¦æŸ
        for (final constraint in constraints) {
          if (constraint['type'] == 'NOT NULL') {
            final columnName = constraint['column'] as String;
            if (!record.containsKey(columnName) || record[columnName] == null) {
              errors.add(
                ValidationError(
                  code: 'NOT_NULL_VIOLATION',
                  message: 'è®°å½• ${i + 1} è¿åNOT NULLçº¦æŸï¼šå­—æ®?$columnName ä¸èƒ½ä¸ºç©º',
                  severity: ErrorSeverity.high,
                  location: '$tableName.$columnName[${i + 1}]',
                  details: {
                    'recordIndex': i,
                    'constraintType': 'NOT NULL',
                    'columnName': columnName,
                  },
                ),
              );
            }
          }

          // æ£€æŸ¥UNIQUEçº¦æŸ
          if (constraint['type'] == 'UNIQUE') {
            final columnName = constraint['column'] as String;
            final value = record[columnName];
            
            if (value != null) {
              // æ£€æŸ¥åœ¨å½“å‰è®°å½•é›†ä¸­æ˜¯å¦æœ‰é‡å¤?
              final duplicateCount = records
                  .where((r) => r[columnName] == value)
                  .length;
              
              if (duplicateCount > 1) {
                warnings.add(
                  ValidationWarning(
                    code: 'UNIQUE_VIOLATION',
                    message: 'å­—æ®µ $columnName çš„å€?$value åœ¨å¤šæ¡è®°å½•ä¸­é‡å¤',
                    location: '$tableName.$columnName',
                    details: {
                      'constraintType': 'UNIQUE',
                      'columnName': columnName,
                      'duplicateValue': value,
                      'duplicateCount': duplicateCount,
                    },
                  ),
                );
              }
            }
          }

          // æ£€æŸ¥CHECKçº¦æŸï¼ˆå¦‚æœæœ‰å®šä¹‰ï¼?
          if (constraint['type'] == 'CHECK') {
            final checkExpression = constraint['expression'] as String?;
            if (checkExpression != null) {
              // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„CHECKçº¦æŸéªŒè¯é€»è¾‘
              // ç›®å‰åªæ˜¯è®°å½•è­¦å‘Š
              warnings.add(
                ValidationWarning(
                  code: 'CHECK_CONSTRAINT_FOUND',
                  message: 'è¡?$tableName æœ‰CHECKçº¦æŸï¼Œè¯·æ‰‹åŠ¨éªŒè¯: $checkExpression',
                  location: tableName,
                ),
              );
            }
          }
        }
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.dataConstraints,
        target: tableName,
        errors: errors,
        warnings: warnings,
        repairSuggestions: errors.isNotEmpty 
            ? ['ä¿®å¤çº¦æŸè¿åçš„æ•°æ?, 'æ£€æŸ¥æ•°æ®å®Œæ•´æ€?, 'è€ƒè™‘ä¸´æ—¶ç¦ç”¨çº¦æŸ']
            : [],
        details: {
          'recordCount': records.length,
          'constraintCount': constraints.length,
          'violationCount': errors.length,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.dataConstraints,
        target: tableName,
        errors: [
          ValidationError(
            code: 'CONSTRAINT_CHECK_FAILED',
            message: 'æ•°æ®çº¦æŸéªŒè¯å¤±è´¥: ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
        repairSuggestions: ['è¯·æ£€æŸ¥è¡¨çº¦æŸå®šä¹‰'],
      );
    }
  }

  @override
  List<String> generateRepairSuggestions(
    List<ValidationResult> validationResults,
  ) {
    final suggestions = <String>[];
    final errorCodes = <String>{};

    // æ”¶é›†æ‰€æœ‰é”™è¯¯ä»£ç ?
    for (final result in validationResults) {
      for (final error in result.errors) {
        errorCodes.add(error.code);
      }
    }

    // åŸºäºé”™è¯¯ç±»å‹ç”Ÿæˆå»ºè®®
    if (errorCodes.contains('FILE_NOT_FOUND')) {
      suggestions.add('æ£€æŸ¥å¤‡ä»½æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡?);
    }

    if (errorCodes.contains('JSON_CORRUPTION') || errorCodes.contains('CHECKSUM_MISMATCH')) {
      suggestions.addAll([
        'å¤‡ä»½æ–‡ä»¶å¯èƒ½å·²æŸåï¼Œå»ºè®®ä½¿ç”¨å…¶ä»–å¤‡ä»½æ–‡ä»¶',
        'å¦‚æœæ˜¯å”¯ä¸€å¤‡ä»½ï¼Œå¯å°è¯•ä½¿ç”¨æ•°æ®æ¢å¤å·¥å…·',
      ]);
    }

    if (errorCodes.contains('COMPATIBILITY_ERROR')) {
      suggestions.addAll([
        'å‡çº§åº”ç”¨åˆ°æœ€æ–°ç‰ˆæœ?,
        'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶ç‰ˆæœ¬å…¼å®¹æ€?,
        'è€ƒè™‘ä½¿ç”¨ç‰ˆæœ¬è½¬æ¢å·¥å…·',
      ]);
    }

    if (errorCodes.contains('TABLE_NOT_EXISTS')) {
      suggestions.addAll([
        'æ›´æ–°æ•°æ®åº“æ¶æ?,
        'è·³è¿‡ä¸å­˜åœ¨çš„è¡?,
        'æ‰‹åŠ¨åˆ›å»ºç¼ºå¤±çš„è¡¨ç»“æ„',
      ]);
    }

    if (errorCodes.contains('MISSING_FOREIGN_KEY')) {
      suggestions.addAll([
        'è°ƒæ•´æ•°æ®å¯¼å…¥é¡ºåº',
        'ä¸´æ—¶ç¦ç”¨å¤–é”®çº¦æŸ',
        'ä¿®å¤ç¼ºå¤±çš„å…³è”æ•°æ?,
      ]);
    }

    if (errorCodes.contains('DATA_TYPE_MISMATCH')) {
      suggestions.addAll([
        'æ£€æŸ¥æ•°æ®ç±»å‹è½¬æ¢è§„åˆ?,
        'æ¸…ç†ä¸å…¼å®¹çš„æ•°æ®',
        'æ›´æ–°è¡¨ç»“æ„å®šä¹?,
      ]);
    }

    // é€šç”¨å»ºè®®
    if (suggestions.isEmpty && errorCodes.isNotEmpty) {
      suggestions.addAll([
        'æ£€æŸ¥å¤‡ä»½æ–‡ä»¶å®Œæ•´æ€?,
        'ç¡®è®¤æ•°æ®åº“æ¶æ„ç‰ˆæœ¬åŒ¹é…?,
        'è”ç³»æŠ€æœ¯æ”¯æŒè·å–å¸®åŠ?,
      ]);
    }

    return suggestions.toList();
  }

  // ç§æœ‰è¾…åŠ©æ–¹æ³•

  /// è¯»å–å¤‡ä»½æ•°æ®
  Future<BackupData> _readBackupData(
    String filePath, {
    String? password,
  }) async {
    try {
      final file = File(filePath);
      String content = await file.readAsString();
      
      if (password != null) {
        content = await _encryptionService.decryptData(content, password);
      }

      final jsonData = jsonDecode(content) as Map<String, dynamic>;
      return BackupData.fromJson(jsonData);
    } catch (e) {
      throw BackupException(
        type: BackupErrorType.fileSystemError,
        message: 'è¯»å–å¤‡ä»½æ•°æ®å¤±è´¥: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// éªŒè¯è¡¨å®Œæ•´æ€?
  Future<ValidationResult> _validateTableIntegrity(
    String tableName,
    List<Map<String, dynamic>> records,
  ) async {
    final errors = <ValidationError>[];
    final warnings = <ValidationWarning>[];

    try {
      // æ£€æŸ¥è®°å½•æ ¼å¼ä¸€è‡´æ€?
      if (records.isNotEmpty) {
        final firstRecordKeys = records.first.keys.toSet();
        
        for (int i = 1; i < records.length; i++) {
          final currentKeys = records[i].keys.toSet();
          if (!currentKeys.containsAll(firstRecordKeys) || 
              !firstRecordKeys.containsAll(currentKeys)) {
            warnings.add(
              ValidationWarning(
                code: 'INCONSISTENT_RECORD_FORMAT',
                message: 'è®°å½• ${i + 1} çš„å­—æ®µç»“æ„ä¸ç¬¬ä¸€æ¡è®°å½•ä¸ä¸€è‡?,
                location: '$tableName[${i + 1}]',
              ),
            );
          }
        }
      }

      // æ£€æŸ¥ç©ºè®°å½•
      final emptyRecordCount = records.where((record) => 
          record.values.every((value) => value == null || value == '')).length;
      
      if (emptyRecordCount > 0) {
        warnings.add(
          ValidationWarning(
            code: 'EMPTY_RECORDS_FOUND',
            message: 'å‘ç° $emptyRecordCount æ¡ç©ºè®°å½•',
            location: tableName,
          ),
        );
      }

      return ValidationResult(
        isValid: errors.isEmpty,
        type: ValidationType.dataIntegrity,
        target: tableName,
        errors: errors,
        warnings: warnings,
        details: {
          'recordCount': records.length,
          'emptyRecordCount': emptyRecordCount,
        },
      );

    } catch (e) {
      return ValidationResult(
        isValid: false,
        type: ValidationType.dataIntegrity,
        target: tableName,
        errors: [
          ValidationError(
            code: 'TABLE_INTEGRITY_CHECK_FAILED',
            message: 'è¡¨å®Œæ•´æ€§æ£€æŸ¥å¤±è´? ${e.toString()}',
            severity: ErrorSeverity.critical,
          ),
        ],
      );
    }
  }

  /// æŸ¥æ‰¾é‡å¤è®°å½•
  Future<List<DuplicateRecord>> _findDuplicateRecords(
    String tableName,
    List<Map<String, dynamic>> records,
  ) async {
    final duplicates = <DuplicateRecord>[];
    
    try {
      // è·å–ä¸»é”®å­—æ®µ
      final primaryKey = await _getPrimaryKeyColumn(tableName);
      if (primaryKey == null) return duplicates;

      // æŒ‰ä¸»é”®åˆ†ç»„æŸ¥æ‰¾é‡å¤?
      final keyGroups = <dynamic, List<Map<String, dynamic>>>{};
      
      for (final record in records) {
        final keyValue = record[primaryKey];
        if (keyValue != null) {
          keyGroups.putIfAbsent(keyValue, () => []).add(record);
        }
      }

      // æ‰¾å‡ºé‡å¤çš„ç»„
      for (final entry in keyGroups.entries) {
        if (entry.value.length > 1) {
          duplicates.add(
            DuplicateRecord(
              tableName: tableName,
              duplicateFields: [primaryKey],
              duplicateValues: {primaryKey: entry.key},
              duplicateCount: entry.value.length,
              duplicatePrimaryKeys: [entry.key],
            ),
          );
        }
      }

      return duplicates;
    } catch (e) {
      return duplicates;
    }
  }

  /// æŸ¥æ‰¾å­¤ç«‹è®°å½•
  Future<List<OrphanedRecord>> _findOrphanedRecords(
    Map<String, List<Map<String, dynamic>>> tablesData,
  ) async {
    final orphans = <OrphanedRecord>[];
    
    try {
      final foreignKeyRelationships = await _getForeignKeyRelationships();

      for (final relationship in foreignKeyRelationships) {
        final sourceTable = relationship['sourceTable'] as String;
        final targetTable = relationship['targetTable'] as String;
        final foreignKeyField = relationship['foreignKeyField'] as String;
        final targetKeyField = relationship['targetKeyField'] as String;

        if (!tablesData.containsKey(sourceTable) || !tablesData.containsKey(targetTable)) {
          continue;
        }

        final sourceRecords = tablesData[sourceTable]!;
        final targetRecords = tablesData[targetTable]!;

        // æ„å»ºç›®æ ‡è¡¨çš„ä¸»é”®é›†åˆ
        final targetKeys = <dynamic>{};
        for (final record in targetRecords) {
          final keyValue = record[targetKeyField];
          if (keyValue != null) {
            targetKeys.add(keyValue);
          }
        }

        // æŸ¥æ‰¾å­¤ç«‹è®°å½•
        for (final record in sourceRecords) {
          final foreignKeyValue = record[foreignKeyField];
          if (foreignKeyValue != null && !targetKeys.contains(foreignKeyValue)) {
            final primaryKey = await _getPrimaryKeyColumn(sourceTable);
            orphans.add(
              OrphanedRecord(
                tableName: sourceTable,
                primaryKeyField: primaryKey ?? 'id',
                primaryKeyValue: record[primaryKey] ?? 'unknown',
                reason: 'å¤–é”® $foreignKeyField å€?$foreignKeyValue åœ¨ç›®æ ‡è¡¨ $targetTable ä¸­ä¸å­˜åœ¨',
                recordData: record,
              ),
            );
          }
        }
      }

      return orphans;
    } catch (e) {
      return orphans;
    }
  }

  /// æ£€æŸ¥ç»“æ„å®Œæ•´æ€?
  Future<List<ValidationError>> _checkStructuralIntegrity(
    Map<String, dynamic> jsonData,
  ) async {
    final errors = <ValidationError>[];

    // æ£€æŸ¥å¿…éœ€å­—æ®µ
    if (!jsonData.containsKey('metadata')) {
      errors.add(
        ValidationError(
          code: 'MISSING_METADATA',
          message: 'ç¼ºå°‘metadataå­—æ®µ',
          severity: ErrorSeverity.critical,
        ),
      );
    }

    if (!jsonData.containsKey('tables')) {
      errors.add(
        ValidationError(
          code: 'MISSING_TABLES',
          message: 'ç¼ºå°‘tableså­—æ®µ',
          severity: ErrorSeverity.critical,
        ),
      );
    }

    // æ£€æŸ¥metadataç»“æ„
    if (jsonData.containsKey('metadata')) {
      final metadata = jsonData['metadata'];
      if (metadata is! Map<String, dynamic>) {
        errors.add(
          ValidationError(
            code: 'INVALID_METADATA_TYPE',
            message: 'metadataå­—æ®µç±»å‹æ— æ•ˆ',
            severity: ErrorSeverity.high,
          ),
        );
      } else {
        // æ£€æŸ¥metadataå¿…éœ€å­—æ®µ
        final requiredMetadataFields = ['id', 'fileName', 'createdAt', 'version', 'checksum'];
        for (final field in requiredMetadataFields) {
          if (!metadata.containsKey(field)) {
            errors.add(
              ValidationError(
                code: 'MISSING_METADATA_FIELD',
                message: 'metadataç¼ºå°‘å¿…éœ€å­—æ®µ: $field',
                severity: ErrorSeverity.high,
              ),
            );
          }
        }
      }
    }

    // æ£€æŸ¥tablesç»“æ„
    if (jsonData.containsKey('tables')) {
      final tables = jsonData['tables'];
      if (tables is! Map<String, dynamic>) {
        errors.add(
          ValidationError(
            code: 'INVALID_TABLES_TYPE',
            message: 'tableså­—æ®µç±»å‹æ— æ•ˆ',
            severity: ErrorSeverity.high,
          ),
        );
      }
    }

    return errors;
  }

  /// ç”ŸæˆæŸåä¿®å¤å»ºè®®
  List<String> _generateCorruptionRepairSuggestions(
    List<ValidationError> errors,
  ) {
    final suggestions = <String>[];
    final errorCodes = errors.map((e) => e.code).toSet();

    if (errorCodes.contains('JSON_CORRUPTION')) {
      suggestions.addAll([
        'å°è¯•ä½¿ç”¨JSONä¿®å¤å·¥å…·',
        'æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«æˆªæ–­',
        'ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰‹åŠ¨ä¿®å¤JSONæ ¼å¼',
      ]);
    }

    if (errorCodes.contains('CHECKSUM_MISMATCH')) {
      suggestions.addAll([
        'æ–‡ä»¶æ•°æ®å·²è¢«ä¿®æ”¹æˆ–æŸå?,
        'å°è¯•ä»åŸå§‹æ¥æºé‡æ–°è·å–å¤‡ä»?,
        'å¦‚æœæ˜¯ç½‘ç»œä¼ è¾“é—®é¢˜ï¼Œé‡æ–°ä¸‹è½½æ–‡ä»¶',
      ]);
    }

    if (errorCodes.contains('METADATA_CORRUPTION')) {
      suggestions.addAll([
        'å°è¯•æ‰‹åŠ¨é‡å»ºå…ƒæ•°æ?,
        'ä½¿ç”¨å¤‡ä»½æ–‡ä»¶ä¿®å¤å·¥å…·',
        'è”ç³»æŠ€æœ¯æ”¯æŒè·å–ä¸“ä¸šå¸®åŠ?,
      ]);
    }

    return suggestions;
  }

  /// ç”Ÿæˆæ¢å¤å‰ä¿®å¤å»ºè®?
  List<String> _generatePreRestoreRepairSuggestions(
    List<ValidationError> errors,
    List<ValidationWarning> warnings,
  ) {
    final suggestions = <String>[];

    if (errors.isNotEmpty) {
      suggestions.addAll([
        'ä¿®å¤æ‰€æœ‰é”™è¯¯åå†è¿›è¡Œæ¢å¤?,
        'è€ƒè™‘ä½¿ç”¨éƒ¨åˆ†æ¢å¤æ¨¡å¼è·³è¿‡æœ‰é—®é¢˜çš„æ•°æ®',
      ]);
    }

    if (warnings.isNotEmpty) {
      suggestions.addAll([
        'æ³¨æ„è­¦å‘Šä¿¡æ¯ï¼Œå¯èƒ½å½±å“æ¢å¤è´¨é‡?,
        'å»ºè®®åœ¨æµ‹è¯•ç¯å¢ƒä¸­å…ˆè¿›è¡Œæ¢å¤éªŒè¯?,
      ]);
    }

    return suggestions;
  }

  /// è®¡ç®—å…¼å®¹æ€§åˆ†æ•?
  double _calculateCompatibilityScore(CompatibilityCheckResult result) {
    if (result.isCompatible) return 1.0;

    double score = 1.0;
    
    // æ ¹æ®é—®é¢˜ä¸¥é‡ç¨‹åº¦æ‰£åˆ†
    for (final issue in result.issues) {
      switch (issue.severity) {
        case CompatibilityIssueSeverity.critical:
          score -= 0.5;
          break;
        case CompatibilityIssueSeverity.error:
          score -= 0.3;
          break;
        case CompatibilityIssueSeverity.warning:
          score -= 0.1;
          break;
        case CompatibilityIssueSeverity.info:
          score -= 0.05;
          break;
      }
    }

    return (score < 0) ? 0.0 : score;
  }

  /// æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
  Future<bool> _tableExists(String tableName) async {
    try {
      final query = '''
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
      ''';
      final result = await _database.customSelect(
        query,
        variables: [Variable.withString(tableName)],
      ).getSingleOrNull();
      
      return result != null;
    } catch (e) {
      return false;
    }
  }

  /// è·å–è¡¨ç»“æ„ä¿¡æ?
  Future<List<Map<String, dynamic>>> _getTableInfo(String tableName) async {
    try {
      final query = 'PRAGMA table_info($tableName)';
      final result = await _database.customSelect(query).get();
      
      return result.map((row) => row.data).toList();
    } catch (e) {
      return [];
    }
  }

  /// è·å–è¡¨çš„ä¸»é”®åˆ—å
  Future<String?> _getPrimaryKeyColumn(String tableName) async {
    try {
      final tableInfo = await _getTableInfo(tableName);
      
      for (final col in tableInfo) {
        if (col['pk'] == 1) {
          return col['name'] as String;
        }
      }
      
      return null;
    } catch (e) {
      return null;
    }
  }

  /// æ£€æŸ¥æ•°æ®ç±»å‹å…¼å®¹æ€?
  bool _isTypeCompatible(String expectedType, dynamic value) {
    final type = expectedType.toUpperCase();
    
    switch (type) {
      case 'INTEGER':
      case 'INT':
        return value is int;
      case 'REAL':
      case 'FLOAT':
      case 'DOUBLE':
        return value is num;
      case 'TEXT':
      case 'VARCHAR':
      case 'CHAR':
        return value is String;
      case 'BLOB':
        return value is List<int> || value is String;
      case 'BOOLEAN':
      case 'BOOL':
        return value is bool || value is int;
      case 'DATETIME':
      case 'TIMESTAMP':
        return value is String || value is int;
      default:
        return true; // æœªçŸ¥ç±»å‹ï¼Œå‡è®¾å…¼å®?
    }
  }

  /// è·å–å¤–é”®å…³ç³»å®šä¹‰
  Future<List<Map<String, dynamic>>> _getForeignKeyRelationships() async {
    // è¿™é‡Œè¿”å›åº”ç”¨ä¸­å®šä¹‰çš„å¤–é”®å…³ç³»
    // å®é™…å®ç°ä¸­åº”è¯¥ä»æ•°æ®åº“æ¶æ„æˆ–é…ç½®æ–‡ä»¶ä¸­è¯»å?
    return [
      {
        'sourceTable': 'product',
        'targetTable': 'category',
        'foreignKeyField': 'category_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'product',
        'targetTable': 'unit',
        'foreignKeyField': 'unit_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'stock',
        'targetTable': 'product',
        'foreignKeyField': 'product_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'sales_transaction_item',
        'targetTable': 'sales_transaction',
        'foreignKeyField': 'transaction_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'sales_transaction_item',
        'targetTable': 'product',
        'foreignKeyField': 'product_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'purchase_order_item',
        'targetTable': 'purchase_order',
        'foreignKeyField': 'order_id',
        'targetKeyField': 'id',
      },
      {
        'sourceTable': 'purchase_order_item',
        'targetTable': 'product',
        'foreignKeyField': 'product_id',
        'targetKeyField': 'id',
      },
    ];
  }

  /// è·å–è¡¨çº¦æŸä¿¡æ?
  Future<List<Map<String, dynamic>>> _getTableConstraints(String tableName) async {
    final constraints = <Map<String, dynamic>>[];
    
    try {
      // è·å–NOT NULLçº¦æŸ
      final tableInfo = await _getTableInfo(tableName);
      for (final col in tableInfo) {
        if (col['notnull'] == 1) {
          constraints.add({
            'type': 'NOT NULL',
            'column': col['name'],
          });
        }
      }

      // è·å–UNIQUEçº¦æŸï¼ˆä»ç´¢å¼•ä¿¡æ¯ä¸­ï¼‰
      final indexQuery = 'PRAGMA index_list($tableName)';
      final indexes = await _database.customSelect(indexQuery).get();
      
      for (final index in indexes) {
        final indexData = index.data;
        if (indexData['unique'] == 1) {
          final indexName = indexData['name'] as String;
          final indexInfoQuery = 'PRAGMA index_info($indexName)';
          final indexInfo = await _database.customSelect(indexInfoQuery).get();
          
          for (final info in indexInfo) {
            constraints.add({
              'type': 'UNIQUE',
              'column': info.data['name'],
            });
          }
        }
      }

      return constraints;
    } catch (e) {
      return constraints;
    }
  }
}
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';

import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_metadata.dart';

/// å¤‡ä»½æ–‡ä»¶ç®¡ç†å™?
/// å¤„ç†å¤‡ä»½æ–‡ä»¶çš„æœ¬åœ°å­˜å‚¨ã€åˆ†äº«å’Œç®¡ç†æ“ä½œ
class BackupFileManager {
  /// è·å–å¤‡ä»½ç›®å½•
  static Future<Directory> getBackupDirectory() async {
    // æ–¹æ¡ˆ1: å°è¯•ä½¿ç”¨å…¬å…±ä¸‹è½½ç›®å½•ï¼ˆä¸ UnifiedBackupService ä¿æŒä¸€è‡´ï¼‰
    try {
      final publicDownloadDir = Directory('/storage/emulated/0/Download/StockoBackups');
      
      if (!await publicDownloadDir.exists()) {
        await publicDownloadDir.create(recursive: true);
      }
      
      // æµ‹è¯•æ˜¯å¦å¯å†™
      final testFile = File(path.join(publicDownloadDir.path, '.test'));
      await testFile.writeAsString('test');
      await testFile.delete();
      
      return publicDownloadDir;
    } catch (e) {
      // å¦‚æœå…¬å…±ç›®å½•ä¸å¯ç”¨ï¼Œç»§ç»­å°è¯•å…¶ä»–ä½ç½®
    }
    
    // æ–¹æ¡ˆ2: å°è¯•ä½¿ç”¨å¤–éƒ¨å­˜å‚¨ç›®å½•
    try {
      final externalDir = await getExternalStorageDirectory();
      if (externalDir != null) {
        final publicPath = '/storage/emulated/0/Download/StockoBackups';
        final backupDir = Directory(publicPath);
        
        if (!await backupDir.exists()) {
          await backupDir.create(recursive: true);
        }
        
        // æµ‹è¯•æ˜¯å¦å¯å†™
        final testFile = File(path.join(backupDir.path, '.test'));
        await testFile.writeAsString('test');
        await testFile.delete();
        
        return backupDir;
      }
    } catch (e) {
      // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ¡ˆ
    }

    // æ–¹æ¡ˆ3: å›é€€åˆ°åº”ç”¨ç§æœ‰çš„ Downloads ç›®å½•
    try {
      final downloadsDir = await getDownloadsDirectory();
      if (downloadsDir != null) {
        final backupDir = Directory(
          path.join(downloadsDir.path, 'StockoBackups'),
        );

        if (!await backupDir.exists()) {
          await backupDir.create(recursive: true);
        }

        return backupDir;
      }
    } catch (e) {
      // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ¡ˆ
    }

    // æ–¹æ¡ˆ4: å›é€€åˆ°åº”ç”¨æ–‡æ¡£ç›®å½•ï¼ˆåŸæ¥çš„é€»è¾‘ï¼?
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(path.join(appDir.path, 'backups'));

      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
      }

      return backupDir;
    } catch (e) {
      // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ
    }
    
    // æ–¹æ¡ˆ5: æœ€åå›é€€åˆ°ä¸´æ—¶ç›®å½?
    final tempDir = Directory.systemTemp;
    final backupDir = Directory(path.join(tempDir.path, 'unified_backups'));

    if (!await backupDir.exists()) {
      await backupDir.create(recursive: true);
    }

    return backupDir;
  }

  /// è·å–å¤‡ä»½æ–‡ä»¶è·¯å¾„
  static Future<String> getBackupFilePath(String backupId) async {
    final backupDir = await getBackupDirectory();
    return path.join(backupDir.path, '$backupId.json');
  }

  /// æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å­˜åœ?
  static Future<bool> backupFileExists(String backupId) async {
    final filePath = await getBackupFilePath(backupId);
    return File(filePath).exists();
  }

  /// é‡å‘½åå¤‡ä»½æ–‡ä»?
  static Future<bool> renameBackupFile(String oldBackupId, String newBackupId) async {
    try {
      final oldFilePath = await getBackupFilePath(oldBackupId);
      final newFilePath = await getBackupFilePath(newBackupId);
      
      final oldFile = File(oldFilePath);
      if (!await oldFile.exists()) {
        return false;
      }
      
      // æ£€æŸ¥æ–°æ–‡ä»¶åæ˜¯å¦å·²å­˜åœ¨
      if (await File(newFilePath).exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶åå·²å­˜åœ¨: $newBackupId');
      }
      
      await oldFile.rename(newFilePath);
      return true;
    } catch (e) {
      throw BackupException.fileSystem('é‡å‘½åå¤‡ä»½æ–‡ä»¶å¤±è´? ${e.toString()}');
    }
  }

  /// å¤åˆ¶å¤‡ä»½æ–‡ä»¶åˆ°æŒ‡å®šè·¯å¾?
  static Future<void> copyBackupFile(String backupId, String destinationPath) async {
    try {
      final sourceFilePath = await getBackupFilePath(backupId);
      final sourceFile = File(sourceFilePath);
      
      if (!await sourceFile.exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ? $backupId');
      }
      
      await sourceFile.copy(destinationPath);
    } catch (e) {
      throw BackupException.fileSystem('å¤åˆ¶å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// åˆ†äº«å¤‡ä»½æ–‡ä»¶
  /// è¿”å›å¤‡ä»½æ–‡ä»¶è·¯å¾„ï¼Œç”±è°ƒç”¨è€…å¤„ç†åˆ†äº«é€»è¾‘
  static Future<String> getBackupFileForSharing(BackupMetadata metadata) async {
    try {
      final filePath = await getBackupFilePath(metadata.id);
      final file = File(filePath);
      
      if (!await file.exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ? ${metadata.id}');
      }
      
      return filePath;
    } catch (e) {
      throw BackupException.fileSystem('è·å–å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// åˆ é™¤å¤‡ä»½æ–‡ä»¶
  static Future<bool> deleteBackupFile(String backupId) async {
    try {
      final filePath = await getBackupFilePath(backupId);
      final file = File(filePath);
      
      if (await file.exists()) {
        await file.delete();
        return true;
      }
      
      return false;
    } catch (e) {
      throw BackupException.fileSystem('åˆ é™¤å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// è·å–å¤‡ä»½æ–‡ä»¶å¤§å°
  static Future<int> getBackupFileSize(String backupId) async {
    try {
      final filePath = await getBackupFilePath(backupId);
      final file = File(filePath);
      
      if (await file.exists()) {
        return await file.length();
      }
      
      return 0;
    } catch (e) {
      return 0;
    }
  }

  /// æ¸…ç†æ‰€æœ‰å¤‡ä»½æ–‡ä»¶ï¼ˆæ…ç”¨ï¼?
  static Future<void> clearAllBackups() async {
    try {
      final backupDir = await getBackupDirectory();
      
      if (await backupDir.exists()) {
        await for (final entity in backupDir.list()) {
          if (entity is File && entity.path.endsWith('.json')) {
            await entity.delete();
          }
        }
      }
    } catch (e) {
      throw BackupException.fileSystem('æ¸…ç†å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// è·å–å¤‡ä»½ç›®å½•æ€»å¤§å°?
  static Future<int> getBackupDirectorySize() async {
    try {
      final backupDir = await getBackupDirectory();
      int totalSize = 0;
      
      if (await backupDir.exists()) {
        await for (final entity in backupDir.list()) {
          if (entity is File) {
            totalSize += await entity.length();
          }
        }
      }
      
      return totalSize;
    } catch (e) {
      return 0;
    }
  }

  /// éªŒè¯å¤‡ä»½æ–‡ä»¶å?
  static bool isValidBackupFileName(String fileName) {
    // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
    final invalidChars = RegExp(r'[<>:"/\\|?*]');
    if (invalidChars.hasMatch(fileName)) {
      return false;
    }
    
    // æ£€æŸ¥æ–‡ä»¶åé•¿åº¦
    if (fileName.isEmpty || fileName.length > 255) {
      return false;
    }
    
    return true;
  }

  /// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ˜¾ç¤?
  static String formatFileSize(int bytes) {
    if (bytes < 1024) {
      return '$bytes B';
    } else if (bytes < 1024 * 1024) {
      return '${(bytes / 1024).toStringAsFixed(1)} KB';
    } else if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    } else {
      return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
    }
  }

  /// ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
  static String generateSafeFileName(String originalName) {
    // ç§»é™¤æˆ–æ›¿æ¢éæ³•å­—ç¬?
    String safeName = originalName.replaceAll(RegExp(r'[<>:"/\\|?*]'), '_');
    
    // é™åˆ¶é•¿åº¦
    if (safeName.length > 200) {
      safeName = safeName.substring(0, 200);
    }
    
    // ç¡®ä¿ä¸ä¸ºç©?
    if (safeName.isEmpty) {
      safeName = 'backup';
    }
    
    return safeName;
  }

  /// æ£€æŸ¥å¯ç”¨å­˜å‚¨ç©ºé—?
  /// è¿”å›å¯ç”¨ç©ºé—´å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  static Future<int> getAvailableStorageSpace() async {
    try {
      final backupDir = await getBackupDirectory();
      await backupDir.stat();
      
      // åœ¨ä¸åŒå¹³å°ä¸Šè·å–å¯ç”¨ç©ºé—´çš„æ–¹æ³•å¯èƒ½ä¸å?
      // è¿™é‡Œæä¾›ä¸€ä¸ªåŸºæœ¬å®ç°ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä½¿ç”¨å¹³å°ç‰¹å®šçš„API
      
      // å¯¹äºAndroid/iOSï¼Œå¯ä»¥ä½¿ç”¨disk_spaceæ’ä»¶
      // è¿™é‡Œå…ˆè¿”å›ä¸€ä¸ªä¼°ç®—å€?
      return 1024 * 1024 * 1024; // 1GB ä½œä¸ºé»˜è®¤å€?
    } catch (e) {
      // å¦‚æœæ— æ³•è·å–å­˜å‚¨ç©ºé—´ä¿¡æ¯ï¼Œè¿”å›?
      return 0;
    }
  }

  /// æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å­˜å‚¨ç©ºé—?
  /// [requiredSize] éœ€è¦çš„ç©ºé—´å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  /// [reserveSpace] é¢„ç•™ç©ºé—´å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼Œé»˜è®?00MB
  static Future<bool> hasEnoughStorageSpace(
    int requiredSize, {
    int reserveSpace = 100 * 1024 * 1024, // 100MB
  }) async {
    try {
      final availableSpace = await getAvailableStorageSpace();
      return availableSpace >= (requiredSize + reserveSpace);
    } catch (e) {
      // å¦‚æœæ— æ³•æ£€æŸ¥å­˜å‚¨ç©ºé—´ï¼Œå‡è®¾æœ‰è¶³å¤Ÿç©ºé—?
      return true;
    }
  }

  /// éªŒè¯å¤‡ä»½æ–‡ä»¶å®Œæ•´æ€?
  /// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”å¯è¯»
  static Future<bool> validateBackupFileIntegrity(String backupId) async {
    try {
      final filePath = await getBackupFilePath(backupId);
      final file = File(filePath);
      
      if (!await file.exists()) {
        return false;
      }
      
      // å°è¯•è¯»å–æ–‡ä»¶çš„å‰å‡ ä¸ªå­—èŠ‚æ¥éªŒè¯æ–‡ä»¶æ˜¯å¦æŸå?
      final bytes = await file.openRead(0, 100).toList();
      return bytes.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  /// åˆ†äº«å¤‡ä»½æ–‡ä»¶
  /// ä½¿ç”¨ç³»ç»Ÿåˆ†äº«åŠŸèƒ½åˆ†äº«å¤‡ä»½æ–‡ä»¶
  static Future<void> shareBackupFile(BackupMetadata metadata) async {
    try {
      final filePath = await getBackupFileForSharing(metadata);
      final file = File(filePath);
      
      if (!await file.exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ? ${metadata.id}');
      }
      
      // ä½¿ç”¨share_plusæ’ä»¶åˆ†äº«æ–‡ä»¶
      await Share.shareXFiles(
        [XFile(filePath)],
        text: 'å¤‡ä»½æ–‡ä»¶: ${metadata.fileName}\n'
              'åˆ›å»ºæ—¶é—´: ${metadata.createdAt.toLocal()}\n'
              'æ–‡ä»¶å¤§å°: ${formatFileSize(metadata.fileSize)}',
        subject: 'åº“å­˜æ•°æ®å¤‡ä»½ - ${metadata.fileName}',
      );
    } catch (e) {
      throw BackupException.fileSystem('åˆ†äº«å¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// å¯¼å‡ºå¤‡ä»½æ–‡ä»¶åˆ°æŒ‡å®šç›®å½?
  /// [backupId] å¤‡ä»½æ–‡ä»¶ID
  /// [destinationDir] ç›®æ ‡ç›®å½•è·¯å¾„
  /// [newFileName] æ–°æ–‡ä»¶åï¼ˆå¯é€‰ï¼‰
  static Future<String> exportBackupFile(
    String backupId,
    String destinationDir, {
    String? newFileName,
  }) async {
    try {
      final sourceFilePath = await getBackupFilePath(backupId);
      final sourceFile = File(sourceFilePath);
      
      if (!await sourceFile.exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ? $backupId');
      }
      
      // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
      final destDir = Directory(destinationDir);
      if (!await destDir.exists()) {
        await destDir.create(recursive: true);
      }
      
      // ç”Ÿæˆç›®æ ‡æ–‡ä»¶è·¯å¾„
      final fileName = newFileName ?? '$backupId.json';
      final destinationPath = path.join(destinationDir, fileName);
      
      // æ£€æŸ¥ç›®æ ‡æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
      final destFile = File(destinationPath);
      if (await destFile.exists()) {
        throw BackupException.fileSystem('ç›®æ ‡æ–‡ä»¶å·²å­˜åœ? $fileName');
      }
      
      // å¤åˆ¶æ–‡ä»¶
      await sourceFile.copy(destinationPath);
      
      return destinationPath;
    } catch (e) {
      throw BackupException.fileSystem('å¯¼å‡ºå¤‡ä»½æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// è·å–å¤‡ä»½æ–‡ä»¶åˆ—è¡¨ï¼ˆæŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼?
  static Future<List<FileSystemEntity>> getBackupFilesList({
    bool sortByModifiedTime = true,
  }) async {
    try {
      final backupDir = await getBackupDirectory();
      
      if (!await backupDir.exists()) {
        return [];
      }
      
      final files = await backupDir
          .list()
          .where((entity) => entity is File && entity.path.endsWith('.json'))
          .toList();
      
      if (sortByModifiedTime) {
        // æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼?
        files.sort((a, b) {
          final aStat = a.statSync();
          final bStat = b.statSync();
          return bStat.modified.compareTo(aStat.modified);
        });
      }
      
      return files;
    } catch (e) {
      return [];
    }
  }

  /// æ¸…ç†è¿‡æœŸçš„å¤‡ä»½æ–‡ä»?
  /// [maxAge] æœ€å¤§ä¿ç•™å¤©æ•?
  /// [maxCount] æœ€å¤§ä¿ç•™æ–‡ä»¶æ•°é‡?
  static Future<int> cleanupOldBackups({
    int? maxAge,
    int? maxCount,
  }) async {
    try {
      final files = await getBackupFilesList(sortByModifiedTime: true);
      int deletedCount = 0;
      
      for (int i = 0; i < files.length; i++) {
        final file = files[i] as File;
        bool shouldDelete = false;
        
        // æ£€æŸ¥æ–‡ä»¶å¹´é¾?
        if (maxAge != null) {
          final stat = await file.stat();
          final age = DateTime.now().difference(stat.modified).inDays;
          if (age > maxAge) {
            shouldDelete = true;
          }
        }
        
        // æ£€æŸ¥æ–‡ä»¶æ•°é‡é™åˆ?
        if (maxCount != null && i >= maxCount) {
          shouldDelete = true;
        }
        
        if (shouldDelete) {
          try {
            await file.delete();
            deletedCount++;
          } catch (e) {
            // å¿½ç•¥åˆ é™¤å¤±è´¥çš„æ–‡ä»¶ï¼Œç»§ç»­å¤„ç†å…¶ä»–æ–‡ä»¶
            continue;
          }
        }
      }
      
      return deletedCount;
    } catch (e) {
      throw BackupException.fileSystem('æ¸…ç†è¿‡æœŸå¤‡ä»½å¤±è´¥: ${e.toString()}');
    }
  }

  /// è·å–å¤‡ä»½ç›®å½•ä¿¡æ¯
  static Future<Map<String, dynamic>> getBackupDirectoryInfo() async {
    try {
      final backupDir = await getBackupDirectory();
      final files = await getBackupFilesList();
      final totalSize = await getBackupDirectorySize();
      final availableSpace = await getAvailableStorageSpace();
      
      return {
        'path': backupDir.path,
        'fileCount': files.length,
        'totalSize': totalSize,
        'totalSizeFormatted': formatFileSize(totalSize),
        'availableSpace': availableSpace,
        'availableSpaceFormatted': formatFileSize(availableSpace),
        'lastModified': files.isNotEmpty 
            ? (files.first as File).statSync().modified
            : null,
      };
    } catch (e) {
      throw BackupException.fileSystem('è·å–å¤‡ä»½ç›®å½•ä¿¡æ¯å¤±è´¥: ${e.toString()}');
    }
  }

  /// åˆ›å»ºå¤‡ä»½æ–‡ä»¶çš„ä¸´æ—¶å‰¯æœ?
  /// ç”¨äºåœ¨æ“ä½œè¿‡ç¨‹ä¸­ä¿æŠ¤åŸå§‹æ–‡ä»¶
  static Future<String> createTemporaryBackup(String backupId) async {
    try {
      final sourceFilePath = await getBackupFilePath(backupId);
      final sourceFile = File(sourceFilePath);
      
      if (!await sourceFile.exists()) {
        throw BackupException.fileSystem('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ? $backupId');
      }
      
      // åˆ›å»ºä¸´æ—¶æ–‡ä»¶è·¯å¾„
      final backupDir = await getBackupDirectory();
      final tempFilePath = path.join(backupDir.path, '${backupId}_temp.json');
      
      // å¤åˆ¶æ–‡ä»¶
      await sourceFile.copy(tempFilePath);
      
      return tempFilePath;
    } catch (e) {
      throw BackupException.fileSystem('åˆ›å»ºä¸´æ—¶å¤‡ä»½å¤±è´¥: ${e.toString()}');
    }
  }

  /// åˆ é™¤ä¸´æ—¶æ–‡ä»¶
  static Future<void> cleanupTemporaryFiles() async {
    try {
      final backupDir = await getBackupDirectory();
      
      if (!await backupDir.exists()) {
        return;
      }
      
      await for (final entity in backupDir.list()) {
        if (entity is File && entity.path.contains('_temp.json')) {
          try {
            await entity.delete();
          } catch (e) {
            // å¿½ç•¥åˆ é™¤å¤±è´¥çš„ä¸´æ—¶æ–‡ä»?
            continue;
          }
        }
      }
    } catch (e) {
      // å¿½ç•¥æ¸…ç†ä¸´æ—¶æ–‡ä»¶çš„é”™è¯?
    }
  }
}
import 'dart:io';
import 'dart:typed_data';

import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;

/// æ–‡ä»¶è®¿é—®è¾…åŠ©å·¥å…·ç±?
class FileAccessHelper {
  /// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è®¿é—®
  static Future<bool> isFileAccessible(String filePath) async {
    try {
      final file = File(filePath);
      return await file.exists() && await file.length() > 0;
    } catch (e) {
      return false;
    }
  }

  /// å°†æ–‡ä»¶æ•°æ®ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
  static Future<String> saveToTempFile(Uint8List bytes, String fileName) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final backupTempDir = Directory(path.join(tempDir.path, 'backup_temp'));
      
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      if (!await backupTempDir.exists()) {
        await backupTempDir.create(recursive: true);
      }
      
      final tempFile = File(path.join(backupTempDir.path, fileName));
      
      // å†™å…¥æ–‡ä»¶æ•°æ®
      await tempFile.writeAsBytes(bytes);
      
      return tempFile.path;
    } catch (e) {
      throw Exception('ä¿å­˜ä¸´æ—¶æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
  static Future<void> cleanupTempFiles() async {
    try {
      final tempDir = await getTemporaryDirectory();
      final backupTempDir = Directory(path.join(tempDir.path, 'backup_temp'));
      
      if (await backupTempDir.exists()) {
        await backupTempDir.delete(recursive: true);
      }
    } catch (e) {
      // å¿½ç•¥æ¸…ç†é”™è¯¯
    }
  }

  /// è·å–æ–‡ä»¶çš„å¯è¯»è·¯å¾„ï¼ˆç”¨äºæ˜¾ç¤ºï¼?
  static String getDisplayPath(String filePath) {
    try {
      // å¦‚æœæ˜¯ä¸´æ—¶æ–‡ä»¶ï¼Œåªæ˜¾ç¤ºæ–‡ä»¶å
      if (filePath.contains('backup_temp')) {
        return path.basename(filePath);
      }
      
      // å¦‚æœè·¯å¾„å¤ªé•¿ï¼Œæˆªæ–­æ˜¾ç¤?
      if (filePath.length > 50) {
        final fileName = path.basename(filePath);
        final dirName = path.basename(path.dirname(filePath));
        return '.../$dirName/$fileName';
      }
      
      return filePath;
    } catch (e) {
      return path.basename(filePath);
    }
  }

  /// æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦æ”¯æŒ
  static bool isSupportedFileExtension(String fileName) {
    final extension = path.extension(fileName).toLowerCase();
    return ['.json', '.backup'].contains(extension);
  }

  /// è·å–å»ºè®®çš„å¤‡ä»½æ–‡ä»¶ä½ç½?
  static Future<List<String>> getSuggestedBackupLocations() async {
    final suggestions = <String>[];
    
    try {
      // ä¸‹è½½æ–‡ä»¶å¤?
      final downloadsDir = await getDownloadsDirectory();
      if (downloadsDir != null) {
        suggestions.add(downloadsDir.path);
      }
    } catch (e) {
      // å¿½ç•¥é”™è¯¯
    }
    
    try {
      // æ–‡æ¡£æ–‡ä»¶å¤?
      final documentsDir = await getApplicationDocumentsDirectory();
      suggestions.add(documentsDir.path);
    } catch (e) {
      // å¿½ç•¥é”™è¯¯
    }
    
    try {
      // å¤–éƒ¨å­˜å‚¨
      final externalDir = await getExternalStorageDirectory();
      if (externalDir != null) {
        suggestions.add(externalDir.path);
      }
    } catch (e) {
      // å¿½ç•¥é”™è¯¯
    }
    
    return suggestions;
  }

  /// å¤åˆ¶æ–‡ä»¶åˆ°å¯è®¿é—®ä½ç½®
  static Future<String> copyToAccessibleLocation(String sourcePath, String fileName) async {
    try {
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        throw Exception('æºæ–‡ä»¶ä¸å­˜åœ¨');
      }

      // å°è¯•å¤åˆ¶åˆ°ä¸‹è½½æ–‡ä»¶å¤¹
      Directory? targetDir;
      try {
        targetDir = await getDownloadsDirectory();
      } catch (e) {
        // å¦‚æœè·å–ä¸‹è½½æ–‡ä»¶å¤¹å¤±è´¥ï¼Œä½¿ç”¨æ–‡æ¡£æ–‡ä»¶å¤?
        targetDir = await getApplicationDocumentsDirectory();
      }

      targetDir ??= await getApplicationDocumentsDirectory();

      final targetFile = File(path.join(targetDir.path, fileName));
      await sourceFile.copy(targetFile.path);
      
      return targetFile.path;
    } catch (e) {
      throw Exception('å¤åˆ¶æ–‡ä»¶å¤±è´¥: ${e.toString()}');
    }
  }

  /// è·å–ç”¨æˆ·å‹å¥½çš„è®¿é—®æŒ‡å?
  static String getAccessGuide() {
    return '''
å¦‚æœæ— æ³•è®¿é—®å¤‡ä»½æ–‡ä»¶ï¼Œè¯·æŒ‰ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š

1. å°†å¤‡ä»½æ–‡ä»¶å¤åˆ¶åˆ°ä»¥ä¸‹ä»»ä¸€ä½ç½®ï¼?
   â€?ä¸‹è½½æ–‡ä»¶å¤?(Downloads)
   â€?æ–‡æ¡£æ–‡ä»¶å¤?(Documents)
   â€?SDå¡æ ¹ç›®å½•

2. æˆ–è€…ä½¿ç”¨æ–‡ä»¶ç®¡ç†å™¨ï¼?
   â€?æ‰¾åˆ°å¤‡ä»½æ–‡ä»¶ä½ç½®
   â€?é•¿æŒ‰æ–‡ä»¶é€‰æ‹©"å¤åˆ¶"
   â€?å¯¼èˆªåˆ°ä¸‹è½½æˆ–æ–‡æ¡£æ–‡ä»¶å¤?
   â€?ç²˜è´´æ–‡ä»¶

3. ç„¶åé‡æ–°åœ¨åº”ç”¨ä¸­é€‰æ‹©æ–‡ä»¶
''';
  }
}
/// å–æ¶ˆä»¤ç‰Œï¼Œç”¨äºå–æ¶ˆé•¿æ—¶é—´è¿è¡Œçš„æ“ä½?
class CancelToken {
  bool _isCancelled = false;

  /// æ˜¯å¦å·²å–æ¶?
  bool get isCancelled => _isCancelled;

  /// å–æ¶ˆæ“ä½œ
  void cancel() {
    _isCancelled = true;
  }

  /// æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆï¼Œå¦‚æœå·²å–æ¶ˆåˆ™æŠ›å‡ºå¼‚å¸?
  void throwIfCancelled() {
    if (_isCancelled) {
      throw const BackupCancelledException();
    }
  }
}

/// å¤‡ä»½å–æ¶ˆå¼‚å¸¸
class BackupCancelledException implements Exception {
  final String message;

  const BackupCancelledException([this.message = 'å¤‡ä»½æ“ä½œå·²å–æ¶?]);

  @override
  String toString() => 'BackupCancelledException: $message';
}

/// æ¢å¤å–æ¶ˆå¼‚å¸¸
class RestoreCancelledException implements Exception {
  final String message;

  const RestoreCancelledException([this.message = 'æ¢å¤æ“ä½œå·²å–æ¶?]);

  @override
  String toString() => 'RestoreCancelledException: $message';
}



/// æ•°æ®å†²çªä¿¡æ¯
class DataConflict {
  final String tableName;
  final String primaryKey;
  final dynamic primaryKeyValue;
  final Map<String, dynamic> existingRecord;
  final Map<String, dynamic> newRecord;
  final ConflictResolution resolution;

  const DataConflict({
    required this.tableName,
    required this.primaryKey,
    required this.primaryKeyValue,
    required this.existingRecord,
    required this.newRecord,
    required this.resolution,
  });
}

/// æ•°æ®å†²çªè§£å†³ç­–ç•¥
enum ConflictResolution {
  /// è·³è¿‡æ–°è®°å½•ï¼Œä¿ç•™ç°æœ‰è®°å½•
  skip,
  /// ç”¨æ–°è®°å½•è¦†ç›–ç°æœ‰è®°å½•
  overwrite,
  /// åˆå¹¶è®°å½•ï¼ˆä¼˜å…ˆä½¿ç”¨æ–°è®°å½•çš„éç©ºå€¼ï¼‰
  merge,
}

/// æ‰¹å¤„ç†ç»“æ?
class BatchResult {
  final int successCount;
  final int failureCount;
  final List<String> errors;
  final List<DataConflict> conflicts;

  const BatchResult({
    required this.successCount,
    required this.failureCount,
    required this.errors,
    required this.conflicts,
  });

  int get totalCount => successCount + failureCount;
  bool get hasErrors => errors.isNotEmpty;
  bool get hasConflicts => conflicts.isNotEmpty;
}
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auto_backup_settings.freezed.dart';
part 'auto_backup_settings.g.dart';

/// è‡ªåŠ¨å¤‡ä»½é¢‘ç‡æšä¸¾
enum BackupFrequency {
  @JsonValue('daily')
  daily,
  @JsonValue('weekly')
  weekly,
  @JsonValue('monthly')
  monthly,
}

/// è‡ªåŠ¨å¤‡ä»½è®¾ç½®
@freezed
abstract class AutoBackupSettings with _$AutoBackupSettings {
  const factory AutoBackupSettings({
    /// æ˜¯å¦å¯ç”¨è‡ªåŠ¨å¤‡ä»½
    @Default(false) bool enabled,
    /// å¤‡ä»½é¢‘ç‡
    @Default(BackupFrequency.weekly) BackupFrequency frequency,
    /// æœ€å¤§ä¿ç•™å¤‡ä»½æ–‡ä»¶æ•°é‡?
    @Default(5) int maxBackupCount,
    /// ä¸Šæ¬¡è‡ªåŠ¨å¤‡ä»½æ—¶é—´
    DateTime? lastBackupTime,
    /// ä¸‹æ¬¡è®¡åˆ’å¤‡ä»½æ—¶é—´
    DateTime? nextBackupTime,
    /// æ˜¯å¦åœ¨WiFiä¸‹æ‰å¤‡ä»½
    @Default(true) bool wifiOnly,
    /// æ˜¯å¦åœ¨å……ç”µæ—¶æ‰å¤‡ä»?
    @Default(false) bool chargingOnly,
    /// è‡ªåŠ¨å¤‡ä»½çš„å¤‡ä»½é€‰é¡¹
    AutoBackupOptions? backupOptions,
  }) = _AutoBackupSettings;

  factory AutoBackupSettings.fromJson(Map<String, dynamic> json) =>
      _$AutoBackupSettingsFromJson(json);
}

/// è‡ªåŠ¨å¤‡ä»½çš„å¤‡ä»½é€‰é¡¹ï¼ˆç®€åŒ–ç‰ˆï¼?
@freezed
abstract class AutoBackupOptions with _$AutoBackupOptions {
  const factory AutoBackupOptions({
    /// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
    @Default(false) bool includeImages,
    /// æ˜¯å¦åŠ å¯†å¤‡ä»½
    @Default(false) bool encrypt,
    /// åŠ å¯†å¯†ç 
    String? password,
    /// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
    @Default(false) bool compress,
  }) = _AutoBackupOptions;

  factory AutoBackupOptions.fromJson(Map<String, dynamic> json) =>
      _$AutoBackupOptionsFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auto_backup_settings.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AutoBackupSettings {

/// æ˜¯å¦å¯ç”¨è‡ªåŠ¨å¤‡ä»½
 bool get enabled;/// å¤‡ä»½é¢‘ç‡
 BackupFrequency get frequency;/// æœ€å¤§ä¿ç•™å¤‡ä»½æ–‡ä»¶æ•°é‡? int get maxBackupCount;/// ä¸Šæ¬¡è‡ªåŠ¨å¤‡ä»½æ—¶é—´
 DateTime? get lastBackupTime;/// ä¸‹æ¬¡è®¡åˆ’å¤‡ä»½æ—¶é—´
 DateTime? get nextBackupTime;/// æ˜¯å¦åœ¨WiFiä¸‹æ‰å¤‡ä»½
 bool get wifiOnly;/// æ˜¯å¦åœ¨å……ç”µæ—¶æ‰å¤‡ä»? bool get chargingOnly;/// è‡ªåŠ¨å¤‡ä»½çš„å¤‡ä»½é€‰é¡¹
 AutoBackupOptions? get backupOptions;
/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AutoBackupSettingsCopyWith<AutoBackupSettings> get copyWith => _$AutoBackupSettingsCopyWithImpl<AutoBackupSettings>(this as AutoBackupSettings, _$identity);

  /// Serializes this AutoBackupSettings to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AutoBackupSettings&&(identical(other.enabled, enabled) || other.enabled == enabled)&&(identical(other.frequency, frequency) || other.frequency == frequency)&&(identical(other.maxBackupCount, maxBackupCount) || other.maxBackupCount == maxBackupCount)&&(identical(other.lastBackupTime, lastBackupTime) || other.lastBackupTime == lastBackupTime)&&(identical(other.nextBackupTime, nextBackupTime) || other.nextBackupTime == nextBackupTime)&&(identical(other.wifiOnly, wifiOnly) || other.wifiOnly == wifiOnly)&&(identical(other.chargingOnly, chargingOnly) || other.chargingOnly == chargingOnly)&&(identical(other.backupOptions, backupOptions) || other.backupOptions == backupOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,enabled,frequency,maxBackupCount,lastBackupTime,nextBackupTime,wifiOnly,chargingOnly,backupOptions);

@override
String toString() {
  return 'AutoBackupSettings(enabled: $enabled, frequency: $frequency, maxBackupCount: $maxBackupCount, lastBackupTime: $lastBackupTime, nextBackupTime: $nextBackupTime, wifiOnly: $wifiOnly, chargingOnly: $chargingOnly, backupOptions: $backupOptions)';
}


}

/// @nodoc
abstract mixin class $AutoBackupSettingsCopyWith<$Res>  {
  factory $AutoBackupSettingsCopyWith(AutoBackupSettings value, $Res Function(AutoBackupSettings) _then) = _$AutoBackupSettingsCopyWithImpl;
@useResult
$Res call({
 bool enabled, BackupFrequency frequency, int maxBackupCount, DateTime? lastBackupTime, DateTime? nextBackupTime, bool wifiOnly, bool chargingOnly, AutoBackupOptions? backupOptions
});


$AutoBackupOptionsCopyWith<$Res>? get backupOptions;

}
/// @nodoc
class _$AutoBackupSettingsCopyWithImpl<$Res>
    implements $AutoBackupSettingsCopyWith<$Res> {
  _$AutoBackupSettingsCopyWithImpl(this._self, this._then);

  final AutoBackupSettings _self;
  final $Res Function(AutoBackupSettings) _then;

/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? enabled = null,Object? frequency = null,Object? maxBackupCount = null,Object? lastBackupTime = freezed,Object? nextBackupTime = freezed,Object? wifiOnly = null,Object? chargingOnly = null,Object? backupOptions = freezed,}) {
  return _then(_self.copyWith(
enabled: null == enabled ? _self.enabled : enabled // ignore: cast_nullable_to_non_nullable
as bool,frequency: null == frequency ? _self.frequency : frequency // ignore: cast_nullable_to_non_nullable
as BackupFrequency,maxBackupCount: null == maxBackupCount ? _self.maxBackupCount : maxBackupCount // ignore: cast_nullable_to_non_nullable
as int,lastBackupTime: freezed == lastBackupTime ? _self.lastBackupTime : lastBackupTime // ignore: cast_nullable_to_non_nullable
as DateTime?,nextBackupTime: freezed == nextBackupTime ? _self.nextBackupTime : nextBackupTime // ignore: cast_nullable_to_non_nullable
as DateTime?,wifiOnly: null == wifiOnly ? _self.wifiOnly : wifiOnly // ignore: cast_nullable_to_non_nullable
as bool,chargingOnly: null == chargingOnly ? _self.chargingOnly : chargingOnly // ignore: cast_nullable_to_non_nullable
as bool,backupOptions: freezed == backupOptions ? _self.backupOptions : backupOptions // ignore: cast_nullable_to_non_nullable
as AutoBackupOptions?,
  ));
}
/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AutoBackupOptionsCopyWith<$Res>? get backupOptions {
    if (_self.backupOptions == null) {
    return null;
  }

  return $AutoBackupOptionsCopyWith<$Res>(_self.backupOptions!, (value) {
    return _then(_self.copyWith(backupOptions: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _AutoBackupSettings implements AutoBackupSettings {
  const _AutoBackupSettings({this.enabled = false, this.frequency = BackupFrequency.weekly, this.maxBackupCount = 5, this.lastBackupTime, this.nextBackupTime, this.wifiOnly = true, this.chargingOnly = false, this.backupOptions});
  factory _AutoBackupSettings.fromJson(Map<String, dynamic> json) => _$AutoBackupSettingsFromJson(json);

/// æ˜¯å¦å¯ç”¨è‡ªåŠ¨å¤‡ä»½
@override@JsonKey() final  bool enabled;
/// å¤‡ä»½é¢‘ç‡
@override@JsonKey() final  BackupFrequency frequency;
/// æœ€å¤§ä¿ç•™å¤‡ä»½æ–‡ä»¶æ•°é‡?@override@JsonKey() final  int maxBackupCount;
/// ä¸Šæ¬¡è‡ªåŠ¨å¤‡ä»½æ—¶é—´
@override final  DateTime? lastBackupTime;
/// ä¸‹æ¬¡è®¡åˆ’å¤‡ä»½æ—¶é—´
@override final  DateTime? nextBackupTime;
/// æ˜¯å¦åœ¨WiFiä¸‹æ‰å¤‡ä»½
@override@JsonKey() final  bool wifiOnly;
/// æ˜¯å¦åœ¨å……ç”µæ—¶æ‰å¤‡ä»?@override@JsonKey() final  bool chargingOnly;
/// è‡ªåŠ¨å¤‡ä»½çš„å¤‡ä»½é€‰é¡¹
@override final  AutoBackupOptions? backupOptions;

/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AutoBackupSettingsCopyWith<_AutoBackupSettings> get copyWith => __$AutoBackupSettingsCopyWithImpl<_AutoBackupSettings>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AutoBackupSettingsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AutoBackupSettings&&(identical(other.enabled, enabled) || other.enabled == enabled)&&(identical(other.frequency, frequency) || other.frequency == frequency)&&(identical(other.maxBackupCount, maxBackupCount) || other.maxBackupCount == maxBackupCount)&&(identical(other.lastBackupTime, lastBackupTime) || other.lastBackupTime == lastBackupTime)&&(identical(other.nextBackupTime, nextBackupTime) || other.nextBackupTime == nextBackupTime)&&(identical(other.wifiOnly, wifiOnly) || other.wifiOnly == wifiOnly)&&(identical(other.chargingOnly, chargingOnly) || other.chargingOnly == chargingOnly)&&(identical(other.backupOptions, backupOptions) || other.backupOptions == backupOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,enabled,frequency,maxBackupCount,lastBackupTime,nextBackupTime,wifiOnly,chargingOnly,backupOptions);

@override
String toString() {
  return 'AutoBackupSettings(enabled: $enabled, frequency: $frequency, maxBackupCount: $maxBackupCount, lastBackupTime: $lastBackupTime, nextBackupTime: $nextBackupTime, wifiOnly: $wifiOnly, chargingOnly: $chargingOnly, backupOptions: $backupOptions)';
}


}

/// @nodoc
abstract mixin class _$AutoBackupSettingsCopyWith<$Res> implements $AutoBackupSettingsCopyWith<$Res> {
  factory _$AutoBackupSettingsCopyWith(_AutoBackupSettings value, $Res Function(_AutoBackupSettings) _then) = __$AutoBackupSettingsCopyWithImpl;
@override @useResult
$Res call({
 bool enabled, BackupFrequency frequency, int maxBackupCount, DateTime? lastBackupTime, DateTime? nextBackupTime, bool wifiOnly, bool chargingOnly, AutoBackupOptions? backupOptions
});


@override $AutoBackupOptionsCopyWith<$Res>? get backupOptions;

}
/// @nodoc
class __$AutoBackupSettingsCopyWithImpl<$Res>
    implements _$AutoBackupSettingsCopyWith<$Res> {
  __$AutoBackupSettingsCopyWithImpl(this._self, this._then);

  final _AutoBackupSettings _self;
  final $Res Function(_AutoBackupSettings) _then;

/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? enabled = null,Object? frequency = null,Object? maxBackupCount = null,Object? lastBackupTime = freezed,Object? nextBackupTime = freezed,Object? wifiOnly = null,Object? chargingOnly = null,Object? backupOptions = freezed,}) {
  return _then(_AutoBackupSettings(
enabled: null == enabled ? _self.enabled : enabled // ignore: cast_nullable_to_non_nullable
as bool,frequency: null == frequency ? _self.frequency : frequency // ignore: cast_nullable_to_non_nullable
as BackupFrequency,maxBackupCount: null == maxBackupCount ? _self.maxBackupCount : maxBackupCount // ignore: cast_nullable_to_non_nullable
as int,lastBackupTime: freezed == lastBackupTime ? _self.lastBackupTime : lastBackupTime // ignore: cast_nullable_to_non_nullable
as DateTime?,nextBackupTime: freezed == nextBackupTime ? _self.nextBackupTime : nextBackupTime // ignore: cast_nullable_to_non_nullable
as DateTime?,wifiOnly: null == wifiOnly ? _self.wifiOnly : wifiOnly // ignore: cast_nullable_to_non_nullable
as bool,chargingOnly: null == chargingOnly ? _self.chargingOnly : chargingOnly // ignore: cast_nullable_to_non_nullable
as bool,backupOptions: freezed == backupOptions ? _self.backupOptions : backupOptions // ignore: cast_nullable_to_non_nullable
as AutoBackupOptions?,
  ));
}

/// Create a copy of AutoBackupSettings
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AutoBackupOptionsCopyWith<$Res>? get backupOptions {
    if (_self.backupOptions == null) {
    return null;
  }

  return $AutoBackupOptionsCopyWith<$Res>(_self.backupOptions!, (value) {
    return _then(_self.copyWith(backupOptions: value));
  });
}
}


/// @nodoc
mixin _$AutoBackupOptions {

/// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
 bool get includeImages;/// æ˜¯å¦åŠ å¯†å¤‡ä»½
 bool get encrypt;/// åŠ å¯†å¯†ç 
 String? get password;/// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
 bool get compress;
/// Create a copy of AutoBackupOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AutoBackupOptionsCopyWith<AutoBackupOptions> get copyWith => _$AutoBackupOptionsCopyWithImpl<AutoBackupOptions>(this as AutoBackupOptions, _$identity);

  /// Serializes this AutoBackupOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AutoBackupOptions&&(identical(other.includeImages, includeImages) || other.includeImages == includeImages)&&(identical(other.encrypt, encrypt) || other.encrypt == encrypt)&&(identical(other.password, password) || other.password == password)&&(identical(other.compress, compress) || other.compress == compress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeImages,encrypt,password,compress);

@override
String toString() {
  return 'AutoBackupOptions(includeImages: $includeImages, encrypt: $encrypt, password: $password, compress: $compress)';
}


}

/// @nodoc
abstract mixin class $AutoBackupOptionsCopyWith<$Res>  {
  factory $AutoBackupOptionsCopyWith(AutoBackupOptions value, $Res Function(AutoBackupOptions) _then) = _$AutoBackupOptionsCopyWithImpl;
@useResult
$Res call({
 bool includeImages, bool encrypt, String? password, bool compress
});




}
/// @nodoc
class _$AutoBackupOptionsCopyWithImpl<$Res>
    implements $AutoBackupOptionsCopyWith<$Res> {
  _$AutoBackupOptionsCopyWithImpl(this._self, this._then);

  final AutoBackupOptions _self;
  final $Res Function(AutoBackupOptions) _then;

/// Create a copy of AutoBackupOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? includeImages = null,Object? encrypt = null,Object? password = freezed,Object? compress = null,}) {
  return _then(_self.copyWith(
includeImages: null == includeImages ? _self.includeImages : includeImages // ignore: cast_nullable_to_non_nullable
as bool,encrypt: null == encrypt ? _self.encrypt : encrypt // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,compress: null == compress ? _self.compress : compress // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _AutoBackupOptions implements AutoBackupOptions {
  const _AutoBackupOptions({this.includeImages = false, this.encrypt = false, this.password, this.compress = false});
  factory _AutoBackupOptions.fromJson(Map<String, dynamic> json) => _$AutoBackupOptionsFromJson(json);

/// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
@override@JsonKey() final  bool includeImages;
/// æ˜¯å¦åŠ å¯†å¤‡ä»½
@override@JsonKey() final  bool encrypt;
/// åŠ å¯†å¯†ç 
@override final  String? password;
/// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
@override@JsonKey() final  bool compress;

/// Create a copy of AutoBackupOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AutoBackupOptionsCopyWith<_AutoBackupOptions> get copyWith => __$AutoBackupOptionsCopyWithImpl<_AutoBackupOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AutoBackupOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AutoBackupOptions&&(identical(other.includeImages, includeImages) || other.includeImages == includeImages)&&(identical(other.encrypt, encrypt) || other.encrypt == encrypt)&&(identical(other.password, password) || other.password == password)&&(identical(other.compress, compress) || other.compress == compress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeImages,encrypt,password,compress);

@override
String toString() {
  return 'AutoBackupOptions(includeImages: $includeImages, encrypt: $encrypt, password: $password, compress: $compress)';
}


}

/// @nodoc
abstract mixin class _$AutoBackupOptionsCopyWith<$Res> implements $AutoBackupOptionsCopyWith<$Res> {
  factory _$AutoBackupOptionsCopyWith(_AutoBackupOptions value, $Res Function(_AutoBackupOptions) _then) = __$AutoBackupOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool includeImages, bool encrypt, String? password, bool compress
});




}
/// @nodoc
class __$AutoBackupOptionsCopyWithImpl<$Res>
    implements _$AutoBackupOptionsCopyWith<$Res> {
  __$AutoBackupOptionsCopyWithImpl(this._self, this._then);

  final _AutoBackupOptions _self;
  final $Res Function(_AutoBackupOptions) _then;

/// Create a copy of AutoBackupOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? includeImages = null,Object? encrypt = null,Object? password = freezed,Object? compress = null,}) {
  return _then(_AutoBackupOptions(
includeImages: null == includeImages ? _self.includeImages : includeImages // ignore: cast_nullable_to_non_nullable
as bool,encrypt: null == encrypt ? _self.encrypt : encrypt // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,compress: null == compress ? _self.compress : compress // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auto_backup_settings.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_AutoBackupSettings _$AutoBackupSettingsFromJson(Map<String, dynamic> json) =>
    _AutoBackupSettings(
      enabled: json['enabled'] as bool? ?? false,
      frequency:
          $enumDecodeNullable(_$BackupFrequencyEnumMap, json['frequency']) ??
          BackupFrequency.weekly,
      maxBackupCount: (json['maxBackupCount'] as num?)?.toInt() ?? 5,
      lastBackupTime: json['lastBackupTime'] == null
          ? null
          : DateTime.parse(json['lastBackupTime'] as String),
      nextBackupTime: json['nextBackupTime'] == null
          ? null
          : DateTime.parse(json['nextBackupTime'] as String),
      wifiOnly: json['wifiOnly'] as bool? ?? true,
      chargingOnly: json['chargingOnly'] as bool? ?? false,
      backupOptions: json['backupOptions'] == null
          ? null
          : AutoBackupOptions.fromJson(
              json['backupOptions'] as Map<String, dynamic>,
            ),
    );

Map<String, dynamic> _$AutoBackupSettingsToJson(_AutoBackupSettings instance) =>
    <String, dynamic>{
      'enabled': instance.enabled,
      'frequency': _$BackupFrequencyEnumMap[instance.frequency]!,
      'maxBackupCount': instance.maxBackupCount,
      'lastBackupTime': instance.lastBackupTime?.toIso8601String(),
      'nextBackupTime': instance.nextBackupTime?.toIso8601String(),
      'wifiOnly': instance.wifiOnly,
      'chargingOnly': instance.chargingOnly,
      'backupOptions': instance.backupOptions,
    };

const _$BackupFrequencyEnumMap = {
  BackupFrequency.daily: 'daily',
  BackupFrequency.weekly: 'weekly',
  BackupFrequency.monthly: 'monthly',
};

_AutoBackupOptions _$AutoBackupOptionsFromJson(Map<String, dynamic> json) =>
    _AutoBackupOptions(
      includeImages: json['includeImages'] as bool? ?? false,
      encrypt: json['encrypt'] as bool? ?? false,
      password: json['password'] as String?,
      compress: json['compress'] as bool? ?? false,
    );

Map<String, dynamic> _$AutoBackupOptionsToJson(_AutoBackupOptions instance) =>
    <String, dynamic>{
      'includeImages': instance.includeImages,
      'encrypt': instance.encrypt,
      'password': instance.password,
      'compress': instance.compress,
    };
import 'package:freezed_annotation/freezed_annotation.dart';
import 'backup_metadata.dart';

part 'backup_data.freezed.dart';
part 'backup_data.g.dart';

/// å®Œæ•´çš„å¤‡ä»½æ•°æ®ç»“æ?
@freezed
abstract class BackupData with _$BackupData {
  const factory BackupData({
    /// å¤‡ä»½å…ƒæ•°æ?
    required BackupMetadata metadata,
    /// å„è¡¨çš„æ•°æ®ï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
    required Map<String, List<Map<String, dynamic>>> tables,
    /// åº”ç”¨è®¾ç½®æ•°æ®ï¼ˆå¯é€‰ï¼‰
    Map<String, dynamic>? settings,
  }) = _BackupData;

  factory BackupData.fromJson(Map<String, dynamic> json) =>
      _$BackupDataFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BackupData {

/// å¤‡ä»½å…ƒæ•°æ? BackupMetadata get metadata;/// å„è¡¨çš„æ•°æ®ï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
 Map<String, List<Map<String, dynamic>>> get tables;/// åº”ç”¨è®¾ç½®æ•°æ®ï¼ˆå¯é€‰ï¼‰
 Map<String, dynamic>? get settings;
/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupDataCopyWith<BackupData> get copyWith => _$BackupDataCopyWithImpl<BackupData>(this as BackupData, _$identity);

  /// Serializes this BackupData to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupData&&(identical(other.metadata, metadata) || other.metadata == metadata)&&const DeepCollectionEquality().equals(other.tables, tables)&&const DeepCollectionEquality().equals(other.settings, settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,metadata,const DeepCollectionEquality().hash(tables),const DeepCollectionEquality().hash(settings));

@override
String toString() {
  return 'BackupData(metadata: $metadata, tables: $tables, settings: $settings)';
}


}

/// @nodoc
abstract mixin class $BackupDataCopyWith<$Res>  {
  factory $BackupDataCopyWith(BackupData value, $Res Function(BackupData) _then) = _$BackupDataCopyWithImpl;
@useResult
$Res call({
 BackupMetadata metadata, Map<String, List<Map<String, dynamic>>> tables, Map<String, dynamic>? settings
});


$BackupMetadataCopyWith<$Res> get metadata;

}
/// @nodoc
class _$BackupDataCopyWithImpl<$Res>
    implements $BackupDataCopyWith<$Res> {
  _$BackupDataCopyWithImpl(this._self, this._then);

  final BackupData _self;
  final $Res Function(BackupData) _then;

/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? metadata = null,Object? tables = null,Object? settings = freezed,}) {
  return _then(_self.copyWith(
metadata: null == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata,tables: null == tables ? _self.tables : tables // ignore: cast_nullable_to_non_nullable
as Map<String, List<Map<String, dynamic>>>,settings: freezed == settings ? _self.settings : settings // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}
/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res> get metadata {
  
  return $BackupMetadataCopyWith<$Res>(_self.metadata, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _BackupData implements BackupData {
  const _BackupData({required this.metadata, required final  Map<String, List<Map<String, dynamic>>> tables, final  Map<String, dynamic>? settings}): _tables = tables,_settings = settings;
  factory _BackupData.fromJson(Map<String, dynamic> json) => _$BackupDataFromJson(json);

/// å¤‡ä»½å…ƒæ•°æ?@override final  BackupMetadata metadata;
/// å„è¡¨çš„æ•°æ®ï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
 final  Map<String, List<Map<String, dynamic>>> _tables;
/// å„è¡¨çš„æ•°æ®ï¼Œé”®ä¸ºè¡¨åï¼Œå€¼ä¸ºè®°å½•åˆ—è¡¨
@override Map<String, List<Map<String, dynamic>>> get tables {
  if (_tables is EqualUnmodifiableMapView) return _tables;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tables);
}

/// åº”ç”¨è®¾ç½®æ•°æ®ï¼ˆå¯é€‰ï¼‰
 final  Map<String, dynamic>? _settings;
/// åº”ç”¨è®¾ç½®æ•°æ®ï¼ˆå¯é€‰ï¼‰
@override Map<String, dynamic>? get settings {
  final value = _settings;
  if (value == null) return null;
  if (_settings is EqualUnmodifiableMapView) return _settings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupDataCopyWith<_BackupData> get copyWith => __$BackupDataCopyWithImpl<_BackupData>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BackupDataToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupData&&(identical(other.metadata, metadata) || other.metadata == metadata)&&const DeepCollectionEquality().equals(other._tables, _tables)&&const DeepCollectionEquality().equals(other._settings, _settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,metadata,const DeepCollectionEquality().hash(_tables),const DeepCollectionEquality().hash(_settings));

@override
String toString() {
  return 'BackupData(metadata: $metadata, tables: $tables, settings: $settings)';
}


}

/// @nodoc
abstract mixin class _$BackupDataCopyWith<$Res> implements $BackupDataCopyWith<$Res> {
  factory _$BackupDataCopyWith(_BackupData value, $Res Function(_BackupData) _then) = __$BackupDataCopyWithImpl;
@override @useResult
$Res call({
 BackupMetadata metadata, Map<String, List<Map<String, dynamic>>> tables, Map<String, dynamic>? settings
});


@override $BackupMetadataCopyWith<$Res> get metadata;

}
/// @nodoc
class __$BackupDataCopyWithImpl<$Res>
    implements _$BackupDataCopyWith<$Res> {
  __$BackupDataCopyWithImpl(this._self, this._then);

  final _BackupData _self;
  final $Res Function(_BackupData) _then;

/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? metadata = null,Object? tables = null,Object? settings = freezed,}) {
  return _then(_BackupData(
metadata: null == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata,tables: null == tables ? _self._tables : tables // ignore: cast_nullable_to_non_nullable
as Map<String, List<Map<String, dynamic>>>,settings: freezed == settings ? _self._settings : settings // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

/// Create a copy of BackupData
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res> get metadata {
  
  return $BackupMetadataCopyWith<$Res>(_self.metadata, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'backup_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BackupData _$BackupDataFromJson(Map<String, dynamic> json) => _BackupData(
  metadata: BackupMetadata.fromJson(json['metadata'] as Map<String, dynamic>),
  tables: (json['tables'] as Map<String, dynamic>).map(
    (k, e) => MapEntry(
      k,
      (e as List<dynamic>).map((e) => e as Map<String, dynamic>).toList(),
    ),
  ),
  settings: json['settings'] as Map<String, dynamic>?,
);

Map<String, dynamic> _$BackupDataToJson(_BackupData instance) =>
    <String, dynamic>{
      'metadata': instance.metadata,
      'tables': instance.tables,
      'settings': instance.settings,
    };
/// å¤‡ä»½å’Œæ¢å¤æ“ä½œä¸­å¯èƒ½å‡ºç°çš„é”™è¯¯ç±»å?
enum BackupErrorType {
  /// æ–‡ä»¶ç³»ç»Ÿç›¸å…³é”™è¯¯ï¼ˆè¯»å†™æƒé™ã€ç£ç›˜ç©ºé—´ç­‰ï¼?
  fileSystemError,
  
  /// æ•°æ®åº“æ“ä½œé”™è¯?
  databaseError,
  
  /// æ•°æ®åºåˆ—åŒ?ååºåˆ—åŒ–é”™è¯¯
  serializationError,
  
  /// æ•°æ®åŠ å¯†/è§£å¯†é”™è¯¯
  encryptionError,
  
  /// æ•°æ®éªŒè¯é”™è¯¯ï¼ˆæ ¼å¼ã€å®Œæ•´æ€§ç­‰ï¼?
  validationError,
  
  /// ç£ç›˜ç©ºé—´ä¸è¶³
  insufficientSpace,
  
  /// æƒé™è¢«æ‹’ç»?
  permissionDenied,
  
  /// æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®
  fileNotFound,
  
  /// å¤‡ä»½æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ?
  unsupportedFormat,
  
  /// å¯†ç é”™è¯¯
  incorrectPassword,
  
  /// æ“ä½œè¢«ç”¨æˆ·å–æ¶?
  operationCancelled,
  
  /// ç½‘ç»œç›¸å…³é”™è¯¯
  networkError,
  
  /// å‹ç¼©/è§£å‹é”™è¯¯
  compressionError,
  
  /// æœªçŸ¥é”™è¯¯
  unknown,
}
import 'package:freezed_annotation/freezed_annotation.dart';
import 'backup_error_type.dart';

part 'backup_exception.freezed.dart';

/// å¤‡ä»½å’Œæ¢å¤æ“ä½œä¸­çš„å¼‚å¸¸ç±»
@freezed
abstract class BackupException with _$BackupException implements Exception {
  const factory BackupException({
    /// é”™è¯¯ç±»å‹
    required BackupErrorType type,
    /// é”™è¯¯æ¶ˆæ¯
    required String message,
    /// åŸå§‹é”™è¯¯å¯¹è±¡
    Object? originalError,
    /// å †æ ˆè·Ÿè¸ª
    StackTrace? stackTrace,
    /// é”™è¯¯ä»£ç ï¼ˆå¯é€‰ï¼‰
    String? errorCode,
    /// é¢å¤–çš„é”™è¯¯è¯¦æƒ?
    Map<String, dynamic>? details,
  }) = _BackupException;

  /// åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿé”™è¯¯
  factory BackupException.fileSystem(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.fileSystemError,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºæ•°æ®åº“é”™è¯?
  factory BackupException.database(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.databaseError,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºåºåˆ—åŒ–é”™è¯?
  factory BackupException.serialization(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.serializationError,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºåŠ å¯†é”™è¯¯
  factory BackupException.encryption(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.encryptionError,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºéªŒè¯é”™è¯¯
  factory BackupException.validation(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.validationError,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºæƒé™é”™è¯¯
  factory BackupException.permissionDenied(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.permissionDenied,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );

  /// åˆ›å»ºç£ç›˜ç©ºé—´ä¸è¶³é”™è¯¯
  factory BackupException.insufficientSpace(
    String message, {
    Object? originalError,
    StackTrace? stackTrace,
  }) =>
      BackupException(
        type: BackupErrorType.insufficientSpace,
        message: message,
        originalError: originalError,
        stackTrace: stackTrace,
      );
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$BackupException {

/// é”™è¯¯ç±»å‹
 BackupErrorType get type;/// é”™è¯¯æ¶ˆæ¯
 String get message;/// åŸå§‹é”™è¯¯å¯¹è±¡
 Object? get originalError;/// å †æ ˆè·Ÿè¸ª
 StackTrace? get stackTrace;/// é”™è¯¯ä»£ç ï¼ˆå¯é€‰ï¼‰
 String? get errorCode;/// é¢å¤–çš„é”™è¯¯è¯¦æƒ? Map<String, dynamic>? get details;
/// Create a copy of BackupException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupExceptionCopyWith<BackupException> get copyWith => _$BackupExceptionCopyWithImpl<BackupException>(this as BackupException, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupException&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.originalError, originalError)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace)&&(identical(other.errorCode, errorCode) || other.errorCode == errorCode)&&const DeepCollectionEquality().equals(other.details, details));
}


@override
int get hashCode => Object.hash(runtimeType,type,message,const DeepCollectionEquality().hash(originalError),stackTrace,errorCode,const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'BackupException(type: $type, message: $message, originalError: $originalError, stackTrace: $stackTrace, errorCode: $errorCode, details: $details)';
}


}

/// @nodoc
abstract mixin class $BackupExceptionCopyWith<$Res>  {
  factory $BackupExceptionCopyWith(BackupException value, $Res Function(BackupException) _then) = _$BackupExceptionCopyWithImpl;
@useResult
$Res call({
 BackupErrorType type, String message, Object? originalError, StackTrace? stackTrace, String? errorCode, Map<String, dynamic>? details
});




}
/// @nodoc
class _$BackupExceptionCopyWithImpl<$Res>
    implements $BackupExceptionCopyWith<$Res> {
  _$BackupExceptionCopyWithImpl(this._self, this._then);

  final BackupException _self;
  final $Res Function(BackupException) _then;

/// Create a copy of BackupException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? message = null,Object? originalError = freezed,Object? stackTrace = freezed,Object? errorCode = freezed,Object? details = freezed,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as BackupErrorType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,originalError: freezed == originalError ? _self.originalError : originalError ,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,errorCode: freezed == errorCode ? _self.errorCode : errorCode // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc


class _BackupException implements BackupException {
  const _BackupException({required this.type, required this.message, this.originalError, this.stackTrace, this.errorCode, final  Map<String, dynamic>? details}): _details = details;
  

/// é”™è¯¯ç±»å‹
@override final  BackupErrorType type;
/// é”™è¯¯æ¶ˆæ¯
@override final  String message;
/// åŸå§‹é”™è¯¯å¯¹è±¡
@override final  Object? originalError;
/// å †æ ˆè·Ÿè¸ª
@override final  StackTrace? stackTrace;
/// é”™è¯¯ä»£ç ï¼ˆå¯é€‰ï¼‰
@override final  String? errorCode;
/// é¢å¤–çš„é”™è¯¯è¯¦æƒ? final  Map<String, dynamic>? _details;
/// é¢å¤–çš„é”™è¯¯è¯¦æƒ?@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of BackupException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupExceptionCopyWith<_BackupException> get copyWith => __$BackupExceptionCopyWithImpl<_BackupException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupException&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.originalError, originalError)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace)&&(identical(other.errorCode, errorCode) || other.errorCode == errorCode)&&const DeepCollectionEquality().equals(other._details, _details));
}


@override
int get hashCode => Object.hash(runtimeType,type,message,const DeepCollectionEquality().hash(originalError),stackTrace,errorCode,const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'BackupException(type: $type, message: $message, originalError: $originalError, stackTrace: $stackTrace, errorCode: $errorCode, details: $details)';
}


}

/// @nodoc
abstract mixin class _$BackupExceptionCopyWith<$Res> implements $BackupExceptionCopyWith<$Res> {
  factory _$BackupExceptionCopyWith(_BackupException value, $Res Function(_BackupException) _then) = __$BackupExceptionCopyWithImpl;
@override @useResult
$Res call({
 BackupErrorType type, String message, Object? originalError, StackTrace? stackTrace, String? errorCode, Map<String, dynamic>? details
});




}
/// @nodoc
class __$BackupExceptionCopyWithImpl<$Res>
    implements _$BackupExceptionCopyWith<$Res> {
  __$BackupExceptionCopyWithImpl(this._self, this._then);

  final _BackupException _self;
  final $Res Function(_BackupException) _then;

/// Create a copy of BackupException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? message = null,Object? originalError = freezed,Object? stackTrace = freezed,Object? errorCode = freezed,Object? details = freezed,}) {
  return _then(_BackupException(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as BackupErrorType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,originalError: freezed == originalError ? _self.originalError : originalError ,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,errorCode: freezed == errorCode ? _self.errorCode : errorCode // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}

// dart format on
import 'package:freezed_annotation/freezed_annotation.dart';

part 'backup_metadata.freezed.dart';
part 'backup_metadata.g.dart';

/// å¤‡ä»½æ–‡ä»¶çš„å…ƒæ•°æ®ä¿¡æ¯
@freezed
abstract class BackupMetadata with _$BackupMetadata {
  const factory BackupMetadata({
    /// å¤‡ä»½æ–‡ä»¶çš„å”¯ä¸€æ ‡è¯†ç¬?
    required String id,
    /// å¤‡ä»½æ–‡ä»¶å?
    required String fileName,
    /// åˆ›å»ºæ—¶é—´
    required DateTime createdAt,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    required int fileSize,
    /// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
    required String version,
    /// å„è¡¨çš„è®°å½•æ•°é‡ç»Ÿè®?
    required Map<String, int> tableCounts,
    /// æ•°æ®æ ¡éªŒå’?
    required String checksum,
    /// æ˜¯å¦åŠ å¯†
    @Default(false) bool isEncrypted,
    /// å¤‡ä»½æè¿°
    String? description,
    /// åº”ç”¨ç‰ˆæœ¬
    String? appVersion,
    /// æ•°æ®åº“æ¶æ„ç‰ˆæœ?
    int? schemaVersion,
  }) = _BackupMetadata;

  factory BackupMetadata.fromJson(Map<String, dynamic> json) =>
      _$BackupMetadataFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_metadata.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BackupMetadata {

/// å¤‡ä»½æ–‡ä»¶çš„å”¯ä¸€æ ‡è¯†ç¬? String get id;/// å¤‡ä»½æ–‡ä»¶å? String get fileName;/// åˆ›å»ºæ—¶é—´
 DateTime get createdAt;/// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 int get fileSize;/// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
 String get version;/// å„è¡¨çš„è®°å½•æ•°é‡ç»Ÿè®? Map<String, int> get tableCounts;/// æ•°æ®æ ¡éªŒå’? String get checksum;/// æ˜¯å¦åŠ å¯†
 bool get isEncrypted;/// å¤‡ä»½æè¿°
 String? get description;/// åº”ç”¨ç‰ˆæœ¬
 String? get appVersion;/// æ•°æ®åº“æ¶æ„ç‰ˆæœ? int? get schemaVersion;
/// Create a copy of BackupMetadata
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<BackupMetadata> get copyWith => _$BackupMetadataCopyWithImpl<BackupMetadata>(this as BackupMetadata, _$identity);

  /// Serializes this BackupMetadata to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupMetadata&&(identical(other.id, id) || other.id == id)&&(identical(other.fileName, fileName) || other.fileName == fileName)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.fileSize, fileSize) || other.fileSize == fileSize)&&(identical(other.version, version) || other.version == version)&&const DeepCollectionEquality().equals(other.tableCounts, tableCounts)&&(identical(other.checksum, checksum) || other.checksum == checksum)&&(identical(other.isEncrypted, isEncrypted) || other.isEncrypted == isEncrypted)&&(identical(other.description, description) || other.description == description)&&(identical(other.appVersion, appVersion) || other.appVersion == appVersion)&&(identical(other.schemaVersion, schemaVersion) || other.schemaVersion == schemaVersion));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,fileName,createdAt,fileSize,version,const DeepCollectionEquality().hash(tableCounts),checksum,isEncrypted,description,appVersion,schemaVersion);

@override
String toString() {
  return 'BackupMetadata(id: $id, fileName: $fileName, createdAt: $createdAt, fileSize: $fileSize, version: $version, tableCounts: $tableCounts, checksum: $checksum, isEncrypted: $isEncrypted, description: $description, appVersion: $appVersion, schemaVersion: $schemaVersion)';
}


}

/// @nodoc
abstract mixin class $BackupMetadataCopyWith<$Res>  {
  factory $BackupMetadataCopyWith(BackupMetadata value, $Res Function(BackupMetadata) _then) = _$BackupMetadataCopyWithImpl;
@useResult
$Res call({
 String id, String fileName, DateTime createdAt, int fileSize, String version, Map<String, int> tableCounts, String checksum, bool isEncrypted, String? description, String? appVersion, int? schemaVersion
});




}
/// @nodoc
class _$BackupMetadataCopyWithImpl<$Res>
    implements $BackupMetadataCopyWith<$Res> {
  _$BackupMetadataCopyWithImpl(this._self, this._then);

  final BackupMetadata _self;
  final $Res Function(BackupMetadata) _then;

/// Create a copy of BackupMetadata
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? fileName = null,Object? createdAt = null,Object? fileSize = null,Object? version = null,Object? tableCounts = null,Object? checksum = null,Object? isEncrypted = null,Object? description = freezed,Object? appVersion = freezed,Object? schemaVersion = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,fileName: null == fileName ? _self.fileName : fileName // ignore: cast_nullable_to_non_nullable
as String,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,fileSize: null == fileSize ? _self.fileSize : fileSize // ignore: cast_nullable_to_non_nullable
as int,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String,tableCounts: null == tableCounts ? _self.tableCounts : tableCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,checksum: null == checksum ? _self.checksum : checksum // ignore: cast_nullable_to_non_nullable
as String,isEncrypted: null == isEncrypted ? _self.isEncrypted : isEncrypted // ignore: cast_nullable_to_non_nullable
as bool,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,appVersion: freezed == appVersion ? _self.appVersion : appVersion // ignore: cast_nullable_to_non_nullable
as String?,schemaVersion: freezed == schemaVersion ? _self.schemaVersion : schemaVersion // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _BackupMetadata implements BackupMetadata {
  const _BackupMetadata({required this.id, required this.fileName, required this.createdAt, required this.fileSize, required this.version, required final  Map<String, int> tableCounts, required this.checksum, this.isEncrypted = false, this.description, this.appVersion, this.schemaVersion}): _tableCounts = tableCounts;
  factory _BackupMetadata.fromJson(Map<String, dynamic> json) => _$BackupMetadataFromJson(json);

/// å¤‡ä»½æ–‡ä»¶çš„å”¯ä¸€æ ‡è¯†ç¬?@override final  String id;
/// å¤‡ä»½æ–‡ä»¶å?@override final  String fileName;
/// åˆ›å»ºæ—¶é—´
@override final  DateTime createdAt;
/// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
@override final  int fileSize;
/// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
@override final  String version;
/// å„è¡¨çš„è®°å½•æ•°é‡ç»Ÿè®? final  Map<String, int> _tableCounts;
/// å„è¡¨çš„è®°å½•æ•°é‡ç»Ÿè®?@override Map<String, int> get tableCounts {
  if (_tableCounts is EqualUnmodifiableMapView) return _tableCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableCounts);
}

/// æ•°æ®æ ¡éªŒå’?@override final  String checksum;
/// æ˜¯å¦åŠ å¯†
@override@JsonKey() final  bool isEncrypted;
/// å¤‡ä»½æè¿°
@override final  String? description;
/// åº”ç”¨ç‰ˆæœ¬
@override final  String? appVersion;
/// æ•°æ®åº“æ¶æ„ç‰ˆæœ?@override final  int? schemaVersion;

/// Create a copy of BackupMetadata
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupMetadataCopyWith<_BackupMetadata> get copyWith => __$BackupMetadataCopyWithImpl<_BackupMetadata>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BackupMetadataToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupMetadata&&(identical(other.id, id) || other.id == id)&&(identical(other.fileName, fileName) || other.fileName == fileName)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.fileSize, fileSize) || other.fileSize == fileSize)&&(identical(other.version, version) || other.version == version)&&const DeepCollectionEquality().equals(other._tableCounts, _tableCounts)&&(identical(other.checksum, checksum) || other.checksum == checksum)&&(identical(other.isEncrypted, isEncrypted) || other.isEncrypted == isEncrypted)&&(identical(other.description, description) || other.description == description)&&(identical(other.appVersion, appVersion) || other.appVersion == appVersion)&&(identical(other.schemaVersion, schemaVersion) || other.schemaVersion == schemaVersion));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,fileName,createdAt,fileSize,version,const DeepCollectionEquality().hash(_tableCounts),checksum,isEncrypted,description,appVersion,schemaVersion);

@override
String toString() {
  return 'BackupMetadata(id: $id, fileName: $fileName, createdAt: $createdAt, fileSize: $fileSize, version: $version, tableCounts: $tableCounts, checksum: $checksum, isEncrypted: $isEncrypted, description: $description, appVersion: $appVersion, schemaVersion: $schemaVersion)';
}


}

/// @nodoc
abstract mixin class _$BackupMetadataCopyWith<$Res> implements $BackupMetadataCopyWith<$Res> {
  factory _$BackupMetadataCopyWith(_BackupMetadata value, $Res Function(_BackupMetadata) _then) = __$BackupMetadataCopyWithImpl;
@override @useResult
$Res call({
 String id, String fileName, DateTime createdAt, int fileSize, String version, Map<String, int> tableCounts, String checksum, bool isEncrypted, String? description, String? appVersion, int? schemaVersion
});




}
/// @nodoc
class __$BackupMetadataCopyWithImpl<$Res>
    implements _$BackupMetadataCopyWith<$Res> {
  __$BackupMetadataCopyWithImpl(this._self, this._then);

  final _BackupMetadata _self;
  final $Res Function(_BackupMetadata) _then;

/// Create a copy of BackupMetadata
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? fileName = null,Object? createdAt = null,Object? fileSize = null,Object? version = null,Object? tableCounts = null,Object? checksum = null,Object? isEncrypted = null,Object? description = freezed,Object? appVersion = freezed,Object? schemaVersion = freezed,}) {
  return _then(_BackupMetadata(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,fileName: null == fileName ? _self.fileName : fileName // ignore: cast_nullable_to_non_nullable
as String,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,fileSize: null == fileSize ? _self.fileSize : fileSize // ignore: cast_nullable_to_non_nullable
as int,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String,tableCounts: null == tableCounts ? _self._tableCounts : tableCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,checksum: null == checksum ? _self.checksum : checksum // ignore: cast_nullable_to_non_nullable
as String,isEncrypted: null == isEncrypted ? _self.isEncrypted : isEncrypted // ignore: cast_nullable_to_non_nullable
as bool,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,appVersion: freezed == appVersion ? _self.appVersion : appVersion // ignore: cast_nullable_to_non_nullable
as String?,schemaVersion: freezed == schemaVersion ? _self.schemaVersion : schemaVersion // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'backup_metadata.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BackupMetadata _$BackupMetadataFromJson(Map<String, dynamic> json) =>
    _BackupMetadata(
      id: json['id'] as String,
      fileName: json['fileName'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      fileSize: (json['fileSize'] as num).toInt(),
      version: json['version'] as String,
      tableCounts: Map<String, int>.from(json['tableCounts'] as Map),
      checksum: json['checksum'] as String,
      isEncrypted: json['isEncrypted'] as bool? ?? false,
      description: json['description'] as String?,
      appVersion: json['appVersion'] as String?,
      schemaVersion: (json['schemaVersion'] as num?)?.toInt(),
    );

Map<String, dynamic> _$BackupMetadataToJson(_BackupMetadata instance) =>
    <String, dynamic>{
      'id': instance.id,
      'fileName': instance.fileName,
      'createdAt': instance.createdAt.toIso8601String(),
      'fileSize': instance.fileSize,
      'version': instance.version,
      'tableCounts': instance.tableCounts,
      'checksum': instance.checksum,
      'isEncrypted': instance.isEncrypted,
      'description': instance.description,
      'appVersion': instance.appVersion,
      'schemaVersion': instance.schemaVersion,
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'backup_options.freezed.dart';
part 'backup_options.g.dart';

/// å¤‡ä»½é€‰é¡¹é…ç½®
@freezed
abstract class BackupOptions with _$BackupOptions {
  const factory BackupOptions({
    /// è‡ªå®šä¹‰å¤‡ä»½åç§?
    String? customName,
    /// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
    @Default(false) bool includeImages,
    /// æ˜¯å¦åŠ å¯†å¤‡ä»½
    @Default(false) bool encrypt,
    /// åŠ å¯†å¯†ç 
    String? password,
    /// è¦åŒ…å«çš„è¡¨ååˆ—è¡¨ï¼ˆä¸ºç©ºåˆ™åŒ…å«æ‰€æœ‰è¡¨ï¼?
    List<String>? includeTables,
    /// è¦æ’é™¤çš„è¡¨ååˆ—è¡¨
    @Default([]) List<String> excludeTables,
    /// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
    @Default(false) bool compress,
    /// å¤‡ä»½æè¿°
    String? description,
  }) = _BackupOptions;

  factory BackupOptions.fromJson(Map<String, dynamic> json) =>
      _$BackupOptionsFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_options.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BackupOptions {

/// è‡ªå®šä¹‰å¤‡ä»½åç§? String? get customName;/// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
 bool get includeImages;/// æ˜¯å¦åŠ å¯†å¤‡ä»½
 bool get encrypt;/// åŠ å¯†å¯†ç 
 String? get password;/// è¦åŒ…å«çš„è¡¨ååˆ—è¡¨ï¼ˆä¸ºç©ºåˆ™åŒ…å«æ‰€æœ‰è¡¨ï¼? List<String>? get includeTables;/// è¦æ’é™¤çš„è¡¨ååˆ—è¡¨
 List<String> get excludeTables;/// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
 bool get compress;/// å¤‡ä»½æè¿°
 String? get description;
/// Create a copy of BackupOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupOptionsCopyWith<BackupOptions> get copyWith => _$BackupOptionsCopyWithImpl<BackupOptions>(this as BackupOptions, _$identity);

  /// Serializes this BackupOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupOptions&&(identical(other.customName, customName) || other.customName == customName)&&(identical(other.includeImages, includeImages) || other.includeImages == includeImages)&&(identical(other.encrypt, encrypt) || other.encrypt == encrypt)&&(identical(other.password, password) || other.password == password)&&const DeepCollectionEquality().equals(other.includeTables, includeTables)&&const DeepCollectionEquality().equals(other.excludeTables, excludeTables)&&(identical(other.compress, compress) || other.compress == compress)&&(identical(other.description, description) || other.description == description));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,customName,includeImages,encrypt,password,const DeepCollectionEquality().hash(includeTables),const DeepCollectionEquality().hash(excludeTables),compress,description);

@override
String toString() {
  return 'BackupOptions(customName: $customName, includeImages: $includeImages, encrypt: $encrypt, password: $password, includeTables: $includeTables, excludeTables: $excludeTables, compress: $compress, description: $description)';
}


}

/// @nodoc
abstract mixin class $BackupOptionsCopyWith<$Res>  {
  factory $BackupOptionsCopyWith(BackupOptions value, $Res Function(BackupOptions) _then) = _$BackupOptionsCopyWithImpl;
@useResult
$Res call({
 String? customName, bool includeImages, bool encrypt, String? password, List<String>? includeTables, List<String> excludeTables, bool compress, String? description
});




}
/// @nodoc
class _$BackupOptionsCopyWithImpl<$Res>
    implements $BackupOptionsCopyWith<$Res> {
  _$BackupOptionsCopyWithImpl(this._self, this._then);

  final BackupOptions _self;
  final $Res Function(BackupOptions) _then;

/// Create a copy of BackupOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? customName = freezed,Object? includeImages = null,Object? encrypt = null,Object? password = freezed,Object? includeTables = freezed,Object? excludeTables = null,Object? compress = null,Object? description = freezed,}) {
  return _then(_self.copyWith(
customName: freezed == customName ? _self.customName : customName // ignore: cast_nullable_to_non_nullable
as String?,includeImages: null == includeImages ? _self.includeImages : includeImages // ignore: cast_nullable_to_non_nullable
as bool,encrypt: null == encrypt ? _self.encrypt : encrypt // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,includeTables: freezed == includeTables ? _self.includeTables : includeTables // ignore: cast_nullable_to_non_nullable
as List<String>?,excludeTables: null == excludeTables ? _self.excludeTables : excludeTables // ignore: cast_nullable_to_non_nullable
as List<String>,compress: null == compress ? _self.compress : compress // ignore: cast_nullable_to_non_nullable
as bool,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _BackupOptions implements BackupOptions {
  const _BackupOptions({this.customName, this.includeImages = false, this.encrypt = false, this.password, final  List<String>? includeTables, final  List<String> excludeTables = const [], this.compress = false, this.description}): _includeTables = includeTables,_excludeTables = excludeTables;
  factory _BackupOptions.fromJson(Map<String, dynamic> json) => _$BackupOptionsFromJson(json);

/// è‡ªå®šä¹‰å¤‡ä»½åç§?@override final  String? customName;
/// æ˜¯å¦åŒ…å«å›¾ç‰‡æ–‡ä»¶
@override@JsonKey() final  bool includeImages;
/// æ˜¯å¦åŠ å¯†å¤‡ä»½
@override@JsonKey() final  bool encrypt;
/// åŠ å¯†å¯†ç 
@override final  String? password;
/// è¦åŒ…å«çš„è¡¨ååˆ—è¡¨ï¼ˆä¸ºç©ºåˆ™åŒ…å«æ‰€æœ‰è¡¨ï¼? final  List<String>? _includeTables;
/// è¦åŒ…å«çš„è¡¨ååˆ—è¡¨ï¼ˆä¸ºç©ºåˆ™åŒ…å«æ‰€æœ‰è¡¨ï¼?@override List<String>? get includeTables {
  final value = _includeTables;
  if (value == null) return null;
  if (_includeTables is EqualUnmodifiableListView) return _includeTables;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// è¦æ’é™¤çš„è¡¨ååˆ—è¡¨
 final  List<String> _excludeTables;
/// è¦æ’é™¤çš„è¡¨ååˆ—è¡¨
@override@JsonKey() List<String> get excludeTables {
  if (_excludeTables is EqualUnmodifiableListView) return _excludeTables;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_excludeTables);
}

/// æ˜¯å¦å‹ç¼©å¤‡ä»½æ–‡ä»¶
@override@JsonKey() final  bool compress;
/// å¤‡ä»½æè¿°
@override final  String? description;

/// Create a copy of BackupOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupOptionsCopyWith<_BackupOptions> get copyWith => __$BackupOptionsCopyWithImpl<_BackupOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BackupOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupOptions&&(identical(other.customName, customName) || other.customName == customName)&&(identical(other.includeImages, includeImages) || other.includeImages == includeImages)&&(identical(other.encrypt, encrypt) || other.encrypt == encrypt)&&(identical(other.password, password) || other.password == password)&&const DeepCollectionEquality().equals(other._includeTables, _includeTables)&&const DeepCollectionEquality().equals(other._excludeTables, _excludeTables)&&(identical(other.compress, compress) || other.compress == compress)&&(identical(other.description, description) || other.description == description));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,customName,includeImages,encrypt,password,const DeepCollectionEquality().hash(_includeTables),const DeepCollectionEquality().hash(_excludeTables),compress,description);

@override
String toString() {
  return 'BackupOptions(customName: $customName, includeImages: $includeImages, encrypt: $encrypt, password: $password, includeTables: $includeTables, excludeTables: $excludeTables, compress: $compress, description: $description)';
}


}

/// @nodoc
abstract mixin class _$BackupOptionsCopyWith<$Res> implements $BackupOptionsCopyWith<$Res> {
  factory _$BackupOptionsCopyWith(_BackupOptions value, $Res Function(_BackupOptions) _then) = __$BackupOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? customName, bool includeImages, bool encrypt, String? password, List<String>? includeTables, List<String> excludeTables, bool compress, String? description
});




}
/// @nodoc
class __$BackupOptionsCopyWithImpl<$Res>
    implements _$BackupOptionsCopyWith<$Res> {
  __$BackupOptionsCopyWithImpl(this._self, this._then);

  final _BackupOptions _self;
  final $Res Function(_BackupOptions) _then;

/// Create a copy of BackupOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? customName = freezed,Object? includeImages = null,Object? encrypt = null,Object? password = freezed,Object? includeTables = freezed,Object? excludeTables = null,Object? compress = null,Object? description = freezed,}) {
  return _then(_BackupOptions(
customName: freezed == customName ? _self.customName : customName // ignore: cast_nullable_to_non_nullable
as String?,includeImages: null == includeImages ? _self.includeImages : includeImages // ignore: cast_nullable_to_non_nullable
as bool,encrypt: null == encrypt ? _self.encrypt : encrypt // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,includeTables: freezed == includeTables ? _self._includeTables : includeTables // ignore: cast_nullable_to_non_nullable
as List<String>?,excludeTables: null == excludeTables ? _self._excludeTables : excludeTables // ignore: cast_nullable_to_non_nullable
as List<String>,compress: null == compress ? _self.compress : compress // ignore: cast_nullable_to_non_nullable
as bool,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'backup_options.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BackupOptions _$BackupOptionsFromJson(Map<String, dynamic> json) =>
    _BackupOptions(
      customName: json['customName'] as String?,
      includeImages: json['includeImages'] as bool? ?? false,
      encrypt: json['encrypt'] as bool? ?? false,
      password: json['password'] as String?,
      includeTables: (json['includeTables'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      excludeTables:
          (json['excludeTables'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      compress: json['compress'] as bool? ?? false,
      description: json['description'] as String?,
    );

Map<String, dynamic> _$BackupOptionsToJson(_BackupOptions instance) =>
    <String, dynamic>{
      'customName': instance.customName,
      'includeImages': instance.includeImages,
      'encrypt': instance.encrypt,
      'password': instance.password,
      'includeTables': instance.includeTables,
      'excludeTables': instance.excludeTables,
      'compress': instance.compress,
      'description': instance.description,
    };
import 'package:freezed_annotation/freezed_annotation.dart';
import 'backup_metadata.dart';

part 'backup_result.freezed.dart';
part 'backup_result.g.dart';

/// å¤‡ä»½æ“ä½œçš„ç»“æ?
@freezed
abstract class BackupResult with _$BackupResult {
  const factory BackupResult({
    /// æ“ä½œæ˜¯å¦æˆåŠŸ
    required bool success,
    /// å¤‡ä»½æ–‡ä»¶è·¯å¾„
    String? filePath,
    /// å¤‡ä»½å…ƒæ•°æ?
    BackupMetadata? metadata,
    /// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
    String? errorMessage,
    /// æ“ä½œå¼€å§‹æ—¶é—?
    required DateTime startTime,
    /// æ“ä½œç»“æŸæ—¶é—´
    required DateTime endTime,
    /// å¤‡ä»½çš„æ€»è®°å½•æ•°
    @Default(0) int totalRecordsBackedUp,
  }) = _BackupResult;

  factory BackupResult.fromJson(Map<String, dynamic> json) =>
      _$BackupResultFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BackupResult {

/// æ“ä½œæ˜¯å¦æˆåŠŸ
 bool get success;/// å¤‡ä»½æ–‡ä»¶è·¯å¾„
 String? get filePath;/// å¤‡ä»½å…ƒæ•°æ? BackupMetadata? get metadata;/// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
 String? get errorMessage;/// æ“ä½œå¼€å§‹æ—¶é—? DateTime get startTime;/// æ“ä½œç»“æŸæ—¶é—´
 DateTime get endTime;/// å¤‡ä»½çš„æ€»è®°å½•æ•°
 int get totalRecordsBackedUp;
/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupResultCopyWith<BackupResult> get copyWith => _$BackupResultCopyWithImpl<BackupResult>(this as BackupResult, _$identity);

  /// Serializes this BackupResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupResult&&(identical(other.success, success) || other.success == success)&&(identical(other.filePath, filePath) || other.filePath == filePath)&&(identical(other.metadata, metadata) || other.metadata == metadata)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.startTime, startTime) || other.startTime == startTime)&&(identical(other.endTime, endTime) || other.endTime == endTime)&&(identical(other.totalRecordsBackedUp, totalRecordsBackedUp) || other.totalRecordsBackedUp == totalRecordsBackedUp));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success,filePath,metadata,errorMessage,startTime,endTime,totalRecordsBackedUp);

@override
String toString() {
  return 'BackupResult(success: $success, filePath: $filePath, metadata: $metadata, errorMessage: $errorMessage, startTime: $startTime, endTime: $endTime, totalRecordsBackedUp: $totalRecordsBackedUp)';
}


}

/// @nodoc
abstract mixin class $BackupResultCopyWith<$Res>  {
  factory $BackupResultCopyWith(BackupResult value, $Res Function(BackupResult) _then) = _$BackupResultCopyWithImpl;
@useResult
$Res call({
 bool success, String? filePath, BackupMetadata? metadata, String? errorMessage, DateTime startTime, DateTime endTime, int totalRecordsBackedUp
});


$BackupMetadataCopyWith<$Res>? get metadata;

}
/// @nodoc
class _$BackupResultCopyWithImpl<$Res>
    implements $BackupResultCopyWith<$Res> {
  _$BackupResultCopyWithImpl(this._self, this._then);

  final BackupResult _self;
  final $Res Function(BackupResult) _then;

/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? success = null,Object? filePath = freezed,Object? metadata = freezed,Object? errorMessage = freezed,Object? startTime = null,Object? endTime = null,Object? totalRecordsBackedUp = null,}) {
  return _then(_self.copyWith(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,filePath: freezed == filePath ? _self.filePath : filePath // ignore: cast_nullable_to_non_nullable
as String?,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,startTime: null == startTime ? _self.startTime : startTime // ignore: cast_nullable_to_non_nullable
as DateTime,endTime: null == endTime ? _self.endTime : endTime // ignore: cast_nullable_to_non_nullable
as DateTime,totalRecordsBackedUp: null == totalRecordsBackedUp ? _self.totalRecordsBackedUp : totalRecordsBackedUp // ignore: cast_nullable_to_non_nullable
as int,
  ));
}
/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get metadata {
    if (_self.metadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.metadata!, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _BackupResult implements BackupResult {
  const _BackupResult({required this.success, this.filePath, this.metadata, this.errorMessage, required this.startTime, required this.endTime, this.totalRecordsBackedUp = 0});
  factory _BackupResult.fromJson(Map<String, dynamic> json) => _$BackupResultFromJson(json);

/// æ“ä½œæ˜¯å¦æˆåŠŸ
@override final  bool success;
/// å¤‡ä»½æ–‡ä»¶è·¯å¾„
@override final  String? filePath;
/// å¤‡ä»½å…ƒæ•°æ?@override final  BackupMetadata? metadata;
/// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
@override final  String? errorMessage;
/// æ“ä½œå¼€å§‹æ—¶é—?@override final  DateTime startTime;
/// æ“ä½œç»“æŸæ—¶é—´
@override final  DateTime endTime;
/// å¤‡ä»½çš„æ€»è®°å½•æ•°
@override@JsonKey() final  int totalRecordsBackedUp;

/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupResultCopyWith<_BackupResult> get copyWith => __$BackupResultCopyWithImpl<_BackupResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BackupResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupResult&&(identical(other.success, success) || other.success == success)&&(identical(other.filePath, filePath) || other.filePath == filePath)&&(identical(other.metadata, metadata) || other.metadata == metadata)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.startTime, startTime) || other.startTime == startTime)&&(identical(other.endTime, endTime) || other.endTime == endTime)&&(identical(other.totalRecordsBackedUp, totalRecordsBackedUp) || other.totalRecordsBackedUp == totalRecordsBackedUp));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success,filePath,metadata,errorMessage,startTime,endTime,totalRecordsBackedUp);

@override
String toString() {
  return 'BackupResult(success: $success, filePath: $filePath, metadata: $metadata, errorMessage: $errorMessage, startTime: $startTime, endTime: $endTime, totalRecordsBackedUp: $totalRecordsBackedUp)';
}


}

/// @nodoc
abstract mixin class _$BackupResultCopyWith<$Res> implements $BackupResultCopyWith<$Res> {
  factory _$BackupResultCopyWith(_BackupResult value, $Res Function(_BackupResult) _then) = __$BackupResultCopyWithImpl;
@override @useResult
$Res call({
 bool success, String? filePath, BackupMetadata? metadata, String? errorMessage, DateTime startTime, DateTime endTime, int totalRecordsBackedUp
});


@override $BackupMetadataCopyWith<$Res>? get metadata;

}
/// @nodoc
class __$BackupResultCopyWithImpl<$Res>
    implements _$BackupResultCopyWith<$Res> {
  __$BackupResultCopyWithImpl(this._self, this._then);

  final _BackupResult _self;
  final $Res Function(_BackupResult) _then;

/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? success = null,Object? filePath = freezed,Object? metadata = freezed,Object? errorMessage = freezed,Object? startTime = null,Object? endTime = null,Object? totalRecordsBackedUp = null,}) {
  return _then(_BackupResult(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,filePath: freezed == filePath ? _self.filePath : filePath // ignore: cast_nullable_to_non_nullable
as String?,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,startTime: null == startTime ? _self.startTime : startTime // ignore: cast_nullable_to_non_nullable
as DateTime,endTime: null == endTime ? _self.endTime : endTime // ignore: cast_nullable_to_non_nullable
as DateTime,totalRecordsBackedUp: null == totalRecordsBackedUp ? _self.totalRecordsBackedUp : totalRecordsBackedUp // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

/// Create a copy of BackupResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get metadata {
    if (_self.metadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.metadata!, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'backup_result.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BackupResult _$BackupResultFromJson(Map<String, dynamic> json) =>
    _BackupResult(
      success: json['success'] as bool,
      filePath: json['filePath'] as String?,
      metadata: json['metadata'] == null
          ? null
          : BackupMetadata.fromJson(json['metadata'] as Map<String, dynamic>),
      errorMessage: json['errorMessage'] as String?,
      startTime: DateTime.parse(json['startTime'] as String),
      endTime: DateTime.parse(json['endTime'] as String),
      totalRecordsBackedUp:
          (json['totalRecordsBackedUp'] as num?)?.toInt() ?? 0,
    );

Map<String, dynamic> _$BackupResultToJson(_BackupResult instance) =>
    <String, dynamic>{
      'success': instance.success,
      'filePath': instance.filePath,
      'metadata': instance.metadata,
      'errorMessage': instance.errorMessage,
      'startTime': instance.startTime.toIso8601String(),
      'endTime': instance.endTime.toIso8601String(),
      'totalRecordsBackedUp': instance.totalRecordsBackedUp,
    };
/// å–æ¶ˆä»¤ç‰Œï¼Œç”¨äºå–æ¶ˆé•¿æ—¶é—´è¿è¡Œçš„æ“ä½?
class CancelToken {
  bool _isCancelled = false;

  /// æ£€æŸ¥æ˜¯å¦å·²è¢«å–æ¶?
  bool get isCancelled => _isCancelled;

  /// å–æ¶ˆæ“ä½œ
  void cancel() {
    _isCancelled = true;
  }

  /// å¦‚æœå·²å–æ¶ˆåˆ™æŠ›å‡ºå¼‚å¸¸
  void throwIfCancelled() {
    if (_isCancelled) {
      throw BackupCancelledException('æ“ä½œå·²è¢«å–æ¶ˆ');
    }
  }
}

/// å¤‡ä»½æ“ä½œè¢«å–æ¶ˆå¼‚å¸?
class BackupCancelledException implements Exception {
  final String message;
  
  const BackupCancelledException(this.message);
  
  @override
  String toString() => 'BackupCancelledException: $message';
}
import 'package:freezed_annotation/freezed_annotation.dart';

part 'compatibility_check_result.freezed.dart';
part 'compatibility_check_result.g.dart';

/// å…¼å®¹æ€§æ£€æŸ¥ç»“æ?
@freezed
abstract class CompatibilityCheckResult with _$CompatibilityCheckResult {
  const factory CompatibilityCheckResult({
    /// æ•´ä½“å…¼å®¹æ€?
    required bool isCompatible,
    /// åº”ç”¨ç‰ˆæœ¬å…¼å®¹æ€?
    required bool appVersionCompatible,
    /// æ•°æ®åº“æ¶æ„ç‰ˆæœ¬å…¼å®¹æ€?
    required bool schemaVersionCompatible,
    /// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬å…¼å®¹æ€?
    required bool backupFormatCompatible,
    /// è¡¨ç»“æ„å…¼å®¹æ€?
    required Map<String, bool> tableCompatibility,
    /// å…¼å®¹æ€§é—®é¢˜åˆ—è¡?
    @Default([]) List<CompatibilityIssue> issues,
    /// å…¼å®¹æ€§è­¦å‘Šåˆ—è¡?
    @Default([]) List<CompatibilityWarning> warnings,
    /// å‡çº§å»ºè®®
    @Default([]) List<String> upgradeRecommendations,
    /// å…¼å®¹æ€§è¯¦æƒ?
    required CompatibilityDetails details,
  }) = _CompatibilityCheckResult;

  factory CompatibilityCheckResult.fromJson(Map<String, dynamic> json) =>
      _$CompatibilityCheckResultFromJson(json);
}

/// å…¼å®¹æ€§é—®é¢?
@freezed
abstract class CompatibilityIssue with _$CompatibilityIssue {
  const factory CompatibilityIssue({
    /// é—®é¢˜ç±»å‹
    required CompatibilityIssueType type,
    /// é—®é¢˜æè¿°
    required String description,
    /// é—®é¢˜ä¸¥é‡ç¨‹åº¦
    required CompatibilityIssueSeverity severity,
    /// å—å½±å“çš„ç»„ä»¶ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
    String? affectedComponent,
    /// å»ºè®®çš„è§£å†³æ–¹æ¡?
    String? suggestedSolution,
    /// é—®é¢˜è¯¦æƒ…
    Map<String, dynamic>? details,
  }) = _CompatibilityIssue;

  factory CompatibilityIssue.fromJson(Map<String, dynamic> json) =>
      _$CompatibilityIssueFromJson(json);
}

/// å…¼å®¹æ€§è­¦å‘?
@freezed
abstract class CompatibilityWarning with _$CompatibilityWarning {
  const factory CompatibilityWarning({
    /// è­¦å‘Šç±»å‹
    required CompatibilityWarningType type,
    /// è­¦å‘Šæè¿°
    required String description,
    /// å—å½±å“çš„ç»„ä»¶
    String? affectedComponent,
    /// è­¦å‘Šè¯¦æƒ…
    Map<String, dynamic>? details,
  }) = _CompatibilityWarning;

  factory CompatibilityWarning.fromJson(Map<String, dynamic> json) =>
      _$CompatibilityWarningFromJson(json);
}

/// å…¼å®¹æ€§è¯¦æƒ?
@freezed
abstract class CompatibilityDetails with _$CompatibilityDetails {
  const factory CompatibilityDetails({
    /// å½“å‰åº”ç”¨ç‰ˆæœ¬
    required String currentAppVersion,
    /// å¤‡ä»½åº”ç”¨ç‰ˆæœ¬
    required String backupAppVersion,
    /// å½“å‰æ•°æ®åº“æ¶æ„ç‰ˆæœ?
    required int currentSchemaVersion,
    /// å¤‡ä»½æ•°æ®åº“æ¶æ„ç‰ˆæœ?
    required int backupSchemaVersion,
    /// å½“å‰å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
    required String currentBackupFormatVersion,
    /// å¤‡ä»½æ–‡ä»¶æ ¼å¼ç‰ˆæœ¬
    required String backupFormatVersion,
    /// æ”¯æŒçš„æœ€å°æ¶æ„ç‰ˆæœ?
    required int minSupportedSchemaVersion,
    /// æ”¯æŒçš„æœ€å¤§æ¶æ„ç‰ˆæœ?
    required int maxSupportedSchemaVersion,
    /// æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ¬åˆ—è¡?
    required List<String> supportedBackupFormatVersions,
  }) = _CompatibilityDetails;

  factory CompatibilityDetails.fromJson(Map<String, dynamic> json) =>
      _$CompatibilityDetailsFromJson(json);
}

/// å…¼å®¹æ€§é—®é¢˜ç±»å?
enum CompatibilityIssueType {
  /// åº”ç”¨ç‰ˆæœ¬ä¸å…¼å®?
  appVersionIncompatible,
  /// æ•°æ®åº“æ¶æ„ç‰ˆæœ¬ä¸å…¼å®¹
  schemaVersionIncompatible,
  /// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬ä¸å…¼å®?
  backupFormatIncompatible,
  /// è¡¨ç»“æ„ä¸å…¼å®¹
  tableStructureIncompatible,
  /// å­—æ®µç±»å‹ä¸å…¼å®?
  fieldTypeIncompatible,
  /// ç¼ºå¤±å¿…éœ€å­—æ®µ
  missingRequiredField,
  /// æœªçŸ¥è¡?
  unknownTable,
  /// æœªçŸ¥å­—æ®µ
  unknownField,
}

/// å…¼å®¹æ€§é—®é¢˜ä¸¥é‡ç¨‹åº?
enum CompatibilityIssueSeverity {
  /// ä¿¡æ¯æ€§é—®é¢˜ï¼Œä¸å½±å“æ¢å¤?
  info,
  /// è­¦å‘Šçº§é—®é¢˜ï¼Œå¯èƒ½å½±å“éƒ¨åˆ†åŠŸèƒ½
  warning,
  /// é”™è¯¯çº§é—®é¢˜ï¼Œå½±å“æ¢å¤è´¨é‡
  error,
  /// è‡´å‘½é—®é¢˜ï¼Œæ— æ³•æ¢å¤?
  critical,
}

/// å…¼å®¹æ€§è­¦å‘Šç±»å?
enum CompatibilityWarningType {
  /// ç‰ˆæœ¬å·®å¼‚è¾ƒå¤§
  versionGapLarge,
  /// è¡¨ç»“æ„æœ‰å˜åŒ–
  tableStructureChanged,
  /// å­—æ®µå·²åºŸå¼?
  fieldDeprecated,
  /// æ–°å¢å­—æ®µ
  newFieldAdded,
  /// æ•°æ®ç±»å‹å˜åŒ–
  dataTypeChanged,
  /// çº¦æŸå˜åŒ–
  constraintChanged,
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'compatibility_check_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CompatibilityCheckResult {

/// æ•´ä½“å…¼å®¹æ€? bool get isCompatible;/// åº”ç”¨ç‰ˆæœ¬å…¼å®¹æ€? bool get appVersionCompatible;/// æ•°æ®åº“æ¶æ„ç‰ˆæœ¬å…¼å®¹æ€? bool get schemaVersionCompatible;/// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬å…¼å®¹æ€? bool get backupFormatCompatible;/// è¡¨ç»“æ„å…¼å®¹æ€? Map<String, bool> get tableCompatibility;/// å…¼å®¹æ€§é—®é¢˜åˆ—è¡? List<CompatibilityIssue> get issues;/// å…¼å®¹æ€§è­¦å‘Šåˆ—è¡? List<CompatibilityWarning> get warnings;/// å‡çº§å»ºè®®
 List<String> get upgradeRecommendations;/// å…¼å®¹æ€§è¯¦æƒ? CompatibilityDetails get details;
/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompatibilityCheckResultCopyWith<CompatibilityCheckResult> get copyWith => _$CompatibilityCheckResultCopyWithImpl<CompatibilityCheckResult>(this as CompatibilityCheckResult, _$identity);

  /// Serializes this CompatibilityCheckResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompatibilityCheckResult&&(identical(other.isCompatible, isCompatible) || other.isCompatible == isCompatible)&&(identical(other.appVersionCompatible, appVersionCompatible) || other.appVersionCompatible == appVersionCompatible)&&(identical(other.schemaVersionCompatible, schemaVersionCompatible) || other.schemaVersionCompatible == schemaVersionCompatible)&&(identical(other.backupFormatCompatible, backupFormatCompatible) || other.backupFormatCompatible == backupFormatCompatible)&&const DeepCollectionEquality().equals(other.tableCompatibility, tableCompatibility)&&const DeepCollectionEquality().equals(other.issues, issues)&&const DeepCollectionEquality().equals(other.warnings, warnings)&&const DeepCollectionEquality().equals(other.upgradeRecommendations, upgradeRecommendations)&&(identical(other.details, details) || other.details == details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isCompatible,appVersionCompatible,schemaVersionCompatible,backupFormatCompatible,const DeepCollectionEquality().hash(tableCompatibility),const DeepCollectionEquality().hash(issues),const DeepCollectionEquality().hash(warnings),const DeepCollectionEquality().hash(upgradeRecommendations),details);

@override
String toString() {
  return 'CompatibilityCheckResult(isCompatible: $isCompatible, appVersionCompatible: $appVersionCompatible, schemaVersionCompatible: $schemaVersionCompatible, backupFormatCompatible: $backupFormatCompatible, tableCompatibility: $tableCompatibility, issues: $issues, warnings: $warnings, upgradeRecommendations: $upgradeRecommendations, details: $details)';
}


}

/// @nodoc
abstract mixin class $CompatibilityCheckResultCopyWith<$Res>  {
  factory $CompatibilityCheckResultCopyWith(CompatibilityCheckResult value, $Res Function(CompatibilityCheckResult) _then) = _$CompatibilityCheckResultCopyWithImpl;
@useResult
$Res call({
 bool isCompatible, bool appVersionCompatible, bool schemaVersionCompatible, bool backupFormatCompatible, Map<String, bool> tableCompatibility, List<CompatibilityIssue> issues, List<CompatibilityWarning> warnings, List<String> upgradeRecommendations, CompatibilityDetails details
});


$CompatibilityDetailsCopyWith<$Res> get details;

}
/// @nodoc
class _$CompatibilityCheckResultCopyWithImpl<$Res>
    implements $CompatibilityCheckResultCopyWith<$Res> {
  _$CompatibilityCheckResultCopyWithImpl(this._self, this._then);

  final CompatibilityCheckResult _self;
  final $Res Function(CompatibilityCheckResult) _then;

/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isCompatible = null,Object? appVersionCompatible = null,Object? schemaVersionCompatible = null,Object? backupFormatCompatible = null,Object? tableCompatibility = null,Object? issues = null,Object? warnings = null,Object? upgradeRecommendations = null,Object? details = null,}) {
  return _then(_self.copyWith(
isCompatible: null == isCompatible ? _self.isCompatible : isCompatible // ignore: cast_nullable_to_non_nullable
as bool,appVersionCompatible: null == appVersionCompatible ? _self.appVersionCompatible : appVersionCompatible // ignore: cast_nullable_to_non_nullable
as bool,schemaVersionCompatible: null == schemaVersionCompatible ? _self.schemaVersionCompatible : schemaVersionCompatible // ignore: cast_nullable_to_non_nullable
as bool,backupFormatCompatible: null == backupFormatCompatible ? _self.backupFormatCompatible : backupFormatCompatible // ignore: cast_nullable_to_non_nullable
as bool,tableCompatibility: null == tableCompatibility ? _self.tableCompatibility : tableCompatibility // ignore: cast_nullable_to_non_nullable
as Map<String, bool>,issues: null == issues ? _self.issues : issues // ignore: cast_nullable_to_non_nullable
as List<CompatibilityIssue>,warnings: null == warnings ? _self.warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<CompatibilityWarning>,upgradeRecommendations: null == upgradeRecommendations ? _self.upgradeRecommendations : upgradeRecommendations // ignore: cast_nullable_to_non_nullable
as List<String>,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as CompatibilityDetails,
  ));
}
/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompatibilityDetailsCopyWith<$Res> get details {
  
  return $CompatibilityDetailsCopyWith<$Res>(_self.details, (value) {
    return _then(_self.copyWith(details: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _CompatibilityCheckResult implements CompatibilityCheckResult {
  const _CompatibilityCheckResult({required this.isCompatible, required this.appVersionCompatible, required this.schemaVersionCompatible, required this.backupFormatCompatible, required final  Map<String, bool> tableCompatibility, final  List<CompatibilityIssue> issues = const [], final  List<CompatibilityWarning> warnings = const [], final  List<String> upgradeRecommendations = const [], required this.details}): _tableCompatibility = tableCompatibility,_issues = issues,_warnings = warnings,_upgradeRecommendations = upgradeRecommendations;
  factory _CompatibilityCheckResult.fromJson(Map<String, dynamic> json) => _$CompatibilityCheckResultFromJson(json);

/// æ•´ä½“å…¼å®¹æ€?@override final  bool isCompatible;
/// åº”ç”¨ç‰ˆæœ¬å…¼å®¹æ€?@override final  bool appVersionCompatible;
/// æ•°æ®åº“æ¶æ„ç‰ˆæœ¬å…¼å®¹æ€?@override final  bool schemaVersionCompatible;
/// å¤‡ä»½æ ¼å¼ç‰ˆæœ¬å…¼å®¹æ€?@override final  bool backupFormatCompatible;
/// è¡¨ç»“æ„å…¼å®¹æ€? final  Map<String, bool> _tableCompatibility;
/// è¡¨ç»“æ„å…¼å®¹æ€?@override Map<String, bool> get tableCompatibility {
  if (_tableCompatibility is EqualUnmodifiableMapView) return _tableCompatibility;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableCompatibility);
}

/// å…¼å®¹æ€§é—®é¢˜åˆ—è¡? final  List<CompatibilityIssue> _issues;
/// å…¼å®¹æ€§é—®é¢˜åˆ—è¡?@override@JsonKey() List<CompatibilityIssue> get issues {
  if (_issues is EqualUnmodifiableListView) return _issues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_issues);
}

/// å…¼å®¹æ€§è­¦å‘Šåˆ—è¡? final  List<CompatibilityWarning> _warnings;
/// å…¼å®¹æ€§è­¦å‘Šåˆ—è¡?@override@JsonKey() List<CompatibilityWarning> get warnings {
  if (_warnings is EqualUnmodifiableListView) return _warnings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_warnings);
}

/// å‡çº§å»ºè®®
 final  List<String> _upgradeRecommendations;
/// å‡çº§å»ºè®®
@override@JsonKey() List<String> get upgradeRecommendations {
  if (_upgradeRecommendations is EqualUnmodifiableListView) return _upgradeRecommendations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_upgradeRecommendations);
}

/// å…¼å®¹æ€§è¯¦æƒ?@override final  CompatibilityDetails details;

/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompatibilityCheckResultCopyWith<_CompatibilityCheckResult> get copyWith => __$CompatibilityCheckResultCopyWithImpl<_CompatibilityCheckResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompatibilityCheckResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompatibilityCheckResult&&(identical(other.isCompatible, isCompatible) || other.isCompatible == isCompatible)&&(identical(other.appVersionCompatible, appVersionCompatible) || other.appVersionCompatible == appVersionCompatible)&&(identical(other.schemaVersionCompatible, schemaVersionCompatible) || other.schemaVersionCompatible == schemaVersionCompatible)&&(identical(other.backupFormatCompatible, backupFormatCompatible) || other.backupFormatCompatible == backupFormatCompatible)&&const DeepCollectionEquality().equals(other._tableCompatibility, _tableCompatibility)&&const DeepCollectionEquality().equals(other._issues, _issues)&&const DeepCollectionEquality().equals(other._warnings, _warnings)&&const DeepCollectionEquality().equals(other._upgradeRecommendations, _upgradeRecommendations)&&(identical(other.details, details) || other.details == details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isCompatible,appVersionCompatible,schemaVersionCompatible,backupFormatCompatible,const DeepCollectionEquality().hash(_tableCompatibility),const DeepCollectionEquality().hash(_issues),const DeepCollectionEquality().hash(_warnings),const DeepCollectionEquality().hash(_upgradeRecommendations),details);

@override
String toString() {
  return 'CompatibilityCheckResult(isCompatible: $isCompatible, appVersionCompatible: $appVersionCompatible, schemaVersionCompatible: $schemaVersionCompatible, backupFormatCompatible: $backupFormatCompatible, tableCompatibility: $tableCompatibility, issues: $issues, warnings: $warnings, upgradeRecommendations: $upgradeRecommendations, details: $details)';
}


}

/// @nodoc
abstract mixin class _$CompatibilityCheckResultCopyWith<$Res> implements $CompatibilityCheckResultCopyWith<$Res> {
  factory _$CompatibilityCheckResultCopyWith(_CompatibilityCheckResult value, $Res Function(_CompatibilityCheckResult) _then) = __$CompatibilityCheckResultCopyWithImpl;
@override @useResult
$Res call({
 bool isCompatible, bool appVersionCompatible, bool schemaVersionCompatible, bool backupFormatCompatible, Map<String, bool> tableCompatibility, List<CompatibilityIssue> issues, List<CompatibilityWarning> warnings, List<String> upgradeRecommendations, CompatibilityDetails details
});


@override $CompatibilityDetailsCopyWith<$Res> get details;

}
/// @nodoc
class __$CompatibilityCheckResultCopyWithImpl<$Res>
    implements _$CompatibilityCheckResultCopyWith<$Res> {
  __$CompatibilityCheckResultCopyWithImpl(this._self, this._then);

  final _CompatibilityCheckResult _self;
  final $Res Function(_CompatibilityCheckResult) _then;

/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isCompatible = null,Object? appVersionCompatible = null,Object? schemaVersionCompatible = null,Object? backupFormatCompatible = null,Object? tableCompatibility = null,Object? issues = null,Object? warnings = null,Object? upgradeRecommendations = null,Object? details = null,}) {
  return _then(_CompatibilityCheckResult(
isCompatible: null == isCompatible ? _self.isCompatible : isCompatible // ignore: cast_nullable_to_non_nullable
as bool,appVersionCompatible: null == appVersionCompatible ? _self.appVersionCompatible : appVersionCompatible // ignore: cast_nullable_to_non_nullable
as bool,schemaVersionCompatible: null == schemaVersionCompatible ? _self.schemaVersionCompatible : schemaVersionCompatible // ignore: cast_nullable_to_non_nullable
as bool,backupFormatCompatible: null == backupFormatCompatible ? _self.backupFormatCompatible : backupFormatCompatible // ignore: cast_nullable_to_non_nullable
as bool,tableCompatibility: null == tableCompatibility ? _self._tableCompatibility : tableCompatibility // ignore: cast_nullable_to_non_nullable
as Map<String, bool>,issues: null == issues ? _self._issues : issues // ignore: cast_nullable_to_non_nullable
as List<CompatibilityIssue>,warnings: null == warnings ? _self._warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<CompatibilityWarning>,upgradeRecommendations: null == upgradeRecommendations ? _self._upgradeRecommendations : upgradeRecommendations // ignore: cast_nullable_to_non_nullable
as List<String>,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as CompatibilityDetails,
  ));
}

/// Create a copy of CompatibilityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompatibilityDetailsCopyWith<$Res> get details {
  
  return $CompatibilityDetailsCopyWith<$Res>(_self.details, (value) {
    return _then(_self.copyWith(details: value));
  });
}
}


/// @nodoc
mixin _$CompatibilityIssue {

/// é—®é¢˜ç±»å‹
 CompatibilityIssueType get type;/// é—®é¢˜æè¿°
 String get description;/// é—®é¢˜ä¸¥é‡ç¨‹åº¦
 CompatibilityIssueSeverity get severity;/// å—å½±å“çš„ç»„ä»¶ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
 String? get affectedComponent;/// å»ºè®®çš„è§£å†³æ–¹æ¡? String? get suggestedSolution;/// é—®é¢˜è¯¦æƒ…
 Map<String, dynamic>? get details;
/// Create a copy of CompatibilityIssue
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompatibilityIssueCopyWith<CompatibilityIssue> get copyWith => _$CompatibilityIssueCopyWithImpl<CompatibilityIssue>(this as CompatibilityIssue, _$identity);

  /// Serializes this CompatibilityIssue to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompatibilityIssue&&(identical(other.type, type) || other.type == type)&&(identical(other.description, description) || other.description == description)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.affectedComponent, affectedComponent) || other.affectedComponent == affectedComponent)&&(identical(other.suggestedSolution, suggestedSolution) || other.suggestedSolution == suggestedSolution)&&const DeepCollectionEquality().equals(other.details, details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,description,severity,affectedComponent,suggestedSolution,const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'CompatibilityIssue(type: $type, description: $description, severity: $severity, affectedComponent: $affectedComponent, suggestedSolution: $suggestedSolution, details: $details)';
}


}

/// @nodoc
abstract mixin class $CompatibilityIssueCopyWith<$Res>  {
  factory $CompatibilityIssueCopyWith(CompatibilityIssue value, $Res Function(CompatibilityIssue) _then) = _$CompatibilityIssueCopyWithImpl;
@useResult
$Res call({
 CompatibilityIssueType type, String description, CompatibilityIssueSeverity severity, String? affectedComponent, String? suggestedSolution, Map<String, dynamic>? details
});




}
/// @nodoc
class _$CompatibilityIssueCopyWithImpl<$Res>
    implements $CompatibilityIssueCopyWith<$Res> {
  _$CompatibilityIssueCopyWithImpl(this._self, this._then);

  final CompatibilityIssue _self;
  final $Res Function(CompatibilityIssue) _then;

/// Create a copy of CompatibilityIssue
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? description = null,Object? severity = null,Object? affectedComponent = freezed,Object? suggestedSolution = freezed,Object? details = freezed,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as CompatibilityIssueType,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,severity: null == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as CompatibilityIssueSeverity,affectedComponent: freezed == affectedComponent ? _self.affectedComponent : affectedComponent // ignore: cast_nullable_to_non_nullable
as String?,suggestedSolution: freezed == suggestedSolution ? _self.suggestedSolution : suggestedSolution // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _CompatibilityIssue implements CompatibilityIssue {
  const _CompatibilityIssue({required this.type, required this.description, required this.severity, this.affectedComponent, this.suggestedSolution, final  Map<String, dynamic>? details}): _details = details;
  factory _CompatibilityIssue.fromJson(Map<String, dynamic> json) => _$CompatibilityIssueFromJson(json);

/// é—®é¢˜ç±»å‹
@override final  CompatibilityIssueType type;
/// é—®é¢˜æè¿°
@override final  String description;
/// é—®é¢˜ä¸¥é‡ç¨‹åº¦
@override final  CompatibilityIssueSeverity severity;
/// å—å½±å“çš„ç»„ä»¶ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
@override final  String? affectedComponent;
/// å»ºè®®çš„è§£å†³æ–¹æ¡?@override final  String? suggestedSolution;
/// é—®é¢˜è¯¦æƒ…
 final  Map<String, dynamic>? _details;
/// é—®é¢˜è¯¦æƒ…
@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of CompatibilityIssue
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompatibilityIssueCopyWith<_CompatibilityIssue> get copyWith => __$CompatibilityIssueCopyWithImpl<_CompatibilityIssue>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompatibilityIssueToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompatibilityIssue&&(identical(other.type, type) || other.type == type)&&(identical(other.description, description) || other.description == description)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.affectedComponent, affectedComponent) || other.affectedComponent == affectedComponent)&&(identical(other.suggestedSolution, suggestedSolution) || other.suggestedSolution == suggestedSolution)&&const DeepCollectionEquality().equals(other._details, _details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,description,severity,affectedComponent,suggestedSolution,const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'CompatibilityIssue(type: $type, description: $description, severity: $severity, affectedComponent: $affectedComponent, suggestedSolution: $suggestedSolution, details: $details)';
}


}

/// @nodoc
abstract mixin class _$CompatibilityIssueCopyWith<$Res> implements $CompatibilityIssueCopyWith<$Res> {
  factory _$CompatibilityIssueCopyWith(_CompatibilityIssue value, $Res Function(_CompatibilityIssue) _then) = __$CompatibilityIssueCopyWithImpl;
@override @useResult
$Res call({
 CompatibilityIssueType type, String description, CompatibilityIssueSeverity severity, String? affectedComponent, String? suggestedSolution, Map<String, dynamic>? details
});




}
/// @nodoc
class __$CompatibilityIssueCopyWithImpl<$Res>
    implements _$CompatibilityIssueCopyWith<$Res> {
  __$CompatibilityIssueCopyWithImpl(this._self, this._then);

  final _CompatibilityIssue _self;
  final $Res Function(_CompatibilityIssue) _then;

/// Create a copy of CompatibilityIssue
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? description = null,Object? severity = null,Object? affectedComponent = freezed,Object? suggestedSolution = freezed,Object? details = freezed,}) {
  return _then(_CompatibilityIssue(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as CompatibilityIssueType,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,severity: null == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as CompatibilityIssueSeverity,affectedComponent: freezed == affectedComponent ? _self.affectedComponent : affectedComponent // ignore: cast_nullable_to_non_nullable
as String?,suggestedSolution: freezed == suggestedSolution ? _self.suggestedSolution : suggestedSolution // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$CompatibilityWarning {

/// è­¦å‘Šç±»å‹
 CompatibilityWarningType get type;/// è­¦å‘Šæè¿°
 String get description;/// å—å½±å“çš„ç»„ä»¶
 String? get affectedComponent;/// è­¦å‘Šè¯¦æƒ…
 Map<String, dynamic>? get details;
/// Create a copy of CompatibilityWarning
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompatibilityWarningCopyWith<CompatibilityWarning> get copyWith => _$CompatibilityWarningCopyWithImpl<CompatibilityWarning>(this as CompatibilityWarning, _$identity);

  /// Serializes this CompatibilityWarning to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompatibilityWarning&&(identical(other.type, type) || other.type == type)&&(identical(other.description, description) || other.description == description)&&(identical(other.affectedComponent, affectedComponent) || other.affectedComponent == affectedComponent)&&const DeepCollectionEquality().equals(other.details, details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,description,affectedComponent,const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'CompatibilityWarning(type: $type, description: $description, affectedComponent: $affectedComponent, details: $details)';
}


}

/// @nodoc
abstract mixin class $CompatibilityWarningCopyWith<$Res>  {
  factory $CompatibilityWarningCopyWith(CompatibilityWarning value, $Res Function(CompatibilityWarning) _then) = _$CompatibilityWarningCopyWithImpl;
@useResult
$Res call({
 CompatibilityWarningType type, String description, String? affectedComponent, Map<String, dynamic>? details
});




}
/// @nodoc
class _$CompatibilityWarningCopyWithImpl<$Res>
    implements $CompatibilityWarningCopyWith<$Res> {
  _$CompatibilityWarningCopyWithImpl(this._self, this._then);

  final CompatibilityWarning _self;
  final $Res Function(CompatibilityWarning) _then;

/// Create a copy of CompatibilityWarning
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? description = null,Object? affectedComponent = freezed,Object? details = freezed,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as CompatibilityWarningType,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,affectedComponent: freezed == affectedComponent ? _self.affectedComponent : affectedComponent // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _CompatibilityWarning implements CompatibilityWarning {
  const _CompatibilityWarning({required this.type, required this.description, this.affectedComponent, final  Map<String, dynamic>? details}): _details = details;
  factory _CompatibilityWarning.fromJson(Map<String, dynamic> json) => _$CompatibilityWarningFromJson(json);

/// è­¦å‘Šç±»å‹
@override final  CompatibilityWarningType type;
/// è­¦å‘Šæè¿°
@override final  String description;
/// å—å½±å“çš„ç»„ä»¶
@override final  String? affectedComponent;
/// è­¦å‘Šè¯¦æƒ…
 final  Map<String, dynamic>? _details;
/// è­¦å‘Šè¯¦æƒ…
@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of CompatibilityWarning
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompatibilityWarningCopyWith<_CompatibilityWarning> get copyWith => __$CompatibilityWarningCopyWithImpl<_CompatibilityWarning>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompatibilityWarningToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompatibilityWarning&&(identical(other.type, type) || other.type == type)&&(identical(other.description, description) || other.description == description)&&(identical(other.affectedComponent, affectedComponent) || other.affectedComponent == affectedComponent)&&const DeepCollectionEquality().equals(other._details, _details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,description,affectedComponent,const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'CompatibilityWarning(type: $type, description: $description, affectedComponent: $affectedComponent, details: $details)';
}


}

/// @nodoc
abstract mixin class _$CompatibilityWarningCopyWith<$Res> implements $CompatibilityWarningCopyWith<$Res> {
  factory _$CompatibilityWarningCopyWith(_CompatibilityWarning value, $Res Function(_CompatibilityWarning) _then) = __$CompatibilityWarningCopyWithImpl;
@override @useResult
$Res call({
 CompatibilityWarningType type, String description, String? affectedComponent, Map<String, dynamic>? details
});




}
/// @nodoc
class __$CompatibilityWarningCopyWithImpl<$Res>
    implements _$CompatibilityWarningCopyWith<$Res> {
  __$CompatibilityWarningCopyWithImpl(this._self, this._then);

  final _CompatibilityWarning _self;
  final $Res Function(_CompatibilityWarning) _then;

/// Create a copy of CompatibilityWarning
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? description = null,Object? affectedComponent = freezed,Object? details = freezed,}) {
  return _then(_CompatibilityWarning(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as CompatibilityWarningType,description: null == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String,affectedComponent: freezed == affectedComponent ? _self.affectedComponent : affectedComponent // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$CompatibilityDetails {

/// å½“å‰åº”ç”¨ç‰ˆæœ¬
 String get currentAppVersion;/// å¤‡ä»½åº”ç”¨ç‰ˆæœ¬
 String get backupAppVersion;/// å½“å‰æ•°æ®åº“æ¶æ„ç‰ˆæœ? int get currentSchemaVersion;/// å¤‡ä»½æ•°æ®åº“æ¶æ„ç‰ˆæœ? int get backupSchemaVersion;/// å½“å‰å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
 String get currentBackupFormatVersion;/// å¤‡ä»½æ–‡ä»¶æ ¼å¼ç‰ˆæœ¬
 String get backupFormatVersion;/// æ”¯æŒçš„æœ€å°æ¶æ„ç‰ˆæœ? int get minSupportedSchemaVersion;/// æ”¯æŒçš„æœ€å¤§æ¶æ„ç‰ˆæœ? int get maxSupportedSchemaVersion;/// æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ¬åˆ—è¡? List<String> get supportedBackupFormatVersions;
/// Create a copy of CompatibilityDetails
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompatibilityDetailsCopyWith<CompatibilityDetails> get copyWith => _$CompatibilityDetailsCopyWithImpl<CompatibilityDetails>(this as CompatibilityDetails, _$identity);

  /// Serializes this CompatibilityDetails to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompatibilityDetails&&(identical(other.currentAppVersion, currentAppVersion) || other.currentAppVersion == currentAppVersion)&&(identical(other.backupAppVersion, backupAppVersion) || other.backupAppVersion == backupAppVersion)&&(identical(other.currentSchemaVersion, currentSchemaVersion) || other.currentSchemaVersion == currentSchemaVersion)&&(identical(other.backupSchemaVersion, backupSchemaVersion) || other.backupSchemaVersion == backupSchemaVersion)&&(identical(other.currentBackupFormatVersion, currentBackupFormatVersion) || other.currentBackupFormatVersion == currentBackupFormatVersion)&&(identical(other.backupFormatVersion, backupFormatVersion) || other.backupFormatVersion == backupFormatVersion)&&(identical(other.minSupportedSchemaVersion, minSupportedSchemaVersion) || other.minSupportedSchemaVersion == minSupportedSchemaVersion)&&(identical(other.maxSupportedSchemaVersion, maxSupportedSchemaVersion) || other.maxSupportedSchemaVersion == maxSupportedSchemaVersion)&&const DeepCollectionEquality().equals(other.supportedBackupFormatVersions, supportedBackupFormatVersions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,currentAppVersion,backupAppVersion,currentSchemaVersion,backupSchemaVersion,currentBackupFormatVersion,backupFormatVersion,minSupportedSchemaVersion,maxSupportedSchemaVersion,const DeepCollectionEquality().hash(supportedBackupFormatVersions));

@override
String toString() {
  return 'CompatibilityDetails(currentAppVersion: $currentAppVersion, backupAppVersion: $backupAppVersion, currentSchemaVersion: $currentSchemaVersion, backupSchemaVersion: $backupSchemaVersion, currentBackupFormatVersion: $currentBackupFormatVersion, backupFormatVersion: $backupFormatVersion, minSupportedSchemaVersion: $minSupportedSchemaVersion, maxSupportedSchemaVersion: $maxSupportedSchemaVersion, supportedBackupFormatVersions: $supportedBackupFormatVersions)';
}


}

/// @nodoc
abstract mixin class $CompatibilityDetailsCopyWith<$Res>  {
  factory $CompatibilityDetailsCopyWith(CompatibilityDetails value, $Res Function(CompatibilityDetails) _then) = _$CompatibilityDetailsCopyWithImpl;
@useResult
$Res call({
 String currentAppVersion, String backupAppVersion, int currentSchemaVersion, int backupSchemaVersion, String currentBackupFormatVersion, String backupFormatVersion, int minSupportedSchemaVersion, int maxSupportedSchemaVersion, List<String> supportedBackupFormatVersions
});




}
/// @nodoc
class _$CompatibilityDetailsCopyWithImpl<$Res>
    implements $CompatibilityDetailsCopyWith<$Res> {
  _$CompatibilityDetailsCopyWithImpl(this._self, this._then);

  final CompatibilityDetails _self;
  final $Res Function(CompatibilityDetails) _then;

/// Create a copy of CompatibilityDetails
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? currentAppVersion = null,Object? backupAppVersion = null,Object? currentSchemaVersion = null,Object? backupSchemaVersion = null,Object? currentBackupFormatVersion = null,Object? backupFormatVersion = null,Object? minSupportedSchemaVersion = null,Object? maxSupportedSchemaVersion = null,Object? supportedBackupFormatVersions = null,}) {
  return _then(_self.copyWith(
currentAppVersion: null == currentAppVersion ? _self.currentAppVersion : currentAppVersion // ignore: cast_nullable_to_non_nullable
as String,backupAppVersion: null == backupAppVersion ? _self.backupAppVersion : backupAppVersion // ignore: cast_nullable_to_non_nullable
as String,currentSchemaVersion: null == currentSchemaVersion ? _self.currentSchemaVersion : currentSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,backupSchemaVersion: null == backupSchemaVersion ? _self.backupSchemaVersion : backupSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,currentBackupFormatVersion: null == currentBackupFormatVersion ? _self.currentBackupFormatVersion : currentBackupFormatVersion // ignore: cast_nullable_to_non_nullable
as String,backupFormatVersion: null == backupFormatVersion ? _self.backupFormatVersion : backupFormatVersion // ignore: cast_nullable_to_non_nullable
as String,minSupportedSchemaVersion: null == minSupportedSchemaVersion ? _self.minSupportedSchemaVersion : minSupportedSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,maxSupportedSchemaVersion: null == maxSupportedSchemaVersion ? _self.maxSupportedSchemaVersion : maxSupportedSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,supportedBackupFormatVersions: null == supportedBackupFormatVersions ? _self.supportedBackupFormatVersions : supportedBackupFormatVersions // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _CompatibilityDetails implements CompatibilityDetails {
  const _CompatibilityDetails({required this.currentAppVersion, required this.backupAppVersion, required this.currentSchemaVersion, required this.backupSchemaVersion, required this.currentBackupFormatVersion, required this.backupFormatVersion, required this.minSupportedSchemaVersion, required this.maxSupportedSchemaVersion, required final  List<String> supportedBackupFormatVersions}): _supportedBackupFormatVersions = supportedBackupFormatVersions;
  factory _CompatibilityDetails.fromJson(Map<String, dynamic> json) => _$CompatibilityDetailsFromJson(json);

/// å½“å‰åº”ç”¨ç‰ˆæœ¬
@override final  String currentAppVersion;
/// å¤‡ä»½åº”ç”¨ç‰ˆæœ¬
@override final  String backupAppVersion;
/// å½“å‰æ•°æ®åº“æ¶æ„ç‰ˆæœ?@override final  int currentSchemaVersion;
/// å¤‡ä»½æ•°æ®åº“æ¶æ„ç‰ˆæœ?@override final  int backupSchemaVersion;
/// å½“å‰å¤‡ä»½æ ¼å¼ç‰ˆæœ¬
@override final  String currentBackupFormatVersion;
/// å¤‡ä»½æ–‡ä»¶æ ¼å¼ç‰ˆæœ¬
@override final  String backupFormatVersion;
/// æ”¯æŒçš„æœ€å°æ¶æ„ç‰ˆæœ?@override final  int minSupportedSchemaVersion;
/// æ”¯æŒçš„æœ€å¤§æ¶æ„ç‰ˆæœ?@override final  int maxSupportedSchemaVersion;
/// æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ¬åˆ—è¡? final  List<String> _supportedBackupFormatVersions;
/// æ”¯æŒçš„å¤‡ä»½æ ¼å¼ç‰ˆæœ¬åˆ—è¡?@override List<String> get supportedBackupFormatVersions {
  if (_supportedBackupFormatVersions is EqualUnmodifiableListView) return _supportedBackupFormatVersions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_supportedBackupFormatVersions);
}


/// Create a copy of CompatibilityDetails
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompatibilityDetailsCopyWith<_CompatibilityDetails> get copyWith => __$CompatibilityDetailsCopyWithImpl<_CompatibilityDetails>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompatibilityDetailsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompatibilityDetails&&(identical(other.currentAppVersion, currentAppVersion) || other.currentAppVersion == currentAppVersion)&&(identical(other.backupAppVersion, backupAppVersion) || other.backupAppVersion == backupAppVersion)&&(identical(other.currentSchemaVersion, currentSchemaVersion) || other.currentSchemaVersion == currentSchemaVersion)&&(identical(other.backupSchemaVersion, backupSchemaVersion) || other.backupSchemaVersion == backupSchemaVersion)&&(identical(other.currentBackupFormatVersion, currentBackupFormatVersion) || other.currentBackupFormatVersion == currentBackupFormatVersion)&&(identical(other.backupFormatVersion, backupFormatVersion) || other.backupFormatVersion == backupFormatVersion)&&(identical(other.minSupportedSchemaVersion, minSupportedSchemaVersion) || other.minSupportedSchemaVersion == minSupportedSchemaVersion)&&(identical(other.maxSupportedSchemaVersion, maxSupportedSchemaVersion) || other.maxSupportedSchemaVersion == maxSupportedSchemaVersion)&&const DeepCollectionEquality().equals(other._supportedBackupFormatVersions, _supportedBackupFormatVersions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,currentAppVersion,backupAppVersion,currentSchemaVersion,backupSchemaVersion,currentBackupFormatVersion,backupFormatVersion,minSupportedSchemaVersion,maxSupportedSchemaVersion,const DeepCollectionEquality().hash(_supportedBackupFormatVersions));

@override
String toString() {
  return 'CompatibilityDetails(currentAppVersion: $currentAppVersion, backupAppVersion: $backupAppVersion, currentSchemaVersion: $currentSchemaVersion, backupSchemaVersion: $backupSchemaVersion, currentBackupFormatVersion: $currentBackupFormatVersion, backupFormatVersion: $backupFormatVersion, minSupportedSchemaVersion: $minSupportedSchemaVersion, maxSupportedSchemaVersion: $maxSupportedSchemaVersion, supportedBackupFormatVersions: $supportedBackupFormatVersions)';
}


}

/// @nodoc
abstract mixin class _$CompatibilityDetailsCopyWith<$Res> implements $CompatibilityDetailsCopyWith<$Res> {
  factory _$CompatibilityDetailsCopyWith(_CompatibilityDetails value, $Res Function(_CompatibilityDetails) _then) = __$CompatibilityDetailsCopyWithImpl;
@override @useResult
$Res call({
 String currentAppVersion, String backupAppVersion, int currentSchemaVersion, int backupSchemaVersion, String currentBackupFormatVersion, String backupFormatVersion, int minSupportedSchemaVersion, int maxSupportedSchemaVersion, List<String> supportedBackupFormatVersions
});




}
/// @nodoc
class __$CompatibilityDetailsCopyWithImpl<$Res>
    implements _$CompatibilityDetailsCopyWith<$Res> {
  __$CompatibilityDetailsCopyWithImpl(this._self, this._then);

  final _CompatibilityDetails _self;
  final $Res Function(_CompatibilityDetails) _then;

/// Create a copy of CompatibilityDetails
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? currentAppVersion = null,Object? backupAppVersion = null,Object? currentSchemaVersion = null,Object? backupSchemaVersion = null,Object? currentBackupFormatVersion = null,Object? backupFormatVersion = null,Object? minSupportedSchemaVersion = null,Object? maxSupportedSchemaVersion = null,Object? supportedBackupFormatVersions = null,}) {
  return _then(_CompatibilityDetails(
currentAppVersion: null == currentAppVersion ? _self.currentAppVersion : currentAppVersion // ignore: cast_nullable_to_non_nullable
as String,backupAppVersion: null == backupAppVersion ? _self.backupAppVersion : backupAppVersion // ignore: cast_nullable_to_non_nullable
as String,currentSchemaVersion: null == currentSchemaVersion ? _self.currentSchemaVersion : currentSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,backupSchemaVersion: null == backupSchemaVersion ? _self.backupSchemaVersion : backupSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,currentBackupFormatVersion: null == currentBackupFormatVersion ? _self.currentBackupFormatVersion : currentBackupFormatVersion // ignore: cast_nullable_to_non_nullable
as String,backupFormatVersion: null == backupFormatVersion ? _self.backupFormatVersion : backupFormatVersion // ignore: cast_nullable_to_non_nullable
as String,minSupportedSchemaVersion: null == minSupportedSchemaVersion ? _self.minSupportedSchemaVersion : minSupportedSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,maxSupportedSchemaVersion: null == maxSupportedSchemaVersion ? _self.maxSupportedSchemaVersion : maxSupportedSchemaVersion // ignore: cast_nullable_to_non_nullable
as int,supportedBackupFormatVersions: null == supportedBackupFormatVersions ? _self._supportedBackupFormatVersions : supportedBackupFormatVersions // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'compatibility_check_result.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CompatibilityCheckResult _$CompatibilityCheckResultFromJson(
  Map<String, dynamic> json,
) => _CompatibilityCheckResult(
  isCompatible: json['isCompatible'] as bool,
  appVersionCompatible: json['appVersionCompatible'] as bool,
  schemaVersionCompatible: json['schemaVersionCompatible'] as bool,
  backupFormatCompatible: json['backupFormatCompatible'] as bool,
  tableCompatibility: Map<String, bool>.from(json['tableCompatibility'] as Map),
  issues:
      (json['issues'] as List<dynamic>?)
          ?.map((e) => CompatibilityIssue.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
  warnings:
      (json['warnings'] as List<dynamic>?)
          ?.map((e) => CompatibilityWarning.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
  upgradeRecommendations:
      (json['upgradeRecommendations'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
      const [],
  details: CompatibilityDetails.fromJson(
    json['details'] as Map<String, dynamic>,
  ),
);

Map<String, dynamic> _$CompatibilityCheckResultToJson(
  _CompatibilityCheckResult instance,
) => <String, dynamic>{
  'isCompatible': instance.isCompatible,
  'appVersionCompatible': instance.appVersionCompatible,
  'schemaVersionCompatible': instance.schemaVersionCompatible,
  'backupFormatCompatible': instance.backupFormatCompatible,
  'tableCompatibility': instance.tableCompatibility,
  'issues': instance.issues,
  'warnings': instance.warnings,
  'upgradeRecommendations': instance.upgradeRecommendations,
  'details': instance.details,
};

_CompatibilityIssue _$CompatibilityIssueFromJson(Map<String, dynamic> json) =>
    _CompatibilityIssue(
      type: $enumDecode(_$CompatibilityIssueTypeEnumMap, json['type']),
      description: json['description'] as String,
      severity: $enumDecode(
        _$CompatibilityIssueSeverityEnumMap,
        json['severity'],
      ),
      affectedComponent: json['affectedComponent'] as String?,
      suggestedSolution: json['suggestedSolution'] as String?,
      details: json['details'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$CompatibilityIssueToJson(_CompatibilityIssue instance) =>
    <String, dynamic>{
      'type': _$CompatibilityIssueTypeEnumMap[instance.type]!,
      'description': instance.description,
      'severity': _$CompatibilityIssueSeverityEnumMap[instance.severity]!,
      'affectedComponent': instance.affectedComponent,
      'suggestedSolution': instance.suggestedSolution,
      'details': instance.details,
    };

const _$CompatibilityIssueTypeEnumMap = {
  CompatibilityIssueType.appVersionIncompatible: 'appVersionIncompatible',
  CompatibilityIssueType.schemaVersionIncompatible: 'schemaVersionIncompatible',
  CompatibilityIssueType.backupFormatIncompatible: 'backupFormatIncompatible',
  CompatibilityIssueType.tableStructureIncompatible:
      'tableStructureIncompatible',
  CompatibilityIssueType.fieldTypeIncompatible: 'fieldTypeIncompatible',
  CompatibilityIssueType.missingRequiredField: 'missingRequiredField',
  CompatibilityIssueType.unknownTable: 'unknownTable',
  CompatibilityIssueType.unknownField: 'unknownField',
};

const _$CompatibilityIssueSeverityEnumMap = {
  CompatibilityIssueSeverity.info: 'info',
  CompatibilityIssueSeverity.warning: 'warning',
  CompatibilityIssueSeverity.error: 'error',
  CompatibilityIssueSeverity.critical: 'critical',
};

_CompatibilityWarning _$CompatibilityWarningFromJson(
  Map<String, dynamic> json,
) => _CompatibilityWarning(
  type: $enumDecode(_$CompatibilityWarningTypeEnumMap, json['type']),
  description: json['description'] as String,
  affectedComponent: json['affectedComponent'] as String?,
  details: json['details'] as Map<String, dynamic>?,
);

Map<String, dynamic> _$CompatibilityWarningToJson(
  _CompatibilityWarning instance,
) => <String, dynamic>{
  'type': _$CompatibilityWarningTypeEnumMap[instance.type]!,
  'description': instance.description,
  'affectedComponent': instance.affectedComponent,
  'details': instance.details,
};

const _$CompatibilityWarningTypeEnumMap = {
  CompatibilityWarningType.versionGapLarge: 'versionGapLarge',
  CompatibilityWarningType.tableStructureChanged: 'tableStructureChanged',
  CompatibilityWarningType.fieldDeprecated: 'fieldDeprecated',
  CompatibilityWarningType.newFieldAdded: 'newFieldAdded',
  CompatibilityWarningType.dataTypeChanged: 'dataTypeChanged',
  CompatibilityWarningType.constraintChanged: 'constraintChanged',
};

_CompatibilityDetails _$CompatibilityDetailsFromJson(
  Map<String, dynamic> json,
) => _CompatibilityDetails(
  currentAppVersion: json['currentAppVersion'] as String,
  backupAppVersion: json['backupAppVersion'] as String,
  currentSchemaVersion: (json['currentSchemaVersion'] as num).toInt(),
  backupSchemaVersion: (json['backupSchemaVersion'] as num).toInt(),
  currentBackupFormatVersion: json['currentBackupFormatVersion'] as String,
  backupFormatVersion: json['backupFormatVersion'] as String,
  minSupportedSchemaVersion: (json['minSupportedSchemaVersion'] as num).toInt(),
  maxSupportedSchemaVersion: (json['maxSupportedSchemaVersion'] as num).toInt(),
  supportedBackupFormatVersions:
      (json['supportedBackupFormatVersions'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
);

Map<String, dynamic> _$CompatibilityDetailsToJson(
  _CompatibilityDetails instance,
) => <String, dynamic>{
  'currentAppVersion': instance.currentAppVersion,
  'backupAppVersion': instance.backupAppVersion,
  'currentSchemaVersion': instance.currentSchemaVersion,
  'backupSchemaVersion': instance.backupSchemaVersion,
  'currentBackupFormatVersion': instance.currentBackupFormatVersion,
  'backupFormatVersion': instance.backupFormatVersion,
  'minSupportedSchemaVersion': instance.minSupportedSchemaVersion,
  'maxSupportedSchemaVersion': instance.maxSupportedSchemaVersion,
  'supportedBackupFormatVersions': instance.supportedBackupFormatVersions,
};
import 'package:freezed_annotation/freezed_annotation.dart';
import 'validation_result.dart';

part 'integrity_check_result.freezed.dart';
part 'integrity_check_result.g.dart';

/// å®Œæ•´æ€§æ£€æŸ¥ç»“æ?
@freezed
abstract class IntegrityCheckResult with _$IntegrityCheckResult {
  const factory IntegrityCheckResult({
    /// æ•´ä½“å®Œæ•´æ€§æ˜¯å¦é€šè¿‡
    required bool isIntegrityValid,
    /// æ ¡éªŒå’ŒéªŒè¯ç»“æ?
    required bool checksumValid,
    /// æ•°æ®å…³ç³»å®Œæ•´æ€§ç»“æ?
    required bool relationshipIntegrityValid,
    /// è¡¨æ•°æ®å®Œæ•´æ€§ç»“æ?
    required Map<String, bool> tableIntegrityResults,
    /// ç¼ºå¤±çš„å…³è”è®°å½?
    @Default([]) List<MissingRelationship> missingRelationships,
    /// å­¤ç«‹è®°å½•ï¼ˆæ²¡æœ‰å…³è”çš„è®°å½•ï¼?
    @Default([]) List<OrphanedRecord> orphanedRecords,
    /// é‡å¤è®°å½•
    @Default([]) List<DuplicateRecord> duplicateRecords,
    /// æ•°æ®ç»Ÿè®¡ä¿¡æ¯
    required IntegrityStatistics statistics,
    /// è¯¦ç»†çš„éªŒè¯ç»“æ?
    @Default([]) List<ValidationResult> detailedResults,
  }) = _IntegrityCheckResult;

  factory IntegrityCheckResult.fromJson(Map<String, dynamic> json) =>
      _$IntegrityCheckResultFromJson(json);
}

/// ç¼ºå¤±çš„å…³è”è®°å½?
@freezed
abstract class MissingRelationship with _$MissingRelationship {
  const factory MissingRelationship({
    /// æºè¡¨å?
    required String sourceTable,
    /// ç›®æ ‡è¡¨å
    required String targetTable,
    /// å¤–é”®å­—æ®µå?
    required String foreignKeyField,
    /// ç¼ºå¤±çš„å¤–é”®å€?
    required dynamic missingValue,
    /// å—å½±å“çš„è®°å½•æ•°é‡
    required int affectedRecordCount,
  }) = _MissingRelationship;

  factory MissingRelationship.fromJson(Map<String, dynamic> json) =>
      _$MissingRelationshipFromJson(json);
}

/// å­¤ç«‹è®°å½•
@freezed
abstract class OrphanedRecord with _$OrphanedRecord {
  const factory OrphanedRecord({
    /// è¡¨å
    required String tableName,
    /// ä¸»é”®å­—æ®µå?
    required String primaryKeyField,
    /// ä¸»é”®å€?
    required dynamic primaryKeyValue,
    /// å­¤ç«‹çš„åŸå›?
    required String reason,
    /// è®°å½•æ•°æ®
    Map<String, dynamic>? recordData,
  }) = _OrphanedRecord;

  factory OrphanedRecord.fromJson(Map<String, dynamic> json) =>
      _$OrphanedRecordFromJson(json);
}

/// é‡å¤è®°å½•
@freezed
abstract class DuplicateRecord with _$DuplicateRecord {
  const factory DuplicateRecord({
    /// è¡¨å
    required String tableName,
    /// é‡å¤çš„å­—æ®µç»„å?
    required List<String> duplicateFields,
    /// é‡å¤çš„å€?
    required Map<String, dynamic> duplicateValues,
    /// é‡å¤è®°å½•çš„æ•°é‡?
    required int duplicateCount,
    /// é‡å¤è®°å½•çš„ä¸»é”®åˆ—è¡?
    @Default([]) List<dynamic> duplicatePrimaryKeys,
  }) = _DuplicateRecord;

  factory DuplicateRecord.fromJson(Map<String, dynamic> json) =>
      _$DuplicateRecordFromJson(json);
}

/// å®Œæ•´æ€§ç»Ÿè®¡ä¿¡æ?
@freezed
abstract class IntegrityStatistics with _$IntegrityStatistics {
  const factory IntegrityStatistics({
    /// æ€»è®°å½•æ•°
    required int totalRecords,
    /// æœ‰æ•ˆè®°å½•æ•?
    required int validRecords,
    /// æ— æ•ˆè®°å½•æ•?
    required int invalidRecords,
    /// ç¼ºå¤±å…³è”è®°å½•æ•?
    required int missingRelationshipCount,
    /// å­¤ç«‹è®°å½•æ•?
    required int orphanedRecordCount,
    /// é‡å¤è®°å½•æ•?
    required int duplicateRecordCount,
    /// å„è¡¨è®°å½•ç»Ÿè®¡
    required Map<String, int> tableRecordCounts,
    /// å„è¡¨æœ‰æ•ˆè®°å½•ç»Ÿè®¡
    required Map<String, int> tableValidRecordCounts,
  }) = _IntegrityStatistics;

  factory IntegrityStatistics.fromJson(Map<String, dynamic> json) =>
      _$IntegrityStatisticsFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'integrity_check_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$IntegrityCheckResult {

/// æ•´ä½“å®Œæ•´æ€§æ˜¯å¦é€šè¿‡
 bool get isIntegrityValid;/// æ ¡éªŒå’ŒéªŒè¯ç»“æ? bool get checksumValid;/// æ•°æ®å…³ç³»å®Œæ•´æ€§ç»“æ? bool get relationshipIntegrityValid;/// è¡¨æ•°æ®å®Œæ•´æ€§ç»“æ? Map<String, bool> get tableIntegrityResults;/// ç¼ºå¤±çš„å…³è”è®°å½? List<MissingRelationship> get missingRelationships;/// å­¤ç«‹è®°å½•ï¼ˆæ²¡æœ‰å…³è”çš„è®°å½•ï¼? List<OrphanedRecord> get orphanedRecords;/// é‡å¤è®°å½•
 List<DuplicateRecord> get duplicateRecords;/// æ•°æ®ç»Ÿè®¡ä¿¡æ¯
 IntegrityStatistics get statistics;/// è¯¦ç»†çš„éªŒè¯ç»“æ? List<ValidationResult> get detailedResults;
/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$IntegrityCheckResultCopyWith<IntegrityCheckResult> get copyWith => _$IntegrityCheckResultCopyWithImpl<IntegrityCheckResult>(this as IntegrityCheckResult, _$identity);

  /// Serializes this IntegrityCheckResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is IntegrityCheckResult&&(identical(other.isIntegrityValid, isIntegrityValid) || other.isIntegrityValid == isIntegrityValid)&&(identical(other.checksumValid, checksumValid) || other.checksumValid == checksumValid)&&(identical(other.relationshipIntegrityValid, relationshipIntegrityValid) || other.relationshipIntegrityValid == relationshipIntegrityValid)&&const DeepCollectionEquality().equals(other.tableIntegrityResults, tableIntegrityResults)&&const DeepCollectionEquality().equals(other.missingRelationships, missingRelationships)&&const DeepCollectionEquality().equals(other.orphanedRecords, orphanedRecords)&&const DeepCollectionEquality().equals(other.duplicateRecords, duplicateRecords)&&(identical(other.statistics, statistics) || other.statistics == statistics)&&const DeepCollectionEquality().equals(other.detailedResults, detailedResults));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIntegrityValid,checksumValid,relationshipIntegrityValid,const DeepCollectionEquality().hash(tableIntegrityResults),const DeepCollectionEquality().hash(missingRelationships),const DeepCollectionEquality().hash(orphanedRecords),const DeepCollectionEquality().hash(duplicateRecords),statistics,const DeepCollectionEquality().hash(detailedResults));

@override
String toString() {
  return 'IntegrityCheckResult(isIntegrityValid: $isIntegrityValid, checksumValid: $checksumValid, relationshipIntegrityValid: $relationshipIntegrityValid, tableIntegrityResults: $tableIntegrityResults, missingRelationships: $missingRelationships, orphanedRecords: $orphanedRecords, duplicateRecords: $duplicateRecords, statistics: $statistics, detailedResults: $detailedResults)';
}


}

/// @nodoc
abstract mixin class $IntegrityCheckResultCopyWith<$Res>  {
  factory $IntegrityCheckResultCopyWith(IntegrityCheckResult value, $Res Function(IntegrityCheckResult) _then) = _$IntegrityCheckResultCopyWithImpl;
@useResult
$Res call({
 bool isIntegrityValid, bool checksumValid, bool relationshipIntegrityValid, Map<String, bool> tableIntegrityResults, List<MissingRelationship> missingRelationships, List<OrphanedRecord> orphanedRecords, List<DuplicateRecord> duplicateRecords, IntegrityStatistics statistics, List<ValidationResult> detailedResults
});


$IntegrityStatisticsCopyWith<$Res> get statistics;

}
/// @nodoc
class _$IntegrityCheckResultCopyWithImpl<$Res>
    implements $IntegrityCheckResultCopyWith<$Res> {
  _$IntegrityCheckResultCopyWithImpl(this._self, this._then);

  final IntegrityCheckResult _self;
  final $Res Function(IntegrityCheckResult) _then;

/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isIntegrityValid = null,Object? checksumValid = null,Object? relationshipIntegrityValid = null,Object? tableIntegrityResults = null,Object? missingRelationships = null,Object? orphanedRecords = null,Object? duplicateRecords = null,Object? statistics = null,Object? detailedResults = null,}) {
  return _then(_self.copyWith(
isIntegrityValid: null == isIntegrityValid ? _self.isIntegrityValid : isIntegrityValid // ignore: cast_nullable_to_non_nullable
as bool,checksumValid: null == checksumValid ? _self.checksumValid : checksumValid // ignore: cast_nullable_to_non_nullable
as bool,relationshipIntegrityValid: null == relationshipIntegrityValid ? _self.relationshipIntegrityValid : relationshipIntegrityValid // ignore: cast_nullable_to_non_nullable
as bool,tableIntegrityResults: null == tableIntegrityResults ? _self.tableIntegrityResults : tableIntegrityResults // ignore: cast_nullable_to_non_nullable
as Map<String, bool>,missingRelationships: null == missingRelationships ? _self.missingRelationships : missingRelationships // ignore: cast_nullable_to_non_nullable
as List<MissingRelationship>,orphanedRecords: null == orphanedRecords ? _self.orphanedRecords : orphanedRecords // ignore: cast_nullable_to_non_nullable
as List<OrphanedRecord>,duplicateRecords: null == duplicateRecords ? _self.duplicateRecords : duplicateRecords // ignore: cast_nullable_to_non_nullable
as List<DuplicateRecord>,statistics: null == statistics ? _self.statistics : statistics // ignore: cast_nullable_to_non_nullable
as IntegrityStatistics,detailedResults: null == detailedResults ? _self.detailedResults : detailedResults // ignore: cast_nullable_to_non_nullable
as List<ValidationResult>,
  ));
}
/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$IntegrityStatisticsCopyWith<$Res> get statistics {
  
  return $IntegrityStatisticsCopyWith<$Res>(_self.statistics, (value) {
    return _then(_self.copyWith(statistics: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _IntegrityCheckResult implements IntegrityCheckResult {
  const _IntegrityCheckResult({required this.isIntegrityValid, required this.checksumValid, required this.relationshipIntegrityValid, required final  Map<String, bool> tableIntegrityResults, final  List<MissingRelationship> missingRelationships = const [], final  List<OrphanedRecord> orphanedRecords = const [], final  List<DuplicateRecord> duplicateRecords = const [], required this.statistics, final  List<ValidationResult> detailedResults = const []}): _tableIntegrityResults = tableIntegrityResults,_missingRelationships = missingRelationships,_orphanedRecords = orphanedRecords,_duplicateRecords = duplicateRecords,_detailedResults = detailedResults;
  factory _IntegrityCheckResult.fromJson(Map<String, dynamic> json) => _$IntegrityCheckResultFromJson(json);

/// æ•´ä½“å®Œæ•´æ€§æ˜¯å¦é€šè¿‡
@override final  bool isIntegrityValid;
/// æ ¡éªŒå’ŒéªŒè¯ç»“æ?@override final  bool checksumValid;
/// æ•°æ®å…³ç³»å®Œæ•´æ€§ç»“æ?@override final  bool relationshipIntegrityValid;
/// è¡¨æ•°æ®å®Œæ•´æ€§ç»“æ? final  Map<String, bool> _tableIntegrityResults;
/// è¡¨æ•°æ®å®Œæ•´æ€§ç»“æ?@override Map<String, bool> get tableIntegrityResults {
  if (_tableIntegrityResults is EqualUnmodifiableMapView) return _tableIntegrityResults;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableIntegrityResults);
}

/// ç¼ºå¤±çš„å…³è”è®°å½? final  List<MissingRelationship> _missingRelationships;
/// ç¼ºå¤±çš„å…³è”è®°å½?@override@JsonKey() List<MissingRelationship> get missingRelationships {
  if (_missingRelationships is EqualUnmodifiableListView) return _missingRelationships;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_missingRelationships);
}

/// å­¤ç«‹è®°å½•ï¼ˆæ²¡æœ‰å…³è”çš„è®°å½•ï¼? final  List<OrphanedRecord> _orphanedRecords;
/// å­¤ç«‹è®°å½•ï¼ˆæ²¡æœ‰å…³è”çš„è®°å½•ï¼?@override@JsonKey() List<OrphanedRecord> get orphanedRecords {
  if (_orphanedRecords is EqualUnmodifiableListView) return _orphanedRecords;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_orphanedRecords);
}

/// é‡å¤è®°å½•
 final  List<DuplicateRecord> _duplicateRecords;
/// é‡å¤è®°å½•
@override@JsonKey() List<DuplicateRecord> get duplicateRecords {
  if (_duplicateRecords is EqualUnmodifiableListView) return _duplicateRecords;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_duplicateRecords);
}

/// æ•°æ®ç»Ÿè®¡ä¿¡æ¯
@override final  IntegrityStatistics statistics;
/// è¯¦ç»†çš„éªŒè¯ç»“æ? final  List<ValidationResult> _detailedResults;
/// è¯¦ç»†çš„éªŒè¯ç»“æ?@override@JsonKey() List<ValidationResult> get detailedResults {
  if (_detailedResults is EqualUnmodifiableListView) return _detailedResults;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_detailedResults);
}


/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$IntegrityCheckResultCopyWith<_IntegrityCheckResult> get copyWith => __$IntegrityCheckResultCopyWithImpl<_IntegrityCheckResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$IntegrityCheckResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _IntegrityCheckResult&&(identical(other.isIntegrityValid, isIntegrityValid) || other.isIntegrityValid == isIntegrityValid)&&(identical(other.checksumValid, checksumValid) || other.checksumValid == checksumValid)&&(identical(other.relationshipIntegrityValid, relationshipIntegrityValid) || other.relationshipIntegrityValid == relationshipIntegrityValid)&&const DeepCollectionEquality().equals(other._tableIntegrityResults, _tableIntegrityResults)&&const DeepCollectionEquality().equals(other._missingRelationships, _missingRelationships)&&const DeepCollectionEquality().equals(other._orphanedRecords, _orphanedRecords)&&const DeepCollectionEquality().equals(other._duplicateRecords, _duplicateRecords)&&(identical(other.statistics, statistics) || other.statistics == statistics)&&const DeepCollectionEquality().equals(other._detailedResults, _detailedResults));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIntegrityValid,checksumValid,relationshipIntegrityValid,const DeepCollectionEquality().hash(_tableIntegrityResults),const DeepCollectionEquality().hash(_missingRelationships),const DeepCollectionEquality().hash(_orphanedRecords),const DeepCollectionEquality().hash(_duplicateRecords),statistics,const DeepCollectionEquality().hash(_detailedResults));

@override
String toString() {
  return 'IntegrityCheckResult(isIntegrityValid: $isIntegrityValid, checksumValid: $checksumValid, relationshipIntegrityValid: $relationshipIntegrityValid, tableIntegrityResults: $tableIntegrityResults, missingRelationships: $missingRelationships, orphanedRecords: $orphanedRecords, duplicateRecords: $duplicateRecords, statistics: $statistics, detailedResults: $detailedResults)';
}


}

/// @nodoc
abstract mixin class _$IntegrityCheckResultCopyWith<$Res> implements $IntegrityCheckResultCopyWith<$Res> {
  factory _$IntegrityCheckResultCopyWith(_IntegrityCheckResult value, $Res Function(_IntegrityCheckResult) _then) = __$IntegrityCheckResultCopyWithImpl;
@override @useResult
$Res call({
 bool isIntegrityValid, bool checksumValid, bool relationshipIntegrityValid, Map<String, bool> tableIntegrityResults, List<MissingRelationship> missingRelationships, List<OrphanedRecord> orphanedRecords, List<DuplicateRecord> duplicateRecords, IntegrityStatistics statistics, List<ValidationResult> detailedResults
});


@override $IntegrityStatisticsCopyWith<$Res> get statistics;

}
/// @nodoc
class __$IntegrityCheckResultCopyWithImpl<$Res>
    implements _$IntegrityCheckResultCopyWith<$Res> {
  __$IntegrityCheckResultCopyWithImpl(this._self, this._then);

  final _IntegrityCheckResult _self;
  final $Res Function(_IntegrityCheckResult) _then;

/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isIntegrityValid = null,Object? checksumValid = null,Object? relationshipIntegrityValid = null,Object? tableIntegrityResults = null,Object? missingRelationships = null,Object? orphanedRecords = null,Object? duplicateRecords = null,Object? statistics = null,Object? detailedResults = null,}) {
  return _then(_IntegrityCheckResult(
isIntegrityValid: null == isIntegrityValid ? _self.isIntegrityValid : isIntegrityValid // ignore: cast_nullable_to_non_nullable
as bool,checksumValid: null == checksumValid ? _self.checksumValid : checksumValid // ignore: cast_nullable_to_non_nullable
as bool,relationshipIntegrityValid: null == relationshipIntegrityValid ? _self.relationshipIntegrityValid : relationshipIntegrityValid // ignore: cast_nullable_to_non_nullable
as bool,tableIntegrityResults: null == tableIntegrityResults ? _self._tableIntegrityResults : tableIntegrityResults // ignore: cast_nullable_to_non_nullable
as Map<String, bool>,missingRelationships: null == missingRelationships ? _self._missingRelationships : missingRelationships // ignore: cast_nullable_to_non_nullable
as List<MissingRelationship>,orphanedRecords: null == orphanedRecords ? _self._orphanedRecords : orphanedRecords // ignore: cast_nullable_to_non_nullable
as List<OrphanedRecord>,duplicateRecords: null == duplicateRecords ? _self._duplicateRecords : duplicateRecords // ignore: cast_nullable_to_non_nullable
as List<DuplicateRecord>,statistics: null == statistics ? _self.statistics : statistics // ignore: cast_nullable_to_non_nullable
as IntegrityStatistics,detailedResults: null == detailedResults ? _self._detailedResults : detailedResults // ignore: cast_nullable_to_non_nullable
as List<ValidationResult>,
  ));
}

/// Create a copy of IntegrityCheckResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$IntegrityStatisticsCopyWith<$Res> get statistics {
  
  return $IntegrityStatisticsCopyWith<$Res>(_self.statistics, (value) {
    return _then(_self.copyWith(statistics: value));
  });
}
}


/// @nodoc
mixin _$MissingRelationship {

/// æºè¡¨å? String get sourceTable;/// ç›®æ ‡è¡¨å
 String get targetTable;/// å¤–é”®å­—æ®µå? String get foreignKeyField;/// ç¼ºå¤±çš„å¤–é”®å€? dynamic get missingValue;/// å—å½±å“çš„è®°å½•æ•°é‡
 int get affectedRecordCount;
/// Create a copy of MissingRelationship
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MissingRelationshipCopyWith<MissingRelationship> get copyWith => _$MissingRelationshipCopyWithImpl<MissingRelationship>(this as MissingRelationship, _$identity);

  /// Serializes this MissingRelationship to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MissingRelationship&&(identical(other.sourceTable, sourceTable) || other.sourceTable == sourceTable)&&(identical(other.targetTable, targetTable) || other.targetTable == targetTable)&&(identical(other.foreignKeyField, foreignKeyField) || other.foreignKeyField == foreignKeyField)&&const DeepCollectionEquality().equals(other.missingValue, missingValue)&&(identical(other.affectedRecordCount, affectedRecordCount) || other.affectedRecordCount == affectedRecordCount));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,sourceTable,targetTable,foreignKeyField,const DeepCollectionEquality().hash(missingValue),affectedRecordCount);

@override
String toString() {
  return 'MissingRelationship(sourceTable: $sourceTable, targetTable: $targetTable, foreignKeyField: $foreignKeyField, missingValue: $missingValue, affectedRecordCount: $affectedRecordCount)';
}


}

/// @nodoc
abstract mixin class $MissingRelationshipCopyWith<$Res>  {
  factory $MissingRelationshipCopyWith(MissingRelationship value, $Res Function(MissingRelationship) _then) = _$MissingRelationshipCopyWithImpl;
@useResult
$Res call({
 String sourceTable, String targetTable, String foreignKeyField, dynamic missingValue, int affectedRecordCount
});




}
/// @nodoc
class _$MissingRelationshipCopyWithImpl<$Res>
    implements $MissingRelationshipCopyWith<$Res> {
  _$MissingRelationshipCopyWithImpl(this._self, this._then);

  final MissingRelationship _self;
  final $Res Function(MissingRelationship) _then;

/// Create a copy of MissingRelationship
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? sourceTable = null,Object? targetTable = null,Object? foreignKeyField = null,Object? missingValue = freezed,Object? affectedRecordCount = null,}) {
  return _then(_self.copyWith(
sourceTable: null == sourceTable ? _self.sourceTable : sourceTable // ignore: cast_nullable_to_non_nullable
as String,targetTable: null == targetTable ? _self.targetTable : targetTable // ignore: cast_nullable_to_non_nullable
as String,foreignKeyField: null == foreignKeyField ? _self.foreignKeyField : foreignKeyField // ignore: cast_nullable_to_non_nullable
as String,missingValue: freezed == missingValue ? _self.missingValue : missingValue // ignore: cast_nullable_to_non_nullable
as dynamic,affectedRecordCount: null == affectedRecordCount ? _self.affectedRecordCount : affectedRecordCount // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _MissingRelationship implements MissingRelationship {
  const _MissingRelationship({required this.sourceTable, required this.targetTable, required this.foreignKeyField, required this.missingValue, required this.affectedRecordCount});
  factory _MissingRelationship.fromJson(Map<String, dynamic> json) => _$MissingRelationshipFromJson(json);

/// æºè¡¨å?@override final  String sourceTable;
/// ç›®æ ‡è¡¨å
@override final  String targetTable;
/// å¤–é”®å­—æ®µå?@override final  String foreignKeyField;
/// ç¼ºå¤±çš„å¤–é”®å€?@override final  dynamic missingValue;
/// å—å½±å“çš„è®°å½•æ•°é‡
@override final  int affectedRecordCount;

/// Create a copy of MissingRelationship
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MissingRelationshipCopyWith<_MissingRelationship> get copyWith => __$MissingRelationshipCopyWithImpl<_MissingRelationship>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MissingRelationshipToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MissingRelationship&&(identical(other.sourceTable, sourceTable) || other.sourceTable == sourceTable)&&(identical(other.targetTable, targetTable) || other.targetTable == targetTable)&&(identical(other.foreignKeyField, foreignKeyField) || other.foreignKeyField == foreignKeyField)&&const DeepCollectionEquality().equals(other.missingValue, missingValue)&&(identical(other.affectedRecordCount, affectedRecordCount) || other.affectedRecordCount == affectedRecordCount));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,sourceTable,targetTable,foreignKeyField,const DeepCollectionEquality().hash(missingValue),affectedRecordCount);

@override
String toString() {
  return 'MissingRelationship(sourceTable: $sourceTable, targetTable: $targetTable, foreignKeyField: $foreignKeyField, missingValue: $missingValue, affectedRecordCount: $affectedRecordCount)';
}


}

/// @nodoc
abstract mixin class _$MissingRelationshipCopyWith<$Res> implements $MissingRelationshipCopyWith<$Res> {
  factory _$MissingRelationshipCopyWith(_MissingRelationship value, $Res Function(_MissingRelationship) _then) = __$MissingRelationshipCopyWithImpl;
@override @useResult
$Res call({
 String sourceTable, String targetTable, String foreignKeyField, dynamic missingValue, int affectedRecordCount
});




}
/// @nodoc
class __$MissingRelationshipCopyWithImpl<$Res>
    implements _$MissingRelationshipCopyWith<$Res> {
  __$MissingRelationshipCopyWithImpl(this._self, this._then);

  final _MissingRelationship _self;
  final $Res Function(_MissingRelationship) _then;

/// Create a copy of MissingRelationship
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? sourceTable = null,Object? targetTable = null,Object? foreignKeyField = null,Object? missingValue = freezed,Object? affectedRecordCount = null,}) {
  return _then(_MissingRelationship(
sourceTable: null == sourceTable ? _self.sourceTable : sourceTable // ignore: cast_nullable_to_non_nullable
as String,targetTable: null == targetTable ? _self.targetTable : targetTable // ignore: cast_nullable_to_non_nullable
as String,foreignKeyField: null == foreignKeyField ? _self.foreignKeyField : foreignKeyField // ignore: cast_nullable_to_non_nullable
as String,missingValue: freezed == missingValue ? _self.missingValue : missingValue // ignore: cast_nullable_to_non_nullable
as dynamic,affectedRecordCount: null == affectedRecordCount ? _self.affectedRecordCount : affectedRecordCount // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$OrphanedRecord {

/// è¡¨å
 String get tableName;/// ä¸»é”®å­—æ®µå? String get primaryKeyField;/// ä¸»é”®å€? dynamic get primaryKeyValue;/// å­¤ç«‹çš„åŸå›? String get reason;/// è®°å½•æ•°æ®
 Map<String, dynamic>? get recordData;
/// Create a copy of OrphanedRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OrphanedRecordCopyWith<OrphanedRecord> get copyWith => _$OrphanedRecordCopyWithImpl<OrphanedRecord>(this as OrphanedRecord, _$identity);

  /// Serializes this OrphanedRecord to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OrphanedRecord&&(identical(other.tableName, tableName) || other.tableName == tableName)&&(identical(other.primaryKeyField, primaryKeyField) || other.primaryKeyField == primaryKeyField)&&const DeepCollectionEquality().equals(other.primaryKeyValue, primaryKeyValue)&&(identical(other.reason, reason) || other.reason == reason)&&const DeepCollectionEquality().equals(other.recordData, recordData));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tableName,primaryKeyField,const DeepCollectionEquality().hash(primaryKeyValue),reason,const DeepCollectionEquality().hash(recordData));

@override
String toString() {
  return 'OrphanedRecord(tableName: $tableName, primaryKeyField: $primaryKeyField, primaryKeyValue: $primaryKeyValue, reason: $reason, recordData: $recordData)';
}


}

/// @nodoc
abstract mixin class $OrphanedRecordCopyWith<$Res>  {
  factory $OrphanedRecordCopyWith(OrphanedRecord value, $Res Function(OrphanedRecord) _then) = _$OrphanedRecordCopyWithImpl;
@useResult
$Res call({
 String tableName, String primaryKeyField, dynamic primaryKeyValue, String reason, Map<String, dynamic>? recordData
});




}
/// @nodoc
class _$OrphanedRecordCopyWithImpl<$Res>
    implements $OrphanedRecordCopyWith<$Res> {
  _$OrphanedRecordCopyWithImpl(this._self, this._then);

  final OrphanedRecord _self;
  final $Res Function(OrphanedRecord) _then;

/// Create a copy of OrphanedRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tableName = null,Object? primaryKeyField = null,Object? primaryKeyValue = freezed,Object? reason = null,Object? recordData = freezed,}) {
  return _then(_self.copyWith(
tableName: null == tableName ? _self.tableName : tableName // ignore: cast_nullable_to_non_nullable
as String,primaryKeyField: null == primaryKeyField ? _self.primaryKeyField : primaryKeyField // ignore: cast_nullable_to_non_nullable
as String,primaryKeyValue: freezed == primaryKeyValue ? _self.primaryKeyValue : primaryKeyValue // ignore: cast_nullable_to_non_nullable
as dynamic,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as String,recordData: freezed == recordData ? _self.recordData : recordData // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _OrphanedRecord implements OrphanedRecord {
  const _OrphanedRecord({required this.tableName, required this.primaryKeyField, required this.primaryKeyValue, required this.reason, final  Map<String, dynamic>? recordData}): _recordData = recordData;
  factory _OrphanedRecord.fromJson(Map<String, dynamic> json) => _$OrphanedRecordFromJson(json);

/// è¡¨å
@override final  String tableName;
/// ä¸»é”®å­—æ®µå?@override final  String primaryKeyField;
/// ä¸»é”®å€?@override final  dynamic primaryKeyValue;
/// å­¤ç«‹çš„åŸå›?@override final  String reason;
/// è®°å½•æ•°æ®
 final  Map<String, dynamic>? _recordData;
/// è®°å½•æ•°æ®
@override Map<String, dynamic>? get recordData {
  final value = _recordData;
  if (value == null) return null;
  if (_recordData is EqualUnmodifiableMapView) return _recordData;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of OrphanedRecord
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OrphanedRecordCopyWith<_OrphanedRecord> get copyWith => __$OrphanedRecordCopyWithImpl<_OrphanedRecord>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OrphanedRecordToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OrphanedRecord&&(identical(other.tableName, tableName) || other.tableName == tableName)&&(identical(other.primaryKeyField, primaryKeyField) || other.primaryKeyField == primaryKeyField)&&const DeepCollectionEquality().equals(other.primaryKeyValue, primaryKeyValue)&&(identical(other.reason, reason) || other.reason == reason)&&const DeepCollectionEquality().equals(other._recordData, _recordData));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tableName,primaryKeyField,const DeepCollectionEquality().hash(primaryKeyValue),reason,const DeepCollectionEquality().hash(_recordData));

@override
String toString() {
  return 'OrphanedRecord(tableName: $tableName, primaryKeyField: $primaryKeyField, primaryKeyValue: $primaryKeyValue, reason: $reason, recordData: $recordData)';
}


}

/// @nodoc
abstract mixin class _$OrphanedRecordCopyWith<$Res> implements $OrphanedRecordCopyWith<$Res> {
  factory _$OrphanedRecordCopyWith(_OrphanedRecord value, $Res Function(_OrphanedRecord) _then) = __$OrphanedRecordCopyWithImpl;
@override @useResult
$Res call({
 String tableName, String primaryKeyField, dynamic primaryKeyValue, String reason, Map<String, dynamic>? recordData
});




}
/// @nodoc
class __$OrphanedRecordCopyWithImpl<$Res>
    implements _$OrphanedRecordCopyWith<$Res> {
  __$OrphanedRecordCopyWithImpl(this._self, this._then);

  final _OrphanedRecord _self;
  final $Res Function(_OrphanedRecord) _then;

/// Create a copy of OrphanedRecord
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tableName = null,Object? primaryKeyField = null,Object? primaryKeyValue = freezed,Object? reason = null,Object? recordData = freezed,}) {
  return _then(_OrphanedRecord(
tableName: null == tableName ? _self.tableName : tableName // ignore: cast_nullable_to_non_nullable
as String,primaryKeyField: null == primaryKeyField ? _self.primaryKeyField : primaryKeyField // ignore: cast_nullable_to_non_nullable
as String,primaryKeyValue: freezed == primaryKeyValue ? _self.primaryKeyValue : primaryKeyValue // ignore: cast_nullable_to_non_nullable
as dynamic,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as String,recordData: freezed == recordData ? _self._recordData : recordData // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$DuplicateRecord {

/// è¡¨å
 String get tableName;/// é‡å¤çš„å­—æ®µç»„å? List<String> get duplicateFields;/// é‡å¤çš„å€? Map<String, dynamic> get duplicateValues;/// é‡å¤è®°å½•çš„æ•°é‡? int get duplicateCount;/// é‡å¤è®°å½•çš„ä¸»é”®åˆ—è¡? List<dynamic> get duplicatePrimaryKeys;
/// Create a copy of DuplicateRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DuplicateRecordCopyWith<DuplicateRecord> get copyWith => _$DuplicateRecordCopyWithImpl<DuplicateRecord>(this as DuplicateRecord, _$identity);

  /// Serializes this DuplicateRecord to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DuplicateRecord&&(identical(other.tableName, tableName) || other.tableName == tableName)&&const DeepCollectionEquality().equals(other.duplicateFields, duplicateFields)&&const DeepCollectionEquality().equals(other.duplicateValues, duplicateValues)&&(identical(other.duplicateCount, duplicateCount) || other.duplicateCount == duplicateCount)&&const DeepCollectionEquality().equals(other.duplicatePrimaryKeys, duplicatePrimaryKeys));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tableName,const DeepCollectionEquality().hash(duplicateFields),const DeepCollectionEquality().hash(duplicateValues),duplicateCount,const DeepCollectionEquality().hash(duplicatePrimaryKeys));

@override
String toString() {
  return 'DuplicateRecord(tableName: $tableName, duplicateFields: $duplicateFields, duplicateValues: $duplicateValues, duplicateCount: $duplicateCount, duplicatePrimaryKeys: $duplicatePrimaryKeys)';
}


}

/// @nodoc
abstract mixin class $DuplicateRecordCopyWith<$Res>  {
  factory $DuplicateRecordCopyWith(DuplicateRecord value, $Res Function(DuplicateRecord) _then) = _$DuplicateRecordCopyWithImpl;
@useResult
$Res call({
 String tableName, List<String> duplicateFields, Map<String, dynamic> duplicateValues, int duplicateCount, List<dynamic> duplicatePrimaryKeys
});




}
/// @nodoc
class _$DuplicateRecordCopyWithImpl<$Res>
    implements $DuplicateRecordCopyWith<$Res> {
  _$DuplicateRecordCopyWithImpl(this._self, this._then);

  final DuplicateRecord _self;
  final $Res Function(DuplicateRecord) _then;

/// Create a copy of DuplicateRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tableName = null,Object? duplicateFields = null,Object? duplicateValues = null,Object? duplicateCount = null,Object? duplicatePrimaryKeys = null,}) {
  return _then(_self.copyWith(
tableName: null == tableName ? _self.tableName : tableName // ignore: cast_nullable_to_non_nullable
as String,duplicateFields: null == duplicateFields ? _self.duplicateFields : duplicateFields // ignore: cast_nullable_to_non_nullable
as List<String>,duplicateValues: null == duplicateValues ? _self.duplicateValues : duplicateValues // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,duplicateCount: null == duplicateCount ? _self.duplicateCount : duplicateCount // ignore: cast_nullable_to_non_nullable
as int,duplicatePrimaryKeys: null == duplicatePrimaryKeys ? _self.duplicatePrimaryKeys : duplicatePrimaryKeys // ignore: cast_nullable_to_non_nullable
as List<dynamic>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _DuplicateRecord implements DuplicateRecord {
  const _DuplicateRecord({required this.tableName, required final  List<String> duplicateFields, required final  Map<String, dynamic> duplicateValues, required this.duplicateCount, final  List<dynamic> duplicatePrimaryKeys = const []}): _duplicateFields = duplicateFields,_duplicateValues = duplicateValues,_duplicatePrimaryKeys = duplicatePrimaryKeys;
  factory _DuplicateRecord.fromJson(Map<String, dynamic> json) => _$DuplicateRecordFromJson(json);

/// è¡¨å
@override final  String tableName;
/// é‡å¤çš„å­—æ®µç»„å? final  List<String> _duplicateFields;
/// é‡å¤çš„å­—æ®µç»„å?@override List<String> get duplicateFields {
  if (_duplicateFields is EqualUnmodifiableListView) return _duplicateFields;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_duplicateFields);
}

/// é‡å¤çš„å€? final  Map<String, dynamic> _duplicateValues;
/// é‡å¤çš„å€?@override Map<String, dynamic> get duplicateValues {
  if (_duplicateValues is EqualUnmodifiableMapView) return _duplicateValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_duplicateValues);
}

/// é‡å¤è®°å½•çš„æ•°é‡?@override final  int duplicateCount;
/// é‡å¤è®°å½•çš„ä¸»é”®åˆ—è¡? final  List<dynamic> _duplicatePrimaryKeys;
/// é‡å¤è®°å½•çš„ä¸»é”®åˆ—è¡?@override@JsonKey() List<dynamic> get duplicatePrimaryKeys {
  if (_duplicatePrimaryKeys is EqualUnmodifiableListView) return _duplicatePrimaryKeys;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_duplicatePrimaryKeys);
}


/// Create a copy of DuplicateRecord
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DuplicateRecordCopyWith<_DuplicateRecord> get copyWith => __$DuplicateRecordCopyWithImpl<_DuplicateRecord>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DuplicateRecordToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DuplicateRecord&&(identical(other.tableName, tableName) || other.tableName == tableName)&&const DeepCollectionEquality().equals(other._duplicateFields, _duplicateFields)&&const DeepCollectionEquality().equals(other._duplicateValues, _duplicateValues)&&(identical(other.duplicateCount, duplicateCount) || other.duplicateCount == duplicateCount)&&const DeepCollectionEquality().equals(other._duplicatePrimaryKeys, _duplicatePrimaryKeys));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tableName,const DeepCollectionEquality().hash(_duplicateFields),const DeepCollectionEquality().hash(_duplicateValues),duplicateCount,const DeepCollectionEquality().hash(_duplicatePrimaryKeys));

@override
String toString() {
  return 'DuplicateRecord(tableName: $tableName, duplicateFields: $duplicateFields, duplicateValues: $duplicateValues, duplicateCount: $duplicateCount, duplicatePrimaryKeys: $duplicatePrimaryKeys)';
}


}

/// @nodoc
abstract mixin class _$DuplicateRecordCopyWith<$Res> implements $DuplicateRecordCopyWith<$Res> {
  factory _$DuplicateRecordCopyWith(_DuplicateRecord value, $Res Function(_DuplicateRecord) _then) = __$DuplicateRecordCopyWithImpl;
@override @useResult
$Res call({
 String tableName, List<String> duplicateFields, Map<String, dynamic> duplicateValues, int duplicateCount, List<dynamic> duplicatePrimaryKeys
});




}
/// @nodoc
class __$DuplicateRecordCopyWithImpl<$Res>
    implements _$DuplicateRecordCopyWith<$Res> {
  __$DuplicateRecordCopyWithImpl(this._self, this._then);

  final _DuplicateRecord _self;
  final $Res Function(_DuplicateRecord) _then;

/// Create a copy of DuplicateRecord
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tableName = null,Object? duplicateFields = null,Object? duplicateValues = null,Object? duplicateCount = null,Object? duplicatePrimaryKeys = null,}) {
  return _then(_DuplicateRecord(
tableName: null == tableName ? _self.tableName : tableName // ignore: cast_nullable_to_non_nullable
as String,duplicateFields: null == duplicateFields ? _self._duplicateFields : duplicateFields // ignore: cast_nullable_to_non_nullable
as List<String>,duplicateValues: null == duplicateValues ? _self._duplicateValues : duplicateValues // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,duplicateCount: null == duplicateCount ? _self.duplicateCount : duplicateCount // ignore: cast_nullable_to_non_nullable
as int,duplicatePrimaryKeys: null == duplicatePrimaryKeys ? _self._duplicatePrimaryKeys : duplicatePrimaryKeys // ignore: cast_nullable_to_non_nullable
as List<dynamic>,
  ));
}


}


/// @nodoc
mixin _$IntegrityStatistics {

/// æ€»è®°å½•æ•°
 int get totalRecords;/// æœ‰æ•ˆè®°å½•æ•? int get validRecords;/// æ— æ•ˆè®°å½•æ•? int get invalidRecords;/// ç¼ºå¤±å…³è”è®°å½•æ•? int get missingRelationshipCount;/// å­¤ç«‹è®°å½•æ•? int get orphanedRecordCount;/// é‡å¤è®°å½•æ•? int get duplicateRecordCount;/// å„è¡¨è®°å½•ç»Ÿè®¡
 Map<String, int> get tableRecordCounts;/// å„è¡¨æœ‰æ•ˆè®°å½•ç»Ÿè®¡
 Map<String, int> get tableValidRecordCounts;
/// Create a copy of IntegrityStatistics
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$IntegrityStatisticsCopyWith<IntegrityStatistics> get copyWith => _$IntegrityStatisticsCopyWithImpl<IntegrityStatistics>(this as IntegrityStatistics, _$identity);

  /// Serializes this IntegrityStatistics to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is IntegrityStatistics&&(identical(other.totalRecords, totalRecords) || other.totalRecords == totalRecords)&&(identical(other.validRecords, validRecords) || other.validRecords == validRecords)&&(identical(other.invalidRecords, invalidRecords) || other.invalidRecords == invalidRecords)&&(identical(other.missingRelationshipCount, missingRelationshipCount) || other.missingRelationshipCount == missingRelationshipCount)&&(identical(other.orphanedRecordCount, orphanedRecordCount) || other.orphanedRecordCount == orphanedRecordCount)&&(identical(other.duplicateRecordCount, duplicateRecordCount) || other.duplicateRecordCount == duplicateRecordCount)&&const DeepCollectionEquality().equals(other.tableRecordCounts, tableRecordCounts)&&const DeepCollectionEquality().equals(other.tableValidRecordCounts, tableValidRecordCounts));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,totalRecords,validRecords,invalidRecords,missingRelationshipCount,orphanedRecordCount,duplicateRecordCount,const DeepCollectionEquality().hash(tableRecordCounts),const DeepCollectionEquality().hash(tableValidRecordCounts));

@override
String toString() {
  return 'IntegrityStatistics(totalRecords: $totalRecords, validRecords: $validRecords, invalidRecords: $invalidRecords, missingRelationshipCount: $missingRelationshipCount, orphanedRecordCount: $orphanedRecordCount, duplicateRecordCount: $duplicateRecordCount, tableRecordCounts: $tableRecordCounts, tableValidRecordCounts: $tableValidRecordCounts)';
}


}

/// @nodoc
abstract mixin class $IntegrityStatisticsCopyWith<$Res>  {
  factory $IntegrityStatisticsCopyWith(IntegrityStatistics value, $Res Function(IntegrityStatistics) _then) = _$IntegrityStatisticsCopyWithImpl;
@useResult
$Res call({
 int totalRecords, int validRecords, int invalidRecords, int missingRelationshipCount, int orphanedRecordCount, int duplicateRecordCount, Map<String, int> tableRecordCounts, Map<String, int> tableValidRecordCounts
});




}
/// @nodoc
class _$IntegrityStatisticsCopyWithImpl<$Res>
    implements $IntegrityStatisticsCopyWith<$Res> {
  _$IntegrityStatisticsCopyWithImpl(this._self, this._then);

  final IntegrityStatistics _self;
  final $Res Function(IntegrityStatistics) _then;

/// Create a copy of IntegrityStatistics
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? totalRecords = null,Object? validRecords = null,Object? invalidRecords = null,Object? missingRelationshipCount = null,Object? orphanedRecordCount = null,Object? duplicateRecordCount = null,Object? tableRecordCounts = null,Object? tableValidRecordCounts = null,}) {
  return _then(_self.copyWith(
totalRecords: null == totalRecords ? _self.totalRecords : totalRecords // ignore: cast_nullable_to_non_nullable
as int,validRecords: null == validRecords ? _self.validRecords : validRecords // ignore: cast_nullable_to_non_nullable
as int,invalidRecords: null == invalidRecords ? _self.invalidRecords : invalidRecords // ignore: cast_nullable_to_non_nullable
as int,missingRelationshipCount: null == missingRelationshipCount ? _self.missingRelationshipCount : missingRelationshipCount // ignore: cast_nullable_to_non_nullable
as int,orphanedRecordCount: null == orphanedRecordCount ? _self.orphanedRecordCount : orphanedRecordCount // ignore: cast_nullable_to_non_nullable
as int,duplicateRecordCount: null == duplicateRecordCount ? _self.duplicateRecordCount : duplicateRecordCount // ignore: cast_nullable_to_non_nullable
as int,tableRecordCounts: null == tableRecordCounts ? _self.tableRecordCounts : tableRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,tableValidRecordCounts: null == tableValidRecordCounts ? _self.tableValidRecordCounts : tableValidRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _IntegrityStatistics implements IntegrityStatistics {
  const _IntegrityStatistics({required this.totalRecords, required this.validRecords, required this.invalidRecords, required this.missingRelationshipCount, required this.orphanedRecordCount, required this.duplicateRecordCount, required final  Map<String, int> tableRecordCounts, required final  Map<String, int> tableValidRecordCounts}): _tableRecordCounts = tableRecordCounts,_tableValidRecordCounts = tableValidRecordCounts;
  factory _IntegrityStatistics.fromJson(Map<String, dynamic> json) => _$IntegrityStatisticsFromJson(json);

/// æ€»è®°å½•æ•°
@override final  int totalRecords;
/// æœ‰æ•ˆè®°å½•æ•?@override final  int validRecords;
/// æ— æ•ˆè®°å½•æ•?@override final  int invalidRecords;
/// ç¼ºå¤±å…³è”è®°å½•æ•?@override final  int missingRelationshipCount;
/// å­¤ç«‹è®°å½•æ•?@override final  int orphanedRecordCount;
/// é‡å¤è®°å½•æ•?@override final  int duplicateRecordCount;
/// å„è¡¨è®°å½•ç»Ÿè®¡
 final  Map<String, int> _tableRecordCounts;
/// å„è¡¨è®°å½•ç»Ÿè®¡
@override Map<String, int> get tableRecordCounts {
  if (_tableRecordCounts is EqualUnmodifiableMapView) return _tableRecordCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableRecordCounts);
}

/// å„è¡¨æœ‰æ•ˆè®°å½•ç»Ÿè®¡
 final  Map<String, int> _tableValidRecordCounts;
/// å„è¡¨æœ‰æ•ˆè®°å½•ç»Ÿè®¡
@override Map<String, int> get tableValidRecordCounts {
  if (_tableValidRecordCounts is EqualUnmodifiableMapView) return _tableValidRecordCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableValidRecordCounts);
}


/// Create a copy of IntegrityStatistics
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$IntegrityStatisticsCopyWith<_IntegrityStatistics> get copyWith => __$IntegrityStatisticsCopyWithImpl<_IntegrityStatistics>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$IntegrityStatisticsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _IntegrityStatistics&&(identical(other.totalRecords, totalRecords) || other.totalRecords == totalRecords)&&(identical(other.validRecords, validRecords) || other.validRecords == validRecords)&&(identical(other.invalidRecords, invalidRecords) || other.invalidRecords == invalidRecords)&&(identical(other.missingRelationshipCount, missingRelationshipCount) || other.missingRelationshipCount == missingRelationshipCount)&&(identical(other.orphanedRecordCount, orphanedRecordCount) || other.orphanedRecordCount == orphanedRecordCount)&&(identical(other.duplicateRecordCount, duplicateRecordCount) || other.duplicateRecordCount == duplicateRecordCount)&&const DeepCollectionEquality().equals(other._tableRecordCounts, _tableRecordCounts)&&const DeepCollectionEquality().equals(other._tableValidRecordCounts, _tableValidRecordCounts));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,totalRecords,validRecords,invalidRecords,missingRelationshipCount,orphanedRecordCount,duplicateRecordCount,const DeepCollectionEquality().hash(_tableRecordCounts),const DeepCollectionEquality().hash(_tableValidRecordCounts));

@override
String toString() {
  return 'IntegrityStatistics(totalRecords: $totalRecords, validRecords: $validRecords, invalidRecords: $invalidRecords, missingRelationshipCount: $missingRelationshipCount, orphanedRecordCount: $orphanedRecordCount, duplicateRecordCount: $duplicateRecordCount, tableRecordCounts: $tableRecordCounts, tableValidRecordCounts: $tableValidRecordCounts)';
}


}

/// @nodoc
abstract mixin class _$IntegrityStatisticsCopyWith<$Res> implements $IntegrityStatisticsCopyWith<$Res> {
  factory _$IntegrityStatisticsCopyWith(_IntegrityStatistics value, $Res Function(_IntegrityStatistics) _then) = __$IntegrityStatisticsCopyWithImpl;
@override @useResult
$Res call({
 int totalRecords, int validRecords, int invalidRecords, int missingRelationshipCount, int orphanedRecordCount, int duplicateRecordCount, Map<String, int> tableRecordCounts, Map<String, int> tableValidRecordCounts
});




}
/// @nodoc
class __$IntegrityStatisticsCopyWithImpl<$Res>
    implements _$IntegrityStatisticsCopyWith<$Res> {
  __$IntegrityStatisticsCopyWithImpl(this._self, this._then);

  final _IntegrityStatistics _self;
  final $Res Function(_IntegrityStatistics) _then;

/// Create a copy of IntegrityStatistics
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? totalRecords = null,Object? validRecords = null,Object? invalidRecords = null,Object? missingRelationshipCount = null,Object? orphanedRecordCount = null,Object? duplicateRecordCount = null,Object? tableRecordCounts = null,Object? tableValidRecordCounts = null,}) {
  return _then(_IntegrityStatistics(
totalRecords: null == totalRecords ? _self.totalRecords : totalRecords // ignore: cast_nullable_to_non_nullable
as int,validRecords: null == validRecords ? _self.validRecords : validRecords // ignore: cast_nullable_to_non_nullable
as int,invalidRecords: null == invalidRecords ? _self.invalidRecords : invalidRecords // ignore: cast_nullable_to_non_nullable
as int,missingRelationshipCount: null == missingRelationshipCount ? _self.missingRelationshipCount : missingRelationshipCount // ignore: cast_nullable_to_non_nullable
as int,orphanedRecordCount: null == orphanedRecordCount ? _self.orphanedRecordCount : orphanedRecordCount // ignore: cast_nullable_to_non_nullable
as int,duplicateRecordCount: null == duplicateRecordCount ? _self.duplicateRecordCount : duplicateRecordCount // ignore: cast_nullable_to_non_nullable
as int,tableRecordCounts: null == tableRecordCounts ? _self._tableRecordCounts : tableRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,tableValidRecordCounts: null == tableValidRecordCounts ? _self._tableValidRecordCounts : tableValidRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'integrity_check_result.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_IntegrityCheckResult _$IntegrityCheckResultFromJson(
  Map<String, dynamic> json,
) => _IntegrityCheckResult(
  isIntegrityValid: json['isIntegrityValid'] as bool,
  checksumValid: json['checksumValid'] as bool,
  relationshipIntegrityValid: json['relationshipIntegrityValid'] as bool,
  tableIntegrityResults: Map<String, bool>.from(
    json['tableIntegrityResults'] as Map,
  ),
  missingRelationships:
      (json['missingRelationships'] as List<dynamic>?)
          ?.map((e) => MissingRelationship.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
  orphanedRecords:
      (json['orphanedRecords'] as List<dynamic>?)
          ?.map((e) => OrphanedRecord.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
  duplicateRecords:
      (json['duplicateRecords'] as List<dynamic>?)
          ?.map((e) => DuplicateRecord.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
  statistics: IntegrityStatistics.fromJson(
    json['statistics'] as Map<String, dynamic>,
  ),
  detailedResults:
      (json['detailedResults'] as List<dynamic>?)
          ?.map((e) => ValidationResult.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const [],
);

Map<String, dynamic> _$IntegrityCheckResultToJson(
  _IntegrityCheckResult instance,
) => <String, dynamic>{
  'isIntegrityValid': instance.isIntegrityValid,
  'checksumValid': instance.checksumValid,
  'relationshipIntegrityValid': instance.relationshipIntegrityValid,
  'tableIntegrityResults': instance.tableIntegrityResults,
  'missingRelationships': instance.missingRelationships,
  'orphanedRecords': instance.orphanedRecords,
  'duplicateRecords': instance.duplicateRecords,
  'statistics': instance.statistics,
  'detailedResults': instance.detailedResults,
};

_MissingRelationship _$MissingRelationshipFromJson(Map<String, dynamic> json) =>
    _MissingRelationship(
      sourceTable: json['sourceTable'] as String,
      targetTable: json['targetTable'] as String,
      foreignKeyField: json['foreignKeyField'] as String,
      missingValue: json['missingValue'],
      affectedRecordCount: (json['affectedRecordCount'] as num).toInt(),
    );

Map<String, dynamic> _$MissingRelationshipToJson(
  _MissingRelationship instance,
) => <String, dynamic>{
  'sourceTable': instance.sourceTable,
  'targetTable': instance.targetTable,
  'foreignKeyField': instance.foreignKeyField,
  'missingValue': instance.missingValue,
  'affectedRecordCount': instance.affectedRecordCount,
};

_OrphanedRecord _$OrphanedRecordFromJson(Map<String, dynamic> json) =>
    _OrphanedRecord(
      tableName: json['tableName'] as String,
      primaryKeyField: json['primaryKeyField'] as String,
      primaryKeyValue: json['primaryKeyValue'],
      reason: json['reason'] as String,
      recordData: json['recordData'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$OrphanedRecordToJson(_OrphanedRecord instance) =>
    <String, dynamic>{
      'tableName': instance.tableName,
      'primaryKeyField': instance.primaryKeyField,
      'primaryKeyValue': instance.primaryKeyValue,
      'reason': instance.reason,
      'recordData': instance.recordData,
    };

_DuplicateRecord _$DuplicateRecordFromJson(Map<String, dynamic> json) =>
    _DuplicateRecord(
      tableName: json['tableName'] as String,
      duplicateFields: (json['duplicateFields'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      duplicateValues: json['duplicateValues'] as Map<String, dynamic>,
      duplicateCount: (json['duplicateCount'] as num).toInt(),
      duplicatePrimaryKeys:
          json['duplicatePrimaryKeys'] as List<dynamic>? ?? const [],
    );

Map<String, dynamic> _$DuplicateRecordToJson(_DuplicateRecord instance) =>
    <String, dynamic>{
      'tableName': instance.tableName,
      'duplicateFields': instance.duplicateFields,
      'duplicateValues': instance.duplicateValues,
      'duplicateCount': instance.duplicateCount,
      'duplicatePrimaryKeys': instance.duplicatePrimaryKeys,
    };

_IntegrityStatistics _$IntegrityStatisticsFromJson(
  Map<String, dynamic> json,
) => _IntegrityStatistics(
  totalRecords: (json['totalRecords'] as num).toInt(),
  validRecords: (json['validRecords'] as num).toInt(),
  invalidRecords: (json['invalidRecords'] as num).toInt(),
  missingRelationshipCount: (json['missingRelationshipCount'] as num).toInt(),
  orphanedRecordCount: (json['orphanedRecordCount'] as num).toInt(),
  duplicateRecordCount: (json['duplicateRecordCount'] as num).toInt(),
  tableRecordCounts: Map<String, int>.from(json['tableRecordCounts'] as Map),
  tableValidRecordCounts: Map<String, int>.from(
    json['tableValidRecordCounts'] as Map,
  ),
);

Map<String, dynamic> _$IntegrityStatisticsToJson(
  _IntegrityStatistics instance,
) => <String, dynamic>{
  'totalRecords': instance.totalRecords,
  'validRecords': instance.validRecords,
  'invalidRecords': instance.invalidRecords,
  'missingRelationshipCount': instance.missingRelationshipCount,
  'orphanedRecordCount': instance.orphanedRecordCount,
  'duplicateRecordCount': instance.duplicateRecordCount,
  'tableRecordCounts': instance.tableRecordCounts,
  'tableValidRecordCounts': instance.tableValidRecordCounts,
};
// å¤‡ä»½åŠŸèƒ½ç›¸å…³çš„æ•°æ®æ¨¡å‹å¯¼å‡ºæ–‡ä»?

export 'backup_data.dart';
export 'backup_error_type.dart';
export 'backup_exception.dart';
export 'backup_metadata.dart';
export 'backup_options.dart';
export 'backup_result.dart';
export 'restore_mode.dart';
export 'restore_preview.dart';
export 'restore_result.dart';
/// æ€§èƒ½æŒ‡æ ‡æ•°æ®æ¨¡å‹
class PerformanceMetrics {
  final DateTime startTime;
  final DateTime endTime;
  final int totalRecords;
  final int processedRecords;
  final int memoryUsageBytes;
  final int peakMemoryUsageBytes;
  final double processingRatePerSecond;
  final int compressionRatio;
  final int streamBufferSize;
  final Map<String, dynamic>? additionalMetrics;

  const PerformanceMetrics({
    required this.startTime,
    required this.endTime,
    required this.totalRecords,
    required this.processedRecords,
    required this.memoryUsageBytes,
    required this.peakMemoryUsageBytes,
    required this.processingRatePerSecond,
    this.compressionRatio = 0,
    this.streamBufferSize = 0,
    this.additionalMetrics,
  });

  factory PerformanceMetrics.fromJson(Map<String, dynamic> json) {
    return PerformanceMetrics(
      startTime: DateTime.parse(json['startTime'] as String),
      endTime: DateTime.parse(json['endTime'] as String),
      totalRecords: json['totalRecords'] as int,
      processedRecords: json['processedRecords'] as int,
      memoryUsageBytes: json['memoryUsageBytes'] as int,
      peakMemoryUsageBytes: json['peakMemoryUsageBytes'] as int,
      processingRatePerSecond: (json['processingRatePerSecond'] as num).toDouble(),
      compressionRatio: json['compressionRatio'] as int? ?? 0,
      streamBufferSize: json['streamBufferSize'] as int? ?? 0,
      additionalMetrics: json['additionalMetrics'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startTime': startTime.toIso8601String(),
      'endTime': endTime.toIso8601String(),
      'totalRecords': totalRecords,
      'processedRecords': processedRecords,
      'memoryUsageBytes': memoryUsageBytes,
      'peakMemoryUsageBytes': peakMemoryUsageBytes,
      'processingRatePerSecond': processingRatePerSecond,
      'compressionRatio': compressionRatio,
      'streamBufferSize': streamBufferSize,
      'additionalMetrics': additionalMetrics,
    };
  }

  /// è®¡ç®—æ€»è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
  int get durationMs => endTime.difference(startTime).inMilliseconds;

  /// è®¡ç®—æ€»è€—æ—¶ï¼ˆç§’ï¼?
  double get durationSeconds => durationMs / 1000.0;

  /// è®¡ç®—å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼?
  double get memoryUsageMB => memoryUsageBytes / (1024 * 1024);

  /// è®¡ç®—å³°å€¼å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼?
  double get peakMemoryUsageMB => peakMemoryUsageBytes / (1024 * 1024);

  /// è®¡ç®—å®Œæˆç™¾åˆ†æ¯?
  double get completionPercentage => 
      totalRecords > 0 ? (processedRecords / totalRecords) * 100 : 0;
}

/// æµå¼å¤„ç†é…ç½®
class StreamProcessingConfig {
  final int batchSize;
  final int bufferSize;
  final int maxMemoryUsage; // 50MB
  final bool enableCompression;
  final int compressionLevel;
  final bool enableMemoryMonitoring;
  final int memoryCheckIntervalMs;

  const StreamProcessingConfig({
    this.batchSize = 1000,
    this.bufferSize = 8192,
    this.maxMemoryUsage = 50 * 1024 * 1024, // 50MB
    this.enableCompression = true,
    this.compressionLevel = 6,
    this.enableMemoryMonitoring = true,
    this.memoryCheckIntervalMs = 5000,
  });

  factory StreamProcessingConfig.fromJson(Map<String, dynamic> json) {
    return StreamProcessingConfig(
      batchSize: json['batchSize'] as int? ?? 1000,
      bufferSize: json['bufferSize'] as int? ?? 8192,
      maxMemoryUsage: json['maxMemoryUsage'] as int? ?? 50 * 1024 * 1024,
      enableCompression: json['enableCompression'] as bool? ?? true,
      compressionLevel: json['compressionLevel'] as int? ?? 6,
      enableMemoryMonitoring: json['enableMemoryMonitoring'] as bool? ?? true,
      memoryCheckIntervalMs: json['memoryCheckIntervalMs'] as int? ?? 5000,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'batchSize': batchSize,
      'bufferSize': bufferSize,
      'maxMemoryUsage': maxMemoryUsage,
      'enableCompression': enableCompression,
      'compressionLevel': compressionLevel,
      'enableMemoryMonitoring': enableMemoryMonitoring,
      'memoryCheckIntervalMs': memoryCheckIntervalMs,
    };
  }
}

/// å†…å­˜ä½¿ç”¨æƒ…å†µ
class MemoryUsage {
  final int currentBytes;
  final int peakBytes;
  final DateTime timestamp;
  final int availableBytes;
  final int gcCount;

  const MemoryUsage({
    required this.currentBytes,
    required this.peakBytes,
    required this.timestamp,
    this.availableBytes = 0,
    this.gcCount = 0,
  });

  factory MemoryUsage.fromJson(Map<String, dynamic> json) {
    return MemoryUsage(
      currentBytes: json['currentBytes'] as int,
      peakBytes: json['peakBytes'] as int,
      timestamp: DateTime.parse(json['timestamp'] as String),
      availableBytes: json['availableBytes'] as int? ?? 0,
      gcCount: json['gcCount'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'currentBytes': currentBytes,
      'peakBytes': peakBytes,
      'timestamp': timestamp.toIso8601String(),
      'availableBytes': availableBytes,
      'gcCount': gcCount,
    };
  }

  /// å½“å‰å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼?
  double get currentMB => currentBytes / (1024 * 1024);

  /// å³°å€¼å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼?
  double get peakMB => peakBytes / (1024 * 1024);

  /// å¯ç”¨å†…å­˜ï¼ˆMBï¼?
  double get availableMB => availableBytes / (1024 * 1024);
}

/// å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
class CompressionStats {
  final int originalSize;
  final int compressedSize;
  final double compressionRatio;
  final Duration compressionTime;
  final String algorithm;

  const CompressionStats({
    required this.originalSize,
    required this.compressedSize,
    required this.compressionRatio,
    required this.compressionTime,
    required this.algorithm,
  });

  factory CompressionStats.fromJson(Map<String, dynamic> json) {
    return CompressionStats(
      originalSize: json['originalSize'] as int,
      compressedSize: json['compressedSize'] as int,
      compressionRatio: (json['compressionRatio'] as num).toDouble(),
      compressionTime: Duration(milliseconds: json['compressionTimeMs'] as int),
      algorithm: json['algorithm'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'originalSize': originalSize,
      'compressedSize': compressedSize,
      'compressionRatio': compressionRatio,
      'compressionTimeMs': compressionTime.inMilliseconds,
      'algorithm': algorithm,
    };
  }

  /// å‹ç¼©èŠ‚çœçš„ç©ºé—´ï¼ˆå­—èŠ‚ï¼?
  int get spaceSaved => originalSize - compressedSize;

  /// å‹ç¼©èŠ‚çœçš„ç©ºé—´ï¼ˆMBï¼?
  double get spaceSavedMB => spaceSaved / (1024 * 1024);

  /// å‹ç¼©æ•ˆç‡ï¼ˆæ¯ç§’å¤„ç†çš„å­—èŠ‚æ•°ï¼‰
  double get compressionSpeed => 
      compressionTime.inMilliseconds > 0 
          ? originalSize / (compressionTime.inMilliseconds / 1000.0)
          : 0;
}
/// æ•°æ®æ¢å¤æ¨¡å¼
enum RestoreMode {
  /// å®Œå…¨æ›¿æ¢ç°æœ‰æ•°æ®
  replace,
  
  /// åˆå¹¶æ•°æ®ï¼ˆä¿ç•™ç°æœ‰æ•°æ®ï¼Œæ·»åŠ æ–°æ•°æ®ï¼‰
  merge,
  
  /// ä»…æ·»åŠ ä¸å­˜åœ¨çš„æ•°æ?
  addOnly,
}
import 'package:freezed_annotation/freezed_annotation.dart';
import 'backup_metadata.dart';

part 'restore_preview.freezed.dart';
part 'restore_preview.g.dart';

/// æ¢å¤é¢„è§ˆä¿¡æ¯
@freezed
abstract class RestorePreview with _$RestorePreview {
  const factory RestorePreview({
    /// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ?
    required BackupMetadata metadata,
    /// å„è¡¨å°†è¦æ¢å¤çš„è®°å½•æ•°
    required Map<String, int> recordCounts,
    /// å½“å‰æ•°æ®åº“å„è¡¨çš„è®°å½•æ•?
    @Default({}) Map<String, int> currentDatabaseCounts,
    /// é¢„è®¡çš„æ•°æ®å†²çªæ•°é‡?
    @Default(0) int estimatedConflicts,
    /// å…¼å®¹æ€§æ£€æŸ¥ç»“æ?
    required bool isCompatible,
    /// å…¼å®¹æ€§è­¦å‘Šä¿¡æ?
    @Default([]) List<String> compatibilityWarnings,
    /// é¢„è®¡æ¢å¤æ—¶é—´ï¼ˆç§’ï¼?
    int? estimatedDurationSeconds,
  }) = _RestorePreview;

  factory RestorePreview.fromJson(Map<String, dynamic> json) =>
      _$RestorePreviewFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'restore_preview.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$RestorePreview {

/// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ? BackupMetadata get metadata;/// å„è¡¨å°†è¦æ¢å¤çš„è®°å½•æ•°
 Map<String, int> get recordCounts;/// å½“å‰æ•°æ®åº“å„è¡¨çš„è®°å½•æ•? Map<String, int> get currentDatabaseCounts;/// é¢„è®¡çš„æ•°æ®å†²çªæ•°é‡? int get estimatedConflicts;/// å…¼å®¹æ€§æ£€æŸ¥ç»“æ? bool get isCompatible;/// å…¼å®¹æ€§è­¦å‘Šä¿¡æ? List<String> get compatibilityWarnings;/// é¢„è®¡æ¢å¤æ—¶é—´ï¼ˆç§’ï¼? int? get estimatedDurationSeconds;
/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RestorePreviewCopyWith<RestorePreview> get copyWith => _$RestorePreviewCopyWithImpl<RestorePreview>(this as RestorePreview, _$identity);

  /// Serializes this RestorePreview to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RestorePreview&&(identical(other.metadata, metadata) || other.metadata == metadata)&&const DeepCollectionEquality().equals(other.recordCounts, recordCounts)&&const DeepCollectionEquality().equals(other.currentDatabaseCounts, currentDatabaseCounts)&&(identical(other.estimatedConflicts, estimatedConflicts) || other.estimatedConflicts == estimatedConflicts)&&(identical(other.isCompatible, isCompatible) || other.isCompatible == isCompatible)&&const DeepCollectionEquality().equals(other.compatibilityWarnings, compatibilityWarnings)&&(identical(other.estimatedDurationSeconds, estimatedDurationSeconds) || other.estimatedDurationSeconds == estimatedDurationSeconds));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,metadata,const DeepCollectionEquality().hash(recordCounts),const DeepCollectionEquality().hash(currentDatabaseCounts),estimatedConflicts,isCompatible,const DeepCollectionEquality().hash(compatibilityWarnings),estimatedDurationSeconds);

@override
String toString() {
  return 'RestorePreview(metadata: $metadata, recordCounts: $recordCounts, currentDatabaseCounts: $currentDatabaseCounts, estimatedConflicts: $estimatedConflicts, isCompatible: $isCompatible, compatibilityWarnings: $compatibilityWarnings, estimatedDurationSeconds: $estimatedDurationSeconds)';
}


}

/// @nodoc
abstract mixin class $RestorePreviewCopyWith<$Res>  {
  factory $RestorePreviewCopyWith(RestorePreview value, $Res Function(RestorePreview) _then) = _$RestorePreviewCopyWithImpl;
@useResult
$Res call({
 BackupMetadata metadata, Map<String, int> recordCounts, Map<String, int> currentDatabaseCounts, int estimatedConflicts, bool isCompatible, List<String> compatibilityWarnings, int? estimatedDurationSeconds
});


$BackupMetadataCopyWith<$Res> get metadata;

}
/// @nodoc
class _$RestorePreviewCopyWithImpl<$Res>
    implements $RestorePreviewCopyWith<$Res> {
  _$RestorePreviewCopyWithImpl(this._self, this._then);

  final RestorePreview _self;
  final $Res Function(RestorePreview) _then;

/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? metadata = null,Object? recordCounts = null,Object? currentDatabaseCounts = null,Object? estimatedConflicts = null,Object? isCompatible = null,Object? compatibilityWarnings = null,Object? estimatedDurationSeconds = freezed,}) {
  return _then(_self.copyWith(
metadata: null == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata,recordCounts: null == recordCounts ? _self.recordCounts : recordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,currentDatabaseCounts: null == currentDatabaseCounts ? _self.currentDatabaseCounts : currentDatabaseCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,estimatedConflicts: null == estimatedConflicts ? _self.estimatedConflicts : estimatedConflicts // ignore: cast_nullable_to_non_nullable
as int,isCompatible: null == isCompatible ? _self.isCompatible : isCompatible // ignore: cast_nullable_to_non_nullable
as bool,compatibilityWarnings: null == compatibilityWarnings ? _self.compatibilityWarnings : compatibilityWarnings // ignore: cast_nullable_to_non_nullable
as List<String>,estimatedDurationSeconds: freezed == estimatedDurationSeconds ? _self.estimatedDurationSeconds : estimatedDurationSeconds // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}
/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res> get metadata {
  
  return $BackupMetadataCopyWith<$Res>(_self.metadata, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}


/// @nodoc
@JsonSerializable()

class _RestorePreview implements RestorePreview {
  const _RestorePreview({required this.metadata, required final  Map<String, int> recordCounts, final  Map<String, int> currentDatabaseCounts = const {}, this.estimatedConflicts = 0, required this.isCompatible, final  List<String> compatibilityWarnings = const [], this.estimatedDurationSeconds}): _recordCounts = recordCounts,_currentDatabaseCounts = currentDatabaseCounts,_compatibilityWarnings = compatibilityWarnings;
  factory _RestorePreview.fromJson(Map<String, dynamic> json) => _$RestorePreviewFromJson(json);

/// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ?@override final  BackupMetadata metadata;
/// å„è¡¨å°†è¦æ¢å¤çš„è®°å½•æ•°
 final  Map<String, int> _recordCounts;
/// å„è¡¨å°†è¦æ¢å¤çš„è®°å½•æ•°
@override Map<String, int> get recordCounts {
  if (_recordCounts is EqualUnmodifiableMapView) return _recordCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_recordCounts);
}

/// å½“å‰æ•°æ®åº“å„è¡¨çš„è®°å½•æ•? final  Map<String, int> _currentDatabaseCounts;
/// å½“å‰æ•°æ®åº“å„è¡¨çš„è®°å½•æ•?@override@JsonKey() Map<String, int> get currentDatabaseCounts {
  if (_currentDatabaseCounts is EqualUnmodifiableMapView) return _currentDatabaseCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_currentDatabaseCounts);
}

/// é¢„è®¡çš„æ•°æ®å†²çªæ•°é‡?@override@JsonKey() final  int estimatedConflicts;
/// å…¼å®¹æ€§æ£€æŸ¥ç»“æ?@override final  bool isCompatible;
/// å…¼å®¹æ€§è­¦å‘Šä¿¡æ? final  List<String> _compatibilityWarnings;
/// å…¼å®¹æ€§è­¦å‘Šä¿¡æ?@override@JsonKey() List<String> get compatibilityWarnings {
  if (_compatibilityWarnings is EqualUnmodifiableListView) return _compatibilityWarnings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_compatibilityWarnings);
}

/// é¢„è®¡æ¢å¤æ—¶é—´ï¼ˆç§’ï¼?@override final  int? estimatedDurationSeconds;

/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RestorePreviewCopyWith<_RestorePreview> get copyWith => __$RestorePreviewCopyWithImpl<_RestorePreview>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RestorePreviewToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RestorePreview&&(identical(other.metadata, metadata) || other.metadata == metadata)&&const DeepCollectionEquality().equals(other._recordCounts, _recordCounts)&&const DeepCollectionEquality().equals(other._currentDatabaseCounts, _currentDatabaseCounts)&&(identical(other.estimatedConflicts, estimatedConflicts) || other.estimatedConflicts == estimatedConflicts)&&(identical(other.isCompatible, isCompatible) || other.isCompatible == isCompatible)&&const DeepCollectionEquality().equals(other._compatibilityWarnings, _compatibilityWarnings)&&(identical(other.estimatedDurationSeconds, estimatedDurationSeconds) || other.estimatedDurationSeconds == estimatedDurationSeconds));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,metadata,const DeepCollectionEquality().hash(_recordCounts),const DeepCollectionEquality().hash(_currentDatabaseCounts),estimatedConflicts,isCompatible,const DeepCollectionEquality().hash(_compatibilityWarnings),estimatedDurationSeconds);

@override
String toString() {
  return 'RestorePreview(metadata: $metadata, recordCounts: $recordCounts, currentDatabaseCounts: $currentDatabaseCounts, estimatedConflicts: $estimatedConflicts, isCompatible: $isCompatible, compatibilityWarnings: $compatibilityWarnings, estimatedDurationSeconds: $estimatedDurationSeconds)';
}


}

/// @nodoc
abstract mixin class _$RestorePreviewCopyWith<$Res> implements $RestorePreviewCopyWith<$Res> {
  factory _$RestorePreviewCopyWith(_RestorePreview value, $Res Function(_RestorePreview) _then) = __$RestorePreviewCopyWithImpl;
@override @useResult
$Res call({
 BackupMetadata metadata, Map<String, int> recordCounts, Map<String, int> currentDatabaseCounts, int estimatedConflicts, bool isCompatible, List<String> compatibilityWarnings, int? estimatedDurationSeconds
});


@override $BackupMetadataCopyWith<$Res> get metadata;

}
/// @nodoc
class __$RestorePreviewCopyWithImpl<$Res>
    implements _$RestorePreviewCopyWith<$Res> {
  __$RestorePreviewCopyWithImpl(this._self, this._then);

  final _RestorePreview _self;
  final $Res Function(_RestorePreview) _then;

/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? metadata = null,Object? recordCounts = null,Object? currentDatabaseCounts = null,Object? estimatedConflicts = null,Object? isCompatible = null,Object? compatibilityWarnings = null,Object? estimatedDurationSeconds = freezed,}) {
  return _then(_RestorePreview(
metadata: null == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata,recordCounts: null == recordCounts ? _self._recordCounts : recordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,currentDatabaseCounts: null == currentDatabaseCounts ? _self._currentDatabaseCounts : currentDatabaseCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,estimatedConflicts: null == estimatedConflicts ? _self.estimatedConflicts : estimatedConflicts // ignore: cast_nullable_to_non_nullable
as int,isCompatible: null == isCompatible ? _self.isCompatible : isCompatible // ignore: cast_nullable_to_non_nullable
as bool,compatibilityWarnings: null == compatibilityWarnings ? _self._compatibilityWarnings : compatibilityWarnings // ignore: cast_nullable_to_non_nullable
as List<String>,estimatedDurationSeconds: freezed == estimatedDurationSeconds ? _self.estimatedDurationSeconds : estimatedDurationSeconds // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

/// Create a copy of RestorePreview
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res> get metadata {
  
  return $BackupMetadataCopyWith<$Res>(_self.metadata, (value) {
    return _then(_self.copyWith(metadata: value));
  });
}
}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'restore_preview.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_RestorePreview _$RestorePreviewFromJson(
  Map<String, dynamic> json,
) => _RestorePreview(
  metadata: BackupMetadata.fromJson(json['metadata'] as Map<String, dynamic>),
  recordCounts: Map<String, int>.from(json['recordCounts'] as Map),
  currentDatabaseCounts:
      (json['currentDatabaseCounts'] as Map<String, dynamic>?)?.map(
        (k, e) => MapEntry(k, (e as num).toInt()),
      ) ??
      const {},
  estimatedConflicts: (json['estimatedConflicts'] as num?)?.toInt() ?? 0,
  isCompatible: json['isCompatible'] as bool,
  compatibilityWarnings:
      (json['compatibilityWarnings'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ??
      const [],
  estimatedDurationSeconds: (json['estimatedDurationSeconds'] as num?)?.toInt(),
);

Map<String, dynamic> _$RestorePreviewToJson(_RestorePreview instance) =>
    <String, dynamic>{
      'metadata': instance.metadata,
      'recordCounts': instance.recordCounts,
      'currentDatabaseCounts': instance.currentDatabaseCounts,
      'estimatedConflicts': instance.estimatedConflicts,
      'isCompatible': instance.isCompatible,
      'compatibilityWarnings': instance.compatibilityWarnings,
      'estimatedDurationSeconds': instance.estimatedDurationSeconds,
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'restore_result.freezed.dart';
part 'restore_result.g.dart';

/// æ•°æ®æ¢å¤æ“ä½œçš„ç»“æ?
@freezed
abstract class RestoreResult with _$RestoreResult {
  const factory RestoreResult({
    /// æ“ä½œæ˜¯å¦æˆåŠŸ
    required bool success,
    /// æ¢å¤çš„æ€»è®°å½•æ•°
    required int totalRecordsRestored,
    /// å„è¡¨æ¢å¤çš„è®°å½•æ•°ç»Ÿè®¡
    required Map<String, int> tableRecordCounts,
    /// æ“ä½œå¼€å§‹æ—¶é—?
    required DateTime startTime,
    /// æ“ä½œç»“æŸæ—¶é—´
    required DateTime endTime,
    /// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
    String? errorMessage,
    /// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
    @Default([]) List<String> warnings,
    /// è·³è¿‡çš„è®°å½•æ•°ï¼ˆç”±äºå†²çªæˆ–éªŒè¯å¤±è´¥ï¼?
    @Default(0) int skippedRecords,
  }) = _RestoreResult;

  factory RestoreResult.fromJson(Map<String, dynamic> json) =>
      _$RestoreResultFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'restore_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$RestoreResult {

/// æ“ä½œæ˜¯å¦æˆåŠŸ
 bool get success;/// æ¢å¤çš„æ€»è®°å½•æ•°
 int get totalRecordsRestored;/// å„è¡¨æ¢å¤çš„è®°å½•æ•°ç»Ÿè®¡
 Map<String, int> get tableRecordCounts;/// æ“ä½œå¼€å§‹æ—¶é—? DateTime get startTime;/// æ“ä½œç»“æŸæ—¶é—´
 DateTime get endTime;/// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
 String? get errorMessage;/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
 List<String> get warnings;/// è·³è¿‡çš„è®°å½•æ•°ï¼ˆç”±äºå†²çªæˆ–éªŒè¯å¤±è´¥ï¼? int get skippedRecords;
/// Create a copy of RestoreResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RestoreResultCopyWith<RestoreResult> get copyWith => _$RestoreResultCopyWithImpl<RestoreResult>(this as RestoreResult, _$identity);

  /// Serializes this RestoreResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RestoreResult&&(identical(other.success, success) || other.success == success)&&(identical(other.totalRecordsRestored, totalRecordsRestored) || other.totalRecordsRestored == totalRecordsRestored)&&const DeepCollectionEquality().equals(other.tableRecordCounts, tableRecordCounts)&&(identical(other.startTime, startTime) || other.startTime == startTime)&&(identical(other.endTime, endTime) || other.endTime == endTime)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&const DeepCollectionEquality().equals(other.warnings, warnings)&&(identical(other.skippedRecords, skippedRecords) || other.skippedRecords == skippedRecords));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success,totalRecordsRestored,const DeepCollectionEquality().hash(tableRecordCounts),startTime,endTime,errorMessage,const DeepCollectionEquality().hash(warnings),skippedRecords);

@override
String toString() {
  return 'RestoreResult(success: $success, totalRecordsRestored: $totalRecordsRestored, tableRecordCounts: $tableRecordCounts, startTime: $startTime, endTime: $endTime, errorMessage: $errorMessage, warnings: $warnings, skippedRecords: $skippedRecords)';
}


}

/// @nodoc
abstract mixin class $RestoreResultCopyWith<$Res>  {
  factory $RestoreResultCopyWith(RestoreResult value, $Res Function(RestoreResult) _then) = _$RestoreResultCopyWithImpl;
@useResult
$Res call({
 bool success, int totalRecordsRestored, Map<String, int> tableRecordCounts, DateTime startTime, DateTime endTime, String? errorMessage, List<String> warnings, int skippedRecords
});




}
/// @nodoc
class _$RestoreResultCopyWithImpl<$Res>
    implements $RestoreResultCopyWith<$Res> {
  _$RestoreResultCopyWithImpl(this._self, this._then);

  final RestoreResult _self;
  final $Res Function(RestoreResult) _then;

/// Create a copy of RestoreResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? success = null,Object? totalRecordsRestored = null,Object? tableRecordCounts = null,Object? startTime = null,Object? endTime = null,Object? errorMessage = freezed,Object? warnings = null,Object? skippedRecords = null,}) {
  return _then(_self.copyWith(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,totalRecordsRestored: null == totalRecordsRestored ? _self.totalRecordsRestored : totalRecordsRestored // ignore: cast_nullable_to_non_nullable
as int,tableRecordCounts: null == tableRecordCounts ? _self.tableRecordCounts : tableRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,startTime: null == startTime ? _self.startTime : startTime // ignore: cast_nullable_to_non_nullable
as DateTime,endTime: null == endTime ? _self.endTime : endTime // ignore: cast_nullable_to_non_nullable
as DateTime,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,warnings: null == warnings ? _self.warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<String>,skippedRecords: null == skippedRecords ? _self.skippedRecords : skippedRecords // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _RestoreResult implements RestoreResult {
  const _RestoreResult({required this.success, required this.totalRecordsRestored, required final  Map<String, int> tableRecordCounts, required this.startTime, required this.endTime, this.errorMessage, final  List<String> warnings = const [], this.skippedRecords = 0}): _tableRecordCounts = tableRecordCounts,_warnings = warnings;
  factory _RestoreResult.fromJson(Map<String, dynamic> json) => _$RestoreResultFromJson(json);

/// æ“ä½œæ˜¯å¦æˆåŠŸ
@override final  bool success;
/// æ¢å¤çš„æ€»è®°å½•æ•°
@override final  int totalRecordsRestored;
/// å„è¡¨æ¢å¤çš„è®°å½•æ•°ç»Ÿè®¡
 final  Map<String, int> _tableRecordCounts;
/// å„è¡¨æ¢å¤çš„è®°å½•æ•°ç»Ÿè®¡
@override Map<String, int> get tableRecordCounts {
  if (_tableRecordCounts is EqualUnmodifiableMapView) return _tableRecordCounts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_tableRecordCounts);
}

/// æ“ä½œå¼€å§‹æ—¶é—?@override final  DateTime startTime;
/// æ“ä½œç»“æŸæ—¶é—´
@override final  DateTime endTime;
/// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
@override final  String? errorMessage;
/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
 final  List<String> _warnings;
/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
@override@JsonKey() List<String> get warnings {
  if (_warnings is EqualUnmodifiableListView) return _warnings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_warnings);
}

/// è·³è¿‡çš„è®°å½•æ•°ï¼ˆç”±äºå†²çªæˆ–éªŒè¯å¤±è´¥ï¼?@override@JsonKey() final  int skippedRecords;

/// Create a copy of RestoreResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RestoreResultCopyWith<_RestoreResult> get copyWith => __$RestoreResultCopyWithImpl<_RestoreResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RestoreResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RestoreResult&&(identical(other.success, success) || other.success == success)&&(identical(other.totalRecordsRestored, totalRecordsRestored) || other.totalRecordsRestored == totalRecordsRestored)&&const DeepCollectionEquality().equals(other._tableRecordCounts, _tableRecordCounts)&&(identical(other.startTime, startTime) || other.startTime == startTime)&&(identical(other.endTime, endTime) || other.endTime == endTime)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&const DeepCollectionEquality().equals(other._warnings, _warnings)&&(identical(other.skippedRecords, skippedRecords) || other.skippedRecords == skippedRecords));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success,totalRecordsRestored,const DeepCollectionEquality().hash(_tableRecordCounts),startTime,endTime,errorMessage,const DeepCollectionEquality().hash(_warnings),skippedRecords);

@override
String toString() {
  return 'RestoreResult(success: $success, totalRecordsRestored: $totalRecordsRestored, tableRecordCounts: $tableRecordCounts, startTime: $startTime, endTime: $endTime, errorMessage: $errorMessage, warnings: $warnings, skippedRecords: $skippedRecords)';
}


}

/// @nodoc
abstract mixin class _$RestoreResultCopyWith<$Res> implements $RestoreResultCopyWith<$Res> {
  factory _$RestoreResultCopyWith(_RestoreResult value, $Res Function(_RestoreResult) _then) = __$RestoreResultCopyWithImpl;
@override @useResult
$Res call({
 bool success, int totalRecordsRestored, Map<String, int> tableRecordCounts, DateTime startTime, DateTime endTime, String? errorMessage, List<String> warnings, int skippedRecords
});




}
/// @nodoc
class __$RestoreResultCopyWithImpl<$Res>
    implements _$RestoreResultCopyWith<$Res> {
  __$RestoreResultCopyWithImpl(this._self, this._then);

  final _RestoreResult _self;
  final $Res Function(_RestoreResult) _then;

/// Create a copy of RestoreResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? success = null,Object? totalRecordsRestored = null,Object? tableRecordCounts = null,Object? startTime = null,Object? endTime = null,Object? errorMessage = freezed,Object? warnings = null,Object? skippedRecords = null,}) {
  return _then(_RestoreResult(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,totalRecordsRestored: null == totalRecordsRestored ? _self.totalRecordsRestored : totalRecordsRestored // ignore: cast_nullable_to_non_nullable
as int,tableRecordCounts: null == tableRecordCounts ? _self._tableRecordCounts : tableRecordCounts // ignore: cast_nullable_to_non_nullable
as Map<String, int>,startTime: null == startTime ? _self.startTime : startTime // ignore: cast_nullable_to_non_nullable
as DateTime,endTime: null == endTime ? _self.endTime : endTime // ignore: cast_nullable_to_non_nullable
as DateTime,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,warnings: null == warnings ? _self._warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<String>,skippedRecords: null == skippedRecords ? _self.skippedRecords : skippedRecords // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'restore_result.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_RestoreResult _$RestoreResultFromJson(
  Map<String, dynamic> json,
) => _RestoreResult(
  success: json['success'] as bool,
  totalRecordsRestored: (json['totalRecordsRestored'] as num).toInt(),
  tableRecordCounts: Map<String, int>.from(json['tableRecordCounts'] as Map),
  startTime: DateTime.parse(json['startTime'] as String),
  endTime: DateTime.parse(json['endTime'] as String),
  errorMessage: json['errorMessage'] as String?,
  warnings:
      (json['warnings'] as List<dynamic>?)?.map((e) => e as String).toList() ??
      const [],
  skippedRecords: (json['skippedRecords'] as num?)?.toInt() ?? 0,
);

Map<String, dynamic> _$RestoreResultToJson(_RestoreResult instance) =>
    <String, dynamic>{
      'success': instance.success,
      'totalRecordsRestored': instance.totalRecordsRestored,
      'tableRecordCounts': instance.tableRecordCounts,
      'startTime': instance.startTime.toIso8601String(),
      'endTime': instance.endTime.toIso8601String(),
      'errorMessage': instance.errorMessage,
      'warnings': instance.warnings,
      'skippedRecords': instance.skippedRecords,
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'validation_result.freezed.dart';
part 'validation_result.g.dart';

/// éªŒè¯ç»“æœ
@freezed
abstract class ValidationResult with _$ValidationResult {
  const factory ValidationResult({
    /// éªŒè¯æ˜¯å¦é€šè¿‡
    required bool isValid,
    /// éªŒè¯ç±»å‹
    required ValidationType type,
    /// éªŒè¯çš„ç›®æ ‡ï¼ˆæ–‡ä»¶è·¯å¾„ã€è¡¨åç­‰ï¼?
    required String target,
    /// é”™è¯¯ä¿¡æ¯åˆ—è¡¨
    @Default([]) List<ValidationError> errors,
    /// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
    @Default([]) List<ValidationWarning> warnings,
    /// ä¿®å¤å»ºè®®åˆ—è¡¨
    @Default([]) List<String> repairSuggestions,
    /// éªŒè¯è¯¦æƒ…
    Map<String, dynamic>? details,
  }) = _ValidationResult;

  factory ValidationResult.fromJson(Map<String, dynamic> json) =>
      _$ValidationResultFromJson(json);
}

/// éªŒè¯ç±»å‹
enum ValidationType {
  /// æ–‡ä»¶æ ¼å¼éªŒè¯
  fileFormat,
  /// ç‰ˆæœ¬å…¼å®¹æ€§éªŒè¯?
  versionCompatibility,
  /// æ•°æ®å®Œæ•´æ€§éªŒè¯?
  dataIntegrity,
  /// æ–‡ä»¶æŸåæ£€æµ?
  fileCorruption,
  /// æ¢å¤å‰é¢„æ£€æŸ?
  preRestoreCheck,
  /// è¡¨ç»“æ„éªŒè¯?
  tableStructure,
  /// æ•°æ®ç±»å‹éªŒè¯
  dataTypes,
  /// å¤–é”®å…³ç³»éªŒè¯
  foreignKeyRelationships,
  /// æ•°æ®çº¦æŸéªŒè¯
  dataConstraints,
}

/// éªŒè¯é”™è¯¯
@freezed
abstract class ValidationError with _$ValidationError {
  const factory ValidationError({
    /// é”™è¯¯ä»£ç 
    required String code,
    /// é”™è¯¯æ¶ˆæ¯
    required String message,
    /// é”™è¯¯ä¸¥é‡ç¨‹åº¦
    required ErrorSeverity severity,
    /// é”™è¯¯ä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
    String? location,
    /// é”™è¯¯è¯¦æƒ…
    Map<String, dynamic>? details,
  }) = _ValidationError;

  factory ValidationError.fromJson(Map<String, dynamic> json) =>
      _$ValidationErrorFromJson(json);
}

/// éªŒè¯è­¦å‘Š
@freezed
abstract class ValidationWarning with _$ValidationWarning {
  const factory ValidationWarning({
    /// è­¦å‘Šä»£ç 
    required String code,
    /// è­¦å‘Šæ¶ˆæ¯
    required String message,
    /// è­¦å‘Šä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
    String? location,
    /// è­¦å‘Šè¯¦æƒ…
    Map<String, dynamic>? details,
  }) = _ValidationWarning;

  factory ValidationWarning.fromJson(Map<String, dynamic> json) =>
      _$ValidationWarningFromJson(json);
}

/// é”™è¯¯ä¸¥é‡ç¨‹åº¦
enum ErrorSeverity {
  /// ä½çº§é”™è¯¯ï¼Œä¸å½±å“æ¢å¤
  low,
  /// ä¸­çº§é”™è¯¯ï¼Œå¯èƒ½å½±å“éƒ¨åˆ†æ•°æ?
  medium,
  /// é«˜çº§é”™è¯¯ï¼Œä¸¥é‡å½±å“æ¢å¤?
  high,
  /// è‡´å‘½é”™è¯¯ï¼Œæ— æ³•æ¢å¤?
  critical,
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'validation_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ValidationResult {

/// éªŒè¯æ˜¯å¦é€šè¿‡
 bool get isValid;/// éªŒè¯ç±»å‹
 ValidationType get type;/// éªŒè¯çš„ç›®æ ‡ï¼ˆæ–‡ä»¶è·¯å¾„ã€è¡¨åç­‰ï¼? String get target;/// é”™è¯¯ä¿¡æ¯åˆ—è¡¨
 List<ValidationError> get errors;/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
 List<ValidationWarning> get warnings;/// ä¿®å¤å»ºè®®åˆ—è¡¨
 List<String> get repairSuggestions;/// éªŒè¯è¯¦æƒ…
 Map<String, dynamic>? get details;
/// Create a copy of ValidationResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ValidationResultCopyWith<ValidationResult> get copyWith => _$ValidationResultCopyWithImpl<ValidationResult>(this as ValidationResult, _$identity);

  /// Serializes this ValidationResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ValidationResult&&(identical(other.isValid, isValid) || other.isValid == isValid)&&(identical(other.type, type) || other.type == type)&&(identical(other.target, target) || other.target == target)&&const DeepCollectionEquality().equals(other.errors, errors)&&const DeepCollectionEquality().equals(other.warnings, warnings)&&const DeepCollectionEquality().equals(other.repairSuggestions, repairSuggestions)&&const DeepCollectionEquality().equals(other.details, details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isValid,type,target,const DeepCollectionEquality().hash(errors),const DeepCollectionEquality().hash(warnings),const DeepCollectionEquality().hash(repairSuggestions),const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'ValidationResult(isValid: $isValid, type: $type, target: $target, errors: $errors, warnings: $warnings, repairSuggestions: $repairSuggestions, details: $details)';
}


}

/// @nodoc
abstract mixin class $ValidationResultCopyWith<$Res>  {
  factory $ValidationResultCopyWith(ValidationResult value, $Res Function(ValidationResult) _then) = _$ValidationResultCopyWithImpl;
@useResult
$Res call({
 bool isValid, ValidationType type, String target, List<ValidationError> errors, List<ValidationWarning> warnings, List<String> repairSuggestions, Map<String, dynamic>? details
});




}
/// @nodoc
class _$ValidationResultCopyWithImpl<$Res>
    implements $ValidationResultCopyWith<$Res> {
  _$ValidationResultCopyWithImpl(this._self, this._then);

  final ValidationResult _self;
  final $Res Function(ValidationResult) _then;

/// Create a copy of ValidationResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isValid = null,Object? type = null,Object? target = null,Object? errors = null,Object? warnings = null,Object? repairSuggestions = null,Object? details = freezed,}) {
  return _then(_self.copyWith(
isValid: null == isValid ? _self.isValid : isValid // ignore: cast_nullable_to_non_nullable
as bool,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as ValidationType,target: null == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String,errors: null == errors ? _self.errors : errors // ignore: cast_nullable_to_non_nullable
as List<ValidationError>,warnings: null == warnings ? _self.warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<ValidationWarning>,repairSuggestions: null == repairSuggestions ? _self.repairSuggestions : repairSuggestions // ignore: cast_nullable_to_non_nullable
as List<String>,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _ValidationResult implements ValidationResult {
  const _ValidationResult({required this.isValid, required this.type, required this.target, final  List<ValidationError> errors = const [], final  List<ValidationWarning> warnings = const [], final  List<String> repairSuggestions = const [], final  Map<String, dynamic>? details}): _errors = errors,_warnings = warnings,_repairSuggestions = repairSuggestions,_details = details;
  factory _ValidationResult.fromJson(Map<String, dynamic> json) => _$ValidationResultFromJson(json);

/// éªŒè¯æ˜¯å¦é€šè¿‡
@override final  bool isValid;
/// éªŒè¯ç±»å‹
@override final  ValidationType type;
/// éªŒè¯çš„ç›®æ ‡ï¼ˆæ–‡ä»¶è·¯å¾„ã€è¡¨åç­‰ï¼?@override final  String target;
/// é”™è¯¯ä¿¡æ¯åˆ—è¡¨
 final  List<ValidationError> _errors;
/// é”™è¯¯ä¿¡æ¯åˆ—è¡¨
@override@JsonKey() List<ValidationError> get errors {
  if (_errors is EqualUnmodifiableListView) return _errors;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_errors);
}

/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
 final  List<ValidationWarning> _warnings;
/// è­¦å‘Šä¿¡æ¯åˆ—è¡¨
@override@JsonKey() List<ValidationWarning> get warnings {
  if (_warnings is EqualUnmodifiableListView) return _warnings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_warnings);
}

/// ä¿®å¤å»ºè®®åˆ—è¡¨
 final  List<String> _repairSuggestions;
/// ä¿®å¤å»ºè®®åˆ—è¡¨
@override@JsonKey() List<String> get repairSuggestions {
  if (_repairSuggestions is EqualUnmodifiableListView) return _repairSuggestions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_repairSuggestions);
}

/// éªŒè¯è¯¦æƒ…
 final  Map<String, dynamic>? _details;
/// éªŒè¯è¯¦æƒ…
@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of ValidationResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ValidationResultCopyWith<_ValidationResult> get copyWith => __$ValidationResultCopyWithImpl<_ValidationResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ValidationResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ValidationResult&&(identical(other.isValid, isValid) || other.isValid == isValid)&&(identical(other.type, type) || other.type == type)&&(identical(other.target, target) || other.target == target)&&const DeepCollectionEquality().equals(other._errors, _errors)&&const DeepCollectionEquality().equals(other._warnings, _warnings)&&const DeepCollectionEquality().equals(other._repairSuggestions, _repairSuggestions)&&const DeepCollectionEquality().equals(other._details, _details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isValid,type,target,const DeepCollectionEquality().hash(_errors),const DeepCollectionEquality().hash(_warnings),const DeepCollectionEquality().hash(_repairSuggestions),const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'ValidationResult(isValid: $isValid, type: $type, target: $target, errors: $errors, warnings: $warnings, repairSuggestions: $repairSuggestions, details: $details)';
}


}

/// @nodoc
abstract mixin class _$ValidationResultCopyWith<$Res> implements $ValidationResultCopyWith<$Res> {
  factory _$ValidationResultCopyWith(_ValidationResult value, $Res Function(_ValidationResult) _then) = __$ValidationResultCopyWithImpl;
@override @useResult
$Res call({
 bool isValid, ValidationType type, String target, List<ValidationError> errors, List<ValidationWarning> warnings, List<String> repairSuggestions, Map<String, dynamic>? details
});




}
/// @nodoc
class __$ValidationResultCopyWithImpl<$Res>
    implements _$ValidationResultCopyWith<$Res> {
  __$ValidationResultCopyWithImpl(this._self, this._then);

  final _ValidationResult _self;
  final $Res Function(_ValidationResult) _then;

/// Create a copy of ValidationResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isValid = null,Object? type = null,Object? target = null,Object? errors = null,Object? warnings = null,Object? repairSuggestions = null,Object? details = freezed,}) {
  return _then(_ValidationResult(
isValid: null == isValid ? _self.isValid : isValid // ignore: cast_nullable_to_non_nullable
as bool,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as ValidationType,target: null == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String,errors: null == errors ? _self._errors : errors // ignore: cast_nullable_to_non_nullable
as List<ValidationError>,warnings: null == warnings ? _self._warnings : warnings // ignore: cast_nullable_to_non_nullable
as List<ValidationWarning>,repairSuggestions: null == repairSuggestions ? _self._repairSuggestions : repairSuggestions // ignore: cast_nullable_to_non_nullable
as List<String>,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$ValidationError {

/// é”™è¯¯ä»£ç 
 String get code;/// é”™è¯¯æ¶ˆæ¯
 String get message;/// é”™è¯¯ä¸¥é‡ç¨‹åº¦
 ErrorSeverity get severity;/// é”™è¯¯ä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
 String? get location;/// é”™è¯¯è¯¦æƒ…
 Map<String, dynamic>? get details;
/// Create a copy of ValidationError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ValidationErrorCopyWith<ValidationError> get copyWith => _$ValidationErrorCopyWithImpl<ValidationError>(this as ValidationError, _$identity);

  /// Serializes this ValidationError to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ValidationError&&(identical(other.code, code) || other.code == code)&&(identical(other.message, message) || other.message == message)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other.details, details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,message,severity,location,const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'ValidationError(code: $code, message: $message, severity: $severity, location: $location, details: $details)';
}


}

/// @nodoc
abstract mixin class $ValidationErrorCopyWith<$Res>  {
  factory $ValidationErrorCopyWith(ValidationError value, $Res Function(ValidationError) _then) = _$ValidationErrorCopyWithImpl;
@useResult
$Res call({
 String code, String message, ErrorSeverity severity, String? location, Map<String, dynamic>? details
});




}
/// @nodoc
class _$ValidationErrorCopyWithImpl<$Res>
    implements $ValidationErrorCopyWith<$Res> {
  _$ValidationErrorCopyWithImpl(this._self, this._then);

  final ValidationError _self;
  final $Res Function(ValidationError) _then;

/// Create a copy of ValidationError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? code = null,Object? message = null,Object? severity = null,Object? location = freezed,Object? details = freezed,}) {
  return _then(_self.copyWith(
code: null == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as String,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,severity: null == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as ErrorSeverity,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _ValidationError implements ValidationError {
  const _ValidationError({required this.code, required this.message, required this.severity, this.location, final  Map<String, dynamic>? details}): _details = details;
  factory _ValidationError.fromJson(Map<String, dynamic> json) => _$ValidationErrorFromJson(json);

/// é”™è¯¯ä»£ç 
@override final  String code;
/// é”™è¯¯æ¶ˆæ¯
@override final  String message;
/// é”™è¯¯ä¸¥é‡ç¨‹åº¦
@override final  ErrorSeverity severity;
/// é”™è¯¯ä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
@override final  String? location;
/// é”™è¯¯è¯¦æƒ…
 final  Map<String, dynamic>? _details;
/// é”™è¯¯è¯¦æƒ…
@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of ValidationError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ValidationErrorCopyWith<_ValidationError> get copyWith => __$ValidationErrorCopyWithImpl<_ValidationError>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ValidationErrorToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ValidationError&&(identical(other.code, code) || other.code == code)&&(identical(other.message, message) || other.message == message)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other._details, _details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,message,severity,location,const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'ValidationError(code: $code, message: $message, severity: $severity, location: $location, details: $details)';
}


}

/// @nodoc
abstract mixin class _$ValidationErrorCopyWith<$Res> implements $ValidationErrorCopyWith<$Res> {
  factory _$ValidationErrorCopyWith(_ValidationError value, $Res Function(_ValidationError) _then) = __$ValidationErrorCopyWithImpl;
@override @useResult
$Res call({
 String code, String message, ErrorSeverity severity, String? location, Map<String, dynamic>? details
});




}
/// @nodoc
class __$ValidationErrorCopyWithImpl<$Res>
    implements _$ValidationErrorCopyWith<$Res> {
  __$ValidationErrorCopyWithImpl(this._self, this._then);

  final _ValidationError _self;
  final $Res Function(_ValidationError) _then;

/// Create a copy of ValidationError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? code = null,Object? message = null,Object? severity = null,Object? location = freezed,Object? details = freezed,}) {
  return _then(_ValidationError(
code: null == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as String,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,severity: null == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as ErrorSeverity,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$ValidationWarning {

/// è­¦å‘Šä»£ç 
 String get code;/// è­¦å‘Šæ¶ˆæ¯
 String get message;/// è­¦å‘Šä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
 String? get location;/// è­¦å‘Šè¯¦æƒ…
 Map<String, dynamic>? get details;
/// Create a copy of ValidationWarning
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ValidationWarningCopyWith<ValidationWarning> get copyWith => _$ValidationWarningCopyWithImpl<ValidationWarning>(this as ValidationWarning, _$identity);

  /// Serializes this ValidationWarning to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ValidationWarning&&(identical(other.code, code) || other.code == code)&&(identical(other.message, message) || other.message == message)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other.details, details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,message,location,const DeepCollectionEquality().hash(details));

@override
String toString() {
  return 'ValidationWarning(code: $code, message: $message, location: $location, details: $details)';
}


}

/// @nodoc
abstract mixin class $ValidationWarningCopyWith<$Res>  {
  factory $ValidationWarningCopyWith(ValidationWarning value, $Res Function(ValidationWarning) _then) = _$ValidationWarningCopyWithImpl;
@useResult
$Res call({
 String code, String message, String? location, Map<String, dynamic>? details
});




}
/// @nodoc
class _$ValidationWarningCopyWithImpl<$Res>
    implements $ValidationWarningCopyWith<$Res> {
  _$ValidationWarningCopyWithImpl(this._self, this._then);

  final ValidationWarning _self;
  final $Res Function(ValidationWarning) _then;

/// Create a copy of ValidationWarning
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? code = null,Object? message = null,Object? location = freezed,Object? details = freezed,}) {
  return _then(_self.copyWith(
code: null == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as String,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _ValidationWarning implements ValidationWarning {
  const _ValidationWarning({required this.code, required this.message, this.location, final  Map<String, dynamic>? details}): _details = details;
  factory _ValidationWarning.fromJson(Map<String, dynamic> json) => _$ValidationWarningFromJson(json);

/// è­¦å‘Šä»£ç 
@override final  String code;
/// è­¦å‘Šæ¶ˆæ¯
@override final  String message;
/// è­¦å‘Šä½ç½®ï¼ˆè¡¨åã€å­—æ®µåç­‰ï¼‰
@override final  String? location;
/// è­¦å‘Šè¯¦æƒ…
 final  Map<String, dynamic>? _details;
/// è­¦å‘Šè¯¦æƒ…
@override Map<String, dynamic>? get details {
  final value = _details;
  if (value == null) return null;
  if (_details is EqualUnmodifiableMapView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of ValidationWarning
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ValidationWarningCopyWith<_ValidationWarning> get copyWith => __$ValidationWarningCopyWithImpl<_ValidationWarning>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ValidationWarningToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ValidationWarning&&(identical(other.code, code) || other.code == code)&&(identical(other.message, message) || other.message == message)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other._details, _details));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,message,location,const DeepCollectionEquality().hash(_details));

@override
String toString() {
  return 'ValidationWarning(code: $code, message: $message, location: $location, details: $details)';
}


}

/// @nodoc
abstract mixin class _$ValidationWarningCopyWith<$Res> implements $ValidationWarningCopyWith<$Res> {
  factory _$ValidationWarningCopyWith(_ValidationWarning value, $Res Function(_ValidationWarning) _then) = __$ValidationWarningCopyWithImpl;
@override @useResult
$Res call({
 String code, String message, String? location, Map<String, dynamic>? details
});




}
/// @nodoc
class __$ValidationWarningCopyWithImpl<$Res>
    implements _$ValidationWarningCopyWith<$Res> {
  __$ValidationWarningCopyWithImpl(this._self, this._then);

  final _ValidationWarning _self;
  final $Res Function(_ValidationWarning) _then;

/// Create a copy of ValidationWarning
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? code = null,Object? message = null,Object? location = freezed,Object? details = freezed,}) {
  return _then(_ValidationWarning(
code: null == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as String,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as String?,details: freezed == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'validation_result.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ValidationResult _$ValidationResultFromJson(Map<String, dynamic> json) =>
    _ValidationResult(
      isValid: json['isValid'] as bool,
      type: $enumDecode(_$ValidationTypeEnumMap, json['type']),
      target: json['target'] as String,
      errors:
          (json['errors'] as List<dynamic>?)
              ?.map((e) => ValidationError.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      warnings:
          (json['warnings'] as List<dynamic>?)
              ?.map(
                (e) => ValidationWarning.fromJson(e as Map<String, dynamic>),
              )
              .toList() ??
          const [],
      repairSuggestions:
          (json['repairSuggestions'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      details: json['details'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$ValidationResultToJson(_ValidationResult instance) =>
    <String, dynamic>{
      'isValid': instance.isValid,
      'type': _$ValidationTypeEnumMap[instance.type]!,
      'target': instance.target,
      'errors': instance.errors,
      'warnings': instance.warnings,
      'repairSuggestions': instance.repairSuggestions,
      'details': instance.details,
    };

const _$ValidationTypeEnumMap = {
  ValidationType.fileFormat: 'fileFormat',
  ValidationType.versionCompatibility: 'versionCompatibility',
  ValidationType.dataIntegrity: 'dataIntegrity',
  ValidationType.fileCorruption: 'fileCorruption',
  ValidationType.preRestoreCheck: 'preRestoreCheck',
  ValidationType.tableStructure: 'tableStructure',
  ValidationType.dataTypes: 'dataTypes',
  ValidationType.foreignKeyRelationships: 'foreignKeyRelationships',
  ValidationType.dataConstraints: 'dataConstraints',
};

_ValidationError _$ValidationErrorFromJson(Map<String, dynamic> json) =>
    _ValidationError(
      code: json['code'] as String,
      message: json['message'] as String,
      severity: $enumDecode(_$ErrorSeverityEnumMap, json['severity']),
      location: json['location'] as String?,
      details: json['details'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$ValidationErrorToJson(_ValidationError instance) =>
    <String, dynamic>{
      'code': instance.code,
      'message': instance.message,
      'severity': _$ErrorSeverityEnumMap[instance.severity]!,
      'location': instance.location,
      'details': instance.details,
    };

const _$ErrorSeverityEnumMap = {
  ErrorSeverity.low: 'low',
  ErrorSeverity.medium: 'medium',
  ErrorSeverity.high: 'high',
  ErrorSeverity.critical: 'critical',
};

_ValidationWarning _$ValidationWarningFromJson(Map<String, dynamic> json) =>
    _ValidationWarning(
      code: json['code'] as String,
      message: json['message'] as String,
      location: json['location'] as String?,
      details: json['details'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$ValidationWarningToJson(_ValidationWarning instance) =>
    <String, dynamic>{
      'code': instance.code,
      'message': instance.message,
      'location': instance.location,
      'details': instance.details,
    };
import '../models/backup_metadata.dart';
import '../models/backup_options.dart';
import '../common/backup_common.dart';

/// å¤‡ä»½ç»“æœ
class BackupResult {
  final bool success;
  final String? filePath;
  final BackupMetadata? metadata;
  final String? errorMessage;

  const BackupResult({
    required this.success,
    this.filePath,
    this.metadata,
    this.errorMessage,
  });

  factory BackupResult.success({
    required String filePath,
    required BackupMetadata metadata,
  }) =>
      BackupResult(
        success: true,
        filePath: filePath,
        metadata: metadata,
      );

  factory BackupResult.failure(String errorMessage) => BackupResult(
        success: false,
        errorMessage: errorMessage,
      );
}

/// å¤‡ä»½è¿›åº¦å›è°ƒå‡½æ•°ç±»å‹
typedef BackupProgressCallback = void Function(
  String currentStep,
  int currentProgress,
  int totalProgress,
);

/// å¤‡ä»½æœåŠ¡æ¥å£
abstract class IBackupService {
  /// åˆ›å»ºå¤‡ä»½
  /// [options] å¤‡ä»½é€‰é¡¹é…ç½®
  /// [onProgress] è¿›åº¦å›è°ƒå‡½æ•°
  /// [cancelToken] å–æ¶ˆä»¤ç‰Œï¼Œç”¨äºå–æ¶ˆå¤‡ä»½æ“ä½?
  Future<BackupResult> createBackup({
    BackupOptions? options,
    BackupProgressCallback? onProgress,
    CancelToken? cancelToken,
  });

  /// è·å–æœ¬åœ°å¤‡ä»½æ–‡ä»¶åˆ—è¡¨
  Future<List<BackupMetadata>> getLocalBackups();

  /// åˆ é™¤å¤‡ä»½æ–‡ä»¶
  /// [backupId] å¤‡ä»½æ–‡ä»¶ID
  Future<bool> deleteBackup(String backupId);

  /// è·å–å¤‡ä»½æ–‡ä»¶ä¿¡æ¯
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  Future<BackupMetadata?> getBackupInfo(String filePath);

  /// éªŒè¯å¤‡ä»½æ–‡ä»¶
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  Future<bool> validateBackupFile(String filePath);

  /// ä¼°ç®—å¤‡ä»½æ–‡ä»¶å¤§å°
  Future<int> estimateBackupSize();
}

/// æ•°æ®åº“ç»Ÿè®¡æœåŠ¡æ¥å?
/// æä¾›å½“å‰æ•°æ®åº“è¡¨çš„ç»Ÿè®¡ä¿¡æ?
abstract class IDatabaseStatisticsService {
  /// è·å–æ‰€æœ‰è¡¨çš„è®°å½•æ•°ç»Ÿè®¡
  Future<Map<String, int>> getAllTableCounts();
  
  /// è·å–æŒ‡å®šè¡¨çš„è®°å½•æ•?
  Future<int> getTableCount(String tableName);
  
  /// è·å–æ•°æ®åº“æ€»è®°å½•æ•°
  Future<int> getTotalRecordCount();
}
/// Interface for encryption and security services
/// Defines the contract for data encryption, decryption, and integrity verification
abstract class IEncryptionService {
  /// Encrypts data using AES-256-GCM with password-based key derivation
  /// 
  /// [data] - The data to encrypt as a string
  /// [password] - The password to derive the encryption key from
  /// 
  /// Returns encrypted data as base64 string
  Future<String> encryptData(String data, String password);

  /// Decrypts data that was encrypted with encryptData
  /// 
  /// [encryptedData] - Base64 encoded encrypted data
  /// [password] - The password used for encryption
  /// 
  /// Returns the original plaintext data
  Future<String> decryptData(String encryptedData, String password);

  /// Validates if a password can decrypt the given encrypted data
  /// 
  /// [encryptedData] - Base64 encoded encrypted data
  /// [password] - The password to validate
  /// 
  /// Returns true if password is correct, false otherwise
  Future<bool> validatePassword(String encryptedData, String password);

  /// Generates HMAC-SHA256 for data integrity verification
  /// 
  /// [data] - The data to generate HMAC for
  /// [key] - The key to use for HMAC generation
  /// 
  /// Returns HMAC as hex string
  String generateHmac(String data, String key);

  /// Verifies HMAC-SHA256 for data integrity
  /// 
  /// [data] - The original data
  /// [key] - The key used for HMAC generation
  /// [expectedHmac] - The expected HMAC value
  /// 
  /// Returns true if HMAC is valid, false otherwise
  bool verifyHmac(String data, String key, String expectedHmac);

  /// Generates a secure random password for encryption
  /// 
  /// [length] - The length of the password to generate (default: 32)
  /// 
  /// Returns a random password string
  String generateSecurePassword([int length = 32]);
}
import '../models/performance_metrics.dart';

/// æ€§èƒ½ç›‘æ§æœåŠ¡æ¥å£
abstract class IPerformanceService {
  /// å¼€å§‹æ€§èƒ½ç›‘æ§
  /// [operationId] æ“ä½œæ ‡è¯†ç¬?
  /// [totalRecords] é¢„æœŸå¤„ç†çš„æ€»è®°å½•æ•°
  Future<void> startMonitoring(String operationId, int totalRecords);

  /// æ›´æ–°å¤„ç†è¿›åº¦
  /// [operationId] æ“ä½œæ ‡è¯†ç¬?
  /// [processedRecords] å·²å¤„ç†çš„è®°å½•æ•?
  Future<void> updateProgress(String operationId, int processedRecords);

  /// è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
  /// [operationId] æ“ä½œæ ‡è¯†ç¬?
  Future<void> recordMemoryUsage(String operationId);

  /// ç»“æŸæ€§èƒ½ç›‘æ§
  /// [operationId] æ“ä½œæ ‡è¯†ç¬?
  Future<PerformanceMetrics> endMonitoring(String operationId);

  /// è·å–å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ
  Future<MemoryUsage> getCurrentMemoryUsage();

  /// æ£€æŸ¥æ˜¯å¦éœ€è¦è¿›è¡Œåƒåœ¾å›æ”?
  Future<bool> shouldTriggerGC();

  /// è§¦å‘åƒåœ¾å›æ”¶
  Future<void> triggerGC();

  /// è·å–æ€§èƒ½å»ºè®®
  /// [metrics] æ€§èƒ½æŒ‡æ ‡
  List<String> getPerformanceRecommendations(PerformanceMetrics metrics);
}

/// æµå¼å¤„ç†æœåŠ¡æ¥å£
abstract class IStreamProcessingService {
  /// æµå¼å¯¼å‡ºæ•°æ®
  /// [tableName] è¡¨å
  /// [config] æµå¼å¤„ç†é…ç½®
  /// [onBatch] æ‰¹å¤„ç†å›è°?
  /// [onProgress] è¿›åº¦å›è°ƒ
  Stream<List<Map<String, dynamic>>> streamExportTable(
    String tableName,
    StreamProcessingConfig config, {
    void Function(List<Map<String, dynamic>> batch)? onBatch,
    void Function(int processed, int total)? onProgress,
  });

  /// æµå¼å¯¼å…¥æ•°æ®
  /// [tableName] è¡¨å
  /// [dataStream] æ•°æ®æµ?
  /// [config] æµå¼å¤„ç†é…ç½®
  /// [onProgress] è¿›åº¦å›è°ƒ
  Future<int> streamImportTable(
    String tableName,
    Stream<List<Map<String, dynamic>>> dataStream,
    StreamProcessingConfig config, {
    void Function(int processed, int total)? onProgress,
  });

  /// æµå¼JSONåºåˆ—åŒ?
  /// [data] è¦åºåˆ—åŒ–çš„æ•°æ?
  /// [config] æµå¼å¤„ç†é…ç½®
  Stream<String> streamJsonSerialize(
    Map<String, dynamic> data,
    StreamProcessingConfig config,
  );

  /// æµå¼JSONååºåˆ—åŒ–
  /// [jsonStream] JSONæ•°æ®æµ?
  /// [config] æµå¼å¤„ç†é…ç½®
  Future<Map<String, dynamic>> streamJsonDeserialize(
    Stream<String> jsonStream,
    StreamProcessingConfig config,
  );
}

/// å‹ç¼©æœåŠ¡æ¥å£
abstract class ICompressionService {
  /// å‹ç¼©æ•°æ®
  /// [data] è¦å‹ç¼©çš„æ•°æ®
  /// [level] å‹ç¼©çº§åˆ« (1-9)
  Future<CompressionResult> compressData(List<int> data, {int level = 6});

  /// è§£å‹æ•°æ®
  /// [compressedData] å‹ç¼©çš„æ•°æ?
  Future<List<int>> decompressData(List<int> compressedData);

  /// å‹ç¼©æ–‡ä»¶
  /// [inputPath] è¾“å…¥æ–‡ä»¶è·¯å¾„
  /// [outputPath] è¾“å‡ºæ–‡ä»¶è·¯å¾„
  /// [level] å‹ç¼©çº§åˆ«
  Future<CompressionStats> compressFile(
    String inputPath,
    String outputPath, {
    int level = 6,
  });

  /// è§£å‹æ–‡ä»¶
  /// [inputPath] å‹ç¼©æ–‡ä»¶è·¯å¾„
  /// [outputPath] è¾“å‡ºæ–‡ä»¶è·¯å¾„
  Future<void> decompressFile(String inputPath, String outputPath);

  /// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å‹ç¼©
  /// [filePath] æ–‡ä»¶è·¯å¾„
  Future<bool> isCompressed(String filePath);
}

/// å‹ç¼©ç»“æœ
class CompressionResult {
  final List<int> compressedData;
  final CompressionStats stats;

  const CompressionResult({
    required this.compressedData,
    required this.stats,
  });
}
import '../models/backup_metadata.dart';
import '../models/restore_result.dart';
import '../models/restore_preview.dart';
import '../models/restore_mode.dart';
import '../common/backup_common.dart';

/// æ¢å¤è¿›åº¦å›è°ƒå‡½æ•°ç±»å‹
/// [message] å½“å‰æ“ä½œæè¿°
/// [current] å½“å‰è¿›åº¦å€?
/// [total] æ€»è¿›åº¦å€?
typedef RestoreProgressCallback = void Function(String message, int current, int total);



/// æ•°æ®æ¢å¤æœåŠ¡æ¥å£
abstract class IRestoreService {
  /// éªŒè¯å¤‡ä»½æ–‡ä»¶å¹¶è·å–å…ƒæ•°æ®
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœå¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›å¤‡ä»½æ–‡ä»¶çš„å…ƒæ•°æ®ä¿¡æ¯
  Future<BackupMetadata> validateBackupFile(
    String filePath, {
    String? password,
  });

  /// é¢„è§ˆæ¢å¤æ“ä½œ
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœå¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›æ¢å¤é¢„è§ˆä¿¡æ¯ï¼ŒåŒ…å«å°†è¦æ¢å¤çš„æ•°æ®ç»Ÿè®¡
  Future<RestorePreview> previewRestore(
    String filePath, {
    RestoreMode mode,
    String? password,
  });

  /// ä»å¤‡ä»½æ–‡ä»¶æ¢å¤æ•°æ?
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [mode] æ¢å¤æ¨¡å¼ï¼ˆå®Œå…¨æ›¿æ?åˆå¹¶æ•°æ®ï¼?
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœå¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼?
  /// [selectedTables] é€‰æ‹©è¦æ¢å¤çš„è¡¨ï¼ˆnullè¡¨ç¤ºæ¢å¤æ‰€æœ‰è¡¨ï¼?
  /// [onProgress] è¿›åº¦å›è°ƒå‡½æ•°
  /// [cancelToken] å–æ¶ˆä»¤ç‰Œ
  /// è¿”å›æ¢å¤æ“ä½œç»“æœ
  Future<RestoreResult> restoreFromBackup({
    required String filePath,
    required RestoreMode mode,
    String? password,
    List<String>? selectedTables,
    RestoreProgressCallback? onProgress,
    CancelToken? cancelToken,
  });

  /// æ£€æŸ¥å¤‡ä»½æ–‡ä»¶å…¼å®¹æ€?
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœå¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›å…¼å®¹æ€§æ£€æŸ¥ç»“æ?
  Future<bool> checkCompatibility(
    String filePath, {
    String? password,
  });

  /// ä¼°ç®—æ¢å¤æ—¶é—´
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [mode] æ¢å¤æ¨¡å¼
  /// [selectedTables] é€‰æ‹©è¦æ¢å¤çš„è¡?
  /// è¿”å›é¢„è®¡æ¢å¤æ—¶é—´ï¼ˆç§’ï¼?
  Future<int> estimateRestoreTime(
    String filePath,
    RestoreMode mode, {
    List<String>? selectedTables,
  });
}
import '../models/backup_metadata.dart';
import '../models/validation_result.dart';
import '../models/integrity_check_result.dart';
import '../models/compatibility_check_result.dart';

/// æ•°æ®éªŒè¯æœåŠ¡æ¥å£
/// è´Ÿè´£å¤‡ä»½æ–‡ä»¶çš„æ ¼å¼éªŒè¯ã€å®Œæ•´æ€§æ£€æŸ¥å’Œå…¼å®¹æ€§éªŒè¯?
abstract class IValidationService {
  /// éªŒè¯å¤‡ä»½æ–‡ä»¶æ ¼å¼
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœæ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›æ ¼å¼éªŒè¯ç»“æœ
  Future<ValidationResult> validateBackupFormat(
    String filePath, {
    String? password,
  });

  /// æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€?
  /// [metadata] å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ?
  /// è¿”å›å…¼å®¹æ€§æ£€æŸ¥ç»“æ?
  Future<CompatibilityCheckResult> checkVersionCompatibility(
    BackupMetadata metadata,
  );

  /// éªŒè¯æ•°æ®å…³ç³»å®Œæ•´æ€?
  /// [tablesData] è¡¨æ•°æ?
  /// [metadata] å¤‡ä»½å…ƒæ•°æ?
  /// è¿”å›å®Œæ•´æ€§æ£€æŸ¥ç»“æ?
  Future<IntegrityCheckResult> validateDataIntegrity(
    Map<String, List<Map<String, dynamic>>> tablesData,
    BackupMetadata metadata,
  );

  /// æ£€æµ‹å¤‡ä»½æ–‡ä»¶æŸå?
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœæ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›æŸåæ£€æµ‹ç»“æœå’Œä¿®å¤å»ºè®®
  Future<ValidationResult> detectFileCorruption(
    String filePath, {
    String? password,
  });

  /// æ¢å¤å‰æ•°æ®é¢„æ£€æŸ?
  /// [filePath] å¤‡ä»½æ–‡ä»¶è·¯å¾„
  /// [selectedTables] é€‰æ‹©è¦æ¢å¤çš„è¡?
  /// [password] è§£å¯†å¯†ç ï¼ˆå¦‚æœæ–‡ä»¶å·²åŠ å¯†ï¼?
  /// è¿”å›é¢„æ£€æŸ¥ç»“æ?
  Future<ValidationResult> preRestoreValidation(
    String filePath, {
    List<String>? selectedTables,
    String? password,
  });

  /// éªŒè¯è¡¨ç»“æ„å…¼å®¹æ€?
  /// [tableName] è¡¨å
  /// [backupTableData] å¤‡ä»½ä¸­çš„è¡¨æ•°æ®æ ·æœ?
  /// è¿”å›è¡¨ç»“æ„å…¼å®¹æ€§ç»“æ?
  Future<ValidationResult> validateTableStructure(
    String tableName,
    Map<String, dynamic> backupTableData,
  );

  /// éªŒè¯æ•°æ®ç±»å‹å…¼å®¹æ€?
  /// [tableName] è¡¨å
  /// [records] è®°å½•åˆ—è¡¨
  /// è¿”å›æ•°æ®ç±»å‹éªŒè¯ç»“æœ
  Future<ValidationResult> validateDataTypes(
    String tableName,
    List<Map<String, dynamic>> records,
  );

  /// éªŒè¯å¤–é”®å…³ç³»
  /// [tablesData] æ‰€æœ‰è¡¨æ•°æ®
  /// è¿”å›å¤–é”®å…³ç³»éªŒè¯ç»“æœ
  Future<ValidationResult> validateForeignKeyRelationships(
    Map<String, List<Map<String, dynamic>>> tablesData,
  );

  /// éªŒè¯æ•°æ®çº¦æŸ
  /// [tableName] è¡¨å
  /// [records] è®°å½•åˆ—è¡¨
  /// è¿”å›çº¦æŸéªŒè¯ç»“æœ
  Future<ValidationResult> validateDataConstraints(
    String tableName,
    List<Map<String, dynamic>> records,
  );

  /// ç”Ÿæˆä¿®å¤å»ºè®®
  /// [validationResults] éªŒè¯ç»“æœåˆ—è¡¨
  /// è¿”å›ä¿®å¤å»ºè®®åˆ—è¡¨
  List<String> generateRepairSuggestions(
    List<ValidationResult> validationResults,
  );
}
// å¤‡ä»½åŠŸèƒ½ç›¸å…³çš„æœåŠ¡æ¥å£å¯¼å‡ºæ–‡ä»?

export 'i_backup_service.dart';
export 'i_encryption_service.dart';
export 'i_restore_service.dart';
export '../common/backup_common.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/services/unified_backup_service.dart';
import '../data/providers/backup_service_provider.dart';
import '../domain/models/backup_options.dart';
import '../domain/common/backup_common.dart';
import '../domain/models/backup_metadata.dart';

/// ç»Ÿä¸€å¤‡ä»½æœåŠ¡é›†æˆç¤ºä¾‹
class UnifiedBackupIntegration {
  /// ä½¿ç”¨ Riverpod è·å–ç»Ÿä¸€å¤‡ä»½æœåŠ¡å®ä¾‹
  static UnifiedBackupService getService(WidgetRef ref) {
    return ref.read(backupServiceProvider) as UnifiedBackupService;
  }
  
  /// åˆ›å»ºå¤‡ä»½çš„å®Œæ•´æµç¨?
  static Future<void> createBackupWithErrorHandling({
    required BuildContext context,
    required WidgetRef ref,
    BackupOptions? options,
    VoidCallback? onSuccess,
    Function(String)? onError,
  }) async {
    final backupService = getService(ref);
    final cancelToken = CancelToken();
    
    // æ˜¾ç¤ºè¿›åº¦å¯¹è¯æ¡?
    final progressKey = GlobalKey<_BackupProgressDialogState>();
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => BackupProgressDialog(
        key: progressKey,
        onCancel: () {
          cancelToken.cancel();
          Navigator.of(context).pop();
        },
      ),
    );
    
    try {
      final result = await backupService.createBackup(
        options: options ?? const BackupOptions(
          description: 'ç»Ÿä¸€å¤‡ä»½æœåŠ¡è‡ªåŠ¨å¤‡ä»½',
        ),
        onProgress: (message, current, total) {
          progressKey.currentState?.updateProgress(message, current, total);
        },
        cancelToken: cancelToken,
      );
      
      // å…³é—­è¿›åº¦å¯¹è¯æ¡?
      if (context.mounted) {
        Navigator.of(context).pop();
      }
      
      if (result.success) {
        if (context.mounted) {
          _showSuccessDialog(context, result.filePath!, result.metadata);
        }
        onSuccess?.call();
      } else {
        if (context.mounted) {
          _showErrorDialog(context, result.errorMessage!);
        }
        onError?.call(result.errorMessage!);
      }
      
    } catch (e) {
      if (context.mounted) {
        Navigator.of(context).pop();
        _showErrorDialog(context, 'å¤‡ä»½è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸? ${e.toString()}');
      }
      onError?.call(e.toString());
    }
  }
  
  /// ä½¿ç”¨ Consumer Widget çš„é›†æˆç¤ºä¾?
  static Widget buildBackupButton({
    required String label,
    BackupOptions? options,
    VoidCallback? onSuccess,
    Function(String)? onError,
  }) {
    return Consumer(
      builder: (context, ref, child) {
        return ElevatedButton(
          onPressed: () => createBackupWithErrorHandling(
            context: context,
            ref: ref,
            options: options,
            onSuccess: onSuccess,
            onError: onError,
          ),
          child: Text(label),
        );
      },
    );
  }
  
  static void _showSuccessDialog(BuildContext context, String filePath, BackupMetadata? metadata) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.check_circle, color: Colors.green),
            SizedBox(width: 8),
            Text('å¤‡ä»½æˆåŠŸ'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('å¤‡ä»½æ–‡ä»¶å·²ä¿å­˜åˆ°ï¼?),
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                filePath,
                style: const TextStyle(fontSize: 12, fontFamily: 'monospace'),
              ),
            ),
            if (metadata != null) ...[
              const SizedBox(height: 16),
              Text('å¤‡ä»½ä¿¡æ¯ï¼?),
              const SizedBox(height: 4),
              Text('æ–‡ä»¶å¤§å°ï¼?{(metadata.fileSize / 1024 / 1024).toStringAsFixed(2)} MB'),
              Text('åˆ›å»ºæ—¶é—´ï¼?{metadata.createdAt.toString().split('.')[0]}'),
              if (metadata.description?.isNotEmpty == true)
                Text('æè¿°ï¼?{metadata.description}'),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );
  }
  
  static void _showErrorDialog(BuildContext context, String error) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.error, color: Colors.red),
            SizedBox(width: 8),
            Text('å¤‡ä»½å¤±è´¥'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('å¤‡ä»½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š'),
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.red[50],
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: Colors.red[200]!),
              ),
              child: Text(
                error,
                style: const TextStyle(fontSize: 12),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'å»ºè®®æ“ä½œï¼š\n1. æ£€æŸ¥å­˜å‚¨ç©ºé—´æ˜¯å¦è¶³å¤Ÿ\n2. ç¡®ä¿æ•°æ®åº“æ²¡æœ‰è¢«å…¶ä»–è¿›ç¨‹å ç”¨\n3. ç¨åé‡è¯•',
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );
  }
}

/// å¤‡ä»½è¿›åº¦å¯¹è¯æ¡?
class BackupProgressDialog extends StatefulWidget {
  final VoidCallback? onCancel;
  
  const BackupProgressDialog({
    super.key,
    this.onCancel,
  });
  
  @override
  State<BackupProgressDialog> createState() => _BackupProgressDialogState();
}

class _BackupProgressDialogState extends State<BackupProgressDialog> {
  String _currentMessage = 'å‡†å¤‡å¤‡ä»½...';
  double _progress = 0.0;
  
  void updateProgress(String message, int current, int total) {
    if (mounted) {
      setState(() {
        _currentMessage = message;
        _progress = total > 0 ? current / total : 0.0;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false, // ç¦æ­¢è¿”å›é”®å…³é—?
      child: AlertDialog(
        title: const Row(
          children: [
            SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
            SizedBox(width: 12),
            Text('æ­£åœ¨åˆ›å»ºå¤‡ä»½'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            LinearProgressIndicator(
              value: _progress,
              backgroundColor: Colors.grey[300],
              valueColor: AlwaysStoppedAnimation<Color>(Colors.blue),
            ),
            const SizedBox(height: 16),
            Text(
              _currentMessage,
              textAlign: TextAlign.center,
              style: const TextStyle(fontSize: 14),
            ),
            const SizedBox(height: 8),
            Text(
              '${(_progress * 100).toStringAsFixed(1)}%',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.grey,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        actions: [
          if (widget.onCancel != null)
            TextButton(
              onPressed: widget.onCancel,
              child: const Text('å–æ¶ˆ'),
            ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../domain/models/backup_options.dart';
import 'unified_backup_integration.dart';

/// ç»Ÿä¸€å¤‡ä»½æœåŠ¡ä½¿ç”¨ç¤ºä¾‹
class UnifiedBackupUsageExample extends ConsumerWidget {
  const UnifiedBackupUsageExample({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ç»Ÿä¸€å¤‡ä»½ç¤ºä¾‹'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'ç»Ÿä¸€å¤‡ä»½æœåŠ¡é›†æˆç¤ºä¾‹',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            
            // åŸºæœ¬å¤‡ä»½æŒ‰é’®
            UnifiedBackupIntegration.buildBackupButton(
              label: 'åˆ›å»ºåŸºæœ¬å¤‡ä»½',
              onSuccess: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('å¤‡ä»½åˆ›å»ºæˆåŠŸï¼?)),
                );
              },
              onError: (error) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('å¤‡ä»½å¤±è´¥ï¼?error')),
                );
              },
            ),
            
            const SizedBox(height: 12),
            
            // å¸¦æè¿°çš„å¤‡ä»½æŒ‰é’®
            UnifiedBackupIntegration.buildBackupButton(
              label: 'åˆ›å»ºå¸¦æè¿°çš„å¤‡ä»½',
              options: const BackupOptions(
                description: 'æ‰‹åŠ¨åˆ›å»ºçš„ç»Ÿä¸€å¤‡ä»½',
                customName: 'manual_backup',
              ),
              onSuccess: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('å¸¦æè¿°çš„å¤‡ä»½åˆ›å»ºæˆåŠŸï¼?)),
                );
              },
              onError: (error) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('å¤‡ä»½å¤±è´¥ï¼?error')),
                );
              },
            ),
            
            const SizedBox(height: 12),
            
            // è‡ªå®šä¹‰å¤‡ä»½æŒ‰é’?
            ElevatedButton(
              onPressed: () => _createCustomBackup(context, ref),
              child: const Text('åˆ›å»ºè‡ªå®šä¹‰å¤‡ä»?),
            ),
            
            const SizedBox(height: 24),
            
            const Text(
              'ç‰¹æ€§è¯´æ˜ï¼š',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            
            const Card(
              child: Padding(
                padding: EdgeInsets.all(12.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('âœ?æµå¼æ•°æ®å¤„ç†ï¼Œå‡å°‘å†…å­˜å ç”?),
                    Text('âœ?å¢å¼ºçš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶'),
                    Text('âœ?è¯¦ç»†çš„è¿›åº¦æ˜¾ç¤?),
                    Text('âœ?æ•°æ®åº“å¥åº·æ£€æŸ?),
                    Text('âœ?å¯å–æ¶ˆçš„å¤‡ä»½æ“ä½œ'),
                    Text('âœ?æ™ºèƒ½å‹ç¼©å’Œæ€§èƒ½ç›‘æ§'),
                    Text('âœ?ç»Ÿä¸€çš„èµ„æºç®¡ç?),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void _createCustomBackup(BuildContext context, WidgetRef ref) {
    // æ˜¾ç¤ºè‡ªå®šä¹‰é€‰é¡¹å¯¹è¯æ¡?
    showDialog(
      context: context,
      builder: (context) => _CustomBackupDialog(ref: ref),
    );
  }
}

class _CustomBackupDialog extends StatefulWidget {
  final WidgetRef ref;
  
  const _CustomBackupDialog({required this.ref});
  
  @override
  State<_CustomBackupDialog> createState() => _CustomBackupDialogState();
}

class _CustomBackupDialogState extends State<_CustomBackupDialog> {
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final bool _encrypt = false;
  
  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('è‡ªå®šä¹‰å¤‡ä»½é€‰é¡¹'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(
              labelText: 'å¤‡ä»½åç§°ï¼ˆå¯é€‰ï¼‰',
              hintText: 'ä¾‹å¦‚ï¼šdaily_backup',
            ),
          ),
          const SizedBox(height: 12),
          TextField(
            controller: _descriptionController,
            decoration: const InputDecoration(
              labelText: 'å¤‡ä»½æè¿°',
              hintText: 'ä¾‹å¦‚ï¼šæ¯æ—¥è‡ªåŠ¨å¤‡ä»?,
            ),
            maxLines: 2,
          ),
          const SizedBox(height: 12),
          CheckboxListTile(
            title: const Text('åŠ å¯†å¤‡ä»½'),
            subtitle: const Text('å½“å‰ç‰ˆæœ¬æš‚ä¸æ”¯æŒ'),
            value: _encrypt,
            onChanged: null, // æš‚æ—¶ç¦ç”¨
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: _createBackup,
          child: const Text('åˆ›å»ºå¤‡ä»½'),
        ),
      ],
    );
  }
  
  void _createBackup() {
    Navigator.of(context).pop();
    
    final options = BackupOptions(
      customName: _nameController.text.trim().isEmpty 
          ? null 
          : _nameController.text.trim(),
      description: _descriptionController.text.trim().isEmpty 
          ? null 
          : _descriptionController.text.trim(),
      encrypt: _encrypt,
    );
    
    UnifiedBackupIntegration.createBackupWithErrorHandling(
      context: context,
      ref: widget.ref,
      options: options,
      onSuccess: () {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('è‡ªå®šä¹‰å¤‡ä»½åˆ›å»ºæˆåŠŸï¼')),
        );
      },
      onError: (error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('å¤‡ä»½å¤±è´¥ï¼?error')),
        );
      },
    );
  }
}
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../domain/models/auto_backup_settings.dart';
import '../../data/services/auto_backup_scheduler.dart';
import '../../data/services/unified_backup_service.dart';
import '../../../../core/database/database.dart';

part 'auto_backup_controller.g.dart';

/// è‡ªåŠ¨å¤‡ä»½è°ƒåº¦å™¨æä¾›è€?
@riverpod
AutoBackupScheduler autoBackupScheduler(AutoBackupSchedulerRef ref) {
  final database = ref.watch(appDatabaseProvider);
  final backupService = UnifiedBackupService(database);
  return AutoBackupScheduler(backupService);
}

/// è‡ªåŠ¨å¤‡ä»½è®¾ç½®çŠ¶æ€?
@riverpod
class AutoBackupController extends _$AutoBackupController {
  AutoBackupScheduler? _scheduler;

  @override
  Future<AutoBackupSettings> build() async {
    _scheduler = ref.read(autoBackupSchedulerProvider);
    await _scheduler!.initialize();
    return _scheduler!.currentSettings;
  }

  /// æ›´æ–°è‡ªåŠ¨å¤‡ä»½è®¾ç½®
  Future<void> updateSettings(AutoBackupSettings settings) async {
    if (_scheduler == null) return;
    
    state = const AsyncValue.loading();
    
    try {
      await _scheduler!.updateSettings(settings);
      state = AsyncValue.data(settings);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }

  /// å¯ç”¨/ç¦ç”¨è‡ªåŠ¨å¤‡ä»½
  Future<void> toggleAutoBackup(bool enabled) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(enabled: enabled);
    await updateSettings(newSettings);
  }

  /// è®¾ç½®å¤‡ä»½é¢‘ç‡
  Future<void> setBackupFrequency(BackupFrequency frequency) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(frequency: frequency);
    await updateSettings(newSettings);
  }

  /// è®¾ç½®æœ€å¤§å¤‡ä»½æ•°é‡?
  Future<void> setMaxBackupCount(int count) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(maxBackupCount: count);
    await updateSettings(newSettings);
  }

  /// è®¾ç½®WiFié™åˆ¶
  Future<void> setWifiOnly(bool wifiOnly) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(wifiOnly: wifiOnly);
    await updateSettings(newSettings);
  }

  /// è®¾ç½®å……ç”µé™åˆ¶
  Future<void> setChargingOnly(bool chargingOnly) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(chargingOnly: chargingOnly);
    await updateSettings(newSettings);
  }

  /// è®¾ç½®å¤‡ä»½é€‰é¡¹
  Future<void> setBackupOptions(AutoBackupOptions options) async {
    final currentSettings = await future;
    final newSettings = currentSettings.copyWith(backupOptions: options);
    await updateSettings(newSettings);
  }

  /// æ‰‹åŠ¨è§¦å‘å¤‡ä»½
  Future<String> triggerManualBackup() async {
    if (_scheduler == null) {
      return 'è°ƒåº¦å™¨æœªåˆå§‹åŒ?;
    }
    
    try {
      final result = await _scheduler!.triggerManualBackup();
      if (result.success) {
        // åˆ·æ–°çŠ¶æ€?
        ref.invalidateSelf();
        return 'æ‰‹åŠ¨å¤‡ä»½æˆåŠŸ';
      } else {
        return result.errorMessage ?? 'æ‰‹åŠ¨å¤‡ä»½å¤±è´¥';
      }
    } catch (e) {
      return 'æ‰‹åŠ¨å¤‡ä»½å¼‚å¸¸: $e';
    }
  }

  /// è·å–ä¸‹æ¬¡å¤‡ä»½æ—¶é—´æè¿°
  String getNextBackupDescription() {
    return _scheduler?.getNextBackupDescription() ?? 'æœªçŸ¥';
  }
}

/// è‡ªåŠ¨å¤‡ä»½çŠ¶æ€æä¾›è€?
@riverpod
class AutoBackupStatus extends _$AutoBackupStatus {
  @override
  String build() {
    final controller = ref.watch(autoBackupControllerProvider);
    return controller.when(
      data: (settings) {
        final scheduler = ref.read(autoBackupSchedulerProvider);
        return scheduler.getNextBackupDescription();
      },
      loading: () => 'åŠ è½½ä¸?..',
      error: (_, __) => 'è·å–çŠ¶æ€å¤±è´?,
    );
  }

  /// åˆ·æ–°çŠ¶æ€?
  void refresh() {
    ref.invalidateSelf();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auto_backup_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$autoBackupSchedulerHash() =>
    r'0e8a9368882ed245d22a2f9597e1832449dcc88a';

/// è‡ªåŠ¨å¤‡ä»½è°ƒåº¦å™¨æä¾›è€?///
/// Copied from [autoBackupScheduler].
@ProviderFor(autoBackupScheduler)
final autoBackupSchedulerProvider =
    AutoDisposeProvider<AutoBackupScheduler>.internal(
      autoBackupScheduler,
      name: r'autoBackupSchedulerProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$autoBackupSchedulerHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef AutoBackupSchedulerRef = AutoDisposeProviderRef<AutoBackupScheduler>;
String _$autoBackupControllerHash() =>
    r'baed946ff19f18e4953443ddeb4785faf6be61e6';

/// è‡ªåŠ¨å¤‡ä»½è®¾ç½®çŠ¶æ€?///
/// Copied from [AutoBackupController].
@ProviderFor(AutoBackupController)
final autoBackupControllerProvider =
    AutoDisposeAsyncNotifierProvider<
      AutoBackupController,
      AutoBackupSettings
    >.internal(
      AutoBackupController.new,
      name: r'autoBackupControllerProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$autoBackupControllerHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$AutoBackupController = AutoDisposeAsyncNotifier<AutoBackupSettings>;
String _$autoBackupStatusHash() => r'0d9f0d633c4f5467dd4ba52510ef79bff8f3ae71';

/// è‡ªåŠ¨å¤‡ä»½çŠ¶æ€æä¾›è€?///
/// Copied from [AutoBackupStatus].
@ProviderFor(AutoBackupStatus)
final autoBackupStatusProvider =
    AutoDisposeNotifierProvider<AutoBackupStatus, String>.internal(
      AutoBackupStatus.new,
      name: r'autoBackupStatusProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$autoBackupStatusHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$AutoBackupStatus = AutoDisposeNotifier<String>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/models/backup_options.dart';
import '../../domain/models/backup_metadata.dart';
import '../../domain/services/i_backup_service.dart';
import '../../domain/common/backup_common.dart';
import '../../data/providers/backup_service_provider.dart';
import '../../data/services/backup_error_service.dart';
import '../widgets/backup_progress_dialog.dart';

part 'backup_controller.freezed.dart';

/// å¤‡ä»½æ§åˆ¶å™¨çŠ¶æ€?
@freezed
abstract class BackupState with _$BackupState {
  const factory BackupState({
    /// æ˜¯å¦æ­£åœ¨å¤‡ä»½
    @Default(false) bool isBackingUp,

    /// é”™è¯¯ä¿¡æ¯
    String? errorMessage,

    /// å¤‡ä»½è¿›åº¦ä¿¡æ¯
    BackupProgressInfo? progressInfo,

    /// å¤‡ä»½ç»“æœå…ƒæ•°æ?
    BackupMetadata? resultMetadata,

    /// å¤‡ä»½æ–‡ä»¶è·¯å¾„
    String? resultFilePath,
  }) = _BackupState;
}

/// å¤‡ä»½æ§åˆ¶å™?
class BackupController extends StateNotifier<BackupState> {
  final IBackupService _backupService;
  CancelToken? _cancelToken;

  BackupController(this._backupService) : super(const BackupState());

  /// å¼€å§‹å¤‡ä»?
  Future<void> startBackup({
    BackupOptions? options,
  }) async {
    try {
      _cancelToken = CancelToken();

      state = state.copyWith(
        isBackingUp: true,
        errorMessage: null,
        progressInfo: const BackupProgressInfo(
          message: 'å‡†å¤‡å¼€å§‹å¤‡ä»?..',
          current: 0,
          total: 100,
        ),
        resultMetadata: null,
        resultFilePath: null,
      );

      final result = await _backupService.createBackup(
        options: options,
        onProgress: (message, current, total) {
          if (!mounted) return;
          
          state = state.copyWith(
            progressInfo: BackupProgressInfo(
              message: message,
              current: current,
              total: total,
            ),
          );
        },
        cancelToken: _cancelToken,
      );

      if (!mounted) return;

      if (result.success) {
        state = state.copyWith(
          isBackingUp: false,
          progressInfo: state.progressInfo?.copyWith(
            isCompleted: true,
            message: 'å¤‡ä»½å®Œæˆ',
          ),
          resultMetadata: result.metadata,
          resultFilePath: result.filePath,
        );
      } else {
        state = state.copyWith(
          isBackingUp: false,
          errorMessage: result.errorMessage,
          progressInfo: state.progressInfo?.copyWith(
            isCompleted: true,
            errorMessage: result.errorMessage,
          ),
        );
      }
    } on BackupCancelledException {
      if (!mounted) return;
      
      state = state.copyWith(
        isBackingUp: false,
        progressInfo: state.progressInfo?.copyWith(
          isCancelled: true,
          isCompleted: true,
        ),
      );
    } catch (e) {
      if (!mounted) return;
      
      // ä½¿ç”¨é”™è¯¯æœåŠ¡å¤„ç†é”™è¯¯ï¼Œè·å–ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
      final userError = await BackupErrorService.instance.handleError(
        e,
        operation: 'CreateBackup',
        context: {'controllerState': 'backup'},
      );
      
      state = state.copyWith(
        isBackingUp: false,
        errorMessage: userError.message,
        progressInfo: state.progressInfo?.copyWith(
          isCompleted: true,
          errorMessage: userError.message,
        ),
      );
    }
  }

  /// å–æ¶ˆå¤‡ä»½
  void cancelBackup() {
    _cancelToken?.cancel();
    
    if (state.isBackingUp) {
      state = state.copyWith(
        isBackingUp: false,
        progressInfo: state.progressInfo?.copyWith(
          isCancelled: true,
          isCompleted: true,
        ),
      );
    }
  }

  /// é‡è¯•å¤‡ä»½
  Future<void> retryBackup({BackupOptions? options}) async {
    await startBackup(options: options);
  }

  /// é‡ç½®çŠ¶æ€?
  void reset() {
    _cancelToken?.cancel();
    state = const BackupState();
  }

  /// æ¸…é™¤é”™è¯¯
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }

  /// ä¼°ç®—å¤‡ä»½å¤§å°
  Future<int> estimateBackupSize() async {
    try {
      return await _backupService.estimateBackupSize();
    } catch (e) {
      return 0;
    }
  }

  @override
  void dispose() {
    _cancelToken?.cancel();
    super.dispose();
  }
}

/// å¤‡ä»½æ§åˆ¶å™¨æä¾›è€?
final backupControllerProvider =
    StateNotifierProvider<BackupController, BackupState>((ref) {
      final backupService = ref.watch(backupServiceProvider);
      return BackupController(backupService);
    });
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_controller.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$BackupState {

/// æ˜¯å¦æ­£åœ¨å¤‡ä»½
 bool get isBackingUp;/// é”™è¯¯ä¿¡æ¯
 String? get errorMessage;/// å¤‡ä»½è¿›åº¦ä¿¡æ¯
 BackupProgressInfo? get progressInfo;/// å¤‡ä»½ç»“æœå…ƒæ•°æ? BackupMetadata? get resultMetadata;/// å¤‡ä»½æ–‡ä»¶è·¯å¾„
 String? get resultFilePath;
/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupStateCopyWith<BackupState> get copyWith => _$BackupStateCopyWithImpl<BackupState>(this as BackupState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupState&&(identical(other.isBackingUp, isBackingUp) || other.isBackingUp == isBackingUp)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.progressInfo, progressInfo) || other.progressInfo == progressInfo)&&(identical(other.resultMetadata, resultMetadata) || other.resultMetadata == resultMetadata)&&(identical(other.resultFilePath, resultFilePath) || other.resultFilePath == resultFilePath));
}


@override
int get hashCode => Object.hash(runtimeType,isBackingUp,errorMessage,progressInfo,resultMetadata,resultFilePath);

@override
String toString() {
  return 'BackupState(isBackingUp: $isBackingUp, errorMessage: $errorMessage, progressInfo: $progressInfo, resultMetadata: $resultMetadata, resultFilePath: $resultFilePath)';
}


}

/// @nodoc
abstract mixin class $BackupStateCopyWith<$Res>  {
  factory $BackupStateCopyWith(BackupState value, $Res Function(BackupState) _then) = _$BackupStateCopyWithImpl;
@useResult
$Res call({
 bool isBackingUp, String? errorMessage, BackupProgressInfo? progressInfo, BackupMetadata? resultMetadata, String? resultFilePath
});


$BackupMetadataCopyWith<$Res>? get resultMetadata;

}
/// @nodoc
class _$BackupStateCopyWithImpl<$Res>
    implements $BackupStateCopyWith<$Res> {
  _$BackupStateCopyWithImpl(this._self, this._then);

  final BackupState _self;
  final $Res Function(BackupState) _then;

/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isBackingUp = null,Object? errorMessage = freezed,Object? progressInfo = freezed,Object? resultMetadata = freezed,Object? resultFilePath = freezed,}) {
  return _then(_self.copyWith(
isBackingUp: null == isBackingUp ? _self.isBackingUp : isBackingUp // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,progressInfo: freezed == progressInfo ? _self.progressInfo : progressInfo // ignore: cast_nullable_to_non_nullable
as BackupProgressInfo?,resultMetadata: freezed == resultMetadata ? _self.resultMetadata : resultMetadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,resultFilePath: freezed == resultFilePath ? _self.resultFilePath : resultFilePath // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get resultMetadata {
    if (_self.resultMetadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.resultMetadata!, (value) {
    return _then(_self.copyWith(resultMetadata: value));
  });
}
}


/// @nodoc


class _BackupState implements BackupState {
  const _BackupState({this.isBackingUp = false, this.errorMessage, this.progressInfo, this.resultMetadata, this.resultFilePath});
  

/// æ˜¯å¦æ­£åœ¨å¤‡ä»½
@override@JsonKey() final  bool isBackingUp;
/// é”™è¯¯ä¿¡æ¯
@override final  String? errorMessage;
/// å¤‡ä»½è¿›åº¦ä¿¡æ¯
@override final  BackupProgressInfo? progressInfo;
/// å¤‡ä»½ç»“æœå…ƒæ•°æ?@override final  BackupMetadata? resultMetadata;
/// å¤‡ä»½æ–‡ä»¶è·¯å¾„
@override final  String? resultFilePath;

/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupStateCopyWith<_BackupState> get copyWith => __$BackupStateCopyWithImpl<_BackupState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupState&&(identical(other.isBackingUp, isBackingUp) || other.isBackingUp == isBackingUp)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.progressInfo, progressInfo) || other.progressInfo == progressInfo)&&(identical(other.resultMetadata, resultMetadata) || other.resultMetadata == resultMetadata)&&(identical(other.resultFilePath, resultFilePath) || other.resultFilePath == resultFilePath));
}


@override
int get hashCode => Object.hash(runtimeType,isBackingUp,errorMessage,progressInfo,resultMetadata,resultFilePath);

@override
String toString() {
  return 'BackupState(isBackingUp: $isBackingUp, errorMessage: $errorMessage, progressInfo: $progressInfo, resultMetadata: $resultMetadata, resultFilePath: $resultFilePath)';
}


}

/// @nodoc
abstract mixin class _$BackupStateCopyWith<$Res> implements $BackupStateCopyWith<$Res> {
  factory _$BackupStateCopyWith(_BackupState value, $Res Function(_BackupState) _then) = __$BackupStateCopyWithImpl;
@override @useResult
$Res call({
 bool isBackingUp, String? errorMessage, BackupProgressInfo? progressInfo, BackupMetadata? resultMetadata, String? resultFilePath
});


@override $BackupMetadataCopyWith<$Res>? get resultMetadata;

}
/// @nodoc
class __$BackupStateCopyWithImpl<$Res>
    implements _$BackupStateCopyWith<$Res> {
  __$BackupStateCopyWithImpl(this._self, this._then);

  final _BackupState _self;
  final $Res Function(_BackupState) _then;

/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isBackingUp = null,Object? errorMessage = freezed,Object? progressInfo = freezed,Object? resultMetadata = freezed,Object? resultFilePath = freezed,}) {
  return _then(_BackupState(
isBackingUp: null == isBackingUp ? _self.isBackingUp : isBackingUp // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,progressInfo: freezed == progressInfo ? _self.progressInfo : progressInfo // ignore: cast_nullable_to_non_nullable
as BackupProgressInfo?,resultMetadata: freezed == resultMetadata ? _self.resultMetadata : resultMetadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,resultFilePath: freezed == resultFilePath ? _self.resultFilePath : resultFilePath // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of BackupState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get resultMetadata {
    if (_self.resultMetadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.resultMetadata!, (value) {
    return _then(_self.copyWith(resultMetadata: value));
  });
}
}

// dart format on
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/models/backup_metadata.dart';
import '../../domain/services/i_backup_service.dart';
import '../../data/providers/backup_service_provider.dart';

part 'backup_management_controller.freezed.dart';

/// å¤‡ä»½ç®¡ç†çŠ¶æ€?
@freezed
abstract class BackupManagementState with _$BackupManagementState {
  const factory BackupManagementState({
    @Default(false) bool isLoading,
    @Default([]) List<BackupMetadata> backups,
    String? errorMessage,
  }) = _BackupManagementState;
}

/// å¤‡ä»½ç®¡ç†æ§åˆ¶å™?
class BackupManagementController extends StateNotifier<BackupManagementState> {
  final IBackupService _backupService;

  BackupManagementController(this._backupService) : super(const BackupManagementState());

  /// åˆ·æ–°å¤‡ä»½åˆ—è¡¨
  Future<void> refreshBackups() async {
    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final backups = await _backupService.getLocalBackups();
      // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
      backups.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      
      state = state.copyWith(
        isLoading: false,
        backups: backups,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: e.toString(),
      );
    }
  }

  /// åˆ é™¤å¤‡ä»½
  Future<void> deleteBackup(String backupId) async {
    try {
      final success = await _backupService.deleteBackup(backupId);
      if (success) {
        // ä»åˆ—è¡¨ä¸­ç§»é™¤å·²åˆ é™¤çš„å¤‡ä»½
        final updatedBackups = state.backups.where((backup) => backup.id != backupId).toList();
        state = state.copyWith(backups: updatedBackups);
      } else {
        throw Exception('åˆ é™¤å¤‡ä»½å¤±è´¥');
      }
    } catch (e) {
      rethrow;
    }
  }

  /// é‡å‘½åå¤‡ä»?
  Future<void> renameBackup(String backupId, String newName) async {
    try {
      // æ‰¾åˆ°è¦é‡å‘½åçš„å¤‡ä»?
      final backupIndex = state.backups.indexWhere((backup) => backup.id == backupId);
      if (backupIndex == -1) {
        throw Exception('æ‰¾ä¸åˆ°æŒ‡å®šçš„å¤‡ä»½æ–‡ä»¶');
      }

      // åˆ›å»ºæ–°çš„å¤‡ä»½å…ƒæ•°æ?
      final oldBackup = state.backups[backupIndex];
      final updatedBackup = oldBackup.copyWith(fileName: newName);

      // æ›´æ–°åˆ—è¡¨
      final updatedBackups = List<BackupMetadata>.from(state.backups);
      updatedBackups[backupIndex] = updatedBackup;

      state = state.copyWith(backups: updatedBackups);
    } catch (e) {
      rethrow;
    }
  }

  /// è·å–å¤‡ä»½è¯¦æƒ…
  Future<BackupMetadata?> getBackupDetails(String filePath) async {
    try {
      return await _backupService.getBackupInfo(filePath);
    } catch (e) {
      return null;
    }
  }

  /// éªŒè¯å¤‡ä»½æ–‡ä»¶
  Future<bool> validateBackup(String filePath) async {
    try {
      return await _backupService.validateBackupFile(filePath);
    } catch (e) {
      return false;
    }
  }
}

/// å¤‡ä»½ç®¡ç†æ§åˆ¶å™¨æä¾›è€?
final backupManagementControllerProvider = 
    StateNotifierProvider<BackupManagementController, BackupManagementState>((ref) {
  final backupService = ref.watch(backupServiceProvider);
  return BackupManagementController(backupService);
});

/// å¤‡ä»½æ•°é‡æä¾›è€?
final backupCountProvider = Provider<int>((ref) {
  final state = ref.watch(backupManagementControllerProvider);
  return state.backups.length;
});

/// æ€»å¤‡ä»½å¤§å°æä¾›è€?
final totalBackupSizeProvider = Provider<int>((ref) {
  final state = ref.watch(backupManagementControllerProvider);
  return state.backups.fold(0, (sum, backup) => sum + backup.fileSize);
});
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'backup_management_controller.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$BackupManagementState {

 bool get isLoading; List<BackupMetadata> get backups; String? get errorMessage;
/// Create a copy of BackupManagementState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BackupManagementStateCopyWith<BackupManagementState> get copyWith => _$BackupManagementStateCopyWithImpl<BackupManagementState>(this as BackupManagementState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BackupManagementState&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&const DeepCollectionEquality().equals(other.backups, backups)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage));
}


@override
int get hashCode => Object.hash(runtimeType,isLoading,const DeepCollectionEquality().hash(backups),errorMessage);

@override
String toString() {
  return 'BackupManagementState(isLoading: $isLoading, backups: $backups, errorMessage: $errorMessage)';
}


}

/// @nodoc
abstract mixin class $BackupManagementStateCopyWith<$Res>  {
  factory $BackupManagementStateCopyWith(BackupManagementState value, $Res Function(BackupManagementState) _then) = _$BackupManagementStateCopyWithImpl;
@useResult
$Res call({
 bool isLoading, List<BackupMetadata> backups, String? errorMessage
});




}
/// @nodoc
class _$BackupManagementStateCopyWithImpl<$Res>
    implements $BackupManagementStateCopyWith<$Res> {
  _$BackupManagementStateCopyWithImpl(this._self, this._then);

  final BackupManagementState _self;
  final $Res Function(BackupManagementState) _then;

/// Create a copy of BackupManagementState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isLoading = null,Object? backups = null,Object? errorMessage = freezed,}) {
  return _then(_self.copyWith(
isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,backups: null == backups ? _self.backups : backups // ignore: cast_nullable_to_non_nullable
as List<BackupMetadata>,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


/// @nodoc


class _BackupManagementState implements BackupManagementState {
  const _BackupManagementState({this.isLoading = false, final  List<BackupMetadata> backups = const [], this.errorMessage}): _backups = backups;
  

@override@JsonKey() final  bool isLoading;
 final  List<BackupMetadata> _backups;
@override@JsonKey() List<BackupMetadata> get backups {
  if (_backups is EqualUnmodifiableListView) return _backups;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_backups);
}

@override final  String? errorMessage;

/// Create a copy of BackupManagementState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BackupManagementStateCopyWith<_BackupManagementState> get copyWith => __$BackupManagementStateCopyWithImpl<_BackupManagementState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BackupManagementState&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&const DeepCollectionEquality().equals(other._backups, _backups)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage));
}


@override
int get hashCode => Object.hash(runtimeType,isLoading,const DeepCollectionEquality().hash(_backups),errorMessage);

@override
String toString() {
  return 'BackupManagementState(isLoading: $isLoading, backups: $backups, errorMessage: $errorMessage)';
}


}

/// @nodoc
abstract mixin class _$BackupManagementStateCopyWith<$Res> implements $BackupManagementStateCopyWith<$Res> {
  factory _$BackupManagementStateCopyWith(_BackupManagementState value, $Res Function(_BackupManagementState) _then) = __$BackupManagementStateCopyWithImpl;
@override @useResult
$Res call({
 bool isLoading, List<BackupMetadata> backups, String? errorMessage
});




}
/// @nodoc
class __$BackupManagementStateCopyWithImpl<$Res>
    implements _$BackupManagementStateCopyWith<$Res> {
  __$BackupManagementStateCopyWithImpl(this._self, this._then);

  final _BackupManagementState _self;
  final $Res Function(_BackupManagementState) _then;

/// Create a copy of BackupManagementState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isLoading = null,Object? backups = null,Object? errorMessage = freezed,}) {
  return _then(_BackupManagementState(
isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,backups: null == backups ? _self._backups : backups // ignore: cast_nullable_to_non_nullable
as List<BackupMetadata>,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:file_picker/file_picker.dart';

import '../../domain/models/backup_metadata.dart';
import '../../domain/models/restore_preview.dart';
import '../../domain/models/restore_result.dart';
import '../../domain/models/restore_mode.dart';
import '../../domain/services/i_restore_service.dart';
import '../../domain/common/backup_common.dart';
import '../../data/providers/restore_service_provider.dart';
import '../../data/utils/file_access_helper.dart';

part 'restore_controller.freezed.dart';

/// æ¢å¤æ§åˆ¶å™¨çŠ¶æ€?
@freezed
abstract class RestoreState with _$RestoreState {
  const factory RestoreState({
    /// æ˜¯å¦æ­£åœ¨åŠ è½½
    @Default(false) bool isLoading,
    /// é”™è¯¯ä¿¡æ¯
    String? errorMessage,
    /// é€‰ä¸­çš„å¤‡ä»½æ–‡ä»¶è·¯å¾?
    String? selectedFilePath,
    /// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ?
    BackupMetadata? backupMetadata,
    /// æ¢å¤é¢„è§ˆä¿¡æ¯
    RestorePreview? restorePreview,
    /// é€‰æ‹©çš„æ¢å¤æ¨¡å¼?
    @Default(RestoreMode.merge) RestoreMode restoreMode,
    /// æ˜¯å¦éœ€è¦å¯†ç ?
    @Default(false) bool requiresPassword,
    /// è¾“å…¥çš„å¯†ç ?
    String? password,
    /// é€‰æ‹©çš„è¡¨ï¼ˆnullè¡¨ç¤ºå…¨éƒ¨ï¼?
    List<String>? selectedTables,
    /// æ¢å¤è¿›åº¦ä¿¡æ¯
    RestoreProgressInfo? progressInfo,
    /// æ¢å¤ç»“æœ
    RestoreResult? restoreResult,
  }) = _RestoreState;
}

/// æ¢å¤è¿›åº¦ä¿¡æ¯
@freezed
abstract class RestoreProgressInfo with _$RestoreProgressInfo {
  const factory RestoreProgressInfo({
    required String message,
    required int current,
    required int total,
    @Default(false) bool isCompleted,
    @Default(false) bool isCancelled,
  }) = _RestoreProgressInfo;
}

/// æ¢å¤æ§åˆ¶å™?
class RestoreController extends StateNotifier<RestoreState> {
  final IRestoreService _restoreService;
  CancelToken? _cancelToken;

  RestoreController(this._restoreService) : super(const RestoreState());

  /// é€‰æ‹©å¤‡ä»½æ–‡ä»¶
  Future<void> selectBackupFile() async {
    try {
      state = state.copyWith(isLoading: true, errorMessage: null);

      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['json', 'backup'],
        allowMultiple: false,
        withData: true, // ç¡®ä¿è·å–æ–‡ä»¶æ•°æ®
      );

      if (result != null && result.files.isNotEmpty) {
        final platformFile = result.files.first;
        String? filePath = platformFile.path;
        
        // å¦‚æœæ— æ³•è·å–è·¯å¾„æˆ–è·¯å¾„æ— æ•ˆï¼Œå°è¯•ä½¿ç”¨æ–‡ä»¶æ•°æ®
        if (filePath == null || !await FileAccessHelper.isFileAccessible(filePath)) {
          if (platformFile.bytes != null) {
            // å°†æ–‡ä»¶æ•°æ®ä¿å­˜åˆ°ä¸´æ—¶ä½ç½®
            filePath = await FileAccessHelper.saveToTempFile(platformFile.bytes!, platformFile.name);
            
            // æç¤ºç”¨æˆ·æ–‡ä»¶å·²å¤åˆ¶åˆ°ä¸´æ—¶ä½ç½®
            state = state.copyWith(
              errorMessage: 'åŸæ–‡ä»¶è·¯å¾„æ— æ³•è®¿é—®ï¼Œå·²è‡ªåŠ¨å¤åˆ¶åˆ°ä¸´æ—¶ä½ç½®è¿›è¡Œå¤„ç†',
            );
          } else {
            throw Exception('æ— æ³•è®¿é—®é€‰æ‹©çš„æ–‡ä»¶ã€‚è¯·å°†å¤‡ä»½æ–‡ä»¶å¤åˆ¶åˆ°ä¸‹è½½æˆ–æ–‡æ¡£æ–‡ä»¶å¤¹åé‡æ–°é€‰æ‹©ã€?);
          }
        }
        
        state = state.copyWith(
          selectedFilePath: filePath,
          backupMetadata: null,
          restorePreview: null,
          requiresPassword: false,
          password: null,
        );
          
        // å°è¯•éªŒè¯æ–‡ä»¶
        await _validateBackupFile(filePath);
      }
    } catch (e) {
      state = state.copyWith(
        errorMessage: 'é€‰æ‹©æ–‡ä»¶å¤±è´¥: ${e.toString()}',
      );
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }

  /// éªŒè¯å¤‡ä»½æ–‡ä»¶
  Future<void> _validateBackupFile(String filePath, {String? password}) async {
    try {
      state = state.copyWith(isLoading: true, errorMessage: null);

      final metadata = await _restoreService.validateBackupFile(
        filePath,
        password: password,
      );

      state = state.copyWith(
        backupMetadata: metadata,
        requiresPassword: false,
      );

      // ç”Ÿæˆé¢„è§ˆ
      await _generatePreview(filePath, password: password);
    } catch (e) {
      final errorMessage = e.toString();
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†é”™è¯¯ï¼Œéœ€è¦å¯†ç ?
      if (errorMessage.contains('è§£å¯†') || errorMessage.contains('å¯†ç ')) {
        state = state.copyWith(
          requiresPassword: true,
          errorMessage: 'æ­¤å¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼Œè¯·è¾“å…¥å¯†ç ',
        );
      } else {
        state = state.copyWith(
          errorMessage: 'éªŒè¯å¤‡ä»½æ–‡ä»¶å¤±è´¥: $errorMessage',
        );
      }
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }

  /// è¾“å…¥å¯†ç å¹¶éªŒè¯?
  Future<void> validateWithPassword(String password) async {
    if (state.selectedFilePath == null) return;

    state = state.copyWith(password: password);
    await _validateBackupFile(state.selectedFilePath!, password: password);
  }

  /// ç”Ÿæˆæ¢å¤é¢„è§ˆ
  Future<void> _generatePreview(String filePath, {String? password}) async {
    try {
      final preview = await _restoreService.previewRestore(
        filePath,
        mode: state.restoreMode,
        password: password,
      );

      state = state.copyWith(restorePreview: preview);
    } catch (e) {
      state = state.copyWith(
        errorMessage: 'ç”Ÿæˆé¢„è§ˆå¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// è®¾ç½®æ¢å¤æ¨¡å¼
  void setRestoreMode(RestoreMode mode) {
    state = state.copyWith(restoreMode: mode);
    
    // å¦‚æœå·²ç»é€‰æ‹©äº†æ–‡ä»¶ï¼Œé‡æ–°ç”Ÿæˆé¢„è§ˆä»¥åæ˜ æ–°çš„æ¨¡å¼?
    if (state.selectedFilePath != null && state.backupMetadata != null) {
      _generatePreview(state.selectedFilePath!, password: state.password);
    }
  }

  /// è®¾ç½®é€‰æ‹©çš„è¡¨
  void setSelectedTables(List<String>? tables) {
    state = state.copyWith(selectedTables: tables);
  }

  /// å¼€å§‹æ¢å¤?
  Future<void> startRestore() async {
    if (state.selectedFilePath == null) return;

    try {
      _cancelToken = CancelToken();
      
      state = state.copyWith(
        progressInfo: const RestoreProgressInfo(
          message: 'å‡†å¤‡å¼€å§‹æ¢å¤?..',
          current: 0,
          total: 100,
        ),
        restoreResult: null,
        errorMessage: null,
      );

      final result = await _restoreService.restoreFromBackup(
        filePath: state.selectedFilePath!,
        mode: state.restoreMode,
        password: state.password,
        selectedTables: state.selectedTables,
        onProgress: (message, current, total) {
          state = state.copyWith(
            progressInfo: RestoreProgressInfo(
              message: message,
              current: current,
              total: total,
            ),
          );
        },
        cancelToken: _cancelToken,
      );

      state = state.copyWith(
        restoreResult: result,
        progressInfo: state.progressInfo?.copyWith(
          isCompleted: true,
        ),
      );
    } on RestoreCancelledException {
      state = state.copyWith(
        progressInfo: state.progressInfo?.copyWith(
          isCancelled: true,
          isCompleted: true,
        ),
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: 'æ¢å¤å¤±è´¥: ${e.toString()}',
        progressInfo: state.progressInfo?.copyWith(
          isCompleted: true,
        ),
      );
    }
  }

  /// å–æ¶ˆæ¢å¤
  void cancelRestore() {
    _cancelToken?.cancel();
    state = state.copyWith(
      progressInfo: state.progressInfo?.copyWith(
        isCancelled: true,
        isCompleted: true,
      ),
    );
  }

  /// é‡ç½®çŠ¶æ€?
  void reset() {
    _cancelToken?.cancel();
    state = const RestoreState();
  }

  /// æ¸…é™¤é”™è¯¯
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }


}

/// æ¢å¤æ§åˆ¶å™¨æä¾›è€?
final restoreControllerProvider = StateNotifierProvider<RestoreController, RestoreState>((ref) {
  final restoreService = ref.watch(restoreServiceProvider);
  return RestoreController(restoreService);
});
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'restore_controller.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$RestoreState {

/// æ˜¯å¦æ­£åœ¨åŠ è½½
 bool get isLoading;/// é”™è¯¯ä¿¡æ¯
 String? get errorMessage;/// é€‰ä¸­çš„å¤‡ä»½æ–‡ä»¶è·¯å¾? String? get selectedFilePath;/// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ? BackupMetadata? get backupMetadata;/// æ¢å¤é¢„è§ˆä¿¡æ¯
 RestorePreview? get restorePreview;/// é€‰æ‹©çš„æ¢å¤æ¨¡å¼? RestoreMode get restoreMode;/// æ˜¯å¦éœ€è¦å¯†ç ? bool get requiresPassword;/// è¾“å…¥çš„å¯†ç ? String? get password;/// é€‰æ‹©çš„è¡¨ï¼ˆnullè¡¨ç¤ºå…¨éƒ¨ï¼? List<String>? get selectedTables;/// æ¢å¤è¿›åº¦ä¿¡æ¯
 RestoreProgressInfo? get progressInfo;/// æ¢å¤ç»“æœ
 RestoreResult? get restoreResult;
/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RestoreStateCopyWith<RestoreState> get copyWith => _$RestoreStateCopyWithImpl<RestoreState>(this as RestoreState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RestoreState&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.selectedFilePath, selectedFilePath) || other.selectedFilePath == selectedFilePath)&&(identical(other.backupMetadata, backupMetadata) || other.backupMetadata == backupMetadata)&&(identical(other.restorePreview, restorePreview) || other.restorePreview == restorePreview)&&(identical(other.restoreMode, restoreMode) || other.restoreMode == restoreMode)&&(identical(other.requiresPassword, requiresPassword) || other.requiresPassword == requiresPassword)&&(identical(other.password, password) || other.password == password)&&const DeepCollectionEquality().equals(other.selectedTables, selectedTables)&&(identical(other.progressInfo, progressInfo) || other.progressInfo == progressInfo)&&(identical(other.restoreResult, restoreResult) || other.restoreResult == restoreResult));
}


@override
int get hashCode => Object.hash(runtimeType,isLoading,errorMessage,selectedFilePath,backupMetadata,restorePreview,restoreMode,requiresPassword,password,const DeepCollectionEquality().hash(selectedTables),progressInfo,restoreResult);

@override
String toString() {
  return 'RestoreState(isLoading: $isLoading, errorMessage: $errorMessage, selectedFilePath: $selectedFilePath, backupMetadata: $backupMetadata, restorePreview: $restorePreview, restoreMode: $restoreMode, requiresPassword: $requiresPassword, password: $password, selectedTables: $selectedTables, progressInfo: $progressInfo, restoreResult: $restoreResult)';
}


}

/// @nodoc
abstract mixin class $RestoreStateCopyWith<$Res>  {
  factory $RestoreStateCopyWith(RestoreState value, $Res Function(RestoreState) _then) = _$RestoreStateCopyWithImpl;
@useResult
$Res call({
 bool isLoading, String? errorMessage, String? selectedFilePath, BackupMetadata? backupMetadata, RestorePreview? restorePreview, RestoreMode restoreMode, bool requiresPassword, String? password, List<String>? selectedTables, RestoreProgressInfo? progressInfo, RestoreResult? restoreResult
});


$BackupMetadataCopyWith<$Res>? get backupMetadata;$RestorePreviewCopyWith<$Res>? get restorePreview;$RestoreProgressInfoCopyWith<$Res>? get progressInfo;$RestoreResultCopyWith<$Res>? get restoreResult;

}
/// @nodoc
class _$RestoreStateCopyWithImpl<$Res>
    implements $RestoreStateCopyWith<$Res> {
  _$RestoreStateCopyWithImpl(this._self, this._then);

  final RestoreState _self;
  final $Res Function(RestoreState) _then;

/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isLoading = null,Object? errorMessage = freezed,Object? selectedFilePath = freezed,Object? backupMetadata = freezed,Object? restorePreview = freezed,Object? restoreMode = null,Object? requiresPassword = null,Object? password = freezed,Object? selectedTables = freezed,Object? progressInfo = freezed,Object? restoreResult = freezed,}) {
  return _then(_self.copyWith(
isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,selectedFilePath: freezed == selectedFilePath ? _self.selectedFilePath : selectedFilePath // ignore: cast_nullable_to_non_nullable
as String?,backupMetadata: freezed == backupMetadata ? _self.backupMetadata : backupMetadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,restorePreview: freezed == restorePreview ? _self.restorePreview : restorePreview // ignore: cast_nullable_to_non_nullable
as RestorePreview?,restoreMode: null == restoreMode ? _self.restoreMode : restoreMode // ignore: cast_nullable_to_non_nullable
as RestoreMode,requiresPassword: null == requiresPassword ? _self.requiresPassword : requiresPassword // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,selectedTables: freezed == selectedTables ? _self.selectedTables : selectedTables // ignore: cast_nullable_to_non_nullable
as List<String>?,progressInfo: freezed == progressInfo ? _self.progressInfo : progressInfo // ignore: cast_nullable_to_non_nullable
as RestoreProgressInfo?,restoreResult: freezed == restoreResult ? _self.restoreResult : restoreResult // ignore: cast_nullable_to_non_nullable
as RestoreResult?,
  ));
}
/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get backupMetadata {
    if (_self.backupMetadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.backupMetadata!, (value) {
    return _then(_self.copyWith(backupMetadata: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestorePreviewCopyWith<$Res>? get restorePreview {
    if (_self.restorePreview == null) {
    return null;
  }

  return $RestorePreviewCopyWith<$Res>(_self.restorePreview!, (value) {
    return _then(_self.copyWith(restorePreview: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestoreProgressInfoCopyWith<$Res>? get progressInfo {
    if (_self.progressInfo == null) {
    return null;
  }

  return $RestoreProgressInfoCopyWith<$Res>(_self.progressInfo!, (value) {
    return _then(_self.copyWith(progressInfo: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestoreResultCopyWith<$Res>? get restoreResult {
    if (_self.restoreResult == null) {
    return null;
  }

  return $RestoreResultCopyWith<$Res>(_self.restoreResult!, (value) {
    return _then(_self.copyWith(restoreResult: value));
  });
}
}


/// @nodoc


class _RestoreState implements RestoreState {
  const _RestoreState({this.isLoading = false, this.errorMessage, this.selectedFilePath, this.backupMetadata, this.restorePreview, this.restoreMode = RestoreMode.merge, this.requiresPassword = false, this.password, final  List<String>? selectedTables, this.progressInfo, this.restoreResult}): _selectedTables = selectedTables;
  

/// æ˜¯å¦æ­£åœ¨åŠ è½½
@override@JsonKey() final  bool isLoading;
/// é”™è¯¯ä¿¡æ¯
@override final  String? errorMessage;
/// é€‰ä¸­çš„å¤‡ä»½æ–‡ä»¶è·¯å¾?@override final  String? selectedFilePath;
/// å¤‡ä»½æ–‡ä»¶å…ƒæ•°æ?@override final  BackupMetadata? backupMetadata;
/// æ¢å¤é¢„è§ˆä¿¡æ¯
@override final  RestorePreview? restorePreview;
/// é€‰æ‹©çš„æ¢å¤æ¨¡å¼?@override@JsonKey() final  RestoreMode restoreMode;
/// æ˜¯å¦éœ€è¦å¯†ç ?@override@JsonKey() final  bool requiresPassword;
/// è¾“å…¥çš„å¯†ç ?@override final  String? password;
/// é€‰æ‹©çš„è¡¨ï¼ˆnullè¡¨ç¤ºå…¨éƒ¨ï¼? final  List<String>? _selectedTables;
/// é€‰æ‹©çš„è¡¨ï¼ˆnullè¡¨ç¤ºå…¨éƒ¨ï¼?@override List<String>? get selectedTables {
  final value = _selectedTables;
  if (value == null) return null;
  if (_selectedTables is EqualUnmodifiableListView) return _selectedTables;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// æ¢å¤è¿›åº¦ä¿¡æ¯
@override final  RestoreProgressInfo? progressInfo;
/// æ¢å¤ç»“æœ
@override final  RestoreResult? restoreResult;

/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RestoreStateCopyWith<_RestoreState> get copyWith => __$RestoreStateCopyWithImpl<_RestoreState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RestoreState&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.selectedFilePath, selectedFilePath) || other.selectedFilePath == selectedFilePath)&&(identical(other.backupMetadata, backupMetadata) || other.backupMetadata == backupMetadata)&&(identical(other.restorePreview, restorePreview) || other.restorePreview == restorePreview)&&(identical(other.restoreMode, restoreMode) || other.restoreMode == restoreMode)&&(identical(other.requiresPassword, requiresPassword) || other.requiresPassword == requiresPassword)&&(identical(other.password, password) || other.password == password)&&const DeepCollectionEquality().equals(other._selectedTables, _selectedTables)&&(identical(other.progressInfo, progressInfo) || other.progressInfo == progressInfo)&&(identical(other.restoreResult, restoreResult) || other.restoreResult == restoreResult));
}


@override
int get hashCode => Object.hash(runtimeType,isLoading,errorMessage,selectedFilePath,backupMetadata,restorePreview,restoreMode,requiresPassword,password,const DeepCollectionEquality().hash(_selectedTables),progressInfo,restoreResult);

@override
String toString() {
  return 'RestoreState(isLoading: $isLoading, errorMessage: $errorMessage, selectedFilePath: $selectedFilePath, backupMetadata: $backupMetadata, restorePreview: $restorePreview, restoreMode: $restoreMode, requiresPassword: $requiresPassword, password: $password, selectedTables: $selectedTables, progressInfo: $progressInfo, restoreResult: $restoreResult)';
}


}

/// @nodoc
abstract mixin class _$RestoreStateCopyWith<$Res> implements $RestoreStateCopyWith<$Res> {
  factory _$RestoreStateCopyWith(_RestoreState value, $Res Function(_RestoreState) _then) = __$RestoreStateCopyWithImpl;
@override @useResult
$Res call({
 bool isLoading, String? errorMessage, String? selectedFilePath, BackupMetadata? backupMetadata, RestorePreview? restorePreview, RestoreMode restoreMode, bool requiresPassword, String? password, List<String>? selectedTables, RestoreProgressInfo? progressInfo, RestoreResult? restoreResult
});


@override $BackupMetadataCopyWith<$Res>? get backupMetadata;@override $RestorePreviewCopyWith<$Res>? get restorePreview;@override $RestoreProgressInfoCopyWith<$Res>? get progressInfo;@override $RestoreResultCopyWith<$Res>? get restoreResult;

}
/// @nodoc
class __$RestoreStateCopyWithImpl<$Res>
    implements _$RestoreStateCopyWith<$Res> {
  __$RestoreStateCopyWithImpl(this._self, this._then);

  final _RestoreState _self;
  final $Res Function(_RestoreState) _then;

/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isLoading = null,Object? errorMessage = freezed,Object? selectedFilePath = freezed,Object? backupMetadata = freezed,Object? restorePreview = freezed,Object? restoreMode = null,Object? requiresPassword = null,Object? password = freezed,Object? selectedTables = freezed,Object? progressInfo = freezed,Object? restoreResult = freezed,}) {
  return _then(_RestoreState(
isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,selectedFilePath: freezed == selectedFilePath ? _self.selectedFilePath : selectedFilePath // ignore: cast_nullable_to_non_nullable
as String?,backupMetadata: freezed == backupMetadata ? _self.backupMetadata : backupMetadata // ignore: cast_nullable_to_non_nullable
as BackupMetadata?,restorePreview: freezed == restorePreview ? _self.restorePreview : restorePreview // ignore: cast_nullable_to_non_nullable
as RestorePreview?,restoreMode: null == restoreMode ? _self.restoreMode : restoreMode // ignore: cast_nullable_to_non_nullable
as RestoreMode,requiresPassword: null == requiresPassword ? _self.requiresPassword : requiresPassword // ignore: cast_nullable_to_non_nullable
as bool,password: freezed == password ? _self.password : password // ignore: cast_nullable_to_non_nullable
as String?,selectedTables: freezed == selectedTables ? _self._selectedTables : selectedTables // ignore: cast_nullable_to_non_nullable
as List<String>?,progressInfo: freezed == progressInfo ? _self.progressInfo : progressInfo // ignore: cast_nullable_to_non_nullable
as RestoreProgressInfo?,restoreResult: freezed == restoreResult ? _self.restoreResult : restoreResult // ignore: cast_nullable_to_non_nullable
as RestoreResult?,
  ));
}

/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BackupMetadataCopyWith<$Res>? get backupMetadata {
    if (_self.backupMetadata == null) {
    return null;
  }

  return $BackupMetadataCopyWith<$Res>(_self.backupMetadata!, (value) {
    return _then(_self.copyWith(backupMetadata: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestorePreviewCopyWith<$Res>? get restorePreview {
    if (_self.restorePreview == null) {
    return null;
  }

  return $RestorePreviewCopyWith<$Res>(_self.restorePreview!, (value) {
    return _then(_self.copyWith(restorePreview: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestoreProgressInfoCopyWith<$Res>? get progressInfo {
    if (_self.progressInfo == null) {
    return null;
  }

  return $RestoreProgressInfoCopyWith<$Res>(_self.progressInfo!, (value) {
    return _then(_self.copyWith(progressInfo: value));
  });
}/// Create a copy of RestoreState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RestoreResultCopyWith<$Res>? get restoreResult {
    if (_self.restoreResult == null) {
    return null;
  }

  return $RestoreResultCopyWith<$Res>(_self.restoreResult!, (value) {
    return _then(_self.copyWith(restoreResult: value));
  });
}
}

/// @nodoc
mixin _$RestoreProgressInfo {

 String get message; int get current; int get total; bool get isCompleted; bool get isCancelled;
/// Create a copy of RestoreProgressInfo
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RestoreProgressInfoCopyWith<RestoreProgressInfo> get copyWith => _$RestoreProgressInfoCopyWithImpl<RestoreProgressInfo>(this as RestoreProgressInfo, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RestoreProgressInfo&&(identical(other.message, message) || other.message == message)&&(identical(other.current, current) || other.current == current)&&(identical(other.total, total) || other.total == total)&&(identical(other.isCompleted, isCompleted) || other.isCompleted == isCompleted)&&(identical(other.isCancelled, isCancelled) || other.isCancelled == isCancelled));
}


@override
int get hashCode => Object.hash(runtimeType,message,current,total,isCompleted,isCancelled);

@override
String toString() {
  return 'RestoreProgressInfo(message: $message, current: $current, total: $total, isCompleted: $isCompleted, isCancelled: $isCancelled)';
}


}

/// @nodoc
abstract mixin class $RestoreProgressInfoCopyWith<$Res>  {
  factory $RestoreProgressInfoCopyWith(RestoreProgressInfo value, $Res Function(RestoreProgressInfo) _then) = _$RestoreProgressInfoCopyWithImpl;
@useResult
$Res call({
 String message, int current, int total, bool isCompleted, bool isCancelled
});




}
/// @nodoc
class _$RestoreProgressInfoCopyWithImpl<$Res>
    implements $RestoreProgressInfoCopyWith<$Res> {
  _$RestoreProgressInfoCopyWithImpl(this._self, this._then);

  final RestoreProgressInfo _self;
  final $Res Function(RestoreProgressInfo) _then;

/// Create a copy of RestoreProgressInfo
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? current = null,Object? total = null,Object? isCompleted = null,Object? isCancelled = null,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,current: null == current ? _self.current : current // ignore: cast_nullable_to_non_nullable
as int,total: null == total ? _self.total : total // ignore: cast_nullable_to_non_nullable
as int,isCompleted: null == isCompleted ? _self.isCompleted : isCompleted // ignore: cast_nullable_to_non_nullable
as bool,isCancelled: null == isCancelled ? _self.isCancelled : isCancelled // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// @nodoc


class _RestoreProgressInfo implements RestoreProgressInfo {
  const _RestoreProgressInfo({required this.message, required this.current, required this.total, this.isCompleted = false, this.isCancelled = false});
  

@override final  String message;
@override final  int current;
@override final  int total;
@override@JsonKey() final  bool isCompleted;
@override@JsonKey() final  bool isCancelled;

/// Create a copy of RestoreProgressInfo
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RestoreProgressInfoCopyWith<_RestoreProgressInfo> get copyWith => __$RestoreProgressInfoCopyWithImpl<_RestoreProgressInfo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RestoreProgressInfo&&(identical(other.message, message) || other.message == message)&&(identical(other.current, current) || other.current == current)&&(identical(other.total, total) || other.total == total)&&(identical(other.isCompleted, isCompleted) || other.isCompleted == isCompleted)&&(identical(other.isCancelled, isCancelled) || other.isCancelled == isCancelled));
}


@override
int get hashCode => Object.hash(runtimeType,message,current,total,isCompleted,isCancelled);

@override
String toString() {
  return 'RestoreProgressInfo(message: $message, current: $current, total: $total, isCompleted: $isCompleted, isCancelled: $isCancelled)';
}


}

/// @nodoc
abstract mixin class _$RestoreProgressInfoCopyWith<$Res> implements $RestoreProgressInfoCopyWith<$Res> {
  factory _$RestoreProgressInfoCopyWith(_RestoreProgressInfo value, $Res Function(_RestoreProgressInfo) _then) = __$RestoreProgressInfoCopyWithImpl;
@override @useResult
$Res call({
 String message, int current, int total, bool isCompleted, bool isCancelled
});




}
/// @nodoc
class __$RestoreProgressInfoCopyWithImpl<$Res>
    implements _$RestoreProgressInfoCopyWith<$Res> {
  __$RestoreProgressInfoCopyWithImpl(this._self, this._then);

  final _RestoreProgressInfo _self;
  final $Res Function(_RestoreProgressInfo) _then;

/// Create a copy of RestoreProgressInfo
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? current = null,Object? total = null,Object? isCompleted = null,Object? isCancelled = null,}) {
  return _then(_RestoreProgressInfo(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,current: null == current ? _self.current : current // ignore: cast_nullable_to_non_nullable
as int,total: null == total ? _self.total : total // ignore: cast_nullable_to_non_nullable
as int,isCompleted: null == isCompleted ? _self.isCompleted : isCompleted // ignore: cast_nullable_to_non_nullable
as bool,isCancelled: null == isCancelled ? _self.isCancelled : isCancelled // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../data/providers/backup_error_service_provider.dart';
import '../../data/services/backup_error_handler.dart';
import '../widgets/backup_error_widget.dart';

/// é”™è¯¯å¤„ç†é›†æˆç¤ºä¾‹
class ErrorHandlingIntegrationExample extends ConsumerStatefulWidget {
  const ErrorHandlingIntegrationExample({super.key});

  @override
  ConsumerState<ErrorHandlingIntegrationExample> createState() =>
      _ErrorHandlingIntegrationExampleState();
}

class _ErrorHandlingIntegrationExampleState
    extends ConsumerState<ErrorHandlingIntegrationExample> {
  UserFriendlyError? _currentError;

  @override
  void initState() {
    super.initState();
    
    // ç›‘å¬é”™è¯¯æµ?
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _listenToErrors();
    });
  }

  void _listenToErrors() {
    ref.listen(backupErrorStreamProvider, (previous, next) {
      next.when(
        data: (error) {
          setState(() {
            _currentError = error;
          });
          
          // æ ¹æ®é”™è¯¯ä¸¥é‡ç¨‹åº¦é€‰æ‹©æ˜¾ç¤ºæ–¹å¼
          if (_shouldShowAsDialog(error)) {
            _showErrorDialog(error);
          } else {
            _showErrorSnackBar(error);
          }
        },
        loading: () {},
        error: (error, stackTrace) {
          // å¤„ç†ç›‘å¬é”™è¯¯æµæ—¶çš„é”™è¯?
          debugPrint('Error listening to error stream: $error');
        },
      );
    });
  }

  bool _shouldShowAsDialog(UserFriendlyError error) {
    // æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦æ˜¾ç¤ºå¯¹è¯æ¡?
    return error.suggestion != null || 
           error.technicalDetails != null ||
           error.title.contains('ä¸¥é‡') ||
           error.title.contains('å¤±è´¥');
  }

  void _showErrorDialog(UserFriendlyError error) {
    BackupErrorDialog.show(
      context,
      error: error,
      onRetry: error.canRetry ? () => _retryLastOperation() : null,
      showTechnicalDetails: true,
    );
  }

  void _showErrorSnackBar(UserFriendlyError error) {
    BackupErrorSnackBar.show(
      context,
      error: error,
      onRetry: error.canRetry ? () => _retryLastOperation() : null,
    );
  }

  void _retryLastOperation() {
    // è¿™é‡Œåº”è¯¥é‡è¯•æœ€åå¤±è´¥çš„æ“ä½œ
    // å…·ä½“å®ç°å–å†³äºåº”ç”¨çš„çŠ¶æ€ç®¡ç?
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('æ­£åœ¨é‡è¯•æ“ä½œ...')),
    );
  }

  @override
  Widget build(BuildContext context) {
    final errorStatsAsync = ref.watch(backupErrorStatsProvider());

    return Scaffold(
      appBar: AppBar(
        title: const Text('é”™è¯¯å¤„ç†é›†æˆç¤ºä¾‹'),
        actions: [
          IconButton(
            icon: const Icon(Icons.bug_report),
            onPressed: _showErrorStats,
            tooltip: 'æŸ¥çœ‹é”™è¯¯ç»Ÿè®¡',
          ),
        ],
      ),
      body: Column(
        children: [
          // å½“å‰é”™è¯¯æ˜¾ç¤º
          if (_currentError != null) ...[
            BackupErrorWidget(
              error: _currentError!,
              onRetry: _currentError!.canRetry ? _retryLastOperation : null,
              onDismiss: () => setState(() => _currentError = null),
              showTechnicalDetails: true,
            ),
            const Divider(),
          ],

          // é”™è¯¯ç»Ÿè®¡ä¿¡æ¯
          Expanded(
            child: errorStatsAsync.when(
              data: (stats) => _buildErrorStats(stats),
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (error, stackTrace) => Center(
                child: Text('åŠ è½½é”™è¯¯ç»Ÿè®¡å¤±è´¥: $error'),
              ),
            ),
          ),

          // æµ‹è¯•æŒ‰é’®
          Padding(
            padding: const EdgeInsets.all(16),
            child: Wrap(
              spacing: 8,
              children: [
                ElevatedButton(
                  onPressed: _simulateFileSystemError,
                  child: const Text('æ¨¡æ‹Ÿæ–‡ä»¶ç³»ç»Ÿé”™è¯¯'),
                ),
                ElevatedButton(
                  onPressed: _simulateDatabaseError,
                  child: const Text('æ¨¡æ‹Ÿæ•°æ®åº“é”™è¯?),
                ),
                ElevatedButton(
                  onPressed: _simulateValidationError,
                  child: const Text('æ¨¡æ‹ŸéªŒè¯é”™è¯¯'),
                ),
                ElevatedButton(
                  onPressed: _exportErrorReport,
                  child: const Text('å¯¼å‡ºé”™è¯¯æŠ¥å‘Š'),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorStats(Map<String, dynamic> stats) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'é”™è¯¯ç»Ÿè®¡ (æœ€è¿?${stats['period']} å¤?',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text('æ€»é”™è¯¯æ•°: ${stats['totalErrors']}'),
                const SizedBox(height: 16),
                
                if (stats['errorsByType'] != null) ...[
                  Text(
                    'æŒ‰ç±»å‹åˆ†ç±?',
                    style: Theme.of(context).textTheme.titleSmall,
                  ),
                  const SizedBox(height: 8),
                  ...(stats['errorsByType'] as Map<String, dynamic>)
                      .entries
                      .map((entry) => Padding(
                            padding: const EdgeInsets.only(left: 16, bottom: 4),
                            child: Text('${entry.key}: ${entry.value}'),
                          )),
                ],
                
                const SizedBox(height: 16),
                
                if (stats['errorsByOperation'] != null) ...[
                  Text(
                    'æŒ‰æ“ä½œåˆ†ç±?',
                    style: Theme.of(context).textTheme.titleSmall,
                  ),
                  const SizedBox(height: 8),
                  ...(stats['errorsByOperation'] as Map<String, dynamic>)
                      .entries
                      .map((entry) => Padding(
                            padding: const EdgeInsets.only(left: 16, bottom: 4),
                            child: Text('${entry.key}: ${entry.value}'),
                          )),
                ],
              ],
            ),
          ),
        ),
        
        if (stats['resourceStats'] != null) ...[
          const SizedBox(height: 16),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'èµ„æºç»Ÿè®¡',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 8),
                  Text('æ€»èµ„æºæ•°: ${stats['resourceStats']['totalResources']}'),
                  Text('æ´»è·ƒæ“ä½œæ•? ${stats['resourceStats']['activeOperations']}'),
                  
                  if (stats['resourceStats']['resourcesByType'] != null) ...[
                    const SizedBox(height: 8),
                    Text(
                      'æŒ‰ç±»å‹åˆ†ç±?',
                      style: Theme.of(context).textTheme.titleSmall,
                    ),
                    ...(stats['resourceStats']['resourcesByType'] as Map<String, dynamic>)
                        .entries
                        .map((entry) => Padding(
                              padding: const EdgeInsets.only(left: 16, bottom: 4),
                              child: Text('${entry.key}: ${entry.value}'),
                            )),
                  ],
                ],
              ),
            ),
          ),
        ],
      ],
    );
  }

  void _showErrorStats() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('é”™è¯¯ç»Ÿè®¡'),
        content: SizedBox(
          width: double.maxFinite,
          height: 400,
          child: Consumer(
            builder: (context, ref, child) {
              final statsAsync = ref.watch(backupErrorStatsProvider());
              return statsAsync.when(
                data: (stats) => _buildErrorStats(stats),
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (error, stackTrace) => Center(
                  child: Text('åŠ è½½å¤±è´¥: $error'),
                ),
              );
            },
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å…³é—­'),
          ),
        ],
      ),
    );
  }

  void _simulateFileSystemError() async {
    final errorService = ref.read(backupErrorServiceProvider);
    
    try {
      await errorService.executeWithRetry(
        () => throw Exception('æ¨¡æ‹Ÿçš„æ–‡ä»¶ç³»ç»Ÿé”™è¯?),
        operationName: 'SimulateFileSystemError',
        context: {'test': true},
      );
    } catch (e) {
      // é”™è¯¯å·²ç»è¢«å¤„ç†å’Œè®°å½•
    }
  }

  void _simulateDatabaseError() async {
    final errorService = ref.read(backupErrorServiceProvider);
    
    try {
      await errorService.executeWithRetry(
        () => throw Exception('æ¨¡æ‹Ÿçš„æ•°æ®åº“é”™è¯¯'),
        operationName: 'SimulateDatabaseError',
        context: {'test': true},
      );
    } catch (e) {
      // é”™è¯¯å·²ç»è¢«å¤„ç†å’Œè®°å½•
    }
  }

  void _simulateValidationError() async {
    final errorService = ref.read(backupErrorServiceProvider);
    
    try {
      await errorService.executeWithRetry(
        () => throw FormatException('æ¨¡æ‹Ÿçš„éªŒè¯é”™è¯?),
        operationName: 'SimulateValidationError',
        context: {'test': true},
      );
    } catch (e) {
      // é”™è¯¯å·²ç»è¢«å¤„ç†å’Œè®°å½•
    }
  }

  void _exportErrorReport() async {
    final errorService = ref.read(backupErrorServiceProvider);
    
    try {
      final filePath = await errorService.exportErrorReport(
        period: const Duration(days: 7),
      );
      
      if (filePath != null && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('é”™è¯¯æŠ¥å‘Šå·²å¯¼å‡ºåˆ°: $filePath'),
            duration: const Duration(seconds: 3),
          ),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('å¯¼å‡ºé”™è¯¯æŠ¥å‘Šå¤±è´¥'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('å¯¼å‡ºå¤±è´¥: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../widgets/backup_button.dart';

/// ç¤ºä¾‹ï¼šå¦‚ä½•å°†å¤‡ä»½åŠŸèƒ½é›†æˆåˆ°è®¾ç½®é¡µé?
/// 
/// åœ¨ç°æœ‰çš„ _DataManagementSection ä¸­æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š
/// 
/// ```dart
/// // åœ?_DataManagementSection çš?build æ–¹æ³•ä¸­æ·»åŠ ï¼š
/// const QuickBackupButton(),
/// const Divider(),
/// ```
/// 
/// æˆ–è€…åˆ›å»ºä¸€ä¸ªä¸“é—¨çš„å¤‡ä»½ç®¡ç†éƒ¨åˆ†ï¼?
class BackupManagementSection extends ConsumerWidget {
  const BackupManagementSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            'æ•°æ®å¤‡ä»½',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        const QuickBackupButton(),
        ListTile(
          leading: const Icon(Icons.folder),
          title: const Text('ç®¡ç†å¤‡ä»½æ–‡ä»¶'),
          subtitle: const Text('æŸ¥çœ‹ã€åˆ é™¤æˆ–åˆ†äº«å·²åˆ›å»ºçš„å¤‡ä»½'),
          trailing: const Icon(Icons.arrow_forward_ios),
          onTap: () {
            // TODO: å¯¼èˆªåˆ°å¤‡ä»½ç®¡ç†é¡µé?
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('å¤‡ä»½ç®¡ç†åŠŸèƒ½å³å°†æ¨å‡º')),
            );
          },
        ),
      ],
    );
  }
}

/// ä½¿ç”¨ç¤ºä¾‹ï¼?
/// 
/// åœ?SettingsScreen ä¸­ä½¿ç”¨ï¼š
/// ```dart
/// ListView(
///   children: [
///     // ... å…¶ä»–è®¾ç½®é¡?
///     const Divider(),
///     const BackupManagementSection(),
///     // ... å…¶ä»–è®¾ç½®é¡?
///   ],
/// )
/// ```
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fluttertoast/fluttertoast.dart';

import '../../domain/models/auto_backup_settings.dart';
import '../controllers/auto_backup_controller.dart';
import '../widgets/auto_backup_settings_card.dart';
import '../widgets/backup_frequency_selector.dart';
import '../widgets/backup_options_card.dart';

/// è‡ªåŠ¨å¤‡ä»½è®¾ç½®é¡µé¢
class AutoBackupSettingsScreen extends ConsumerWidget {
  const AutoBackupSettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settingsAsync = ref.watch(autoBackupControllerProvider);
    final statusText = ref.watch(autoBackupStatusProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('è‡ªåŠ¨å¤‡ä»½è®¾ç½®'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: settingsAsync.when(
        data: (settings) => _buildSettingsContent(context, ref, settings, statusText),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.error_outline,
                size: 64,
                color: Theme.of(context).colorScheme.error,
              ),
              const SizedBox(height: 16),
              Text(
                'åŠ è½½è®¾ç½®å¤±è´¥',
                style: Theme.of(context).textTheme.headlineSmall,
              ),
              const SizedBox(height: 8),
              Text(
                error.toString(),
                style: Theme.of(context).textTheme.bodyMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () => ref.refresh(autoBackupControllerProvider),
                child: const Text('é‡è¯•'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSettingsContent(
    BuildContext context,
    WidgetRef ref,
    AutoBackupSettings settings,
    String statusText,
  ) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // è‡ªåŠ¨å¤‡ä»½å¼€å…?
          AutoBackupSettingsCard(
            title: 'å¯ç”¨è‡ªåŠ¨å¤‡ä»½',
            subtitle: settings.enabled ? 'è‡ªåŠ¨å¤‡ä»½å·²å¯ç”? : 'è‡ªåŠ¨å¤‡ä»½å·²ç¦ç”?,
            trailing: Switch(
              value: settings.enabled,
              onChanged: (value) async {
                await ref.read(autoBackupControllerProvider.notifier).toggleAutoBackup(value);
                Fluttertoast.showToast(
                  msg: value ? 'è‡ªåŠ¨å¤‡ä»½å·²å¯ç”? : 'è‡ªåŠ¨å¤‡ä»½å·²ç¦ç”?,
                );
              },
            ),
          ),

          const SizedBox(height: 16),

          // çŠ¶æ€ä¿¡æ?
          if (settings.enabled) ...[
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.schedule,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'å¤‡ä»½çŠ¶æ€?,
                          style: Theme.of(context).textTheme.titleMedium,
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    _buildStatusRow(
                      context,
                      'ä¸‹æ¬¡å¤‡ä»½',
                      statusText,
                      Icons.access_time,
                    ),
                    if (settings.lastBackupTime != null) ...[
                      const SizedBox(height: 8),
                      _buildStatusRow(
                        context,
                        'ä¸Šæ¬¡å¤‡ä»½',
                        _formatDateTime(settings.lastBackupTime!),
                        Icons.backup,
                      ),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
          ],

          // å¤‡ä»½é¢‘ç‡è®¾ç½®
          if (settings.enabled) ...[
            BackupFrequencySelector(
              currentFrequency: settings.frequency,
              onFrequencyChanged: (frequency) async {
                await ref.read(autoBackupControllerProvider.notifier).setBackupFrequency(frequency);
                Fluttertoast.showToast(msg: 'å¤‡ä»½é¢‘ç‡å·²æ›´æ–?);
              },
            ),
            const SizedBox(height: 16),
          ],

          // å¤‡ä»½æ•°é‡è®¾ç½®
          if (settings.enabled) ...[
            AutoBackupSettingsCard(
              title: 'æœ€å¤§å¤‡ä»½æ•°é‡?,
              subtitle: 'ä¿ç•™æœ€è¿?${settings.maxBackupCount} ä¸ªè‡ªåŠ¨å¤‡ä»½æ–‡ä»?,
              trailing: DropdownButton<int>(
                value: settings.maxBackupCount,
                items: [3, 5, 10, 15, 20].map((count) {
                  return DropdownMenuItem(
                    value: count,
                    child: Text('$count ä¸?),
                  );
                }).toList(),
                onChanged: (value) async {
                  if (value != null) {
                    await ref.read(autoBackupControllerProvider.notifier).setMaxBackupCount(value);
                    Fluttertoast.showToast(msg: 'æœ€å¤§å¤‡ä»½æ•°é‡å·²æ›´æ–°');
                  }
                },
              ),
            ),
            const SizedBox(height: 16),
          ],

          // è®¾å¤‡æ¡ä»¶è®¾ç½®
          if (settings.enabled) ...[
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.phone_android,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'è®¾å¤‡æ¡ä»¶',
                          style: Theme.of(context).textTheme.titleMedium,
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    SwitchListTile(
                      title: const Text('ä»…åœ¨WiFiä¸‹å¤‡ä»?),
                      subtitle: const Text('é¿å…ä½¿ç”¨ç§»åŠ¨æ•°æ®'),
                      value: settings.wifiOnly,
                      onChanged: (value) async {
                        await ref.read(autoBackupControllerProvider.notifier).setWifiOnly(value);
                        Fluttertoast.showToast(
                          msg: value ? 'å·²å¯ç”¨WiFié™åˆ¶' : 'å·²ç¦ç”¨WiFié™åˆ¶',
                        );
                      },
                    ),
                    SwitchListTile(
                      title: const Text('ä»…åœ¨å……ç”µæ—¶å¤‡ä»?),
                      subtitle: const Text('é¿å…æ¶ˆè€—ç”µæ± ç”µé‡?),
                      value: settings.chargingOnly,
                      onChanged: (value) async {
                        await ref.read(autoBackupControllerProvider.notifier).setChargingOnly(value);
                        Fluttertoast.showToast(
                          msg: value ? 'å·²å¯ç”¨å……ç”µé™åˆ? : 'å·²ç¦ç”¨å……ç”µé™åˆ?,
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
          ],

          // å¤‡ä»½é€‰é¡¹è®¾ç½®
          if (settings.enabled) ...[
            BackupOptionsCard(
              options: settings.backupOptions ?? const AutoBackupOptions(),
              onOptionsChanged: (options) async {
                await ref.read(autoBackupControllerProvider.notifier).setBackupOptions(options);
                Fluttertoast.showToast(msg: 'å¤‡ä»½é€‰é¡¹å·²æ›´æ–?);
              },
            ),
            const SizedBox(height: 16),
          ],

          // æ‰‹åŠ¨è§¦å‘å¤‡ä»½æŒ‰é’®
          if (settings.enabled) ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () async {
                  final result = await ref.read(autoBackupControllerProvider.notifier).triggerManualBackup();
                  Fluttertoast.showToast(msg: result);
                },
                icon: const Icon(Icons.backup),
                label: const Text('ç«‹å³å¤‡ä»½'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildStatusRow(BuildContext context, String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(
          icon,
          size: 16,
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        ),
        const SizedBox(width: 8),
        Text(
          '$label: ',
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
        Expanded(
          child: Text(
            value,
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ],
    );
  }

  String _formatDateTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 0) {
      return '${difference.inDays}å¤©å‰';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}å°æ—¶å‰?;
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes}åˆ†é’Ÿå‰?;
    } else {
      return 'åˆšåˆš';
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../data/utils/backup_file_manager.dart';
import '../../domain/models/backup_metadata.dart';
import '../../domain/models/backup_options.dart';
import '../controllers/backup_controller.dart';
import '../controllers/backup_management_controller.dart';
import '../widgets/progress_manager.dart';
import '../widgets/create_backup_dialog.dart';
import '../widgets/backup_details_dialog.dart';
import '../widgets/backup_troubleshooting_guide.dart';
import '../widgets/backup_diagnostic_dialog.dart';
import 'restore_screen.dart';
import '../../../../core/services/toast_service.dart';

/// å¤‡ä»½ç®¡ç†ç•Œé¢
class BackupManagementScreen extends ConsumerStatefulWidget {
  const BackupManagementScreen({super.key});

  @override
  ConsumerState<BackupManagementScreen> createState() => _BackupManagementScreenState();
}

class _BackupManagementScreenState extends ConsumerState<BackupManagementScreen> {
  @override
  void initState() {
    super.initState();
    // é¡µé¢åŠ è½½æ—¶åˆ·æ–°å¤‡ä»½åˆ—è¡?
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(backupManagementControllerProvider.notifier).refreshBackups();
    });
  }

  @override
  Widget build(BuildContext context) {
    final backupState = ref.watch(backupManagementControllerProvider);

    return ProgressManager(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('å¤‡ä»½ç®¡ç†'),
          actions: [
            IconButton(
              icon: const Icon(Icons.healing),
              onPressed: () => _showDiagnosticDialog(context),
              tooltip: 'ç³»ç»Ÿè¯Šæ–­',
            ),
            IconButton(
              icon: const Icon(Icons.help_outline),
              onPressed: () => BackupTroubleshootingGuide.show(context),
              tooltip: 'æ•…éšœæ’é™¤',
            ),
            IconButton(
              icon: const Icon(Icons.restore),
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const RestoreScreen(),
                  ),
                );
              },
              tooltip: 'æ¢å¤æ•°æ®',
            ),
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () {
                ref.read(backupManagementControllerProvider.notifier).refreshBackups();
              },
            ),
          ],
        ),
        body: RefreshIndicator(
          onRefresh: () async {
            await ref.read(backupManagementControllerProvider.notifier).refreshBackups();
          },
          child: _buildBody(context, backupState),
        ),
        floatingActionButton: FloatingActionButton.extended(
          onPressed: () => _showCreateBackupDialog(context),
          icon: const Icon(Icons.backup),
          label: const Text('åˆ›å»ºå¤‡ä»½'),
        ),
      ),
    );
  }

  Widget _buildBody(BuildContext context, BackupManagementState state) {
    if (state.isLoading) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    if (state.errorMessage != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              'åŠ è½½å¤±è´¥',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              state.errorMessage!,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                ref.read(backupManagementControllerProvider.notifier).refreshBackups();
              },
              child: const Text('é‡è¯•'),
            ),
          ],
        ),
      );
    }

    if (state.backups.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.backup_outlined,
              size: 64,
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            const SizedBox(height: 16),
            Text(
              'æš‚æ— å¤‡ä»½æ–‡ä»¶',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ›å»ºæ‚¨çš„ç¬¬ä¸€ä¸ªå¤‡ä»?,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: state.backups.length,
      itemBuilder: (context, index) {
        final backup = state.backups[index];
        return _buildBackupCard(context, backup);
      },
    );
  }

  Widget _buildBackupCard(BuildContext context, BackupMetadata backup) {
    final dateFormat = DateFormat('yyyy-MM-dd HH:mm');
    final fileSizeText = _formatFileSize(backup.fileSize);
    final totalRecords = backup.tableCounts.values.fold(0, (sum, count) => sum + count);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => _showBackupDetails(context, backup),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    backup.isEncrypted ? Icons.lock : Icons.backup,
                    color: backup.isEncrypted 
                        ? Theme.of(context).colorScheme.secondary
                        : Theme.of(context).colorScheme.primary,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          backup.fileName,
                          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          dateFormat.format(backup.createdAt),
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  PopupMenuButton<String>(
                    onSelected: (value) => _handleMenuAction(context, value, backup),
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                        value: 'details',
                        child: ListTile(
                          leading: Icon(Icons.info_outline),
                          title: Text('æŸ¥çœ‹è¯¦æƒ…'),
                          contentPadding: EdgeInsets.zero,
                        ),
                      ),
                      const PopupMenuItem(
                        value: 'rename',
                        child: ListTile(
                          leading: Icon(Icons.edit),
                          title: Text('é‡å‘½å?),
                          contentPadding: EdgeInsets.zero,
                        ),
                      ),
                      const PopupMenuItem(
                        value: 'share',
                        child: ListTile(
                          leading: Icon(Icons.share),
                          title: Text('åˆ†äº«'),
                          contentPadding: EdgeInsets.zero,
                        ),
                      ),
                      const PopupMenuDivider(),
                      const PopupMenuItem(
                        value: 'delete',
                        child: ListTile(
                          leading: Icon(Icons.delete, color: Colors.red),
                          title: Text('åˆ é™¤', style: TextStyle(color: Colors.red)),
                          contentPadding: EdgeInsets.zero,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  _buildInfoChip(
                    context,
                    Icons.storage,
                    fileSizeText,
                  ),
                  const SizedBox(width: 8),
                  _buildInfoChip(
                    context,
                    Icons.dataset,
                    '$totalRecords æ¡è®°å½?,
                  ),
                  if (backup.isEncrypted) ...[
                    const SizedBox(width: 8),
                    _buildInfoChip(
                      context,
                      Icons.security,
                      'å·²åŠ å¯?,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                  ],
                ],
              ),
              if (backup.description != null) ...[
                const SizedBox(height: 8),
                Text(
                  backup.description!,
                  style: Theme.of(context).textTheme.bodySmall,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInfoChip(
    BuildContext context,
    IconData icon,
    String label, {
    Color? color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: (color ?? Theme.of(context).colorScheme.primary).withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: color ?? Theme.of(context).colorScheme.primary,
          ),
          const SizedBox(width: 4),
          Text(
            label,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: color ?? Theme.of(context).colorScheme.primary,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  void _showCreateBackupDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => CreateBackupDialog(
        onCreateBackup: (options) => _createBackup(options),
      ),
    );
  }

  void _showBackupDetails(BuildContext context, BackupMetadata backup) {
    showDialog(
      context: context,
      builder: (context) => BackupDetailsDialog(backup: backup),
    );
  }

  Future<void> _createBackup(BackupOptions options) async {
    try {
      // å¼€å§‹å¤‡ä»?- è¿›åº¦å¯¹è¯æ¡†å°†ç”?ProgressManager è‡ªåŠ¨æ˜¾ç¤º
      await ref.read(backupControllerProvider.notifier).startBackup(options: options);
      
      // åˆ·æ–°å¤‡ä»½åˆ—è¡¨
      await ref.read(backupManagementControllerProvider.notifier).refreshBackups();
    } catch (e) {
      // é”™è¯¯å¤„ç†ç”?ProgressManager å¤„ç†
      ToastService.error('å¤‡ä»½åˆ›å»ºå¤±è´¥: $e');
    }
  }

  void _handleMenuAction(BuildContext context, String action, BackupMetadata backup) {
    switch (action) {
      case 'details':
        _showBackupDetails(context, backup);
        break;
      case 'rename':
        _showRenameDialog(context, backup);
        break;
      case 'share':
        _shareBackup(context, backup);
        break;
      case 'delete':
        _showDeleteConfirmation(context, backup);
        break;
    }
  }

  void _showRenameDialog(BuildContext context, BackupMetadata backup) {
    final controller = TextEditingController(text: backup.fileName);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('é‡å‘½åå¤‡ä»?),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            labelText: 'æ–°æ–‡ä»¶å',
            hintText: 'è¯·è¾“å…¥æ–°çš„æ–‡ä»¶å',
          ),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              final newName = controller.text.trim();
              if (newName.isEmpty) {
                ToastService.error('æ–‡ä»¶åä¸èƒ½ä¸ºç©?);
                return;
              }
              
              Navigator.of(context).pop();
              
              try {
                await ref.read(backupManagementControllerProvider.notifier)
                    .renameBackup(backup.id, newName);
                ToastService.success('é‡å‘½åæˆåŠ?);
              } catch (e) {
                ToastService.error('é‡å‘½åå¤±è´? $e');
              }
            },
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );
  }

  void _shareBackup(BuildContext context, BackupMetadata backup) async {
    try {
      await BackupFileManager.shareBackupFile(backup);
      ToastService.success('åˆ†äº«æˆåŠŸ');
    } catch (e) {
      ToastService.error('åˆ†äº«å¤±è´¥: $e');
    }
  }

  void _showDeleteConfirmation(BuildContext context, BackupMetadata backup) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('åˆ é™¤å¤‡ä»½'),
        content: Text('ç¡®å®šè¦åˆ é™¤å¤‡ä»½æ–‡ä»?"${backup.fileName}" å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ã€?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.of(context).pop();
              
              try {
                await ref.read(backupManagementControllerProvider.notifier)
                    .deleteBackup(backup.id);
                ToastService.success('å¤‡ä»½å·²åˆ é™?);
              } catch (e) {
                ToastService.error('åˆ é™¤å¤±è´¥: $e');
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
              foregroundColor: Theme.of(context).colorScheme.onError,
            ),
            child: const Text('åˆ é™¤'),
          ),
        ],
      ),
    );
  }

  void _showDiagnosticDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const BackupDiagnosticDialog(),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/restore_mode.dart';
import '../controllers/restore_controller.dart';
import '../widgets/restore_file_selector.dart';
import '../widgets/restore_mode_selector.dart';
import '../widgets/restore_preview_card.dart';
import '../widgets/progress_manager.dart';
import '../widgets/password_input_dialog.dart';

/// æ•°æ®æ¢å¤ç•Œé¢
class RestoreScreen extends ConsumerStatefulWidget {
  const RestoreScreen({super.key});

  @override
  ConsumerState<RestoreScreen> createState() => _RestoreScreenState();
}

class _RestoreScreenState extends ConsumerState<RestoreScreen> {
  @override
  void initState() {
    super.initState();
    // é‡ç½®çŠ¶æ€?
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(restoreControllerProvider.notifier).reset();
    });
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(restoreControllerProvider);

    return ProgressManager(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('æ¢å¤æ•°æ®'),
          actions: [
            if (state.selectedFilePath != null)
              IconButton(
                icon: const Icon(Icons.refresh),
                onPressed: () {
                  ref.read(restoreControllerProvider.notifier).reset();
                },
                tooltip: 'é‡æ–°é€‰æ‹©',
              ),
          ],
        ),
        body: _buildBody(context, state),
      ),
    );
  }

  Widget _buildBody(BuildContext context, RestoreState state) {
    if (state.isLoading) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('æ­£åœ¨å¤„ç†...'),
          ],
        ),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // æ–‡ä»¶é€‰æ‹©å™?
          RestoreFileSelector(
            selectedFilePath: state.selectedFilePath,
            onSelectFile: () {
              ref.read(restoreControllerProvider.notifier).selectBackupFile();
            },
          ),
          
          if (state.errorMessage != null) ...[
            const SizedBox(height: 16),
            _buildErrorCard(context, state.errorMessage!),
          ],

          if (state.requiresPassword) ...[
            const SizedBox(height: 16),
            _buildPasswordPrompt(context),
          ],

          if (state.restorePreview != null) ...[
            const SizedBox(height: 16),
            RestorePreviewCard(
              preview: state.restorePreview!,
            ),
            
            const SizedBox(height: 16),
            RestoreModeSelector(
              selectedMode: state.restoreMode,
              onModeChanged: (mode) {
                ref.read(restoreControllerProvider.notifier).setRestoreMode(mode);
              },
            ),
            
            const SizedBox(height: 24),
            _buildRestoreButton(context, state),
          ],
        ],
      ),
    );
  }

  Widget _buildErrorCard(BuildContext context, String errorMessage) {
    return Card(
      color: Theme.of(context).colorScheme.errorContainer,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Icon(
              Icons.error_outline,
              color: Theme.of(context).colorScheme.onErrorContainer,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                errorMessage,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.onErrorContainer,
                ),
              ),
            ),
            IconButton(
              icon: Icon(
                Icons.close,
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
              onPressed: () {
                ref.read(restoreControllerProvider.notifier).clearError();
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPasswordPrompt(BuildContext context) {
    return Card(
      color: Theme.of(context).colorScheme.secondaryContainer,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.lock,
                  color: Theme.of(context).colorScheme.onSecondaryContainer,
                ),
                const SizedBox(width: 12),
                Text(
                  'éœ€è¦å¯†ç ?,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondaryContainer,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              'æ­¤å¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼Œè¯·è¾“å…¥å¯†ç ä»¥ç»§ç»?,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSecondaryContainer,
              ),
            ),
            const SizedBox(height: 12),
            ElevatedButton.icon(
              onPressed: () => _showPasswordDialog(context),
              icon: const Icon(Icons.key),
              label: const Text('è¾“å…¥å¯†ç '),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRestoreButton(BuildContext context, RestoreState state) {
    final preview = state.restorePreview!;
    final totalRecords = preview.recordCounts.values.fold<int>(0, (sum, count) => sum + count);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (!preview.isCompatible) ...[
          Card(
            color: Theme.of(context).colorScheme.errorContainer,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.warning,
                        color: Theme.of(context).colorScheme.onErrorContainer,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        'å…¼å®¹æ€§è­¦å‘?,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          color: Theme.of(context).colorScheme.onErrorContainer,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'æ­¤å¤‡ä»½æ–‡ä»¶ä¸å½“å‰åº”ç”¨ç‰ˆæœ¬å¯èƒ½ä¸å®Œå…¨å…¼å®¹ï¼Œæ¢å¤è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°é—®é¢˜ã€?,
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.onErrorContainer,
                    ),
                  ),
                  if (preview.compatibilityWarnings.isNotEmpty) ...[
                    const SizedBox(height: 8),
                    ...preview.compatibilityWarnings.map((warning) => 
                      Text(
                        'â€?$warning',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.onErrorContainer,
                          fontSize: 12,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),
        ],
        
        ElevatedButton.icon(
          onPressed: () => _showRestoreConfirmation(context, state),
          icon: const Icon(Icons.restore),
          label: Text('å¼€å§‹æ¢å¤?($totalRecords æ¡è®°å½?'),
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(vertical: 16),
            backgroundColor: preview.isCompatible 
                ? Theme.of(context).colorScheme.primary
                : Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  // ç§»é™¤æ‰‹åŠ¨çŠ¶æ€å¤„ç†ï¼Œç”?ProgressManager ç»Ÿä¸€ç®¡ç†

  void _showPasswordDialog(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => PasswordInputDialog(
        onPasswordSubmitted: (password) {
          ref.read(restoreControllerProvider.notifier).validateWithPassword(password);
        },
      ),
    );
  }

  void _showRestoreConfirmation(BuildContext context, RestoreState state) {
    final preview = state.restorePreview!;
    final totalRecords = preview.recordCounts.values.fold<int>(0, (sum, count) => sum + count);
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤æ¢å¤'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('å³å°†æ¢å¤ $totalRecords æ¡è®°å½•åˆ°æ•°æ®åº“ä¸­ã€?),
            const SizedBox(height: 8),
            Text('æ¢å¤æ¨¡å¼: ${_getRestoreModeText(state.restoreMode)}'),
            const SizedBox(height: 16),
            if (state.restoreMode == RestoreMode.replace) ...[
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.errorContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.warning,
                      color: Theme.of(context).colorScheme.onErrorContainer,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'è­¦å‘Šï¼šå®Œå…¨æ›¿æ¢æ¨¡å¼å°†åˆ é™¤æ‰€æœ‰ç°æœ‰æ•°æ®ï¼',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.onErrorContainer,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
            ],
            const Text('æ­¤æ“ä½œæ— æ³•æ’¤é”€ï¼Œè¯·ç¡®è®¤æ˜¯å¦ç»§ç»­ï¼?),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              ref.read(restoreControllerProvider.notifier).startRestore();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: state.restoreMode == RestoreMode.replace
                  ? Theme.of(context).colorScheme.error
                  : null,
            ),
            child: const Text('ç¡®è®¤æ¢å¤'),
          ),
        ],
      ),
    );
  }

  String _getRestoreModeText(RestoreMode mode) {
    switch (mode) {
      case RestoreMode.replace:
        return 'å®Œå…¨æ›¿æ¢ç°æœ‰æ•°æ®';
      case RestoreMode.merge:
        return 'åˆå¹¶æ•°æ®';
      case RestoreMode.addOnly:
        return 'ä»…æ·»åŠ æ–°æ•°æ®';
    }
  }
}
import 'package:flutter/material.dart';

/// è‡ªåŠ¨å¤‡ä»½è®¾ç½®å¡ç‰‡ç»„ä»¶
class AutoBackupSettingsCard extends StatelessWidget {
  final String title;
  final String? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;
  final IconData? leadingIcon;

  const AutoBackupSettingsCard({
    super.key,
    required this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.leadingIcon,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        leading: leadingIcon != null
            ? Icon(
                leadingIcon,
                color: Theme.of(context).colorScheme.primary,
              )
            : null,
        title: Text(
          title,
          style: Theme.of(context).textTheme.titleMedium,
        ),
        subtitle: subtitle != null
            ? Text(
                subtitle!,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              )
            : null,
        trailing: trailing,
        onTap: onTap,
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/backup_options.dart';
import '../controllers/backup_controller.dart';

/// å¤‡ä»½æŒ‰é’®ç»„ä»¶
class BackupButton extends ConsumerWidget {
  final String? customName;
  final bool showIcon;
  final String? buttonText;

  const BackupButton({
    super.key,
    this.customName,
    this.showIcon = true,
    this.buttonText,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final backupState = ref.watch(backupControllerProvider);

    return ElevatedButton.icon(
      onPressed: backupState.isBackingUp ? null : () => _startBackup(context, ref),
      icon: showIcon 
          ? (backupState.isBackingUp 
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Icon(Icons.backup))
          : const SizedBox.shrink(),
      label: Text(
        backupState.isBackingUp 
            ? 'å¤‡ä»½ä¸?..' 
            : (buttonText ?? 'åˆ›å»ºå¤‡ä»½'),
      ),
    );
  }

  Future<void> _startBackup(BuildContext context, WidgetRef ref) async {
    // åˆ›å»ºå¤‡ä»½é€‰é¡¹
    final options = BackupOptions(
      customName: customName,
      includeImages: false, // æš‚æ—¶ä¸åŒ…å«å›¾ç‰?
      encrypt: false, // æš‚æ—¶ä¸åŠ å¯?
      description: 'æ‰‹åŠ¨åˆ›å»ºçš„å¤‡ä»?,
    );

    // å¼€å§‹å¤‡ä»?- è¿›åº¦å¯¹è¯æ¡†å°†ç”?ProgressManager è‡ªåŠ¨æ˜¾ç¤º
    await ref.read(backupControllerProvider.notifier).startBackup(
      options: options,
    );
  }
}

/// å¿«é€Ÿå¤‡ä»½æŒ‰é’®ï¼ˆç”¨äºè®¾ç½®é¡µé¢ï¼?
class QuickBackupButton extends ConsumerWidget {
  const QuickBackupButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: const Icon(Icons.backup),
      title: const Text('åˆ›å»ºæ•°æ®å¤‡ä»½'),
      subtitle: const Text('å°†æ‰€æœ‰æ•°æ®å¯¼å‡ºåˆ°å¤‡ä»½æ–‡ä»¶'),
      trailing: const Icon(Icons.arrow_forward_ios),
      onTap: () => _showBackupOptions(context, ref),
    );
  }

  void _showBackupOptions(BuildContext context, WidgetRef ref) {
    showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('åˆ›å»ºå¤‡ä»½'),
        content: const Text('ç¡®å®šè¦åˆ›å»ºæ•°æ®å¤‡ä»½å—ï¼Ÿè¿™å°†å¯¼å‡ºæ‰€æœ‰äº§å“ã€åº“å­˜å’Œäº¤æ˜“æ•°æ®ã€?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              _startQuickBackup(context, ref);
            },
            child: const Text('å¼€å§‹å¤‡ä»?),
          ),
        ],
      ),
    );
  }

  Future<void> _startQuickBackup(BuildContext context, WidgetRef ref) async {
    final options = BackupOptions(
      description: 'å¿«é€Ÿå¤‡ä»?- ${DateTime.now().toLocal().toString().split('.')[0]}',
    );

    // å¼€å§‹å¤‡ä»?- è¿›åº¦å¯¹è¯æ¡†å°†ç”?ProgressManager è‡ªåŠ¨æ˜¾ç¤º
    await ref.read(backupControllerProvider.notifier).startBackup(
      options: options,
    );
  }
}
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../domain/models/backup_metadata.dart';

/// å¤‡ä»½è¯¦æƒ…å¯¹è¯æ¡?
class BackupDetailsDialog extends StatelessWidget {
  final BackupMetadata backup;

  const BackupDetailsDialog({
    super.key,
    required this.backup,
  });

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('yyyy-MM-dd HH:mm:ss');
    final fileSizeText = _formatFileSize(backup.fileSize);
    final totalRecords = backup.tableCounts.values.fold(0, (sum, count) => sum + count);

    return AlertDialog(
      title: Row(
        children: [
          Icon(
            backup.isEncrypted ? Icons.lock : Icons.backup,
            color: backup.isEncrypted 
                ? Theme.of(context).colorScheme.secondary
                : Theme.of(context).colorScheme.primary,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'å¤‡ä»½è¯¦æƒ…',
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ),
        ],
      ),
      content: SizedBox(
        width: double.maxFinite,
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // åŸºæœ¬ä¿¡æ¯
              _buildSection(
                context,
                'åŸºæœ¬ä¿¡æ¯',
                [
                  _buildDetailRow(context, 'æ–‡ä»¶å?, backup.fileName),
                  _buildDetailRow(context, 'åˆ›å»ºæ—¶é—´', dateFormat.format(backup.createdAt)),
                  _buildDetailRow(context, 'æ–‡ä»¶å¤§å°', fileSizeText),
                  _buildDetailRow(context, 'å¤‡ä»½ç‰ˆæœ¬', backup.version),
                  if (backup.appVersion != null)
                    _buildDetailRow(context, 'åº”ç”¨ç‰ˆæœ¬', backup.appVersion!),
                  if (backup.schemaVersion != null)
                    _buildDetailRow(context, 'æ•°æ®åº“ç‰ˆæœ?, backup.schemaVersion.toString()),
                ],
              ),

              const SizedBox(height: 16),

              // å®‰å…¨ä¿¡æ¯
              _buildSection(
                context,
                'å®‰å…¨ä¿¡æ¯',
                [
                  _buildDetailRow(
                    context, 
                    'åŠ å¯†çŠ¶æ€?, 
                    backup.isEncrypted ? 'å·²åŠ å¯? : 'æœªåŠ å¯?,
                    valueColor: backup.isEncrypted 
                        ? Theme.of(context).colorScheme.secondary
                        : Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                  _buildDetailRow(context, 'æ ¡éªŒå’?, backup.checksum),
                ],
              ),

              const SizedBox(height: 16),

              // æ•°æ®ç»Ÿè®¡
              _buildSection(
                context,
                'æ•°æ®ç»Ÿè®¡',
                [
                  _buildDetailRow(context, 'æ€»è®°å½•æ•°', totalRecords.toString()),
                  const SizedBox(height: 8),
                  ...backup.tableCounts.entries.map((entry) =>
                    _buildDetailRow(
                      context,
                      _getTableDisplayName(entry.key),
                      '${entry.value} æ?,
                      indent: true,
                    ),
                  ),
                ],
              ),

              // æè¿°ä¿¡æ¯
              if (backup.description != null) ...[
                const SizedBox(height: 16),
                _buildSection(
                  context,
                  'å¤‡ä»½æè¿°',
                  [
                    Container(
                      width: double.infinity,
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Theme.of(context).colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        backup.description!,
                        style: Theme.of(context).textTheme.bodyMedium,
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å…³é—­'),
        ),
      ],
    );
  }

  Widget _buildSection(BuildContext context, String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 8),
        ...children,
      ],
    );
  }

  Widget _buildDetailRow(
    BuildContext context,
    String label,
    String value, {
    Color? valueColor,
    bool indent = false,
  }) {
    return Padding(
      padding: EdgeInsets.only(
        bottom: 4,
        left: indent ? 16 : 0,
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: indent ? 100 : 120,
            child: Text(
              label,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: valueColor,
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  String _getTableDisplayName(String tableName) {
    // å°†æ•°æ®åº“è¡¨åè½¬æ¢ä¸ºç”¨æˆ·å‹å¥½çš„æ˜¾ç¤ºåç§°
    final lowerTableName = tableName.toLowerCase();
    switch (lowerTableName) {
      case 'products':
        return 'äº§å“';
      case 'inventory':
        return 'åº“å­˜';
      case 'sales':
        return 'é”€å”?;
      case 'purchases':
        return 'é‡‡è´­';
      case 'customers':
        return 'å®¢æˆ·';
      case 'suppliers':
        return 'ä¾›åº”å•?;
      case 'categories':
        return 'åˆ†ç±»';
      case 'users':
        return 'ç”¨æˆ·';
      case 'settings':
        return 'è®¾ç½®';
      default:
        return tableName;
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/database/database.dart';
import '../../data/services/backup_diagnostic_service.dart';
import '../../data/services/backup_repair_service.dart';

/// å¤‡ä»½è¯Šæ–­å¯¹è¯æ¡?
class BackupDiagnosticDialog extends ConsumerStatefulWidget {
  const BackupDiagnosticDialog({super.key});

  @override
  ConsumerState<BackupDiagnosticDialog> createState() =>
      _BackupDiagnosticDialogState();
}

class _BackupDiagnosticDialogState
    extends ConsumerState<BackupDiagnosticDialog> {
  BackupDiagnosticResult? _diagnosticResult;
  BackupRepairResult? _repairResult;
  bool _isRunningDiagnostic = false;
  bool _isRunningRepair = false;

  late final BackupDiagnosticService _diagnosticService;
  late final BackupRepairService _repairService;

  @override
  void initState() {
    super.initState();
    final database = ref.read(appDatabaseProvider);
    _diagnosticService = BackupDiagnosticService(database);
    _repairService = BackupRepairService(database);

    // è‡ªåŠ¨è¿è¡Œå¿«é€Ÿè¯Šæ–?
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _runQuickDiagnostic();
    });
  }

  Future<void> _runQuickDiagnostic() async {
    if (_isRunningDiagnostic) return;

    setState(() {
      _isRunningDiagnostic = true;
      _diagnosticResult = null;
    });

    try {
      final result = await _diagnosticService.runQuickDiagnostic();
      if (mounted) {
        setState(() {
          _diagnosticResult = result;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('è¯Šæ–­å¤±è´¥: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isRunningDiagnostic = false;
        });
      }
    }
  }

  Future<void> _runFullDiagnostic() async {
    if (_isRunningDiagnostic) return;

    setState(() {
      _isRunningDiagnostic = true;
      _diagnosticResult = null;
    });

    try {
      final result = await _diagnosticService.runFullDiagnostic();
      if (mounted) {
        setState(() {
          _diagnosticResult = result;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('å®Œæ•´è¯Šæ–­å¤±è´¥: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isRunningDiagnostic = false;
        });
      }
    }
  }

  Future<void> _runAutoRepair() async {
    if (_isRunningRepair) return;

    setState(() {
      _isRunningRepair = true;
      _repairResult = null;
    });

    try {
      final result = await _repairService.autoRepair();
      if (mounted) {
        setState(() {
          _repairResult = result;
        });

        // ä¿®å¤åé‡æ–°è¿è¡Œè¯Šæ–?
        if (result.success) {
          await _runQuickDiagnostic();
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('è‡ªåŠ¨ä¿®å¤å¤±è´¥: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isRunningRepair = false;
        });
      }
    }
  }

  Future<void> _resetBackupSystem() async {
    // ç¡®è®¤å¯¹è¯æ¡?
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤é‡ç½®'),
        content: const Text('è¿™å°†åˆ é™¤æ‰€æœ‰ç°æœ‰å¤‡ä»½æ–‡ä»¶å¹¶é‡ç½®å¤‡ä»½ç³»ç»Ÿã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    setState(() {
      _isRunningRepair = true;
      _repairResult = null;
    });

    try {
      final result = await _repairService.resetBackupSystem();
      if (mounted) {
        setState(() {
          _repairResult = result;
        });

        // é‡ç½®åé‡æ–°è¿è¡Œè¯Šæ–?
        await _runQuickDiagnostic();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('é‡ç½®å¤±è´¥: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isRunningRepair = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        height: MediaQuery.of(context).size.height * 0.8,
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // æ ‡é¢˜æ ?
            Row(
              children: [
                const Icon(Icons.healing, color: Colors.blue),
                const SizedBox(width: 8),
                const Text(
                  'å¤‡ä»½ç³»ç»Ÿè¯Šæ–­',
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
            const Divider(),

            // æ“ä½œæŒ‰é’®
            Wrap(
              spacing: 8,
              children: [
                ElevatedButton.icon(
                  onPressed: _isRunningDiagnostic ? null : _runQuickDiagnostic,
                  icon: _isRunningDiagnostic
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.speed),
                  label: const Text('å¿«é€Ÿè¯Šæ–?),
                ),
                ElevatedButton.icon(
                  onPressed: _isRunningDiagnostic ? null : _runFullDiagnostic,
                  icon: _isRunningDiagnostic
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.search),
                  label: const Text('å®Œæ•´è¯Šæ–­'),
                ),
                ElevatedButton.icon(
                  onPressed: _isRunningRepair ? null : _runAutoRepair,
                  icon: _isRunningRepair
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.build),
                  label: const Text('è‡ªåŠ¨ä¿®å¤'),
                ),
                ElevatedButton.icon(
                  onPressed: _isRunningRepair ? null : _resetBackupSystem,
                  icon: _isRunningRepair
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.refresh),
                  label: const Text('é‡ç½®ç³»ç»Ÿ'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // ç»“æœæ˜¾ç¤º
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // è¯Šæ–­ç»“æœ
                    if (_diagnosticResult != null) ...[
                      _buildDiagnosticResultCard(_diagnosticResult!),
                      const SizedBox(height: 16),
                    ],

                    // ä¿®å¤ç»“æœ
                    if (_repairResult != null) ...[
                      _buildRepairResultCard(_repairResult!),
                      const SizedBox(height: 16),
                    ],

                    // åŠ è½½çŠ¶æ€?
                    if (_isRunningDiagnostic || _isRunningRepair) ...[
                      const Center(
                        child: Column(
                          children: [
                            CircularProgressIndicator(),
                            SizedBox(height: 8),
                            Text('æ­£åœ¨å¤„ç†ä¸?..'),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDiagnosticResultCard(BackupDiagnosticResult result) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  result.isHealthy ? Icons.check_circle : Icons.error,
                  color: result.isHealthy ? Colors.green : Colors.red,
                ),
                const SizedBox(width: 8),
                Text(
                  'è¯Šæ–­ç»“æœ: ${result.isHealthy ? "ç³»ç»Ÿæ­£å¸¸" : "å‘ç°é—®é¢˜"}',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),

            // é—®é¢˜åˆ—è¡¨
            if (result.issues.isNotEmpty) ...[
              const Text(
                'å‘ç°çš„é—®é¢?',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.red,
                ),
              ),
              const SizedBox(height: 4),
              ...result.issues.map(
                (issue) => Padding(
                  padding: const EdgeInsets.only(left: 16, bottom: 4),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Icon(
                        Icons.error_outline,
                        size: 16,
                        color: Colors.red,
                      ),
                      const SizedBox(width: 4),
                      Expanded(child: Text(issue)),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],

            // è­¦å‘Šåˆ—è¡¨
            if (result.warnings.isNotEmpty) ...[
              const Text(
                'è­¦å‘Šä¿¡æ¯:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.orange,
                ),
              ),
              const SizedBox(height: 4),
              ...result.warnings.map(
                (warning) => Padding(
                  padding: const EdgeInsets.only(left: 16, bottom: 4),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Icon(
                        Icons.warning_outlined,
                        size: 16,
                        color: Colors.orange,
                      ),
                      const SizedBox(width: 4),
                      Expanded(child: Text(warning)),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],

            // ç³»ç»Ÿä¿¡æ¯
            if (result.systemInfo.isNotEmpty) ...[
              ExpansionTile(
                title: const Text('ç³»ç»Ÿä¿¡æ¯'),
                children: [
                  ...result.systemInfo.entries.map(
                    (entry) => ListTile(
                      dense: true,
                      title: Text(entry.key),
                      subtitle: Text(entry.value.toString()),
                    ),
                  ),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildRepairResultCard(BackupRepairResult result) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  result.success ? Icons.check_circle : Icons.warning,
                  color: result.success ? Colors.green : Colors.orange,
                ),
                const SizedBox(width: 8),
                Text(
                  'ä¿®å¤ç»“æœ: ${result.message}',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),

            // å·²ä¿®å¤çš„é—®é¢˜
            if (result.fixedIssues.isNotEmpty) ...[
              const Text(
                'å·²ä¿®å¤çš„é—®é¢˜:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.green,
                ),
              ),
              const SizedBox(height: 4),
              ...result.fixedIssues.map(
                (issue) => Padding(
                  padding: const EdgeInsets.only(left: 16, bottom: 4),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Icon(Icons.check, size: 16, color: Colors.green),
                      const SizedBox(width: 4),
                      Expanded(child: Text(issue)),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],

            // å‰©ä½™é—®é¢˜
            if (result.remainingIssues.isNotEmpty) ...[
              const Text(
                'å‰©ä½™é—®é¢˜:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.red,
                ),
              ),
              const SizedBox(height: 4),
              ...result.remainingIssues.map(
                (issue) => Padding(
                  padding: const EdgeInsets.only(left: 16, bottom: 4),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Icon(
                        Icons.error_outline,
                        size: 16,
                        color: Colors.red,
                      ),
                      const SizedBox(width: 4),
                      Expanded(child: Text(issue)),
                    ],
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';

import '../../domain/models/backup_exception.dart';
import '../../domain/models/backup_error_type.dart';
import '../../data/services/backup_error_handler.dart';
import 'enhanced_error_dialog.dart';

/// å¤‡ä»½é”™è¯¯æµ‹è¯•å¯¹è¯æ¡?- ç”¨äºæµ‹è¯•ä¸åŒç±»å‹çš„é”™è¯¯æ˜¾ç¤?
class BackupErrorTestDialog extends StatelessWidget {
  const BackupErrorTestDialog({super.key});

  static void show(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const BackupErrorTestDialog(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('æµ‹è¯•é”™è¯¯å¤„ç†'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildErrorTestButton(
              context,
              'å­˜å‚¨ç©ºé—´ä¸è¶³',
              BackupException.insufficientSpace('è®¾å¤‡å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œéœ€è¦è‡³å°?00MBå¯ç”¨ç©ºé—´'),
            ),
            _buildErrorTestButton(
              context,
              'æƒé™è¢«æ‹’ç»?,
              BackupException.permissionDenied('åº”ç”¨æ²¡æœ‰å­˜å‚¨æƒé™ï¼Œæ— æ³•åˆ›å»ºå¤‡ä»½æ–‡ä»?),
            ),
            _buildErrorTestButton(
              context,
              'æ•°æ®åº“é”™è¯?,
              BackupException.database('æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œå¯èƒ½è¢«å…¶ä»–è¿›ç¨‹å ç”?),
            ),
            _buildErrorTestButton(
              context,
              'æ–‡ä»¶ç³»ç»Ÿé”™è¯¯',
              BackupException.fileSystem('æ— æ³•è®¿é—®å¤‡ä»½ç›®å½•ï¼Œè¯·æ£€æŸ¥å­˜å‚¨è®¾å¤‡çŠ¶æ€?),
            ),
            _buildErrorTestButton(
              context,
              'ç½‘ç»œè¿æ¥é”™è¯¯',
              BackupException(
                type: BackupErrorType.networkError,
                message: 'ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œæ— æ³•ä¸Šä¼ å¤‡ä»½æ–‡ä»¶',
              ),
            ),
            _buildErrorTestButton(
              context,
              'åŠ å¯†é”™è¯¯',
              BackupException.encryption('å¤‡ä»½æ–‡ä»¶åŠ å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†ç è®¾ç½?),
            ),
            _buildErrorTestButton(
              context,
              'å‹ç¼©é”™è¯¯',
              BackupException(
                type: BackupErrorType.compressionError,
                message: 'å¤‡ä»½æ–‡ä»¶å‹ç¼©å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶è¿‡å¤§æˆ–å­˜å‚¨ç©ºé—´ä¸è¶?,
              ),
            ),
            _buildErrorTestButton(
              context,
              'æœªçŸ¥é”™è¯¯',
              BackupException(
                type: BackupErrorType.unknown,
                message: 'å‘ç”Ÿäº†æœªçŸ¥é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•æˆ–è”ç³»æŠ€æœ¯æ”¯æŒ?,
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å…³é—­'),
        ),
      ],
    );
  }

  Widget _buildErrorTestButton(
    BuildContext context,
    String title,
    BackupException exception,
  ) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 8),
      child: ElevatedButton(
        onPressed: () => _showTestError(context, exception),
        child: Text(title),
      ),
    );
  }

  void _showTestError(BuildContext context, BackupException exception) {
    Navigator.of(context).pop(); // å…³é—­æµ‹è¯•å¯¹è¯æ¡?
    
    final userError = BackupErrorHandler.handleError(exception);
    
    EnhancedErrorDialog.show(
      context,
      error: userError,
      onRetry: () {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('è¿™æ˜¯æµ‹è¯•é”™è¯¯ï¼Œé‡è¯•åŠŸèƒ½å·²æ¨¡æ‹Ÿæ‰§è¡Œ'),
          ),
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../data/services/backup_error_handler.dart';

/// å¤‡ä»½é”™è¯¯æ˜¾ç¤ºç»„ä»¶
class BackupErrorWidget extends StatelessWidget {
  final UserFriendlyError error;
  final VoidCallback? onRetry;
  final VoidCallback? onDismiss;
  final bool showTechnicalDetails;
  final bool showSuggestions;

  const BackupErrorWidget({
    super.key,
    required this.error,
    this.onRetry,
    this.onDismiss,
    this.showTechnicalDetails = false,
    this.showSuggestions = true,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            // é”™è¯¯æ ‡é¢˜å’Œå›¾æ ?
            Row(
              children: [
                Icon(
                  Icons.error_outline,
                  color: Theme.of(context).colorScheme.error,
                  size: 24,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    error.title,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      color: Theme.of(context).colorScheme.error,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                if (onDismiss != null)
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: onDismiss,
                    iconSize: 20,
                  ),
              ],
            ),
            
            const SizedBox(height: 12),
            
            // é”™è¯¯æ¶ˆæ¯
            Text(
              error.message,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            
            // æŠ€æœ¯è¯¦æƒ…ï¼ˆå¯å±•å¼€ï¼?
            if (showTechnicalDetails && error.technicalDetails != null) ...[
              const SizedBox(height: 16),
              _TechnicalDetailsSection(
                details: error.technicalDetails!,
              ),
            ],
            
            // è§£å†³å»ºè®®
            if (showSuggestions && error.suggestion != null) ...[
              const SizedBox(height: 16),
              _SuggestionSection(
                suggestion: error.suggestion!,
              ),
            ],
            
            // æ“ä½œæŒ‰é’®
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                if (error.canRetry && onRetry != null) ...[
                  ElevatedButton.icon(
                    onPressed: onRetry,
                    icon: const Icon(Icons.refresh, size: 18),
                    label: const Text('é‡è¯•'),
                  ),
                  const SizedBox(width: 8),
                ],
                TextButton(
                  onPressed: onDismiss ?? () => Navigator.of(context).pop(),
                  child: const Text('ç¡®å®š'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// æŠ€æœ¯è¯¦æƒ…å±•å¼€ç»„ä»¶
class _TechnicalDetailsSection extends StatefulWidget {
  final String details;

  const _TechnicalDetailsSection({
    required this.details,
  });

  @override
  State<_TechnicalDetailsSection> createState() => _TechnicalDetailsSectionState();
}

class _TechnicalDetailsSectionState extends State<_TechnicalDetailsSection> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        InkWell(
          onTap: () => setState(() => _expanded = !_expanded),
          child: Row(
            children: [
              Icon(
                _expanded ? Icons.expand_less : Icons.expand_more,
                size: 20,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 4),
              Text(
                'æŠ€æœ¯è¯¦æƒ?,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
        
        if (_expanded) ...[
          const SizedBox(height: 8),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surfaceContainerHighest.withOpacity(0.3),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        widget.details,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.copy, size: 16),
                      onPressed: () => _copyToClipboard(context),
                      tooltip: 'å¤åˆ¶åˆ°å‰ªè´´æ¿',
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }

  void _copyToClipboard(BuildContext context) {
    Clipboard.setData(ClipboardData(text: widget.details));
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('æŠ€æœ¯è¯¦æƒ…å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'),
        duration: Duration(seconds: 2),
      ),
    );
  }
}

/// è§£å†³å»ºè®®ç»„ä»¶
class _SuggestionSection extends StatelessWidget {
  final ErrorRecoverySuggestion suggestion;

  const _SuggestionSection({
    required this.suggestion,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primaryContainer.withOpacity(0.3),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Theme.of(context).colorScheme.primary.withOpacity(0.2),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.lightbulb_outline,
                size: 20,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Text(
                suggestion.title,
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 8),
          
          Text(
            suggestion.description,
            style: Theme.of(context).textTheme.bodySmall,
          ),
          
          const SizedBox(height: 8),
          
          ...suggestion.steps.asMap().entries.map((entry) {
            final index = entry.key;
            final step = entry.value;
            
            return Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    width: 20,
                    height: 20,
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primary,
                      shape: BoxShape.circle,
                    ),
                    child: Center(
                      child: Text(
                        '${index + 1}',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                          fontWeight: FontWeight.bold,
                          fontSize: 10,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      step,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            );
          }),
        ],
      ),
    );
  }
}

/// é”™è¯¯å¯¹è¯æ¡?
class BackupErrorDialog extends StatelessWidget {
  final UserFriendlyError error;
  final VoidCallback? onRetry;
  final bool showTechnicalDetails;

  const BackupErrorDialog({
    super.key,
    required this.error,
    this.onRetry,
    this.showTechnicalDetails = false,
  });

  static Future<bool?> show(
    BuildContext context, {
    required UserFriendlyError error,
    VoidCallback? onRetry,
    bool showTechnicalDetails = false,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => BackupErrorDialog(
        error: error,
        onRetry: onRetry,
        showTechnicalDetails: showTechnicalDetails,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      content: BackupErrorWidget(
        error: error,
        onRetry: onRetry != null ? () {
          Navigator.of(context).pop(true);
          onRetry!();
        } : null,
        onDismiss: () => Navigator.of(context).pop(false),
        showTechnicalDetails: showTechnicalDetails,
      ),
      contentPadding: EdgeInsets.zero,
    );
  }
}

/// ç®€åŒ–çš„é”™è¯¯æç¤ºæ?
class BackupErrorSnackBar extends SnackBar {
  BackupErrorSnackBar({
    super.key,
    required UserFriendlyError error,
    VoidCallback? onRetry,
  }) : super(
          content: Row(
            children: [
              const Icon(
                Icons.error_outline,
                color: Colors.white,
                size: 20,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  error.message,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          backgroundColor: Colors.red[700],
          action: error.canRetry && onRetry != null
              ? SnackBarAction(
                  label: 'é‡è¯•',
                  textColor: Colors.white,
                  onPressed: onRetry,
                )
              : null,
          duration: const Duration(seconds: 4),
        );

  static void show(
    BuildContext context, {
    required UserFriendlyError error,
    VoidCallback? onRetry,
  }) {
    ScaffoldMessenger.of(context).showSnackBar(
      BackupErrorSnackBar(
        error: error,
        onRetry: onRetry,
      ),
    );
  }
}
import 'package:flutter/material.dart';

import '../../domain/models/auto_backup_settings.dart';

/// å¤‡ä»½é¢‘ç‡é€‰æ‹©å™?
class BackupFrequencySelector extends StatelessWidget {
  final BackupFrequency currentFrequency;
  final ValueChanged<BackupFrequency> onFrequencyChanged;

  const BackupFrequencySelector({
    super.key,
    required this.currentFrequency,
    required this.onFrequencyChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.schedule,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 8),
                Text(
                  'å¤‡ä»½é¢‘ç‡',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              ],
            ),
            const SizedBox(height: 16),
            Column(
              children: BackupFrequency.values.map((frequency) {
                return RadioListTile<BackupFrequency>(
                  title: Text(_getFrequencyTitle(frequency)),
                  subtitle: Text(_getFrequencyDescription(frequency)),
                  value: frequency,
                  groupValue: currentFrequency,
                  onChanged: (value) {
                    if (value != null) {
                      onFrequencyChanged(value);
                    }
                  },
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  String _getFrequencyTitle(BackupFrequency frequency) {
    switch (frequency) {
      case BackupFrequency.daily:
        return 'æ¯æ—¥å¤‡ä»½';
      case BackupFrequency.weekly:
        return 'æ¯å‘¨å¤‡ä»½';
      case BackupFrequency.monthly:
        return 'æ¯æœˆå¤‡ä»½';
    }
  }

  String _getFrequencyDescription(BackupFrequency frequency) {
    switch (frequency) {
      case BackupFrequency.daily:
        return 'æ¯å¤©å‡Œæ™¨2ç‚¹è‡ªåŠ¨å¤‡ä»?;
      case BackupFrequency.weekly:
        return 'æ¯å‘¨æ—¥å‡Œæ™?ç‚¹è‡ªåŠ¨å¤‡ä»?;
      case BackupFrequency.monthly:
        return 'æ¯æœˆ1å·å‡Œæ™?ç‚¹è‡ªåŠ¨å¤‡ä»?;
    }
  }
}
import 'package:flutter/material.dart';

import '../../domain/models/auto_backup_settings.dart';

/// å¤‡ä»½é€‰é¡¹é…ç½®å¡ç‰‡
class BackupOptionsCard extends StatelessWidget {
  final AutoBackupOptions options;
  final ValueChanged<AutoBackupOptions> onOptionsChanged;

  const BackupOptionsCard({
    super.key,
    required this.options,
    required this.onOptionsChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.settings,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 8),
                Text(
                  'å¤‡ä»½é€‰é¡¹',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              ],
            ),
            const SizedBox(height: 12),
            SwitchListTile(
              title: const Text('åŒ…å«å›¾ç‰‡æ–‡ä»¶'),
              subtitle: const Text('å¤‡ä»½æ—¶åŒ…å«äº§å“å›¾ç‰‡ç­‰æ–‡ä»¶'),
              value: options.includeImages,
              onChanged: (value) {
                onOptionsChanged(options.copyWith(includeImages: value));
              },
            ),
            SwitchListTile(
              title: const Text('å‹ç¼©å¤‡ä»½æ–‡ä»¶'),
              subtitle: const Text('å‡å°‘å¤‡ä»½æ–‡ä»¶å¤§å°'),
              value: options.compress,
              onChanged: (value) {
                onOptionsChanged(options.copyWith(compress: value));
              },
            ),
            SwitchListTile(
              title: const Text('åŠ å¯†å¤‡ä»½æ–‡ä»¶'),
              subtitle: const Text('ä½¿ç”¨å¯†ç ä¿æŠ¤å¤‡ä»½æ–‡ä»¶'),
              value: options.encrypt,
              onChanged: (value) {
                if (value) {
                  _showPasswordDialog(context);
                } else {
                  onOptionsChanged(options.copyWith(
                    encrypt: false,
                    password: null,
                  ));
                }
              },
            ),
            if (options.encrypt && options.password != null) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.lock,
                      size: 16,
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'å·²è®¾ç½®åŠ å¯†å¯†ç ?,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                    const Spacer(),
                    TextButton(
                      onPressed: () => _showPasswordDialog(context),
                      child: const Text('ä¿®æ”¹'),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _showPasswordDialog(BuildContext context) {
    final passwordController = TextEditingController(text: options.password ?? '');
    final confirmController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('è®¾ç½®åŠ å¯†å¯†ç '),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: passwordController,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'å¯†ç ',
                hintText: 'è¯·è¾“å…¥åŠ å¯†å¯†ç ?,
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: confirmController,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'ç¡®è®¤å¯†ç ',
                hintText: 'è¯·å†æ¬¡è¾“å…¥å¯†ç ?,
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () {
              final password = passwordController.text.trim();
              final confirm = confirmController.text.trim();

              if (password.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('å¯†ç ä¸èƒ½ä¸ºç©º')),
                );
                return;
              }

              if (password != confirm) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡?)),
                );
                return;
              }

              onOptionsChanged(options.copyWith(
                encrypt: true,
                password: password,
              ));

              Navigator.of(context).pop();
            },
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';

/// å¤‡ä»½è¿›åº¦ä¿¡æ¯
class BackupProgressInfo {
  final String message;
  final int current;
  final int total;
  final bool isCompleted;
  final bool isCancelled;
  final String? errorMessage;

  const BackupProgressInfo({
    required this.message,
    required this.current,
    required this.total,
    this.isCompleted = false,
    this.isCancelled = false,
    this.errorMessage,
  });

  BackupProgressInfo copyWith({
    String? message,
    int? current,
    int? total,
    bool? isCompleted,
    bool? isCancelled,
    String? errorMessage,
  }) {
    return BackupProgressInfo(
      message: message ?? this.message,
      current: current ?? this.current,
      total: total ?? this.total,
      isCompleted: isCompleted ?? this.isCompleted,
      isCancelled: isCancelled ?? this.isCancelled,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  double get progress => total > 0 ? current / total : 0.0;
  int get progressPercent => (progress * 100).toInt();
}

/// å¤‡ä»½è¿›åº¦å¯¹è¯æ¡?
class BackupProgressDialog extends StatelessWidget {
  final BackupProgressInfo progressInfo;
  final VoidCallback? onCancel;
  final VoidCallback? onRetry;
  final VoidCallback? onClose;

  const BackupProgressDialog({
    super.key,
    required this.progressInfo,
    this.onCancel,
    this.onRetry,
    this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: progressInfo.isCompleted || progressInfo.isCancelled,
      child: AlertDialog(
        title: _buildTitle(context),
        content: _buildContent(context),
        actions: _buildActions(context),
      ),
    );
  }

  Widget _buildTitle(BuildContext context) {
    IconData iconData;
    Color iconColor;
    String titleText;

    if (progressInfo.isCancelled) {
      iconData = Icons.cancel;
      iconColor = Theme.of(context).colorScheme.error;
      titleText = 'å¤‡ä»½å·²å–æ¶?;
    } else if (progressInfo.errorMessage != null) {
      iconData = Icons.error;
      iconColor = Theme.of(context).colorScheme.error;
      titleText = 'å¤‡ä»½å¤±è´¥';
    } else if (progressInfo.isCompleted) {
      iconData = Icons.check_circle;
      iconColor = Theme.of(context).colorScheme.primary;
      titleText = 'å¤‡ä»½å®Œæˆ';
    } else {
      iconData = Icons.backup;
      iconColor = Theme.of(context).colorScheme.primary;
      titleText = 'æ­£åœ¨å¤‡ä»½æ•°æ®';
    }

    return Row(
      children: [
        Icon(iconData, color: iconColor),
        const SizedBox(width: 12),
        Text(titleText),
      ],
    );
  }

  Widget _buildContent(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (progressInfo.errorMessage != null) ...[
          _buildErrorContent(context),
        ] else if (progressInfo.isCompleted && !progressInfo.isCancelled) ...[
          _buildSuccessContent(context),
        ] else if (progressInfo.isCancelled) ...[
          _buildCancelledContent(context),
        ] else ...[
          _buildProgressContent(context),
        ],
      ],
    );
  }

  Widget _buildProgressContent(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // è¿›åº¦æ?
        LinearProgressIndicator(
          value: progressInfo.progress,
          backgroundColor: Theme.of(context).colorScheme.surfaceContainerHighest,
          valueColor: AlwaysStoppedAnimation<Color>(
            Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 16),
        
        // è¿›åº¦æ–‡æœ¬
        Text(
          '${progressInfo.progressPercent}% (${progressInfo.current}/${progressInfo.total})',
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        
        // å½“å‰æ“ä½œæè¿°
        Text(
          progressInfo.message,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
        
        const SizedBox(height: 16),
        
        // æç¤ºä¿¡æ¯
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.secondaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.info_outline,
                size: 16,
                color: Theme.of(context).colorScheme.onSecondaryContainer,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'è¯·å‹¿å…³é—­åº”ç”¨æˆ–åˆ‡æ¢åˆ°å…¶ä»–é¡µé¢',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondaryContainer,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildSuccessContent(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.check_circle,
                color: Theme.of(context).colorScheme.onPrimaryContainer,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'å¤‡ä»½åˆ›å»ºæˆåŠŸï¼?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'æ•°æ®å·²å®‰å…¨å¤‡ä»½åˆ°æœ¬åœ°å­˜å‚¨',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildErrorContent(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.errorContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.error,
                    color: Theme.of(context).colorScheme.onErrorContainer,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'å¤‡ä»½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onErrorContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                progressInfo.errorMessage!,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onErrorContainer,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildCancelledContent(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.cancel,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'å¤‡ä»½æ“ä½œå·²å–æ¶?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'æ‚¨å¯ä»¥ç¨åé‡æ–°å¼€å§‹å¤‡ä»?,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  List<Widget> _buildActions(BuildContext context) {
    if (progressInfo.errorMessage != null) {
      return [
        TextButton(
          onPressed: onClose,
          child: const Text('å…³é—­'),
        ),
        if (onRetry != null)
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('é‡è¯•'),
          ),
      ];
    } else if (progressInfo.isCompleted || progressInfo.isCancelled) {
      return [
        ElevatedButton(
          onPressed: onClose,
          child: const Text('å®Œæˆ'),
        ),
      ];
    } else {
      return [
        TextButton(
          onPressed: () => _showCancelConfirmation(context),
          child: const Text('å–æ¶ˆ'),
        ),
      ];
    }
  }

  void _showCancelConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤å–æ¶ˆ'),
        content: const Text('ç¡®å®šè¦å–æ¶ˆå¤‡ä»½æ“ä½œå—ï¼Ÿ\n\nå½“å‰è¿›åº¦å°†ä¸¢å¤±ï¼Œéœ€è¦é‡æ–°å¼€å§‹ã€?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ç»§ç»­å¤‡ä»½'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(); // å…³é—­ç¡®è®¤å¯¹è¯æ¡?
              onCancel?.call();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
              foregroundColor: Theme.of(context).colorScheme.onError,
            ),
            child: const Text('ç¡®è®¤å–æ¶ˆ'),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// å¤‡ä»½æ•…éšœæ’é™¤æŒ‡å—
class BackupTroubleshootingGuide extends StatelessWidget {
  const BackupTroubleshootingGuide({super.key});

  static void show(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const BackupTroubleshootingGuide(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Row(
        children: [
          Icon(Icons.help_outline),
          SizedBox(width: 12),
          Text('å¤‡ä»½æ•…éšœæ’é™¤'),
        ],
      ),
      content: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSection(
              context,
              'å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡?,
              [
                _TroubleshootingItem(
                  problem: 'å¤‡ä»½å¤±è´¥ - å­˜å‚¨ç©ºé—´ä¸è¶³',
                  solutions: [
                    'æ¸…ç†è®¾å¤‡å­˜å‚¨ç©ºé—´ï¼Œåˆ é™¤ä¸éœ€è¦çš„æ–‡ä»¶',
                    'å¸è½½ä¸å¸¸ç”¨çš„åº”ç”¨ç¨‹åº',
                    'æ¸…ç†åº”ç”¨ç¼“å­˜å’Œä¸´æ—¶æ–‡ä»?,
                    'ä½¿ç”¨å¤–éƒ¨å­˜å‚¨è®¾å¤‡ï¼ˆå¦‚SDå¡ï¼‰',
                  ],
                ),
                _TroubleshootingItem(
                  problem: 'å¤‡ä»½å¤±è´¥ - æƒé™è¢«æ‹’ç»?,
                  solutions: [
                    'åœ¨ç³»ç»Ÿè®¾ç½®ä¸­æ£€æŸ¥åº”ç”¨æƒé™?,
                    'æˆäºˆåº”ç”¨å­˜å‚¨æƒé™',
                    'é‡å¯åº”ç”¨åé‡è¯?,
                    'æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†åº”ç”¨æƒé™ç®¡ç†',
                  ],
                ),
                _TroubleshootingItem(
                  problem: 'å¤‡ä»½è¿‡ç¨‹ä¸­åº”ç”¨å´©æº?,
                  solutions: [
                    'å…³é—­å…¶ä»–æ­£åœ¨è¿è¡Œçš„åº”ç”?,
                    'é‡å¯è®¾å¤‡é‡Šæ”¾å†…å­˜',
                    'ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å¯ç”¨å†…å­˜',
                    'å°è¯•åœ¨è®¾å¤‡ç©ºé—²æ—¶è¿›è¡Œå¤‡ä»½',
                  ],
                ),
                _TroubleshootingItem(
                  problem: 'æ•°æ®åº“è¿æ¥å¤±è´?,
                  solutions: [
                    'å®Œå…¨å…³é—­åº”ç”¨åé‡æ–°æ‰“å¼€',
                    'é‡å¯è®¾å¤‡',
                    'æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–åº”ç”¨å ç”¨æ•°æ®åº?,
                    'æ¸…ç†åº”ç”¨ç¼“å­˜ï¼ˆæ³¨æ„ï¼šå¯èƒ½ä¸¢å¤±æœªä¿å­˜æ•°æ®ï¼‰',
                  ],
                ),
              ],
            ),
            const SizedBox(height: 24),
            _buildSection(
              context,
              'é¢„é˜²æªæ–½',
              [
                _TroubleshootingItem(
                  problem: 'å¦‚ä½•é¿å…å¤‡ä»½å¤±è´¥',
                  solutions: [
                    'å®šæœŸæ¸…ç†è®¾å¤‡å­˜å‚¨ç©ºé—´',
                    'ä¿æŒåº”ç”¨ä¸ºæœ€æ–°ç‰ˆæœ?,
                    'åœ¨è®¾å¤‡ç”µé‡å……è¶³æ—¶è¿›è¡Œå¤‡ä»½',
                    'é¿å…åœ¨å¤‡ä»½è¿‡ç¨‹ä¸­ä½¿ç”¨å…¶ä»–åŠŸèƒ½',
                    'å®šæœŸé‡å¯è®¾å¤‡ä¿æŒç³»ç»Ÿç¨³å®š',
                  ],
                ),
              ],
            ),
            const SizedBox(height: 24),
            _buildSection(
              context,
              'è”ç³»æŠ€æœ¯æ”¯æŒ?,
              [
                _TroubleshootingItem(
                  problem: 'å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨',
                  solutions: [
                    'è®°å½•é”™è¯¯å‘ç”Ÿçš„å…·ä½“æ—¶é—´å’Œæ“ä½œ',
                    'æˆªå›¾ä¿å­˜é”™è¯¯ä¿¡æ¯',
                    'æä¾›è®¾å¤‡å‹å·å’Œç³»ç»Ÿç‰ˆæœ¬ä¿¡æ?,
                    'è”ç³»æŠ€æœ¯æ”¯æŒå›¢é˜Ÿè·å–å¸®åŠ?,
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å…³é—­'),
        ),
        ElevatedButton(
          onPressed: () => _copyTroubleshootingInfo(context),
          child: const Text('å¤åˆ¶æ•…éšœæ’é™¤ä¿¡æ¯'),
        ),
      ],
    );
  }

  Widget _buildSection(
    BuildContext context,
    String title,
    List<_TroubleshootingItem> items,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 12),
        ...items.map((item) => _buildTroubleshootingItem(context, item)),
      ],
    );
  }

  Widget _buildTroubleshootingItem(
    BuildContext context,
    _TroubleshootingItem item,
  ) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.help_outline,
                size: 16,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  item.problem,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ...item.solutions.asMap().entries.map((entry) {
            final index = entry.key;
            final solution = entry.value;
            
            return Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    width: 20,
                    height: 20,
                    margin: const EdgeInsets.only(top: 2),
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primary,
                      shape: BoxShape.circle,
                    ),
                    child: Center(
                      child: Text(
                        '${index + 1}',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                          fontWeight: FontWeight.bold,
                          fontSize: 10,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      solution,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            );
          }),
        ],
      ),
    );
  }

  void _copyTroubleshootingInfo(BuildContext context) {
    const troubleshootingText = '''
å¤‡ä»½æ•…éšœæ’é™¤æŒ‡å—

å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆï¼š

1. å¤‡ä»½å¤±è´¥ - å­˜å‚¨ç©ºé—´ä¸è¶³
   â€?æ¸…ç†è®¾å¤‡å­˜å‚¨ç©ºé—´ï¼Œåˆ é™¤ä¸éœ€è¦çš„æ–‡ä»¶
   â€?å¸è½½ä¸å¸¸ç”¨çš„åº”ç”¨ç¨‹åº
   â€?æ¸…ç†åº”ç”¨ç¼“å­˜å’Œä¸´æ—¶æ–‡ä»?
   â€?ä½¿ç”¨å¤–éƒ¨å­˜å‚¨è®¾å¤‡ï¼ˆå¦‚SDå¡ï¼‰

2. å¤‡ä»½å¤±è´¥ - æƒé™è¢«æ‹’ç»?
   â€?åœ¨ç³»ç»Ÿè®¾ç½®ä¸­æ£€æŸ¥åº”ç”¨æƒé™?
   â€?æˆäºˆåº”ç”¨å­˜å‚¨æƒé™
   â€?é‡å¯åº”ç”¨åé‡è¯?
   â€?æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†åº”ç”¨æƒé™ç®¡ç†

3. å¤‡ä»½è¿‡ç¨‹ä¸­åº”ç”¨å´©æº?
   â€?å…³é—­å…¶ä»–æ­£åœ¨è¿è¡Œçš„åº”ç”?
   â€?é‡å¯è®¾å¤‡é‡Šæ”¾å†…å­˜
   â€?ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å¯ç”¨å†…å­˜
   â€?å°è¯•åœ¨è®¾å¤‡ç©ºé—²æ—¶è¿›è¡Œå¤‡ä»½

4. æ•°æ®åº“è¿æ¥å¤±è´?
   â€?å®Œå…¨å…³é—­åº”ç”¨åé‡æ–°æ‰“å¼€
   â€?é‡å¯è®¾å¤‡
   â€?æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–åº”ç”¨å ç”¨æ•°æ®åº?
   â€?æ¸…ç†åº”ç”¨ç¼“å­˜ï¼ˆæ³¨æ„ï¼šå¯èƒ½ä¸¢å¤±æœªä¿å­˜æ•°æ®ï¼‰

é¢„é˜²æªæ–½ï¼?
â€?å®šæœŸæ¸…ç†è®¾å¤‡å­˜å‚¨ç©ºé—´
â€?ä¿æŒåº”ç”¨ä¸ºæœ€æ–°ç‰ˆæœ?
â€?åœ¨è®¾å¤‡ç”µé‡å……è¶³æ—¶è¿›è¡Œå¤‡ä»½
â€?é¿å…åœ¨å¤‡ä»½è¿‡ç¨‹ä¸­ä½¿ç”¨å…¶ä»–åŠŸèƒ½
â€?å®šæœŸé‡å¯è®¾å¤‡ä¿æŒç³»ç»Ÿç¨³å®š

å¦‚éœ€æ›´å¤šå¸®åŠ©ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒå›¢é˜Ÿã€?
''';

    Clipboard.setData(const ClipboardData(text: troubleshootingText));
    
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('æ•…éšœæ’é™¤ä¿¡æ¯å·²å¤åˆ¶åˆ°å‰ªè´´æ?),
        duration: Duration(seconds: 2),
      ),
    );
  }
}

class _TroubleshootingItem {
  final String problem;
  final List<String> solutions;

  const _TroubleshootingItem({
    required this.problem,
    required this.solutions,
  });
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/backup_options.dart';

/// åˆ›å»ºå¤‡ä»½å¯¹è¯æ¡?
class CreateBackupDialog extends ConsumerStatefulWidget {
  final Function(BackupOptions) onCreateBackup;

  const CreateBackupDialog({
    super.key,
    required this.onCreateBackup,
  });

  @override
  ConsumerState<CreateBackupDialog> createState() => _CreateBackupDialogState();
}

class _CreateBackupDialogState extends ConsumerState<CreateBackupDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  bool _includeImages = false;
  bool _encrypt = false;
  bool _compress = false;
  bool _showPassword = false;
  bool _showConfirmPassword = false;

  @override
  void initState() {
    super.initState();
    // è®¾ç½®é»˜è®¤å¤‡ä»½åç§°
    final now = DateTime.now();
    final defaultName = 'backup_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}${now.minute.toString().padLeft(2, '0')}';
    _nameController.text = defaultName;
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('åˆ›å»ºå¤‡ä»½'),
      content: SizedBox(
        width: double.maxFinite,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // å¤‡ä»½åç§°
                TextFormField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: 'å¤‡ä»½åç§°',
                    hintText: 'è¯·è¾“å…¥å¤‡ä»½åç§?,
                    prefixIcon: Icon(Icons.label),
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'è¯·è¾“å…¥å¤‡ä»½åç§?;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // å¤‡ä»½æè¿°
                TextFormField(
                  controller: _descriptionController,
                  decoration: const InputDecoration(
                    labelText: 'å¤‡ä»½æè¿°ï¼ˆå¯é€‰ï¼‰',
                    hintText: 'è¯·è¾“å…¥å¤‡ä»½æè¿?,
                    prefixIcon: Icon(Icons.description),
                  ),
                  maxLines: 2,
                ),
                const SizedBox(height: 16),

                // é€‰é¡¹æ ‡é¢˜
                Text(
                  'å¤‡ä»½é€‰é¡¹',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),

                // åŒ…å«å›¾ç‰‡
                CheckboxListTile(
                  title: const Text('åŒ…å«å›¾ç‰‡æ–‡ä»¶'),
                  subtitle: const Text('å¤‡ä»½äº§å“å›¾ç‰‡ç­‰åª’ä½“æ–‡ä»?),
                  value: _includeImages,
                  onChanged: (value) {
                    setState(() {
                      _includeImages = value ?? false;
                    });
                  },
                  controlAffinity: ListTileControlAffinity.leading,
                  contentPadding: EdgeInsets.zero,
                ),

                // å‹ç¼©å¤‡ä»½
                CheckboxListTile(
                  title: const Text('å‹ç¼©å¤‡ä»½æ–‡ä»¶'),
                  subtitle: const Text('å‡å°å¤‡ä»½æ–‡ä»¶å¤§å°'),
                  value: _compress,
                  onChanged: (value) {
                    setState(() {
                      _compress = value ?? false;
                    });
                  },
                  controlAffinity: ListTileControlAffinity.leading,
                  contentPadding: EdgeInsets.zero,
                ),

                // åŠ å¯†å¤‡ä»½
                CheckboxListTile(
                  title: const Text('åŠ å¯†å¤‡ä»½'),
                  subtitle: const Text('ä½¿ç”¨å¯†ç ä¿æŠ¤å¤‡ä»½æ–‡ä»¶'),
                  value: _encrypt,
                  onChanged: (value) {
                    setState(() {
                      _encrypt = value ?? false;
                      if (!_encrypt) {
                        _passwordController.clear();
                        _confirmPasswordController.clear();
                      }
                    });
                  },
                  controlAffinity: ListTileControlAffinity.leading,
                  contentPadding: EdgeInsets.zero,
                ),

                // åŠ å¯†å¯†ç è¾“å…¥
                if (_encrypt) ...[
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: _passwordController,
                    decoration: InputDecoration(
                      labelText: 'åŠ å¯†å¯†ç ',
                      hintText: 'è¯·è¾“å…¥åŠ å¯†å¯†ç ?,
                      prefixIcon: const Icon(Icons.lock),
                      suffixIcon: IconButton(
                        icon: Icon(_showPassword ? Icons.visibility_off : Icons.visibility),
                        onPressed: () {
                          setState(() {
                            _showPassword = !_showPassword;
                          });
                        },
                      ),
                    ),
                    obscureText: !_showPassword,
                    validator: (value) {
                      if (_encrypt && (value == null || value.length < 6)) {
                        return 'å¯†ç é•¿åº¦è‡³å°‘6ä½?;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: _confirmPasswordController,
                    decoration: InputDecoration(
                      labelText: 'ç¡®è®¤å¯†ç ',
                      hintText: 'è¯·å†æ¬¡è¾“å…¥å¯†ç ?,
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(_showConfirmPassword ? Icons.visibility_off : Icons.visibility),
                        onPressed: () {
                          setState(() {
                            _showConfirmPassword = !_showConfirmPassword;
                          });
                        },
                      ),
                    ),
                    obscureText: !_showConfirmPassword,
                    validator: (value) {
                      if (_encrypt && value != _passwordController.text) {
                        return 'ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡?;
                      }
                      return null;
                    },
                  ),
                ],

                const SizedBox(height: 16),

                // æç¤ºä¿¡æ¯
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primaryContainer.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.info_outline,
                        size: 20,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'å¤‡ä»½å°†åŒ…å«æ‰€æœ‰ä¸šåŠ¡æ•°æ®ï¼Œè¯·ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å­˜å‚¨ç©ºé—´ã€?,
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: _createBackup,
          child: const Text('åˆ›å»ºå¤‡ä»½'),
        ),
      ],
    );
  }

  void _createBackup() {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    final options = BackupOptions(
      customName: _nameController.text.trim(),
      description: _descriptionController.text.trim().isEmpty 
          ? null 
          : _descriptionController.text.trim(),
      includeImages: _includeImages,
      encrypt: _encrypt,
      password: _encrypt ? _passwordController.text : null,
      compress: _compress,
    );

    Navigator.of(context).pop();
    widget.onCreateBackup(options);
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../data/services/backup_error_handler.dart';
import '../../data/services/backup_diagnostic_service.dart';

/// å¢å¼ºçš„é”™è¯¯å¯¹è¯æ¡† - æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œè§£å†³å»ºè®®
class EnhancedErrorDialog extends StatefulWidget {
  final UserFriendlyError error;
  final VoidCallback? onRetry;
  final VoidCallback? onDiagnose;
  final bool showDiagnosticButton;

  const EnhancedErrorDialog({
    super.key,
    required this.error,
    this.onRetry,
    this.onDiagnose,
    this.showDiagnosticButton = true,
  });

  static Future<bool?> show(
    BuildContext context, {
    required UserFriendlyError error,
    VoidCallback? onRetry,
    VoidCallback? onDiagnose,
    bool showDiagnosticButton = true,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => EnhancedErrorDialog(
        error: error,
        onRetry: onRetry,
        onDiagnose: onDiagnose,
        showDiagnosticButton: showDiagnosticButton,
      ),
    );
  }

  @override
  State<EnhancedErrorDialog> createState() => _EnhancedErrorDialogState();
}

class _EnhancedErrorDialogState extends State<EnhancedErrorDialog> {
  bool _showTechnicalDetails = false;
  bool _isDiagnosing = false;
  BackupDiagnosticResult? _diagnosticResult;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: _buildTitle(context),
      content: SingleChildScrollView(
        child: _buildContent(context),
      ),
      actions: _buildActions(context),
    );
  }

  Widget _buildTitle(BuildContext context) {
    return Row(
      children: [
        Icon(
          Icons.error_outline,
          color: Theme.of(context).colorScheme.error,
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Text(
            widget.error.title,
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              color: Theme.of(context).colorScheme.error,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildContent(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        // é”™è¯¯æè¿°
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.errorContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Text(
            widget.error.message,
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onErrorContainer,
            ),
          ),
        ),

        // è§£å†³å»ºè®®
        if (widget.error.suggestion != null) ...[
          const SizedBox(height: 16),
          _buildSuggestionSection(context),
        ],

        // è¯Šæ–­ç»“æœ
        if (_diagnosticResult != null) ...[
          const SizedBox(height: 16),
          _buildDiagnosticResult(context),
        ],

        // æŠ€æœ¯è¯¦æƒ?
        if (widget.error.technicalDetails != null) ...[
          const SizedBox(height: 16),
          _buildTechnicalDetailsSection(context),
        ],
      ],
    );
  }

  Widget _buildSuggestionSection(BuildContext context) {
    final suggestion = widget.error.suggestion!;
    
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primaryContainer.withOpacity(0.3),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.lightbulb_outline,
                size: 20,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Text(
                suggestion.title,
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            suggestion.description,
            style: Theme.of(context).textTheme.bodySmall,
          ),
          const SizedBox(height: 12),
          ...suggestion.steps.asMap().entries.map((entry) {
            final index = entry.key;
            final step = entry.value;
            
            return Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primary,
                      shape: BoxShape.circle,
                    ),
                    child: Center(
                      child: Text(
                        '${index + 1}',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      step,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            );
          }),
        ],
      ),
    );
  }

  Widget _buildDiagnosticResult(BuildContext context) {
    final result = _diagnosticResult!;
    
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Colors.blue.withOpacity(0.3),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.info_outline,
                size: 20,
                color: Colors.blue,
              ),
              const SizedBox(width: 8),
              Text(
                'è¯Šæ–­ç»“æœ',
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  color: Colors.blue,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            result.isHealthy ? 'ç³»ç»Ÿæ­£å¸¸' : 'å‘ç°é—®é¢˜',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          if (result.issues.isNotEmpty) ...[
            const SizedBox(height: 12),
            ...result.issues.map((issue) => _buildDiagnosticIssueText(context, issue)),
          ],
        ],
      ),
    );
  }

  Widget _buildDiagnosticIssueText(BuildContext context, String issue) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            Icons.error_outline,
            size: 16,
            color: Colors.red,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              issue,
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTechnicalDetailsSection(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        InkWell(
          onTap: () => setState(() => _showTechnicalDetails = !_showTechnicalDetails),
          child: Row(
            children: [
              Icon(
                _showTechnicalDetails ? Icons.expand_less : Icons.expand_more,
                size: 20,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 4),
              Text(
                'æŠ€æœ¯è¯¦æƒ?,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
        
        if (_showTechnicalDetails) ...[
          const SizedBox(height: 8),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surface.withOpacity(0.3),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        widget.error.technicalDetails!,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.copy, size: 16),
                      onPressed: () => _copyToClipboard(context, widget.error.technicalDetails!),
                      tooltip: 'å¤åˆ¶åˆ°å‰ªè´´æ¿',
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }

  List<Widget> _buildActions(BuildContext context) {
    return [
      // è¯Šæ–­æŒ‰é’®
      if (widget.showDiagnosticButton && _diagnosticResult == null)
        TextButton.icon(
          onPressed: _isDiagnosing ? null : _runDiagnostic,
          icon: _isDiagnosing 
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Icon(Icons.medical_services, size: 16),
          label: Text(_isDiagnosing ? 'è¯Šæ–­ä¸?..' : 'è¯Šæ–­'),
        ),
      
      // å…³é—­æŒ‰é’®
      TextButton(
        onPressed: () => Navigator.of(context).pop(false),
        child: const Text('å…³é—­'),
      ),
      
      // é‡è¯•æŒ‰é’®
      if (widget.error.canRetry && widget.onRetry != null)
        ElevatedButton.icon(
          onPressed: () {
            Navigator.of(context).pop(true);
            widget.onRetry!();
          },
          icon: const Icon(Icons.refresh, size: 16),
          label: const Text('é‡è¯•'),
        ),
    ];
  }

  Future<void> _runDiagnostic() async {
    setState(() => _isDiagnosing = true);
    
    try {
      // åˆ›å»ºä¸´æ—¶è¯Šæ–­ç»“æœ
      final result = BackupDiagnosticResult(
        isHealthy: true,
        issues: [],
        warnings: [],
        systemInfo: {},
        databaseInfo: {},
        storageInfo: {},
      );
      
      if (mounted) {
        setState(() {
          _diagnosticResult = result;
          _isDiagnosing = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isDiagnosing = false);
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('è¯Šæ–­å¤±è´¥: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    }
  }

  void _copyToClipboard(BuildContext context, String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('æŠ€æœ¯è¯¦æƒ…å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'),
        duration: Duration(seconds: 2),
      ),
    );
  }


}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../data/utils/file_access_helper.dart';

/// æ–‡ä»¶è®¿é—®å¸®åŠ©å¯¹è¯æ¡?
class FileAccessHelpDialog extends StatelessWidget {
  const FileAccessHelpDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: [
          Icon(
            Icons.help_outline,
            color: Theme.of(context).colorScheme.primary,
          ),
          const SizedBox(width: 12),
          const Text('æ— æ³•è®¿é—®å¤‡ä»½æ–‡ä»¶ï¼?),
        ],
      ),
      content: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'å¦‚æœæ‚¨çš„å¤‡ä»½æ–‡ä»¶ä½äº /data/user/0/... è·¯å¾„ä¸‹ï¼Œç³»ç»Ÿæ–‡ä»¶é€‰æ‹©å™¨æ— æ³•ç›´æ¥è®¿é—®ã€?,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 16),
            
            _buildSectionTitle(context, 'è§£å†³æ–¹æ³•ï¼?),
            const SizedBox(height: 8),
            
            _buildStep(context, '1', 'ä½¿ç”¨æ–‡ä»¶ç®¡ç†å™?, [
              'æ‰“å¼€æ‰‹æœºçš„æ–‡ä»¶ç®¡ç†å™¨åº”ç”¨',
              'å¯¼èˆªåˆ°å¤‡ä»½æ–‡ä»¶æ‰€åœ¨ä½ç½?,
              'é•¿æŒ‰å¤‡ä»½æ–‡ä»¶ï¼Œé€‰æ‹©"å¤åˆ¶"',
              'å¯¼èˆªåˆ?ä¸‹è½½"æˆ?æ–‡æ¡£"æ–‡ä»¶å¤?,
              'ç²˜è´´æ–‡ä»¶',
            ]),
            
            const SizedBox(height: 12),
            
            _buildStep(context, '2', 'æ¨èçš„å­˜æ”¾ä½ç½?, [
              'ä¸‹è½½æ–‡ä»¶å¤?(Downloads)',
              'æ–‡æ¡£æ–‡ä»¶å¤?(Documents)', 
              'SDå¡æ ¹ç›®å½•',
              'æ¡Œé¢æ–‡ä»¶å¤?,
            ]),
            
            const SizedBox(height: 12),
            
            _buildStep(context, '3', 'é‡æ–°é€‰æ‹©æ–‡ä»¶', [
              'è¿”å›åº”ç”¨',
              'ç‚¹å‡»"é€‰æ‹©æ–‡ä»¶"æŒ‰é’®',
              'ä»æ–°ä½ç½®é€‰æ‹©å¤‡ä»½æ–‡ä»¶',
            ]),
            
            const SizedBox(height: 16),
            
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primaryContainer.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.lightbulb_outline,
                    color: Theme.of(context).colorScheme.primary,
                    size: 20,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'æç¤ºï¼šåº”ç”¨ä¼šè‡ªåŠ¨å¤„ç†æ–‡ä»¶æ•°æ®ï¼Œå³ä½¿æ— æ³•è®¿é—®åŸå§‹è·¯å¾„ä¹Ÿèƒ½æ­£å¸¸æ¢å¤ã€?,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('æˆ‘çŸ¥é“äº†'),
        ),
        FilledButton(
          onPressed: () {
            Clipboard.setData(ClipboardData(text: FileAccessHelper.getAccessGuide()));
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('å¸®åŠ©ä¿¡æ¯å·²å¤åˆ¶åˆ°å‰ªè´´æ?)),
            );
            Navigator.of(context).pop();
          },
          child: const Text('å¤åˆ¶æŒ‡å—'),
        ),
      ],
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Text(
      title,
      style: Theme.of(context).textTheme.titleSmall?.copyWith(
        fontWeight: FontWeight.w600,
        color: Theme.of(context).colorScheme.primary,
      ),
    );
  }

  Widget _buildStep(BuildContext context, String number, String title, List<String> steps) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              width: 24,
              height: 24,
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                shape: BoxShape.circle,
              ),
              child: Center(
                child: Text(
                  number,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
            Text(
              title,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Padding(
          padding: const EdgeInsets.only(left: 32),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: steps.map((step) => Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'â€?',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                  Expanded(
                    child: Text(
                      step,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
                ],
              ),
            )).toList(),
          ),
        ),
      ],
    );
  }

  /// æ˜¾ç¤ºå¸®åŠ©å¯¹è¯æ¡?
  static Future<void> show(BuildContext context) {
    return showDialog<void>(
      context: context,
      builder: (context) => const FileAccessHelpDialog(),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../domain/models/backup_metadata.dart';
import '../../domain/models/restore_result.dart';

/// æ“ä½œç»“æœå¯¹è¯æ¡?- ç”¨äºæ˜¾ç¤ºå¤‡ä»½æˆ–æ¢å¤å®Œæˆåçš„è¯¦ç»†ç»“æ?
class OperationResultDialog extends StatelessWidget {
  final String title;
  final bool isSuccess;
  final String? errorMessage;
  final BackupMetadata? backupMetadata;
  final RestoreResult? restoreResult;
  final String? filePath;
  final VoidCallback? onClose;
  final VoidCallback? onRetry;
  final VoidCallback? onShare;

  const OperationResultDialog({
    super.key,
    required this.title,
    required this.isSuccess,
    this.errorMessage,
    this.backupMetadata,
    this.restoreResult,
    this.filePath,
    this.onClose,
    this.onRetry,
    this.onShare,
  });

  /// åˆ›å»ºå¤‡ä»½ç»“æœå¯¹è¯æ¡?
  factory OperationResultDialog.backup({
    required bool isSuccess,
    String? errorMessage,
    BackupMetadata? metadata,
    String? filePath,
    VoidCallback? onClose,
    VoidCallback? onRetry,
    VoidCallback? onShare,
  }) {
    return OperationResultDialog(
      title: isSuccess ? 'å¤‡ä»½å®Œæˆ' : 'å¤‡ä»½å¤±è´¥',
      isSuccess: isSuccess,
      errorMessage: errorMessage,
      backupMetadata: metadata,
      filePath: filePath,
      onClose: onClose,
      onRetry: onRetry,
      onShare: onShare,
    );
  }

  /// åˆ›å»ºæ¢å¤ç»“æœå¯¹è¯æ¡?
  factory OperationResultDialog.restore({
    required bool isSuccess,
    String? errorMessage,
    RestoreResult? result,
    VoidCallback? onClose,
    VoidCallback? onRetry,
  }) {
    return OperationResultDialog(
      title: isSuccess ? 'æ¢å¤å®Œæˆ' : 'æ¢å¤å¤±è´¥',
      isSuccess: isSuccess,
      errorMessage: errorMessage,
      restoreResult: result,
      onClose: onClose,
      onRetry: onRetry,
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: _buildTitle(context),
      content: SingleChildScrollView(child: _buildContent(context)),
      actions: _buildActions(context),
    );
  }

  Widget _buildTitle(BuildContext context) {
    final iconData = isSuccess ? Icons.check_circle : Icons.error;
    final iconColor = isSuccess
        ? Theme.of(context).colorScheme.primary
        : Theme.of(context).colorScheme.error;

    return Row(
      children: [
        Icon(iconData, color: iconColor),
        const SizedBox(width: 12),
        Text(title),
      ],
    );
  }

  Widget _buildContent(BuildContext context) {
    if (!isSuccess) {
      return _buildErrorContent(context);
    }

    if (backupMetadata != null) {
      return _buildBackupSuccessContent(context);
    }

    if (restoreResult != null) {
      return _buildRestoreSuccessContent(context);
    }

    return const SizedBox.shrink();
  }

  Widget _buildErrorContent(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.error,
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  'æ“ä½œå¤±è´¥',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onErrorContainer,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            errorMessage ?? 'å‘ç”ŸæœªçŸ¥é”™è¯¯',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onErrorContainer,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBackupSuccessContent(BuildContext context) {
    final metadata = backupMetadata!;
    final totalRecords = metadata.tableCounts.values.fold<int>(
      0,
      (sum, count) => sum + count,
    );
    final fileSizeText = _formatFileSize(metadata.fileSize);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.check_circle,
                    color: Theme.of(context).colorScheme.onPrimaryContainer,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'å¤‡ä»½åˆ›å»ºæˆåŠŸï¼?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              _buildInfoRow(context, 'å¤‡ä»½åç§°', metadata.fileName),
              _buildInfoRow(
                context,
                'åˆ›å»ºæ—¶é—´',
                _formatDateTime(metadata.createdAt),
              ),
              _buildInfoRow(context, 'æ–‡ä»¶å¤§å°', fileSizeText),
              _buildInfoRow(context, 'æ€»è®°å½•æ•°', totalRecords.toString()),
              if (metadata.description != null)
                _buildInfoRow(context, 'æè¿°', metadata.description!),
            ],
          ),
        ),
        const SizedBox(height: 16),
        _buildTableCounts(context, metadata.tableCounts),
        if (filePath != null) ...[
          const SizedBox(height: 16),
          _buildFilePathInfo(context, filePath!),
        ],
      ],
    );
  }

  Widget _buildRestoreSuccessContent(BuildContext context) {
    final result = restoreResult!;
    final duration = result.endTime.difference(result.startTime);
    final durationText = duration.inMinutes > 0
        ? '${duration.inMinutes}åˆ?{duration.inSeconds % 60}ç§?
        : '${duration.inSeconds}ç§?;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.check_circle,
                    color: Theme.of(context).colorScheme.onPrimaryContainer,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'æ•°æ®æ¢å¤æˆåŠŸï¼â€œä»€ä¹ˆæ—¶å€™æ‰èƒ½å¸®çª—å°çš„è€ç›†æ ½æ“¦æ‰å¹´è½®å‘€ï¼Ÿâ€?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              _buildInfoRow(
                context,
                'æ€»è®°å½•æ•°',
                result.totalRecordsRestored.toString(),
              ),
              _buildInfoRow(context, 'è€—æ—¶', durationText),
              _buildInfoRow(context, 'å¼€å§‹æ—¶é—?, _formatDateTime(result.startTime)),
              _buildInfoRow(context, 'ç»“æŸæ—¶é—´', _formatDateTime(result.endTime)),
            ],
          ),
        ),
        if (result.tableRecordCounts.isNotEmpty) ...[
          const SizedBox(height: 16),
          _buildTableCounts(context, result.tableRecordCounts),
        ],
        if (result.warnings.isNotEmpty) ...[
          const SizedBox(height: 16),
          _buildWarnings(context, result.warnings),
        ],
      ],
    );
  }

  Widget _buildInfoRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onPrimaryContainer,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onPrimaryContainer,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTableCounts(BuildContext context, Map<String, int> tableCounts) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.secondaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'æ•°æ®ç»Ÿè®¡:',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSecondaryContainer,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          ...tableCounts.entries.map(
            (entry) => Padding(
              padding: const EdgeInsets.only(bottom: 2),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    _getTableDisplayName(entry.key),
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSecondaryContainer,
                    ),
                  ),
                  Text(
                    entry.value.toString(),
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSecondaryContainer,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWarnings(BuildContext context, List<String> warnings) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.tertiaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning,
                size: 16,
                color: Theme.of(context).colorScheme.onTertiaryContainer,
              ),
              const SizedBox(width: 8),
              Text(
                'æ³¨æ„äº‹é¡¹:',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onTertiaryContainer,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ...warnings.map(
            (warning) => Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Text(
                'â€?$warning',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onTertiaryContainer,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFilePathInfo(BuildContext context, String path) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.folder,
                size: 16,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 8),
              Text(
                'æ–‡ä»¶ä½ç½®:',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              Expanded(
                child: Text(
                  path,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                    fontFamily: 'monospace',
                  ),
                ),
              ),
              IconButton(
                onPressed: () => _copyToClipboard(context, path),
                icon: const Icon(Icons.copy, size: 16),
                tooltip: 'å¤åˆ¶è·¯å¾„',
              ),
            ],
          ),
        ],
      ),
    );
  }

  List<Widget> _buildActions(BuildContext context) {
    if (!isSuccess) {
      return [
        TextButton(onPressed: onClose, child: const Text('å…³é—­')),
        if (onRetry != null)
          ElevatedButton(onPressed: onRetry, child: const Text('é‡è¯•')),
      ];
    }

    final actions = <Widget>[
      TextButton(onPressed: onClose, child: const Text('å…³é—­')),
    ];

    if (onShare != null) {
      actions.insert(
        0,
        TextButton(onPressed: onShare, child: const Text('åˆ†äº«')),
      );
    }

    return actions;
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '${bytes}B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)}KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)}MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
  }

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  String _getTableDisplayName(String tableName) {
    const tableNames = {
      'product': 'äº§å“',
      'category': 'åˆ†ç±»',
      'unit': 'å•ä½',
      'unit_product': 'äº§å“å•ä½',
      'shop': 'åº—é“º',
      'supplier': 'ä¾›åº”å•?,
      'customers': 'å®¢æˆ·',
      'product_batch': 'äº§å“æ‰¹æ¬¡',
      'stock': 'åº“å­˜',
      'inventory_transaction': 'åº“å­˜äº¤æ˜“',
      'locations': 'è´§ä½',
      'inbound_receipt': 'å…¥åº“å?,
      'inbound_item': 'å…¥åº“æ˜ç»†',
      'outbound_receipt': 'å‡ºåº“å?,
      'outbound_item': 'å‡ºåº“æ˜ç»†',
      'purchase_order': 'é‡‡è´­å?,
      'purchase_order_item': 'é‡‡è´­æ˜ç»†',
      'sales_transaction': 'é”€å”®äº¤æ˜?,
      'sales_transaction_item': 'é”€å”®æ˜ç»?,
      'barcode': 'æ¡ç ',
    };
    return tableNames[tableName] ?? tableName;
  }

  void _copyToClipboard(BuildContext context, String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('è·¯å¾„å·²å¤åˆ¶åˆ°å‰ªè´´æ?),
        duration: Duration(seconds: 2),
      ),
    );
  }
}
import 'package:flutter/material.dart';

/// å¯†ç è¾“å…¥å¯¹è¯æ¡?
class PasswordInputDialog extends StatefulWidget {
  final ValueChanged<String> onPasswordSubmitted;

  const PasswordInputDialog({
    super.key,
    required this.onPasswordSubmitted,
  });

  @override
  State<PasswordInputDialog> createState() => _PasswordInputDialogState();
}

class _PasswordInputDialogState extends State<PasswordInputDialog> {
  final _passwordController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  bool _obscurePassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: [
          Icon(
            Icons.lock,
            color: Theme.of(context).colorScheme.primary,
          ),
          const SizedBox(width: 12),
          const Text('è¾“å…¥å¯†ç '),
        ],
      ),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('æ­¤å¤‡ä»½æ–‡ä»¶å·²åŠ å¯†ï¼Œè¯·è¾“å…¥å¯†ç ä»¥ç»§ç»­ï¼š'),
            const SizedBox(height: 16),
            TextFormField(
              controller: _passwordController,
              obscureText: _obscurePassword,
              autofocus: true,
              decoration: InputDecoration(
                labelText: 'å¯†ç ',
                hintText: 'è¯·è¾“å…¥å¤‡ä»½å¯†ç ?,
                prefixIcon: const Icon(Icons.key),
                suffixIcon: IconButton(
                  icon: Icon(
                    _obscurePassword ? Icons.visibility : Icons.visibility_off,
                  ),
                  onPressed: () {
                    setState(() {
                      _obscurePassword = !_obscurePassword;
                    });
                  },
                ),
                border: const OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'è¯·è¾“å…¥å¯†ç ?;
                }
                return null;
              },
              onFieldSubmitted: (_) => _submitPassword(),
            ),
            const SizedBox(height: 8),
            Text(
              'æç¤ºï¼šå¦‚æœå¿˜è®°å¯†ç ï¼Œå°†æ— æ³•æ¢å¤æ­¤å¤‡ä»½æ–‡ä»¶',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _submitPassword,
          child: _isLoading
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('ç¡®å®š'),
        ),
      ],
    );
  }

  void _submitPassword() {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    final password = _passwordController.text.trim();
    
    // å…³é—­å¯¹è¯æ¡†å¹¶æäº¤å¯†ç 
    Navigator.of(context).pop();
    widget.onPasswordSubmitted(password);
  }
}
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:share_plus/share_plus.dart';

import '../controllers/backup_controller.dart';
import '../controllers/restore_controller.dart';
import 'backup_progress_dialog.dart';
import 'restore_progress_dialog.dart';
import 'operation_result_dialog.dart';
import 'enhanced_error_dialog.dart';
import '../../data/services/backup_error_handler.dart';

/// è¿›åº¦ç®¡ç†å™?- ç»Ÿä¸€ç®¡ç†å¤‡ä»½å’Œæ¢å¤çš„è¿›åº¦æ˜¾ç¤º
class ProgressManager extends ConsumerWidget {
  final Widget child;

  const ProgressManager({
    super.key,
    required this.child,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ç›‘å¬å¤‡ä»½çŠ¶æ€?
    ref.listen<BackupState>(backupControllerProvider, (previous, current) {
      _handleBackupStateChange(context, ref, previous, current);
    });

    // ç›‘å¬æ¢å¤çŠ¶æ€?
    ref.listen<RestoreState>(restoreControllerProvider, (previous, current) {
      _handleRestoreStateChange(context, ref, previous, current);
    });

    return child;
  }

  void _handleBackupStateChange(
    BuildContext context,
    WidgetRef ref,
    BackupState? previous,
    BackupState current,
  ) {
    // æ˜¾ç¤ºå¤‡ä»½è¿›åº¦å¯¹è¯æ¡?
    if (current.isBackingUp && current.progressInfo != null) {
      if (previous?.progressInfo == null) {
        _showBackupProgressDialog(context, ref);
      }
    }

    // æ˜¾ç¤ºå¤‡ä»½ç»“æœ
    if (previous?.isBackingUp == true && 
        !current.isBackingUp && 
        current.progressInfo?.isCompleted == true) {
      
      // å»¶è¿Ÿä¸€ä¸‹å†æ˜¾ç¤ºç»“æœï¼Œè®©è¿›åº¦å¯¹è¯æ¡†æœ‰æ—¶é—´æ›´æ–°
      Future.delayed(const Duration(milliseconds: 500), () {
        if (context.mounted) {
          Navigator.of(context).pop(); // å…³é—­è¿›åº¦å¯¹è¯æ¡?
          _showBackupResultDialog(context, ref, current);
        }
      });
    }
  }

  void _handleRestoreStateChange(
    BuildContext context,
    WidgetRef ref,
    RestoreState? previous,
    RestoreState current,
  ) {
    // æ˜¾ç¤ºæ¢å¤è¿›åº¦å¯¹è¯æ¡?
    // åªæœ‰åœ¨å¼€å§‹æ¢å¤æ—¶æ‰æ˜¾ç¤ºå¯¹è¯æ¡†ï¼Œé¿å…åœ¨æ¢å¤å®Œæˆæ—¶é‡å¤æ˜¾ç¤?
    if (current.progressInfo != null && 
        !current.progressInfo!.isCompleted && 
        !current.progressInfo!.isCancelled) {
      // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¾ç¤ºäº†å¯¹è¯æ¡?
      bool isDialogAlreadyShown = false;
      final prevProgress = previous?.progressInfo;
      if (prevProgress != null && 
          !prevProgress.isCompleted && 
          !prevProgress.isCancelled) {
        isDialogAlreadyShown = true;
      }
      
      if (!isDialogAlreadyShown) {
        _showRestoreProgressDialog(context, ref);
      }
    }

    // å¤„ç†æ¢å¤å®Œæˆçš„æƒ…å†?
    // å½“æ¢å¤å®Œæˆæ—¶ï¼Œä¸éœ€è¦é¢å¤–æ“ä½œï¼Œå› ä¸ºç”¨æˆ·ä¼šç‚¹å‡?å®Œæˆ"æŒ‰é’®å…³é—­å¯¹è¯æ¡?
    if (previous?.progressInfo?.isCompleted != true &&
        current.progressInfo?.isCompleted == true) {
      
      // ä¸éœ€è¦é¢å¤–æ“ä½œï¼ŒRestoreProgressDialog ä¼šè‡ªåŠ¨æ›´æ–°æ˜¾ç¤ºå®ŒæˆçŠ¶æ€?
      // ç”¨æˆ·ç‚¹å‡»"å®Œæˆ"æŒ‰é’®åä¼šå…³é—­å¯¹è¯æ¡?
    }
  }

  void _showBackupProgressDialog(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => Consumer(
        builder: (context, ref, child) {
          final state = ref.watch(backupControllerProvider);
          final progressInfo = state.progressInfo;

          if (progressInfo == null) {
            return const SizedBox.shrink();
          }

          return BackupProgressDialog(
            progressInfo: progressInfo,
            onCancel: () {
              ref.read(backupControllerProvider.notifier).cancelBackup();
            },
            onRetry: () {
              Navigator.of(context).pop();
              ref.read(backupControllerProvider.notifier).retryBackup();
            },
            onClose: () {
              Navigator.of(context).pop();
              ref.read(backupControllerProvider.notifier).reset();
            },
          );
        },
      ),
    );
  }

  void _showRestoreProgressDialog(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => RestoreProgressDialog(
        onClose: () {
          // ç¡®ä¿å®Œå…¨å…³é—­æ‰€æœ‰å¯¹è¯æ¡†
          if (Navigator.of(context).canPop()) {
            Navigator.of(context).popUntil((route) => route.isFirst);
          }
          ref.read(restoreControllerProvider.notifier).reset();
        },
        onRetry: () {
          Navigator.of(context).pop();
          ref.read(restoreControllerProvider.notifier).startRestore();
        },
      ),
    );
  }

  void _showBackupResultDialog(
    BuildContext context,
    WidgetRef ref,
    BackupState state,
  ) {
    final isSuccess = state.resultMetadata != null && state.errorMessage == null;
    
    if (!isSuccess && state.errorMessage != null) {
      // æ˜¾ç¤ºå¢å¼ºçš„é”™è¯¯å¯¹è¯æ¡†
      final userError = UserFriendlyError(
        title: 'å¤‡ä»½å¤±è´¥',
        message: state.errorMessage!,
        canRetry: true,
      );
      
      EnhancedErrorDialog.show(
        context,
        error: userError,
        onRetry: () {
          ref.read(backupControllerProvider.notifier).retryBackup();
        },
      ).then((_) {
        ref.read(backupControllerProvider.notifier).reset();
      });
    } else {
      // æ˜¾ç¤ºæˆåŠŸç»“æœå¯¹è¯æ¡?
      showDialog(
        context: context,
        builder: (context) => OperationResultDialog.backup(
          isSuccess: isSuccess,
          errorMessage: state.errorMessage,
          metadata: state.resultMetadata,
          filePath: state.resultFilePath,
          onClose: () {
            Navigator.of(context).pop();
            ref.read(backupControllerProvider.notifier).reset();
          },
          onRetry: () {
            Navigator.of(context).pop();
            ref.read(backupControllerProvider.notifier).retryBackup();
          },
          onShare: state.resultFilePath != null ? () {
            Navigator.of(context).pop();
            _shareBackupFile(context, state.resultFilePath!);
          } : null,
        ),
      );
    }
  }

  // Removed unused method _showRestoreResultDialog - functionality is handled by RestoreProgressDialog

  void _shareBackupFile(BuildContext context, String filePath) async {
    try {
      final file = File(filePath);
      
      if (!await file.exists()) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ?)),
        );
        return;
      }
      
      // ä½¿ç”¨ share_plus åˆ†äº«æ–‡ä»¶
      await Share.shareXFiles(
        [XFile(filePath)],
        text: 'åº“å­˜æ•°æ®å¤‡ä»½æ–‡ä»¶',
        subject: 'åº“å­˜æ•°æ®å¤‡ä»½',
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('åˆ†äº«å¤±è´¥: ${e.toString()}')),
      );
    }
  }
}
import 'package:flutter/material.dart';
import 'package:path/path.dart' as path;
import 'file_access_help_dialog.dart';

/// æ¢å¤æ–‡ä»¶é€‰æ‹©å™¨ç»„ä»?
class RestoreFileSelector extends StatelessWidget {
  final String? selectedFilePath;
  final VoidCallback onSelectFile;

  const RestoreFileSelector({
    super.key,
    this.selectedFilePath,
    required this.onSelectFile,
  });

  /// æ˜¾ç¤ºè®¿é—®å¸®åŠ©
  void _showAccessHelp(BuildContext context) {
    FileAccessHelpDialog.show(context);
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.folder_open,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'é€‰æ‹©å¤‡ä»½æ–‡ä»¶',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () => _showAccessHelp(context),
                  icon: Icon(
                    Icons.help_outline,
                    color: Theme.of(context).colorScheme.primary,
                    size: 20,
                  ),
                  tooltip: 'è®¿é—®å¸®åŠ©',
                  visualDensity: VisualDensity.compact,
                ),
              ],
            ),
            const SizedBox(height: 12),
            
            if (selectedFilePath == null) ...[
              Text(
                'è¯·é€‰æ‹©è¦æ¢å¤çš„å¤‡ä»½æ–‡ä»¶',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: onSelectFile,
                  icon: const Icon(Icons.file_open),
                  label: const Text('é€‰æ‹©æ–‡ä»¶'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                ),
              ),
            ] else ...[
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.insert_drive_file,
                      color: Theme.of(context).colorScheme.onPrimaryContainer,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'å·²é€‰æ‹©æ–‡ä»¶',
                            style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Theme.of(context).colorScheme.onPrimaryContainer,
                            ),
                          ),
                          Text(
                            path.basename(selectedFilePath!),
                            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                              color: Theme.of(context).colorScheme.onPrimaryContainer,
                              fontWeight: FontWeight.w500,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                    ),
                    IconButton(
                      onPressed: onSelectFile,
                      icon: Icon(
                        Icons.edit,
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        size: 20,
                      ),
                      tooltip: 'é‡æ–°é€‰æ‹©',
                    ),
                  ],
                ),
              ),
            ],
            
            const SizedBox(height: 12),
            Text(
              'æ”¯æŒçš„æ–‡ä»¶æ ¼å¼? .json, .backup',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceContainerHighest.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.info_outline,
                        size: 16,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        'è®¿é—®æç¤º',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'å¦‚æœæ— æ³•è®¿é—® /data/user/0/... è·¯å¾„ä¸‹çš„å¤‡ä»½æ–‡ä»¶ï¼Œè¯·ï¼?,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'â€?å°†æ–‡ä»¶å¤åˆ¶åˆ°ä¸‹è½½æ–‡ä»¶å¤¹\nâ€?æˆ–å¤åˆ¶åˆ°æ–‡æ¡£æ–‡ä»¶å¤¹\nâ€?ç„¶åé‡æ–°é€‰æ‹©æ–‡ä»¶',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                      height: 1.3,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../domain/models/restore_mode.dart';

/// æ¢å¤æ¨¡å¼é€‰æ‹©å™¨ç»„ä»?
class RestoreModeSelector extends StatelessWidget {
  final RestoreMode selectedMode;
  final ValueChanged<RestoreMode> onModeChanged;

  const RestoreModeSelector({
    super.key,
    required this.selectedMode,
    required this.onModeChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.settings_backup_restore,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 12),
                Text(
                  'æ¢å¤æ¨¡å¼',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            _buildModeOption(
              context,
              RestoreMode.merge,
              'åˆå¹¶æ•°æ®',
              'ä¿ç•™ç°æœ‰æ•°æ®ï¼Œæ·»åŠ å¤‡ä»½ä¸­çš„æ–°æ•°æ®ã€‚å¦‚æœå­˜åœ¨å†²çªï¼Œä¼˜å…ˆä½¿ç”¨å¤‡ä»½æ•°æ®ã€?,
              Icons.merge,
              Colors.blue,
            ),
            
            const SizedBox(height: 12),
            
            _buildModeOption(
              context,
              RestoreMode.replace,
              'å®Œå…¨æ›¿æ¢',
              'åˆ é™¤æ‰€æœ‰ç°æœ‰æ•°æ®ï¼Œå®Œå…¨ä½¿ç”¨å¤‡ä»½æ•°æ®æ›¿æ¢ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼?,
              Icons.swap_horiz,
              Colors.red,
            ),
            
            const SizedBox(height: 12),
            
            _buildModeOption(
              context,
              RestoreMode.addOnly,
              'ä»…æ·»åŠ æ–°æ•°æ®',
              'åªæ·»åŠ ä¸å­˜åœ¨çš„æ•°æ®ï¼Œä¸ä¿®æ”¹ç°æœ‰è®°å½•ã€‚æœ€å®‰å…¨çš„æ¢å¤æ¨¡å¼ã€?,
              Icons.add_circle_outline,
              Colors.green,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildModeOption(
    BuildContext context,
    RestoreMode mode,
    String title,
    String description,
    IconData icon,
    Color color,
  ) {
    final isSelected = selectedMode == mode;
    
    return InkWell(
      onTap: () => onModeChanged(mode),
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected 
                ? color
                : Theme.of(context).colorScheme.outline.withValues(alpha: 0.3),
            width: isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(8),
          color: isSelected 
              ? color.withValues(alpha: 0.1)
              : null,
        ),
        child: Row(
          children: [
            Radio<RestoreMode>(
              value: mode,
              groupValue: selectedMode,
              onChanged: (value) {
                if (value != null) {
                  onModeChanged(value);
                }
              },
              activeColor: color,
            ),
            const SizedBox(width: 8),
            Icon(
              icon,
              color: isSelected ? color : Theme.of(context).colorScheme.onSurfaceVariant,
              size: 20,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isSelected ? color : null,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../domain/models/restore_preview.dart';

/// æ¢å¤é¢„è§ˆå¡ç‰‡ç»„ä»¶
class RestorePreviewCard extends StatelessWidget {
  final RestorePreview preview;

  const RestorePreviewCard({super.key, required this.preview});

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('yyyy-MM-dd HH:mm');
    final totalRecords = preview.recordCounts.values.fold<int>(
      0,
      (sum, count) => sum + count,
    );

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.preview,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 12),
                Text(
                  'æ•°æ®æ¢å¤é¢„è§ˆ',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // åŸºæœ¬ä¿¡æ¯
            _buildInfoSection(context, 'åŸºæœ¬ä¿¡æ¯', [
              _InfoItem('æ–‡ä»¶å?, preview.metadata.fileName),
              _InfoItem('åˆ›å»ºæ—¶é—´', dateFormat.format(preview.metadata.createdAt)),
              _InfoItem('æ–‡ä»¶å¤§å°', _formatFileSize(preview.metadata.fileSize)),
              _InfoItem('æ€»è®°å½•æ•°', '$totalRecords æ?),
              if (preview.metadata.isEncrypted)
                _InfoItem(
                  'åŠ å¯†çŠ¶æ€?,
                  'å·²åŠ å¯?,
                  color: Theme.of(context).colorScheme.secondary,
                ),
            ]),

            const SizedBox(height: 16),

            // æ•°æ®ç»Ÿè®¡
            _buildDataStatisticsSection(context),

            if (preview.estimatedConflicts > 0) ...[
              const SizedBox(height: 16),
              _buildWarningSection(
                context,
                'é¢„è®¡å†²çª',
                '${preview.estimatedConflicts} æ¡è®°å½•å¯èƒ½å­˜åœ¨å†²çª?,
              ),
            ],

            if (!preview.isCompatible ||
                preview.compatibilityWarnings.isNotEmpty) ...[
              const SizedBox(height: 16),
              _buildCompatibilitySection(context),
            ],

            if (preview.estimatedDurationSeconds != null) ...[
              const SizedBox(height: 16),
              _buildInfoSection(context, 'é¢„è®¡æ—¶é—´', [
                _InfoItem(
                  'æ¢å¤æ—¶é—´',
                  _formatDuration(preview.estimatedDurationSeconds!),
                ),
              ]),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildInfoSection(
    BuildContext context,
    String title,
    List<_InfoItem> items,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 8),
        ...items.map(
          (item) => Padding(
            padding: const EdgeInsets.only(bottom: 4),
            child: Row(
              children: [
                SizedBox(
                  width: 80,
                  child: Text(
                    item.label,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    item.value,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: item.color,
                      fontWeight: item.color != null ? FontWeight.w500 : null,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildWarningSection(
    BuildContext context,
    String title,
    String message,
  ) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning,
                color: Theme.of(context).colorScheme.onErrorContainer,
                size: 16,
              ),
              const SizedBox(width: 8),
              Text(
                title,
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  color: Theme.of(context).colorScheme.onErrorContainer,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            message,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onErrorContainer,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompatibilitySection(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: preview.isCompatible
            ? Theme.of(context).colorScheme.secondaryContainer
            : Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                preview.isCompatible ? Icons.info : Icons.error,
                color: preview.isCompatible
                    ? Theme.of(context).colorScheme.onSecondaryContainer
                    : Theme.of(context).colorScheme.onErrorContainer,
                size: 16,
              ),
              const SizedBox(width: 8),
              Text(
                'å…¼å®¹æ€§æ£€æŸ?,
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  color: preview.isCompatible
                      ? Theme.of(context).colorScheme.onSecondaryContainer
                      : Theme.of(context).colorScheme.onErrorContainer,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            preview.isCompatible ? 'å¤‡ä»½æ–‡ä»¶ä¸å½“å‰ç‰ˆæœ¬å…¼å®? : 'å¤‡ä»½æ–‡ä»¶ä¸å½“å‰ç‰ˆæœ¬ä¸å®Œå…¨å…¼å®¹',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: preview.isCompatible
                  ? Theme.of(context).colorScheme.onSecondaryContainer
                  : Theme.of(context).colorScheme.onErrorContainer,
            ),
          ),
          if (preview.compatibilityWarnings.isNotEmpty) ...[
            const SizedBox(height: 8),
            ...preview.compatibilityWarnings.map(
              (warning) => Padding(
                padding: const EdgeInsets.only(bottom: 2),
                child: Text(
                  'â€?$warning',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: preview.isCompatible
                        ? Theme.of(context).colorScheme.onSecondaryContainer
                        : Theme.of(context).colorScheme.onErrorContainer,
                  ),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  String _formatDuration(int seconds) {
    if (seconds < 60) return '$seconds ç§?;
    final minutes = seconds ~/ 60;
    final remainingSeconds = seconds % 60;
    if (minutes < 60) {
      return remainingSeconds > 0
          ? '$minutes åˆ?$remainingSeconds ç§?
          : '$minutes åˆ?;
    }
    final hours = minutes ~/ 60;
    final remainingMinutes = minutes % 60;
    return '$hours å°æ—¶ $remainingMinutes åˆ?;
  }

  Widget _buildDataStatisticsSection(BuildContext context) {
    final totalRestoreRecords = preview.recordCounts.values.fold<int>(
      0,
      (sum, count) => sum + count,
    );
    final totalCurrentRecords = preview.currentDatabaseCounts.values.fold<int>(
      0,
      (sum, count) => sum + count,
    );

    // è®¡ç®—è¡¨æ•°é‡?
    final backupTableCount = preview.recordCounts.keys
        .where((key) => preview.recordCounts[key]! > 0)
        .length;
    final currentTableCount = preview.currentDatabaseCounts.keys
        .where((key) => preview.currentDatabaseCounts[key]! > 0)
        .length;

    // æ‰¾å‡ºå¤‡ä»½æ–‡ä»¶æ¯”å½“å‰æ•°æ®åº“å¤šå‡ºçš„è¡¨
    final extraTables = preview.recordCounts.keys
        .where(
          (table) =>
              preview.recordCounts[table]! > 0 &&
              (preview.currentDatabaseCounts[table] ?? 0) == 0,
        )
        .toList();

    // æ‰¾å‡ºè®°å½•æ•°ä¸åŒçš„è¡?
    final differentTables = preview.recordCounts.keys.where((table) {
      final backupCount = preview.recordCounts[table] ?? 0;
      final currentCount = preview.currentDatabaseCounts[table] ?? 0;
      return backupCount > 0 && currentCount > 0 && backupCount != currentCount;
    }).toList();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'æ•°æ®ç»Ÿè®¡',
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 8),

        // æ€»ä½“ç»Ÿè®¡
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: Theme.of(
              context,
            ).colorScheme.primaryContainer.withValues(alpha: 0.3),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            children: [
              // å¤‡ä»½æ–‡ä»¶ç»Ÿè®¡
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'å¤‡ä»½æ–‡ä»¶',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                  ),
                  Text(
                    '$backupTableCount ä¸ªè¡¨ï¼?totalRestoreRecords æ¡è®°å½?,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              // å½“å‰æ•°æ®åº“ç»Ÿè®?
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'å½“å‰æ•°æ®åº?,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                  Text(
                    '$currentTableCount ä¸ªè¡¨ï¼?totalCurrentRecords æ¡è®°å½?,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),

        const SizedBox(height: 12),

        // å·®å¼‚å¯¹æ¯”
        if (extraTables.isNotEmpty || differentTables.isNotEmpty) ...[
          Text(
            'å·®å¼‚å¯¹æ¯”',
            style: Theme.of(context).textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.w600,
              color: Theme.of(context).colorScheme.primary,
            ),
          ),
          const SizedBox(height: 8),

          // å¤‡ä»½æ–‡ä»¶å¤šå‡ºçš„è¡¨
          if (extraTables.isNotEmpty) ...[
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Theme.of(
                  context,
                ).colorScheme.secondaryContainer.withValues(alpha: 0.5),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.add_circle_outline,
                        size: 16,
                        color: Theme.of(
                          context,
                        ).colorScheme.onSecondaryContainer,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        'å¤‡ä»½æ–‡ä»¶æ–°å¢çš„è¡¨',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: Theme.of(
                            context,
                          ).colorScheme.onSecondaryContainer,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  ...extraTables.map(
                    (table) => Padding(
                      padding: const EdgeInsets.only(bottom: 4),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            _getTableDisplayName(table),
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onSecondaryContainer,
                                ),
                          ),
                          Text(
                            '${preview.recordCounts[table]} æ¡è®°å½?,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  fontWeight: FontWeight.w500,
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onSecondaryContainer,
                                ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 8),
          ],

          // è®°å½•æ•°ä¸åŒçš„è¡?
          if (differentTables.isNotEmpty) ...[
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Theme.of(
                  context,
                ).colorScheme.tertiaryContainer.withValues(alpha: 0.5),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.compare_arrows,
                        size: 16,
                        color: Theme.of(
                          context,
                        ).colorScheme.onTertiaryContainer,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        'è®°å½•æ•°ä¸åŒçš„è¡?,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: Theme.of(
                            context,
                          ).colorScheme.onTertiaryContainer,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  ...differentTables.map((table) {
                    final backupCount = preview.recordCounts[table] ?? 0;
                    final currentCount =
                        preview.currentDatabaseCounts[table] ?? 0;
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 6),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            _getTableDisplayName(table),
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  fontWeight: FontWeight.w500,
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onTertiaryContainer,
                                ),
                          ),
                          const SizedBox(height: 2),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                'å½“å‰æ•°æ®åº? $currentCount æ?,
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Theme.of(context)
                                          .colorScheme
                                          .onTertiaryContainer
                                          .withValues(alpha: 0.8),
                                    ),
                              ),
                              Text(
                                'å¤‡ä»½æ–‡ä»¶: $backupCount æ?,
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Theme.of(context)
                                          .colorScheme
                                          .onTertiaryContainer
                                          .withValues(alpha: 0.8),
                                    ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    );
                  }),
                ],
              ),
            ),
          ],
        ],
      ],
    );
  }

  String _getTableDisplayName(String tableName) {
    const tableNames = {
      'product': 'äº§å“',
      'category': 'åˆ†ç±»',
      'unit': 'å•ä½',
      'unit_product': 'äº§å“å•ä½',
      'shop': 'åº—é“º',
      'supplier': 'ä¾›åº”å•?,
      'customers': 'å®¢æˆ·',
      'product_batch': 'äº§å“æ‰¹æ¬¡',
      'stock': 'åº“å­˜',
      'inventory_transaction': 'åº“å­˜äº¤æ˜“',
      'locations': 'è´§ä½',
      'inbound_receipt': 'å…¥åº“å?,
      'inbound_item': 'å…¥åº“æ˜ç»†',
      'outbound_receipt': 'å‡ºåº“å?,
      'outbound_item': 'å‡ºåº“æ˜ç»†',
      'purchase_order': 'é‡‡è´­å?,
      'purchase_order_item': 'é‡‡è´­æ˜ç»†',
      'sales_transaction': 'é”€å”®äº¤æ˜?,
      'sales_transaction_item': 'é”€å”®æ˜ç»?,
      'barcode': 'æ¡ç ',
    };
    return tableNames[tableName] ?? tableName;
  }
}

class _InfoItem {
  final String label;
  final String value;
  final Color? color;

  const _InfoItem(this.label, this.value, {this.color});
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../controllers/restore_controller.dart';
import '../../domain/models/restore_result.dart';

/// æ¢å¤è¿›åº¦å¯¹è¯æ¡?
class RestoreProgressDialog extends ConsumerWidget {
  final VoidCallback? onClose;
  final VoidCallback? onRetry;

  const RestoreProgressDialog({
    super.key,
    this.onClose,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(restoreControllerProvider);
    final progressInfo = state.progressInfo;
    final restoreResult = state.restoreResult;

    if (progressInfo == null) {
      return const SizedBox.shrink();
    }

    return PopScope(
      canPop: progressInfo.isCompleted || progressInfo.isCancelled,
      child: AlertDialog(
        title: _buildTitle(context, progressInfo, state.errorMessage, restoreResult),
        content: _buildContent(context, progressInfo, state.errorMessage, restoreResult),
        actions: _buildActions(context, ref, progressInfo, state.errorMessage),
      ),
    );
  }

  Widget _buildTitle(BuildContext context, RestoreProgressInfo progressInfo, 
                    String? errorMessage, RestoreResult? restoreResult) {
    IconData iconData;
    Color iconColor;
    String titleText;

    if (progressInfo.isCancelled) {
      iconData = Icons.cancel;
      iconColor = Theme.of(context).colorScheme.error;
      titleText = 'æ¢å¤å·²å–æ¶?;
    } else if (errorMessage != null || (restoreResult != null && !restoreResult.success)) {
      iconData = Icons.error;
      iconColor = Theme.of(context).colorScheme.error;
      titleText = 'æ¢å¤å¤±è´¥';
    } else if (progressInfo.isCompleted && restoreResult != null && restoreResult.success) {
      iconData = Icons.check_circle;
      iconColor = Theme.of(context).colorScheme.primary;
      titleText = 'æ¢å¤å®Œæˆ';
    } else {
      iconData = Icons.restore;
      iconColor = Theme.of(context).colorScheme.primary;
      titleText = 'æ­£åœ¨æ¢å¤æ•°æ®';
    }

    return Row(
      children: [
        Icon(iconData, color: iconColor),
        const SizedBox(width: 12),
        Text(titleText),
      ],
    );
  }

  Widget _buildContent(BuildContext context, RestoreProgressInfo progressInfo,
                      String? errorMessage, RestoreResult? restoreResult) {
    if (errorMessage != null || (restoreResult != null && !restoreResult.success)) {
      return _buildErrorContent(context, errorMessage ?? restoreResult!.errorMessage!);
    } else if (progressInfo.isCompleted && restoreResult != null && restoreResult.success) {
      return _buildSuccessContent(context, restoreResult);
    } else if (progressInfo.isCancelled) {
      return _buildCancelledContent(context);
    } else {
      return _buildProgressContent(context, progressInfo);
    }
  }

  Widget _buildProgressContent(BuildContext context, RestoreProgressInfo progressInfo) {
    final progress = progressInfo.total > 0 
        ? progressInfo.current / progressInfo.total 
        : 0.0;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // è¿›åº¦æ?
        LinearProgressIndicator(
          value: progress,
          backgroundColor: Theme.of(context).colorScheme.surfaceContainerHighest,
          valueColor: AlwaysStoppedAnimation<Color>(
            Theme.of(context).colorScheme.primary,
          ),
        ),
        const SizedBox(height: 16),
        
        // è¿›åº¦æ–‡æœ¬
        Text(
          '${(progress * 100).toInt()}% (${progressInfo.current}/${progressInfo.total})',
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        
        // å½“å‰æ“ä½œæè¿°
        Text(
          progressInfo.message,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
        
        const SizedBox(height: 16),
        
        // æç¤ºä¿¡æ¯
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.secondaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.info_outline,
                size: 16,
                color: Theme.of(context).colorScheme.onSecondaryContainer,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'è¯·å‹¿å…³é—­åº”ç”¨æˆ–åˆ‡æ¢åˆ°å…¶ä»–é¡µé¢',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondaryContainer,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildSuccessContent(BuildContext context, RestoreResult result) {
    final duration = result.endTime.difference(result.startTime);
    final durationText = duration.inMinutes > 0
        ? '${duration.inMinutes}åˆ?{duration.inSeconds % 60}ç§?
        : '${duration.inSeconds}ç§?;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.check_circle,
                    color: Theme.of(context).colorScheme.onPrimaryContainer,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'æ•°æ®æ¢å¤æˆåŠŸï¼?,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              _buildInfoRow(context, 'æ€»è®°å½•æ•°', result.totalRecordsRestored.toString()),
              _buildInfoRow(context, 'è€—æ—¶', durationText),
              _buildInfoRow(context, 'å¼€å§‹æ—¶é—?, _formatDateTime(result.startTime)),
              _buildInfoRow(context, 'ç»“æŸæ—¶é—´', _formatDateTime(result.endTime)),
              if (result.tableRecordCounts.isNotEmpty) ...[
                const SizedBox(height: 12),
                _buildTableCounts(context, result.tableRecordCounts),
              ],
            ],
          ),
        ),
        if (result.warnings.isNotEmpty) ...[
          const SizedBox(height: 12),
          _buildWarnings(context, result.warnings),
        ],
      ],
    );
  }

  // ç§»é™¤ _buildResultSummary æ–¹æ³•ï¼Œå…¶å†…å®¹å·²æ•´åˆè¿› _buildSuccessContent

  Widget _buildWarnings(BuildContext context, List<String> warnings) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.tertiaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning,
                size: 16,
                color: Theme.of(context).colorScheme.onTertiaryContainer,
              ),
              const SizedBox(width: 8),
              Text(
                'æ³¨æ„äº‹é¡¹:',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onTertiaryContainer,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ...warnings.map((warning) => Padding(
            padding: const EdgeInsets.only(bottom: 4),
            child: Text(
              'â€?$warning',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onTertiaryContainer,
              ),
            ),
          )),
        ],
      ),
    );
  }

  Widget _buildErrorContent(BuildContext context, String errorMessage) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.error,
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  'æ¢å¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯?,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onErrorContainer,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            errorMessage,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onErrorContainer,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCancelledContent(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          Icon(
            Icons.cancel,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'æ¢å¤æ“ä½œå·²å–æ¶?,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  'å·²æ¢å¤çš„æ•°æ®å°†ä¿ç•™ï¼Œæ‚¨å¯ä»¥ç¨åé‡æ–°å¼€å§?,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  List<Widget> _buildActions(BuildContext context, WidgetRef ref,
                            RestoreProgressInfo progressInfo, String? errorMessage) {
    if (errorMessage != null) {
      return [
        TextButton(
          onPressed: onClose,
          child: const Text('å…³é—­'),
        ),
        if (onRetry != null)
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('é‡è¯•'),
          ),
      ];
    } else if (progressInfo.isCompleted) {
      return [
        ElevatedButton(
          onPressed: onClose,
          child: const Text('å®Œæˆ'),
        ),
      ];
    } else if (progressInfo.isCancelled) {
      return [
        ElevatedButton(
          onPressed: onClose,
          child: const Text('å®Œæˆ'),
        ),
      ];
    } else {
      return [
        TextButton(
          onPressed: () => _showCancelConfirmation(context, ref),
          child: const Text('å–æ¶ˆ'),
        ),
      ];
    }
  }

  void _showCancelConfirmation(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤å–æ¶ˆ'),
        content: const Text('ç¡®å®šè¦å–æ¶ˆæ¢å¤æ“ä½œå—ï¼Ÿ\n\nå·²æ¢å¤çš„æ•°æ®å°†ä¿ç•™ï¼Œä½†æ¢å¤è¿‡ç¨‹å°†ä¸­æ–­ã€?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ç»§ç»­æ¢å¤'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(); // å…³é—­ç¡®è®¤å¯¹è¯æ¡?
              ref.read(restoreControllerProvider.notifier).cancelRestore();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
              foregroundColor: Theme.of(context).colorScheme.onError,
            ),
            child: const Text('ç¡®è®¤å–æ¶ˆ'),
          ),
        ],
      ),
    );
  }

  // æ–°å¢æ–¹æ³•ï¼šæ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} '
           '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  // æ–°å¢æ–¹æ³•ï¼šæ„å»ºä¿¡æ¯è¡Œï¼ˆä¸ OperationResultDialog ä¸€è‡´ï¼‰
  Widget _buildInfoRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onPrimaryContainer,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onPrimaryContainer,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // æ–°å¢æ–¹æ³•ï¼šæ„å»ºè¡¨è®°å½•ç»Ÿè®¡ï¼ˆä¸ OperationResultDialog ä¸€è‡´ï¼‰
  Widget _buildTableCounts(BuildContext context, Map<String, int> tableCounts) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.secondaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'æ•°æ®ç»Ÿè®¡:',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSecondaryContainer,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          ...tableCounts.entries.map((entry) => Padding(
            padding: const EdgeInsets.only(bottom: 2),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  _getTableDisplayName(entry.key),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondaryContainer,
                  ),
                ),
                Text(
                  entry.value.toString(),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondaryContainer,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          )),
        ],
      ),
    );
  }

  // æ–°å¢æ–¹æ³•ï¼šè·å–è¡¨åæ˜¾ç¤ºåç§°ï¼ˆä¸?OperationResultDialog ä¸€è‡´ï¼‰
  String _getTableDisplayName(String tableName) {
    const tableNames = {
      'product': 'äº§å“',
      'category': 'åˆ†ç±»',
      'unit': 'å•ä½',
      'unit_product': 'äº§å“å•ä½',
      'shop': 'åº—é“º',
      'supplier': 'ä¾›åº”å•?,
      'customers': 'å®¢æˆ·',
      'product_batch': 'äº§å“æ‰¹æ¬¡',
      'stock': 'åº“å­˜',
      'inventory_transaction': 'åº“å­˜äº¤æ˜“',
      'locations': 'è´§ä½',
      'inbound_receipt': 'å…¥åº“å?,
      'inbound_item': 'å…¥åº“æ˜ç»†',
      'outbound_receipt': 'å‡ºåº“å?,
      'outbound_item': 'å‡ºåº“æ˜ç»†',
      'purchase_order': 'é‡‡è´­å?,
      'purchase_order_item': 'é‡‡è´­æ˜ç»†',
      'sales_transaction': 'é”€å”®äº¤æ˜?,
      'sales_transaction_item': 'é”€å”®æ˜ç»?,
      'barcode': 'æ¡ç ',
    };
    return tableNames[tableName] ?? tableName;
  }
}
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../domain/models/restore_result.dart';

/// æ¢å¤ç»“æœå¯¹è¯æ¡?
class RestoreResultDialog extends StatelessWidget {
  final RestoreResult result;
  final VoidCallback onClose;

  const RestoreResultDialog({
    super.key,
    required this.result,
    required this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final duration = result.endTime.difference(result.startTime);
    final durationText = _formatDuration(duration);

    return AlertDialog(
      title: Row(
        children: [
          Icon(
            result.success ? Icons.check_circle : Icons.error,
            color: result.success 
                ? Colors.green 
                : Theme.of(context).colorScheme.error,
          ),
          const SizedBox(width: 12),
          Text(result.success ? 'æ¢å¤æˆåŠŸ' : 'æ¢å¤å¤±è´¥'),
        ],
      ),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (result.success) ...[
              _buildSuccessContent(context, durationText),
            ] else ...[
              _buildErrorContent(context),
            ],
            
            if (result.warnings.isNotEmpty) ...[
              const SizedBox(height: 16),
              _buildWarningsSection(context),
            ],
            
            const SizedBox(height: 16),
            _buildDetailsSection(context, durationText),
          ],
        ),
      ),
      actions: [
        if (result.success)
          TextButton(
            onPressed: () {
              // å¯ä»¥æ·»åŠ æŸ¥çœ‹è¯¦ç»†æ—¥å¿—çš„åŠŸèƒ?
            },
            child: const Text('æŸ¥çœ‹è¯¦æƒ…'),
          ),
        ElevatedButton(
          onPressed: onClose,
          child: Text(result.success ? 'å®Œæˆ' : 'å…³é—­'),
        ),
      ],
    );
  }

  Widget _buildSuccessContent(BuildContext context, String durationText) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.green.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            children: [
              Icon(
                Icons.backup_outlined,
                size: 48,
                color: Colors.green,
              ),
              const SizedBox(height: 8),
              Text(
                'æ•°æ®æ¢å¤å®Œæˆ',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: Colors.green,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'æˆåŠŸæ¢å¤ ${result.totalRecordsRestored} æ¡è®°å½?,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              Text(
                'è€—æ—¶: $durationText',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
        
        if (result.tableRecordCounts.isNotEmpty) ...[
          const SizedBox(height: 16),
          Text(
            'æ¢å¤è¯¦æƒ…',
            style: Theme.of(context).textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          ...result.tableRecordCounts.entries.map((entry) => 
            Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Row(
                children: [
                  SizedBox(
                    width: 80,
                    child: Text(
                      _getTableDisplayName(entry.key),
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    '${entry.value} æ?,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildErrorContent(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.errorContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            children: [
              Icon(
                Icons.error_outline,
                size: 48,
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
              const SizedBox(height: 8),
              Text(
                'æ¢å¤å¤±è´¥',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onErrorContainer,
                ),
              ),
              if (result.errorMessage != null) ...[
                const SizedBox(height: 8),
                Text(
                  result.errorMessage!,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onErrorContainer,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ],
          ),
        ),
        
        const SizedBox(height: 16),
        Text(
          'å»ºè®®è§£å†³æ–¹æ¡ˆï¼?,
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 8),
        const Text('â€?æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å®Œæ•´ä¸”æœªæŸå?),
        const Text('â€?ç¡®è®¤å¯†ç æ˜¯å¦æ­£ç¡®ï¼ˆå¦‚æœæ–‡ä»¶å·²åŠ å¯†ï¼?),
        const Text('â€?æ£€æŸ¥è®¾å¤‡å­˜å‚¨ç©ºé—´æ˜¯å¦å……è¶?),
        const Text('â€?å°è¯•é‡æ–°é€‰æ‹©å¤‡ä»½æ–‡ä»¶'),
      ],
    );
  }

  Widget _buildWarningsSection(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.orange.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.warning,
                size: 16,
                color: Colors.orange,
              ),
              const SizedBox(width: 8),
              Text(
                'è­¦å‘Šä¿¡æ¯',
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: Colors.orange,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ...result.warnings.map((warning) => 
            Padding(
              padding: const EdgeInsets.only(bottom: 2),
              child: Text(
                'â€?$warning',
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailsSection(BuildContext context, String durationText) {
    final timeFormat = DateFormat('HH:mm:ss');
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'æ“ä½œè¯¦æƒ…',
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 8),
        _buildDetailRow(context, 'å¼€å§‹æ—¶é—?, timeFormat.format(result.startTime)),
        _buildDetailRow(context, 'ç»“æŸæ—¶é—´', timeFormat.format(result.endTime)),
        _buildDetailRow(context, 'æ€»è€—æ—¶', durationText),
        if (result.skippedRecords > 0)
          _buildDetailRow(context, 'è·³è¿‡è®°å½•', '${result.skippedRecords} æ?),
      ],
    );
  }

  Widget _buildDetailRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Row(
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Text(
            value,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  String _formatDuration(Duration duration) {
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    final seconds = duration.inSeconds % 60;
    
    if (hours > 0) {
      return '$hours å°æ—¶ $minutes åˆ?$seconds ç§?;
    } else if (minutes > 0) {
      return '$minutes åˆ?$seconds ç§?;
    } else {
      return '$seconds ç§?;
    }
  }

  String _getTableDisplayName(String tableName) {
    const tableNames = {
      'product': 'äº§å“',
      'category': 'åˆ†ç±»',
      'unit': 'å•ä½',
      'unit_product': 'äº§å“å•ä½',
      'shop': 'åº—é“º',
      'supplier': 'ä¾›åº”å•?,
      'customers': 'å®¢æˆ·',
      'product_batch': 'äº§å“æ‰¹æ¬¡',
      'stock': 'åº“å­˜',
      'inventory_transaction': 'åº“å­˜äº¤æ˜“',
      'locations': 'è´§ä½',
      'inbound_receipt': 'å…¥åº“å?,
      'inbound_item': 'å…¥åº“æ˜ç»†',
      'outbound_receipt': 'å‡ºåº“å?,
      'outbound_item': 'å‡ºåº“æ˜ç»†',
      'purchase_order': 'é‡‡è´­å?,
      'purchase_order_item': 'é‡‡è´­æ˜ç»†',
      'sales_transaction': 'é”€å”®äº¤æ˜?,
      'sales_transaction_item': 'é”€å”®æ˜ç»?,
      'barcode': 'æ¡ç ',
    };
    return tableNames[tableName] ?? tableName;
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../../product/application/category_notifier.dart';
import '../../../product/data/repository/product_unit_repository.dart';
import '../../../product/data/repository/unit_repository.dart';
import '../../../../core/utils/snackbar_helper.dart';
import '../../../../core/widgets/cached_image_widget.dart';
import '../../../../core/widgets/full_screen_image_viewer.dart';

/// æ•°æ®åº“å±•ç¤ºå±å¹?
/// æ˜¾ç¤ºæ•°æ®åº“ä¸­æ‰€æœ‰è¡¨çš„æ•°æ?
class DatabaseViewerScreen extends ConsumerStatefulWidget {
  const DatabaseViewerScreen({super.key});

  @override
  ConsumerState<DatabaseViewerScreen> createState() =>
      _DatabaseViewerScreenState();
}

class _DatabaseViewerScreenState extends ConsumerState<DatabaseViewerScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this); // åˆå§‹åŠ è½½æ•°æ®
    Future.microtask(() {
      ref.read(allProductsProvider);
      ref.read(categoryListProvider.notifier).loadCategories();
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('æ•°æ®åº“æŸ¥çœ‹å™¨'),
        // ç§»é™¤è‡ªå®šä¹‰leadingï¼Œè®©go_routerè‡ªåŠ¨å¤„ç†æ‰‹åŠ¿è¿”å›
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _refreshData,
            tooltip: 'åˆ·æ–°æ•°æ®',
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.inventory), text: 'äº§å“'),
            Tab(icon: Icon(Icons.category), text: 'ç±»åˆ«'),
            Tab(icon: Icon(Icons.straighten), text: 'å•ä½'),
            Tab(icon: Icon(Icons.link), text: 'äº§å“å•ä½'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildProductsTab(),
          _buildCategoriesTab(),
          _buildUnitsTab(),
          _buildProductUnitsTab(),
        ],
      ),
    );
  }

  /// åˆ·æ–°æ‰€æœ‰æ•°æ?
  void _refreshData() {
    // åˆ·æ–°äº§å“æ•°æ®
    ref.invalidate(allProductsProvider);
    // åˆ·æ–°ç±»åˆ«æ•°æ®
    ref.read(categoryListProvider.notifier).loadCategories();

    // æ˜¾ç¤ºåˆ·æ–°æç¤º
    showAppSnackBar(context, message: 'æ•°æ®å·²åˆ·æ–?);
  }

  /// æ„å»ºäº§å“æ•°æ®é¡µé¢
  Widget _buildProductsTab() {
    return Consumer(
      builder: (context, ref, child) {
        final productsAsyncValue = ref.watch(allProductsProvider);

        return productsAsyncValue.when(
          data: (products) {
            if (products.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.inventory_2_outlined,
                      size: 64,
                      color: Colors.grey,
                    ),
                    SizedBox(height: 16),
                    Text('æš‚æ— äº§å“æ•°æ®'),
                  ],
                ),
              );
            }

            return ListView.builder(
              itemCount: products.length,
              itemBuilder: (context, index) {
                final product = products[index];
                return Card(
                  margin: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 4,
                  ),
                  child: ListTile(
                    leading: product.image != null && product.image!.isNotEmpty
                        ? _buildCachedCircleAvatar(product.image!, index + 1)
                        : CircleAvatar(child: Text('${index + 1}')),
                    title: Text(product.name),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('ID: ${product.id}'),
                        // æ¡ç ä¿¡æ¯å·²ç§»é™¤ï¼Œç°åœ¨æ¡ç å­˜å‚¨åœ¨ç‹¬ç«‹çš„æ¡ç è¡¨ä¸­
                        if (product.sku != null) Text('SKU: ${product.sku}'),
                        if (product.categoryId != null)
                          Text('ç±»åˆ«ID: ${product.categoryId}'),
                        if (product.retailPrice != null)
                          Text('é›¶å”®ä»? ${product.retailPrice!.format()}'),
                        Text('çŠ¶æ€? ${product.status}')
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            );
          },
          loading: () => const Center(child: CircularProgressIndicator()),
          error: (error, stackTrace) => Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 64, color: Colors.red),
                const SizedBox(height: 16),
                Text('åŠ è½½äº§å“æ•°æ®å¤±è´¥: $error'),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => ref.invalidate(allProductsProvider),
                  child: const Text('é‡è¯•'),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  /// æ„å»ºç±»åˆ«æ•°æ®é¡µé¢
  Widget _buildCategoriesTab() {
    return Consumer(
      builder: (context, ref, child) {
        final categoriesState = ref.watch(categoryListProvider);

        if (categoriesState.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }

        if (categoriesState.error != null) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 64, color: Colors.red),
                const SizedBox(height: 16),
                Text('åŠ è½½ç±»åˆ«æ•°æ®å¤±è´¥: ${categoriesState.error}'),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(categoryListProvider.notifier).loadCategories(),
                  child: const Text('é‡è¯•'),
                ),
              ],
            ),
          );
        }

        final categories = categoriesState.categories;

        if (categories.isEmpty) {
          return const Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.category_outlined, size: 64, color: Colors.grey),
                SizedBox(height: 16),
                Text('æš‚æ— ç±»åˆ«æ•°æ®'),
              ],
            ),
          );
        }

        return ListView.builder(
          itemCount: categories.length,
          itemBuilder: (context, index) {
            final category = categories[index];
            return Card(
              margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
              child: ListTile(
                leading: CircleAvatar(child: Text('${index + 1}')),
                title: Text(category.name),
                subtitle: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('ID: ${category.id}'),
                    if (category.parentId != null)
                      Text('çˆ¶ç±»åˆ«ID: ${category.parentId}')
                    else
                      const Text('æ ¹ç±»åˆ?),
                  ],
                ),
                trailing: Icon(
                  category.parentId == null
                      ? Icons.folder
                      : Icons.subdirectory_arrow_right,
                  color: category.parentId == null ? Colors.blue : Colors.grey,
                ),
              ),
            );
          },
        );
      },
    );
  }

  /// æ„å»ºå•ä½æ•°æ®é¡µé¢
  Widget _buildUnitsTab() {
    return Consumer(
      builder: (context, ref, child) {
        final unitRepository = ref.watch(unitRepositoryProvider);

        return FutureBuilder(
          future: unitRepository.getAllUnits(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }

            if (snapshot.hasError) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.error_outline, size: 64, color: Colors.red),
                    const SizedBox(height: 16),
                    Text('åŠ è½½å•ä½æ•°æ®å¤±è´¥: ${snapshot.error}'),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _refreshData,
                      child: const Text('é‡è¯•'),
                    ),
                  ],
                ),
              );
            }

            final units = snapshot.data ?? [];

            if (units.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.straighten_outlined, size: 64, color: Colors.grey),
                    SizedBox(height: 16),
                    Text('æš‚æ— å•ä½æ•°æ®'),
                  ],
                ),
              );
            }

            return ListView.builder(
              itemCount: units.length,
              itemBuilder: (context, index) {
                final unit = units[index];
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                  child: ListTile(
                    leading: CircleAvatar(child: Text('${index + 1}')),
                    title: Text(unit.name),
                    subtitle: Text('ID: ${unit.id}'),
                  ),
                );
              },
            );
          },
        );
      },
    );
  }

  /// æ„å»ºäº§å“å•ä½æ•°æ®é¡µé¢
  Widget _buildProductUnitsTab() {
    return Consumer(
      builder: (context, ref, child) {
        final repo = ref.watch(productUnitRepositoryProvider);

        return FutureBuilder(
          future: repo.getAllProductUnits(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }

            if (snapshot.hasError) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.error_outline, size: 64, color: Colors.red),
                    const SizedBox(height: 16),
                    Text('åŠ è½½äº§å“å•ä½æ•°æ®å¤±è´¥: ${snapshot.error}'),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _refreshData,
                      child: const Text('é‡è¯•'),
                    ),
                  ],
                ),
              );
            }

            final productUnits = snapshot.data ?? [];

            if (productUnits.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.link_off, size: 64, color: Colors.grey),
                    SizedBox(height: 16),
                    Text('æš‚æ— äº§å“å•ä½æ•°æ®'),
                  ],
                ),
              );
            }

            return ListView.builder(
              itemCount: productUnits.length,
              itemBuilder: (context, index) {
                final pu = productUnits[index];
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                  child: ListTile(
                    leading: CircleAvatar(child: Text('${index + 1}')),
                    title: Text('äº§å“ID: ${pu.productId}'),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('äº§å“å•ä½ID: ${pu.id ?? '-'}'),
                        Text('å•ä½ID: ${pu.unitId}'),
                        Text('æ¢ç®—ç? ${pu.conversionRate}'),
                        if (pu.sellingPriceInCents != null)
                          Text('å”®ä»·(åˆ?: ${pu.sellingPriceInCents}'),
                        if (pu.wholesalePriceInCents != null)
                          Text('æ‰¹å‘ä»?åˆ?: ${pu.wholesalePriceInCents}'),
                      ],
                    ),
                  ),
                );
              },
            );
          },
        );
      },
    );
  }

  Widget _buildCachedCircleAvatar(String imagePath, int index) {
    return GestureDetector(
      onTap: () => _showFullScreenImage(context, imagePath),
      child: Hero(
        tag: 'db_viewer_image_$imagePath',
        child: ClipOval(
          child: CachedImageWidget(
            imagePath: imagePath,
            width: 40,
            height: 40,
            fit: BoxFit.cover,
          ),
        ),
      ),
    );
  }

  /// æ˜¾ç¤ºå…¨å±å›¾ç‰‡æŸ¥çœ‹å™?
  void _showFullScreenImage(BuildContext context, String imagePath) {
    Navigator.of(context).push(
      PageRouteBuilder(
        pageBuilder: (context, animation, secondaryAnimation) =>
            FullScreenImageViewer(
              imagePath: imagePath,
              heroTag: 'db_viewer_image_$imagePath',
            ),
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          return FadeTransition(opacity: animation, child: child);
        },
        transitionDuration: const Duration(milliseconds: 300),
        reverseTransitionDuration: const Duration(milliseconds: 200),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../core/database/database_providers.dart';
import '../../../core/database/database.dart';
import '../../../core/utils/snackbar_helper.dart';
import '../../../core/constants/app_routes.dart';

/// æ•°æ®åº“ç®¡ç†å¼€å‘å·¥å…?
/// ä»…åœ¨å¼€å‘æ¨¡å¼ä¸‹ä½¿ç”¨
class DatabaseManagementScreen extends ConsumerWidget {
  const DatabaseManagementScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('æ•°æ®åº“ç®¡ç?),
        backgroundColor: Colors.orange.shade400,
        leading: IconButton(
          onPressed: () => context.go(AppRoutes.home),
          icon: const Icon(Icons.arrow_back),
          tooltip: 'è¿”å›é¦–é¡µ',
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 16),

            // åˆå§‹åŒ–æ“ä½?
            Text('åˆå§‹åŒ–æ“ä½?, style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),

            ElevatedButton.icon(
              onPressed: () => _initializeDatabase(ref, context),
              icon: const Icon(Icons.refresh),
              label: const Text('é‡æ–°åˆå§‹åŒ–æ‰€æœ‰é»˜è®¤æ•°æ?),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue.shade600,
                foregroundColor: Colors.white,
              ),
            ),

            const SizedBox(height: 8),

            ElevatedButton.icon(
              onPressed: () => _resetDatabase(ref, context),
              icon: const Icon(Icons.delete_forever),
              label: const Text('æ¸…ç©ºå¹¶é‡ç½®æ•°æ®åº“'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red.shade600,
                foregroundColor: Colors.white,
              ),
            ),

            const SizedBox(height: 24),

            // æ•°æ®æŸ¥çœ‹
            Text('æ•°æ®æŸ¥çœ‹', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),

            _buildDataViewButtons(context, ref),

            const Spacer(),

            // è­¦å‘Šæ–‡æœ¬
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.orange.shade50,
                border: Border.all(color: Colors.orange.shade300),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(Icons.warning, color: Colors.orange.shade600),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'âš ï¸ æ­¤é¡µé¢ä»…ä¾›å¼€å‘ä½¿ç”¨ï¼Œç”Ÿäº§ç¯å¢ƒè¯·å‹¿ä½¿ç”¨',
                      style: TextStyle(color: Colors.orange.shade800),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDataViewButtons(BuildContext context, WidgetRef ref) {
    return Column(
      children: [
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showShopsData(context, ref),
                child: const Text('æŸ¥çœ‹åº—é“º'),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showCategoriesData(context, ref),
                child: const Text('æŸ¥çœ‹ç±»åˆ«'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showUnitsData(context, ref),
                child: const Text('æŸ¥çœ‹å•ä½'),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showProductsData(context, ref),
                child: const Text('æŸ¥çœ‹äº§å“'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showSuppliersData(context, ref),
                child: const Text('æŸ¥çœ‹ä¾›åº”å•?),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showPurchasesData(context, ref),
                child: const Text('æŸ¥çœ‹é‡‡è´­'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showBarcodesData(context, ref),
                child: const Text('æŸ¥çœ‹æ¡ç '),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showBatchesData(context, ref),
                child: const Text('æŸ¥çœ‹æ‰¹æ¬¡'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showSalesTransactionsData(context, ref),
                child: const Text('æŸ¥çœ‹é”€å”®äº¤æ˜?),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showCustomersData(context, ref),
                child: const Text('æŸ¥çœ‹å®¢æˆ·'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showSalesTransactionItemsData(context, ref),
                child: const Text('æŸ¥çœ‹é”€å”®äº¤æ˜“é¡¹'),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showStockData(context, ref),
                child: const Text('æŸ¥çœ‹åº“å­˜'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showOutboundReceiptsData(context, ref),
                child: const Text('æŸ¥çœ‹å‡ºåº“å?),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: () => _showProductUnitsData(context, ref),
                child: const Text('æŸ¥çœ‹äº§å“å•ä½'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Future<void> _showOutboundReceiptsData(
    BuildContext context,
    WidgetRef ref,
  ) async {
    try {
      final database = ref.read(appDatabaseProvider);
      final outboundReceipts = await database
          .select(database.outboundReceipt)
          .get();

      if (context.mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('å‡ºåº“å•æ•°æ?(${outboundReceipts.length} æ?'),
            content: SizedBox(
              width: double.maxFinite,
              height: 500, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: outboundReceipts.length,
                itemBuilder: (context, index) {
                  final outboundReceipt = outboundReceipts[index];
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 4),
                    child: ListTile(
                      title: Text('å‡ºåº“å•å·: ${outboundReceipt.id}'),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('åº—é“ºID: ${outboundReceipt.shopId}'),
                          Text('åŸå› : ${outboundReceipt.reason}'),
                          if (outboundReceipt.salesTransactionId != null)
                            Text(
                              'é”€å”®å•ID: ${outboundReceipt.salesTransactionId}',
                            ),
                          Text(
                            'åˆ›å»ºæ—¶é—´: ${outboundReceipt.createdAt.toString().substring(0, 16)}',
                          ),
                        ],
                      ),
                      isThreeLine: true,
                    ),
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('å…³é—­'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      print('æŸ¥è¯¢å‡ºåº“å•æ•°æ®æ—¶å‡ºé”™: $e');
      if (context.mounted) {
        showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
      }
    }
  }

  Future<void> _initializeDatabase(WidgetRef ref, BuildContext context) async {
    try {
      await ref.read(databaseInitializationProvider.future);
      if (context.mounted) {
        showAppSnackBar(context, message: 'âœ?æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');
      }
    } catch (e) {
      if (context.mounted) {
        showAppSnackBar(context, message: 'â?åˆå§‹åŒ–å¤±è´? $e', isError: true);
      }
    }
  }

  Future<void> _resetDatabase(WidgetRef ref, BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤é‡ç½®'),
        content: const Text('æ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®å¹¶é‡æ–°åˆå§‹åŒ–ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      try {
        await ref.read(resetDatabaseProvider(true).future);
        if (context.mounted) {
          showAppSnackBar(context, message: 'âœ?æ•°æ®åº“é‡ç½®å®Œæˆ?);
        }
      } catch (e) {
        if (context.mounted) {
          showAppSnackBar(context, message: 'â?é‡ç½®å¤±è´¥: $e', isError: true);
        }
      }
    }
  }

  Future<void> _showShopsData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final shops = await database.select(database.shop).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('åº—é“ºæ•°æ® (${shops.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: shops.length,
              itemBuilder: (context, index) {
                final shop = shops[index];
                return ListTile(
                  title: Text(shop.name),
                  subtitle: Text('ç»ç†: ${shop.manager}'),
                  // trailing: Text(shop.id),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showCategoriesData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final categories = await database.select(database.category).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('ç±»åˆ«æ•°æ® (${categories.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: categories.length,
              itemBuilder: (context, index) {
                final category = categories[index];
                return ListTile(
                  title: Text(category.name),
                  trailing: Text(category.id.toString()),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showUnitsData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final units = await database.select(database.unit).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('å•ä½æ•°æ® (${units.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: units.length,
              itemBuilder: (context, index) {
                final unit = units[index];
                return ListTile(
                  title: Text(unit.name),
                  trailing: Text(unit.id.toString()),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showProductsData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final products = await database.select(database.product).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('äº§å“æ•°æ® (${products.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: products.length,
              itemBuilder: (context, index) {
                final product = products[index];
                return ListTile(
                  title: Text(product.name),
                  subtitle: Text('çŠ¶æ€? ${product.status}'),
                  trailing: Text(product.id.toString()),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showSuppliersData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final suppliers = await database.select(database.supplier).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('ä¾›åº”å•†æ•°æ?(${suppliers.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: suppliers.length,
              itemBuilder: (context, index) {
                final supplier = suppliers[index];
                return ListTile(
                  title: Text(supplier.name),
                  subtitle: Text(
                    'åˆ›å»ºæ—¶é—´: ${supplier.createdAt.toString().substring(0, 16)}',
                  ),
                  trailing: Text(supplier.id.toString()),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showPurchasesData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final purchases = await database.select(database.purchaseOrder).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('é‡‡è´­æ•°æ® (${purchases.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            height: 400, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: purchases.length,
              itemBuilder: (context, index) {
                final purchase = purchases[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text('é‡‡è´­å•å·: ${purchase.id}'),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('ä¾›åº”å•†ID: ${purchase.supplierId}'),
                        Text('åº—é“ºID: ${purchase.shopId}'),
                        Text(
                          'é‡‡è´­æ—¥æœŸ: ${purchase.createdAt.toString().substring(0, 16)}',
                        ),
                        Text('çŠ¶æ€? ${purchase.status}'),
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showBarcodesData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final barcodes = await database.select(database.barcode).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('æ¡ç æ•°æ® (${barcodes.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            height: 400, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: barcodes.length,
              itemBuilder: (context, index) {
                final barcode = barcodes[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text('æ¡ç : ${barcode.barcodeValue}'),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('æ¡ç ID: ${barcode.id}'),
                        Text('äº§å“å•ä½ID: ${barcode.id}'),
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showBatchesData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final batches = await database.select(database.productBatch).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('æ‰¹æ¬¡æ•°æ® (${batches.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            height: 400,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: batches.length,
              itemBuilder: (context, index) {
                final batch = batches[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text('æ‰¹æ¬¡å? ${batch.id}'),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('äº§å“ID: ${batch.productId}'),
                        Text(
                          'totalInboundQuantity: ${batch.totalInboundQuantity}',
                        ),
                        Text(
                          'ç”Ÿäº§æ—¥æœŸ: ${batch.productionDate.toString().substring(0, 10)}',
                        ),
                        Text('åº—é“ºID: ${batch.shopId}'),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showSalesTransactionsData(
    BuildContext context,
    WidgetRef ref,
  ) async {
    final database = ref.read(appDatabaseProvider);
    final salesTransactions = await database
        .select(database.salesTransaction)
        .get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('é”€å”®äº¤æ˜“æ•°æ?(${salesTransactions.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            height: 500, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: salesTransactions.length,
              itemBuilder: (context, index) {
                final salesTransaction = salesTransactions[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text('é”€å”®è®¢å•å·: ${salesTransaction.id}'),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('å®¢æˆ·ID: ${salesTransaction.customerId}'),
                        Text('åº—é“ºID: ${salesTransaction.shopId}'),
                        Text(
                          'æ€»é‡‘é¢? Â¥${salesTransaction.totalAmount.toStringAsFixed(2)}',
                        ),
                        Text(
                          'å®é™…é‡‘é¢: Â¥${salesTransaction.actualAmount.toStringAsFixed(2)}',
                        ),
                        Text('çŠ¶æ€? ${salesTransaction.status}'),
                        if (salesTransaction.remarks != null &&
                            salesTransaction.remarks!.isNotEmpty)
                          Text('å¤‡æ³¨: ${salesTransaction.remarks}'),
                        Text(
                          'åˆ›å»ºæ—¶é—´: ${salesTransaction.createdAt.toString().substring(0, 16)}',
                        ),
                        Text(
                          'æ›´æ–°æ—¶é—´: ${salesTransaction.updatedAt.toString().substring(0, 16)}',
                        ),
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showCustomersData(BuildContext context, WidgetRef ref) async {
    final database = ref.read(appDatabaseProvider);
    final customers = await database.select(database.customers).get();

    if (context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('å®¢æˆ·æ•°æ® (${customers.length} æ?'),
          content: SizedBox(
            width: double.maxFinite,
            height: 400, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: customers.length,
              itemBuilder: (context, index) {
                final customer = customers[index];
                return Card(
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    title: Text(customer.name),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('ID: ${customer.id}'),
                        Text('å®¢æˆ·åç§°: ${customer.name}'),
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('å…³é—­'),
            ),
          ],
        ),
      );
    }
  }

  Future<void> _showSalesTransactionItemsData(
    BuildContext context,
    WidgetRef ref,
  ) async {
    try {
      final database = ref.read(appDatabaseProvider);
      final salesTransactionItems = await database
          .select(database.salesTransactionItem)
          .get();

      // æ·»åŠ è°ƒè¯•æ—¥å¿—
      print('é”€å”®äº¤æ˜“é¡¹æ•°æ®æŸ¥è¯¢ç»“æœ: ${salesTransactionItems.length} æ¡è®°å½?);

      if (context.mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('é”€å”®äº¤æ˜“é¡¹æ•°æ® (${salesTransactionItems.length} æ?'),
            content: SizedBox(
              width: double.maxFinite,
              height: 500, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: salesTransactionItems.length,
                itemBuilder: (context, index) {
                  final salesTransactionItem = salesTransactionItems[index];
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 4),
                    child: ListTile(
                      title: Text(
                        'é”€å”®äº¤æ˜“ID: ${salesTransactionItem.salesTransactionId}',
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('äº§å“ID: ${salesTransactionItem.productId}'),
                          Text('æ•°é‡: ${salesTransactionItem.quantity}'),
                          Text('ä»·æ ¼(åˆ?: ${salesTransactionItem.priceInCents}'),
                          Text('æ‰¹æ¬¡ID: ${salesTransactionItem.batchId ?? 'æ—?}'),
                        ],
                      ),
                      isThreeLine: true,
                    ),
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('å…³é—­'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      print('æŸ¥è¯¢é”€å”®äº¤æ˜“é¡¹æ•°æ®æ—¶å‡ºé”? $e');
      if (context.mounted) {
        showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
      }
    }
  }

  Future<void> _showStockData(BuildContext context, WidgetRef ref) async {
    try {
      final database = ref.read(appDatabaseProvider);
      final stockItems = await database.select(database.stock).get();

      if (context.mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('åº“å­˜æ•°æ® (${stockItems.length} æ?'),
            content: SizedBox(
              width: double.maxFinite,
              height: 500, // è®¾ç½®å›ºå®šé«˜åº¦ä»¥ä¾¿æ»šåŠ¨
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: stockItems.length,
                itemBuilder: (context, index) {
                  final stock = stockItems[index];
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 4),
                    child: ListTile(
                      title: Text('äº§å“ID: ${stock.productId}'),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('æ‰¹æ¬¡ID: ${stock.batchId ?? 'æ—?}'),
                          Text('æ•°é‡: ${stock.quantity}'),
                          Text('åº—é“ºID: ${stock.shopId}'),
                        ],
                      ),
                      isThreeLine: true,
                    ),
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('å…³é—­'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      print('æŸ¥è¯¢åº“å­˜æ•°æ®æ—¶å‡ºé”? $e');
      if (context.mounted) {
        showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
      }
    }
  }

  Future<void> _showProductUnitsData(
    BuildContext context,
    WidgetRef ref,
  ) async {
    try {
      final database = ref.read(appDatabaseProvider);
      final productUnits = await database.select(database.unitProduct).get();

      if (context.mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('äº§å“å•ä½æ•°æ® (${productUnits.length} æ?'),
            content: SizedBox(
              width: double.maxFinite,
              height: 500,
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: productUnits.length,
                itemBuilder: (context, index) {
                  final productUnit = productUnits[index];
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 4),
                    child: ListTile(
                      title: Text('ID: ${productUnit.id}'),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('äº§å“ID: ${productUnit.productId}'),
                          Text('å•ä½ID: ${productUnit.unitId}'),
                          Text('æ¢ç®—ç? ${productUnit.conversionRate}'),
                          if (productUnit.sellingPriceInCents != null)
                            Text(
                              'å”®ä»·: Â¥${(productUnit.sellingPriceInCents! / 100).toStringAsFixed(2)}',
                            ),
                          if (productUnit.wholesalePriceInCents != null)
                            Text(
                              'æ‰¹å‘ä»? Â¥${(productUnit.wholesalePriceInCents! / 100).toStringAsFixed(2)}',
                            ),
                          Text(
                            'æ›´æ–°æ—¶é—´: ${productUnit.lastUpdated.toString().substring(0, 16)}',
                          ),
                        ],
                      ),
                      isThreeLine: true,
                    ),
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('å…³é—­'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      print('æŸ¥è¯¢äº§å“å•ä½æ•°æ®æ—¶å‡ºé”? $e');
      if (context.mounted) {
        showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
      }
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../config/flavor_config.dart';
import '../../../../core/constants/app_routes.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  // Removed unused method _scanAndShowProductDialog - functionality may be implemented elsewhere

  // éšç§å¼¹çª—å·²ç”± AppInitializer ç»Ÿä¸€å¤„ç†ï¼Œè¿™é‡Œä¸å†é‡å¤å¤„ç†ã€?

  @override
  Widget build(BuildContext context) {
    final ref = this.ref;
    final flavorConfig = ref.watch(flavorConfigProvider);
    return Scaffold(
      appBar: AppBar(title: const Text('é“ºå¾—æ¸?- é¦–é¡µ')),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 20),
            const Text(
              'æ¬¢è¿ä½¿ç”¨ é“ºå¾—æ¸?åº“å­˜ç®¡ç†ç³»ç»Ÿ',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 40),
            const Text(
              'è¯·é€‰æ‹©åŠŸèƒ½æ¨¡å—',
              textAlign: TextAlign.center,
              style: TextStyle(fontSize: 16),
            ),
            const SizedBox(height: 20),
            Expanded(
              child: GridView.count(
                crossAxisCount: 2,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 2.8,
                children: [
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.products),
                    child: const Text('äº§å“ç®¡ç†'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.productNew),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.teal,
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('æ–°å¢è´§å“'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.productRanking),
                    child: const Text('äº§å“æ’è¡Œ'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.inventory),
                    child: const Text('åº“å­˜ç®¡ç†'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.inboundCreate),
                    child: const Text('æ–°å»ºå…¥åº“å?),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.purchase),
                    child: const Text('é‡‡è´­ç®¡ç†'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.sales),
                    child: const Text('é”€å”®ç®¡ç?),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.saleCreate),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.green,
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('æ”¶é“¶å?),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.customers),
                    child: const Text('å®¢æˆ·ç®¡ç†'),
                  ),
                  ElevatedButton(
                    onPressed: () => context.push(AppRoutes.settings),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.grey.shade600,
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('è®¾ç½®'),
                  ),
                  if (flavorConfig.featureFlags[Feature.showDatabaseTools] == true) ...[
                    ElevatedButton(
                      onPressed: () =>
                          context.push(AppRoutes.databaseManagement),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.orange.shade600,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('æ•°æ®åº“ç®¡ç?),
                    ),
                    ElevatedButton(
                      onPressed: () =>
                          context.push(AppRoutes.databaseViewer),
                      child: const Text('æ•°æ®åº“æŸ¥çœ‹å™¨'),
                    ),
                  ],
                  // ElevatedButton(
                  //   onPressed: () =>
                  //       context.push(AppRoutes.categoryTest),
                  //   child: const Text('ç±»åˆ«ç®¡ç†æµ‹è¯•'),
                  // ),
                ],
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }
}
// Inbound Feature Barrel File
export 'domain/model/models.dart';
export 'presentation/screens/screens.dart';
export 'presentation/widgets/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../product/domain/model/product.dart';

/// Represents an item in the inbound list UI.
/// This is a view model that combines data from Product, Unit,
/// and the temporary inbound state.
class InboundItemState {
  /// A unique identifier for the item in the UI list, generated on the client.
  final String id;
  final int productId;
  final String productName;
  final int unitId;
  final String unitName;
  final int quantity;
  final int unitPriceInCents;
  final int conversionRate; // æ–°å¢ï¼šå•ä½æ¢ç®—ç‡
  final DateTime? productionDate;
  final String? barcode;

  InboundItemState({
    required this.id,
    required this.productId,
    required this.productName,
    required this.unitId,
    required this.unitName,
    required this.quantity,
    required this.unitPriceInCents,
    required this.conversionRate, // æ–°å¢
    this.productionDate,
    this.barcode,
  });

  /// Total amount for this item line, in cents.
  int get amountInCents => quantity * unitPriceInCents;

  /// The total quantity in the base unit.
  // int get totalBaseQuantity => quantity * conversionRate;
  int get totalBaseQuantity => quantity;

  InboundItemState copyWith({
    String? id,
    int? productId,
    String? productName,
    int? unitId,
    String? unitName,
    int? quantity,
    int? unitPriceInCents,
    int? conversionRate, // æ–°å¢
    DateTime? productionDate,
    String? barcode,
    bool clearProductionDate = false,
  }) {
    return InboundItemState(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      productName: productName ?? this.productName,
      unitId: unitId ?? this.unitId,
      unitName: unitName ?? this.unitName,
      quantity: quantity ?? this.quantity,
      unitPriceInCents: unitPriceInCents ?? this.unitPriceInCents,
      conversionRate: conversionRate ?? this.conversionRate, // æ–°å¢
      productionDate:
          clearProductionDate ? null : productionDate ?? this.productionDate,
      barcode: barcode ?? this.barcode,
    );
  }
}

/// å…¥åº“åˆ—è¡¨çŠ¶æ€é€šçŸ¥å™?
///
/// ç®¡ç†å…¥åº“é¡¹åˆ—è¡¨çš„çŠ¶æ€ï¼Œå¹¶æä¾›å¢ã€åˆ ã€æ”¹ã€æŸ¥ç­‰æ“ä½œã€?
class InboundListNotifier extends StateNotifier<List<InboundItemState>> {
  InboundListNotifier() : super([]);

  /// æ·»åŠ å•ä¸ªå…¥åº“é¡¹åˆ°åˆ—è¡¨å¤´éƒ¨
  void addItem(InboundItemState item) {
    state = [item, ...state];
  }

  /// æ·»åŠ å¤šä¸ªå…¥åº“é¡¹åˆ°åˆ—è¡¨å¤´éƒ¨
  void addAllItems(List<InboundItemState> items) {
    state = [...items.reversed, ...state];
  }

  /// æ ¹æ®IDç§»é™¤å…¥åº“é¡?
  void removeItem(String itemId) {
    state = state.where((item) => item.id != itemId).toList();
  }

  /// æ›´æ–°æŒ‡å®šçš„å…¥åº“é¡¹
  void updateItem(InboundItemState updatedItem) {
    state = [
      for (final item in state)
        if (item.id == updatedItem.id) updatedItem else item,
    ];
  }

  /// æ·»åŠ ä¸€ä¸ªæ–°è´§å“ï¼Œæˆ–å¦‚æœå·²å­˜åœ¨åˆ™æ›´æ–°å…¶æ•°é‡?
  /// åˆå¹¶ç­–ç•¥ï¼šä¼˜å…ˆæŒ‰æ¡ç åŒ¹é…ï¼Œå¦‚æœæ²¡æœ‰æ¡ç æˆ–æ¡ç ä¸åŒ¹é…ï¼Œåˆ™æŒ‰äº§å“ID+å•ä½IDåŒ¹é…
  void addOrUpdateItem({
    required ProductModel product,
    required int unitId,
    String? unitName,
    required int conversionRate,
    String? barcode,
    int? wholesalePriceInCents,
    int quantity = 1,
  }) {
    int existingItemIndex = -1;
    
    // ä¼˜å…ˆæŒ‰æ¡ç åŒ¹é…ï¼ˆå¦‚æœæä¾›äº†æ¡ç ï¼‰
    if (barcode != null && barcode.isNotEmpty) {
      existingItemIndex = state.indexWhere((item) => item.barcode == barcode);
    }
    
    // å¦‚æœæŒ‰æ¡ç æ²¡æ‰¾åˆ°ï¼Œåˆ™æŒ‰äº§å“ID+å•ä½IDåŒ¹é…
    if (existingItemIndex == -1) {
      existingItemIndex = state.indexWhere((item) =>
          item.productId == product.id && item.unitId == unitId);
    }

    if (existingItemIndex != -1) {
      final existingItem = state[existingItemIndex];
      final updatedItem = existingItem.copyWith(
        quantity: existingItem.quantity + quantity,
      );
      updateItem(updatedItem);
    } else {
      final itemId =
          'item_${product.id}_${unitId}_${DateTime.now().millisecondsSinceEpoch}';
      final newItem = InboundItemState(
        id: itemId,
        productId: product.id!,
        productName: product.name,
        unitId: unitId,
        unitName: unitName ?? 'æœªçŸ¥å•ä½',
        quantity: quantity,
        unitPriceInCents: wholesalePriceInCents ?? 0,
        conversionRate: conversionRate,
        barcode: barcode,
        productionDate: product.enableBatchManagement
            ? DateTime.now().subtract(const Duration(days: 90))
            : null,
      );
      addItem(newItem);
    }
  }

  /// æ¸…ç©ºæ•´ä¸ªåˆ—è¡¨
  void clear() {
    state = [];
  }
}

/// å…¥åº“åˆ—è¡¨Provider
///
/// è¿™æ˜¯UIå±‚è®¿é—?[InboundListNotifier] çš„å…¥å£ã€?
final inboundListProvider =
    StateNotifierProvider<InboundListNotifier, List<InboundItemState>>(
  (ref) => InboundListNotifier(),
);

/// å…¥åº“ç»Ÿè®¡ä¿¡æ¯Provider
///
/// æ´¾ç”Ÿè‡?[inboundListProvider]ï¼Œç”¨äºé«˜æ•ˆè®¡ç®—æ€»è®¡ä¿¡æ¯ã€?
/// UIå¯ä»¥åªç›‘å¬è¿™ä¸ªProviderï¼Œä»è€Œé¿å…åœ¨åˆ—è¡¨é¡¹å†…å®¹å˜åŒ–æ—¶è¿›è¡Œä¸å¿…è¦çš„é‡ç®—ã€?
final inboundTotalsProvider = Provider<Map<String, double>>((ref) {
  final items = ref.watch(inboundListProvider);
  // ä½¿ç”¨ `totalBaseQuantity` è®¡ç®—åŸºç¡€å•ä½æ€»æ•°
  final totalQuantity =
      items.fold(0.0, (sum, item) => sum + item.totalBaseQuantity);
  final totalAmountInCents =
      items.fold(0.0, (sum, item) => sum + item.amountInCents);
  return {
    'varieties': items.length.toDouble(),
    'quantity': totalQuantity,
    'amount': totalAmountInCents / 100.0, // å°†æ€»é‡‘é¢ä»åˆ†è½¬æ¢ä¸ºå…?
  };
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart' as drift;
import '../../../../core/database/database.dart';
import '../../../purchase/data/dao/purchase_dao.dart';
import '../../../product/data/dao/batch_dao.dart';
import '../../../inbound/data/dao/inbound_receipt_dao.dart';
import '../../../inbound/data/dao/inbound_item_dao.dart';
// import '../../../purchase/data/dao/product_supplier_dao.dart';
import '../../../inventory/application/inventory_service.dart';
import '../../../inventory/application/service/weighted_average_price_service.dart';
import '../../application/provider/inbound_list_provider.dart';
import '../../domain/model/inbound_item.dart';
import '../../../purchase/domain/repository/i_supplier_repository.dart';
import '../../../purchase/domain/model/supplier.dart';
import '../../../purchase/application/provider/supplier_providers.dart';
import '../../../../core/database/purchase_orders_table.dart';

/// A private record type to hold both domain model and UI-related info internally.
typedef _PurchaseItem = ({
  InboundItemModel model,
  int unitPriceInCents,
  String productName,
  String unitName,
  DateTime? productionDate
});

/// å…¥åº“æœåŠ¡
/// å¤„ç†å…¥åº“å•çš„ä¸šåŠ¡é€»è¾‘
class InboundService {
  final AppDatabase _database;
  final PurchaseDao _purchaseDao;
  final BatchDao _batchDao;
  final InboundReceiptDao _inboundReceiptDao;
  final InboundItemDao _inboundItemDao;
  // final ProductSupplierDao _productSupplierDao;
  final InventoryService _inventoryService;
  final WeightedAveragePriceService _weightedAveragePriceService;
  final ISupplierRepository _supplierRepository;

  InboundService(
    this._database,
    this._inventoryService,
    this._weightedAveragePriceService,
    this._supplierRepository,
  ) : _purchaseDao = _database.purchaseDao,
      _batchDao = _database.batchDao,
      _inboundReceiptDao = _database.inboundReceiptDao,
      _inboundItemDao = _database.inboundItemDao;
      // _productSupplierDao = _database.productSupplierDao;

  /// ä¸€é”®å…¥åº?
  /// 1. å¦‚æœæ˜¯é‡‡è´­æ¨¡å¼ï¼Œæ£€æŸ¥å¹¶åˆ›å»ºä¾›åº”å•†ã€åˆ›å»ºé‡‡è´­å•ã€å†™å…¥è´§å“ä¾›åº”å•†å…³è”
  /// 2. å†™å…¥æ‰¹æ¬¡è¡?
  /// 3. å†™å…¥å…¥åº“å•è¡¨ã€å…¥åº“å•æ˜ç»†è¡?
  /// 4. æ›´æ–°åº“å­˜
  Future<String> processOneClickInbound({
    required int shopId,
    required List<InboundItemState> inboundItems,
    required String source,
    required bool isPurchaseMode,
  int? supplierId,
    String? supplierName,
    String? remarks,
  }) async {
    print('ğŸš€ å¼€å§‹æ‰§è¡Œä¸€é”®å…¥åº“æµç¨?..');
    print('ğŸ“¦ æ¨¡å¼: ${isPurchaseMode ? "é‡‡è´­" : "éé‡‡è´?}');
    print('ğŸª åº—é“ºID: $shopId');
    print('ğŸ“¦ å•†å“æ•°é‡: ${inboundItems.length}');
    print('â„¹ï¸ æ¥æº: $source');

    return await _database.transaction(() async {
      int? purchaseOrderId;
      String? id;

      // 1. å°†UIçŠ¶æ€æ¨¡å‹è½¬æ¢ä¸ºå†…éƒ¨å¤„ç†ç”¨çš„å…ƒç»„åˆ—è¡¨
      final internalItems = await Future.wait(inboundItems.map((item) async {
        final domainModel = InboundItemModel(
          // UIä¸Šçš„idæ˜¯ä¸´æ—¶çš„ï¼Œæ•°æ®åº“ä¸­ä¼šè‡ªå¢ï¼Œæ­¤å¤„ä¸ä¼?
          productId: item.productId,
          
          quantity: item.quantity,
          // batchNumberå’ŒreceiptIdåœ¨åç»­æµç¨‹ä¸­ç¡®å®š
        );
        return (
          model: domainModel,
          unitPriceInCents: item.unitPriceInCents,
          productName: item.productName,
          unitName: item.unitName,
          productionDate: item.productionDate
        );
      }).toList());

      if (isPurchaseMode) {
        // --- é‡‡è´­æ¨¡å¼ä¸‹çš„ç‰¹å®šé€»è¾‘ ---
        // å…è®¸ä»…æä¾›åç§°æ—¶è‡ªåŠ¨åˆ›å»ºä¾›åº”å•?
        final actualSupplierId =
            await _ensureSupplierExists(supplierId, supplierName);
        print('âœ?ç¡®è®¤ä¾›åº”å•†ID: $actualSupplierId');

        final purchaseOrderData = await _createPurchaseOrder(
          supplierId: actualSupplierId,
          shopId: shopId,
          purchaseItems: internalItems,
        );
        purchaseOrderId = purchaseOrderData.orderId;
        id = purchaseOrderData.orderNumber;
        print('âœ?é‡‡è´­è®¢å•åˆ›å»ºå®Œæˆï¼ŒID: $purchaseOrderId');

        // await _writeProductSupplierRecords(
        //   supplierId: actualSupplierId,
        //   purchaseItems: internalItems,
        // );
      }

      // --- é€šç”¨é€»è¾‘ ---
      await _writeBatchRecords(shopId: shopId, inboundItems: internalItems);

      final receiptNumber = await _writeInboundRecords(
        shopId: shopId,
        inboundItems: internalItems,
        purchaseOrderId: purchaseOrderId,
        id: id,
        remarks: remarks,
        source: source,
      );

      await _writeInventoryRecords(shopId: shopId, inboundItems: internalItems);

      print('ğŸ‰ ä¸€é”®å…¥åº“æµç¨‹æ‰§è¡Œå®Œæˆï¼å…¥åº“å•å·: $receiptNumber');
      return receiptNumber;
    });
  }

  /// åˆ›å»ºé‡‡è´­è®¢å•ï¼ˆåŒ…æ‹¬è®¢å•å¤´å’Œæ‰€æœ‰æ˜ç»†ï¼‰
  Future<({int orderId, String orderNumber})> _createPurchaseOrder({
    required int supplierId,
    required int shopId,
    required List<_PurchaseItem> purchaseItems,
  }) async {
    // ç”Ÿæˆé‡‡è´­å•å·
    final purchaseNumber = 'PO${DateTime.now().millisecondsSinceEpoch}';

    // å‡†å¤‡è®¢å•å¤?
    final orderCompanion = PurchaseOrderCompanion(
      // id is auto-increment, so we don't set it.
      supplierId: drift.Value(supplierId),
      shopId: drift.Value(shopId),
      status: drift.Value(PurchaseOrderStatus.completed),
    );

    // å‡†å¤‡è®¢å•æ˜ç»†åˆ—è¡¨
    final itemCompanions = <PurchaseOrderItemCompanion>[];
    for (final item in purchaseItems) {
      itemCompanions.add(
        PurchaseOrderItemCompanion(
          // purchaseOrderId is set by the DAO
          productId: drift.Value(item.model.productId),
          
          quantity: drift.Value(item.model.quantity),
          unitPriceInCents: drift.Value(item.unitPriceInCents),
          productionDate: drift.Value(item.productionDate),
        ),
      );
    }

    // è°ƒç”¨DAOä¸­çš„äº‹åŠ¡æ–¹æ³•åˆ›å»ºå®Œæ•´è®¢å•
    final orderId = await _purchaseDao.createFullPurchaseOrder(
      order: orderCompanion,
      items: itemCompanions,
    );

    return (orderId: orderId, orderNumber: purchaseNumber);
  }

  /// æ ¹æ®æ¡ä»¶å†™å…¥æ‰¹æ¬¡è¡?
  Future<void> _writeBatchRecords({
    required int shopId,
    required List<_PurchaseItem> inboundItems,
  }) async {
    for (final item in inboundItems) {
      final product =
          await _database.productDao.getProductById(item.model.productId);

      if (product?.enableBatchManagement == true && item.productionDate != null) {
        await _batchDao.upsertBatchIncrement(
          productId: item.model.productId,
          productionDate: item.productionDate!,
          shopId: shopId,
          increment: item.model.quantity,
        );
        print(
          'ğŸ“¦ æ‰¹æ¬¡(å•†å“:${item.model.productId}, æ—¥æœŸ:${item.productionDate}, åº—é“º:$shopId) æ•°é‡ç´¯è®¡ +${item.model.quantity}',
        );
      }
    }
  }

  /// å†™å…¥è´§å“ä¾›åº”å•†å…³è”è¡¨
  // Future<void> _writeProductSupplierRecords({
  //   required int supplierId,
  //   required List<_PurchaseItem> purchaseItems,
  // }) async {
  //   print('ğŸ“‹ å¼€å§‹å¤„ç†è´§å“ä¾›åº”å•†å…³è”...');

  //   for (final item in purchaseItems) {
  //     try {
  //       // è·å–å•ä½ID
  //       final exists = await _productSupplierDao.existsProductSupplierWithUnit(
  //         item.model.productId,
  //         supplierId,
  //       );

  //       if (exists) {
  //         final existingRelations =
  //             await _productSupplierDao.getSuppliersByProductIdAndUnitId(
  //                 item.model.productId, item.model.unitId);

  //         if (existingRelations.isNotEmpty) {
  //           final existingRelation = existingRelations.firstWhere(
  //             (relation) => relation.supplierId == supplierId,
  //             orElse: () => existingRelations.first,
  //           );

  //           if (existingRelation.supplyPrice != item.unitPriceInCents) {
  //             final updatedRelation = existingRelation.copyWith(
  //               supplyPrice: drift.Value(item.unitPriceInCents.toDouble()),
  //               updatedAt: DateTime.now(),
  //             );
  //             await _productSupplierDao.updateProductSupplier(updatedRelation);
  //             print(
  //               'ğŸ“ æ›´æ–° ${item.productName}(${item.unitName}) çš„ä¾›è´§ä»·æ ? ${item.unitPriceInCents}',
  //             );
  //           } else {
  //             print(
  //                 'âœ?${item.productName}(${item.unitName}) çš„ä¾›åº”å•†å…³è”å·²å­˜åœ¨ï¼Œæ— éœ€æ›´æ–°');
  //           }
  //         }
  //       } else {
  //         final relationId =
  //             '${item.model.productId}_${supplierId}_${item.model.unitId}_${DateTime.now().millisecondsSinceEpoch}';

  //         final companion = ProductSuppliersTableCompanion.insert(
  //           id: relationId,
  //           productId: item.model.productId,
  //           supplierId: supplierId,
  //           supplierProductName: drift.Value(item.productName),
  //           supplyPrice: drift.Value(item.unitPriceInCents.toDouble()),
  //           isPrimary: const drift.Value(false),
  //           status: const drift.Value('active'),
  //           remarks: const drift.Value('é€šè¿‡é‡‡è´­å•è‡ªåŠ¨åˆ›å»?),
  //         );

  //         await _productSupplierDao.insertProductSupplier(companion);
  //         print(
  //           'âœ?æ–°å»ºè´§å“ä¾›åº”å•†å…³è? ${item.productName}(${item.unitName}) - $supplierId',
  //         );
  //       }
  //     } catch (e) {
  //       print('â?å¤„ç† ${item.productName} çš„ä¾›åº”å•†å…³è”å¤±è´¥: $e');
  //       // ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œç»§ç»­å¤„ç†å…¶ä»–å•†å“
  //     }
  //   }

  //   print('ğŸ“‹ è´§å“ä¾›åº”å•†å…³è”å¤„ç†å®Œæˆ?);
  // }

  /// å†™å…¥å…¥åº“å•è¡¨ã€å…¥åº“å•æ˜ç»†è¡?
  Future<String> _writeInboundRecords({
    required int shopId,
    required List<_PurchaseItem> inboundItems,
    required String source,
    int? purchaseOrderId,
    String? id,
    String? remarks,
  }) async {
    // final now = DateTime.now();

    // åˆ›å»ºå…¥åº“å•ä¸»è®°å½•
  // è‹¥ä¸Šæ¸¸æœªç”Ÿæˆå•å·ï¼Œå¯ä½¿ç”¨ receiptId ä½œä¸ºè¿”å›æ ‡è¯†
  String? receiptNumber = id;

    final receipt = InboundReceiptCompanion(
      // id is auto-incrementing
      status: const drift.Value('completed'), // ä¸€é”®å…¥åº“ç›´æ¥å®Œæˆ?
      remarks: drift.Value(remarks),
      shopId: drift.Value(shopId),
      source: drift.Value(source),
    );

    final receiptId = await _inboundReceiptDao.insertInboundReceipt(receipt);
    print('âœ?å…¥åº“å•åˆ›å»ºå®Œæˆ? $receiptId'); // åˆ›å»ºå…¥åº“å•æ˜ç»†è®°å½?
    final itemCompanions = <InboundItemCompanion>[];

    for (final item in inboundItems) {
      final product =
          await _database.productDao.getProductById(item.model.productId);

      int? resolvedBatchNumber;
      if (item.productionDate != null &&
          product?.enableBatchManagement == true) {
  final batchIdOnly = await _batchDao.getBatchIdByBusinessKey(
          productId: item.model.productId,
          productionDate: item.productionDate!,
          shopId: shopId,
        );
  resolvedBatchNumber = batchIdOnly;
      }

      final itemCompanion = InboundItemCompanion(
        // id åœ¨æ•°æ®åº“ä¸­è‡ªå¢ï¼Œæ­¤å¤„ä¸éœ€è¦æä¾?
        receiptId: drift.Value(receiptId),
        productId: drift.Value(item.model.productId),
        quantity: drift.Value(item.model.quantity),
        // æ­£ç¡®å†™å…¥æ‰¹æ¬¡åˆ—åˆ° batchIdï¼Œè€Œä¸æ˜¯è¯¯å†™åˆ°ä¸»é”® id
        batchId: resolvedBatchNumber != null
          ? drift.Value(resolvedBatchNumber)
          : const drift.Value.absent(),
      );
      itemCompanions.add(itemCompanion);
    }

    await _inboundItemDao.insertMultipleInboundItems(itemCompanions);
    print('âœ?å…¥åº“æ˜ç»†åˆ›å»ºå®Œæˆï¼Œå…± ${itemCompanions.length} æ?);

  // å¦‚æœæ²¡æœ‰ä¼ å…¥å•å·ï¼Œåˆ™ç”¨æ•°æ®åº“ç”Ÿæˆçš?receiptId ä½œä¸ºå›ä¼ ç¼–å·
  return (receiptNumber ?? receiptId.toString());
  }

  /// é—´æ¥å†™å…¥æµæ°´è¡¨ã€åº“å­˜è¡¨
  Future<void> _writeInventoryRecords({
    required int shopId,
    required List<_PurchaseItem> inboundItems,
  }) async {
    for (final item in inboundItems) {
      final product =
          await _database.productDao.getProductById(item.model.productId);

      int? batchId;
      if (product?.enableBatchManagement == true &&
          item.productionDate != null) {
  final batchIdOnly = await _batchDao.getBatchIdByBusinessKey(
          productId: item.model.productId,
          productionDate: item.productionDate!,
          shopId: shopId,
        );
  batchId = batchIdOnly;
      }

      // å…ˆæ›´æ–°åº“å­˜æ•°é‡å’Œè®°å½•æµæ°´
      final success = await _inventoryService.inbound(
        productId: item.model.productId,
        shopId: shopId,
        batchId: batchId,
        quantity: item.model.quantity,
        time: DateTime.now(),
      );

      if (!success) {
        throw Exception('å•†å“ ${item.productName} åº“å­˜æ›´æ–°å¤±è´¥');
      }

      // å†æ›´æ–°ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼ï¼ˆæ­¤æ—¶åº“å­˜è®°å½•å·²å­˜åœ¨ï¼‰
      await _weightedAveragePriceService.updateWeightedAveragePrice(
        productId: item.model.productId,
        shopId: shopId,
        batchId: batchId,
        inboundQuantity: item.model.quantity,
        inboundUnitPriceInCents: item.unitPriceInCents,
      );

      print('âœ?å•†å“ ${item.productName} åº“å­˜å’Œç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼æ›´æ–°å®Œæˆ?);
    }
  }

  /// ç¡®ä¿ä¾›åº”å•†å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
  Future<int> _ensureSupplierExists(
    int? supplierId,
    String? supplierName,
  ) async {
    // 1) è‹¥æä¾›äº† IDï¼Œä¼˜å…ˆç”¨ ID æ ¡éªŒ
    if (supplierId != null) {
      final existingSupplier = await _supplierRepository.getSupplierById(
        supplierId,
      );
      if (existingSupplier != null) {
        print('âœ?ä¾›åº”å•†å·²å­˜åœ¨: ${existingSupplier.name}');
        return supplierId;
      }
      // è‹?ID ä¸å­˜åœ¨ï¼Œåˆ™å°è¯•ç”¨åç§°å¤„ç†
    }

    // 2) è‹¥æ— æœ‰æ•ˆ IDï¼Œåˆ™å¿…é¡»æœ‰åç§?
    if (supplierName == null || supplierName.trim().isEmpty) {
      throw Exception('é‡‡è´­æ¨¡å¼ä¸‹éœ€è¦æä¾›ä¾›åº”å•†åç§°ï¼Œæˆ–é€‰æ‹©ä¸€ä¸ªå·²æœ‰ä¾›åº”å•†');
    }

    // 3) åç§°å·²å­˜åœ¨åˆ™å¤ç”¨
    final supplierByName = await _supplierRepository.getSupplierByName(
      supplierName,
    );
    if (supplierByName != null) {
      print('âœ?æ‰¾åˆ°é‡åä¾›åº”å•†ï¼Œä½¿ç”¨ç°æœ‰ä¾›åº”å•? ${supplierByName.name}');
      return supplierByName.id!;
    }

    // 4) å¦åˆ™åˆ›å»ºæ–°ä¾›åº”å•†
    final newSupplier = Supplier(name: supplierName.trim());

    try {
      final newId = await _supplierRepository.addSupplier(newSupplier);
      print('âœ?è‡ªåŠ¨åˆ›å»ºæ–°ä¾›åº”å•†: ${newSupplier.name} (ID: $newId)');
      return newId;
    } catch (e) {
      print('â?åˆ›å»ºä¾›åº”å•†å¤±è´? $e');
      throw Exception('åˆ›å»ºä¾›åº”å•†å¤±è´? $e');
    }
  }
}

/// å…¥åº“æœåŠ¡æä¾›è€?
final inboundServiceProvider = Provider<InboundService>((ref) {
  final database = ref.watch(appDatabaseProvider);
  final inventoryService = ref.watch(inventoryServiceProvider);
  final weightedAveragePriceService = ref.watch(weightedAveragePriceServiceProvider);
  final supplierRepository = ref.watch(supplierRepositoryProvider);
  return InboundService(database, inventoryService, weightedAveragePriceService, supplierRepository);
});
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/inbound_receipt_items_table.dart';

part 'inbound_item_dao.g.dart';

/// å…¥åº“å•æ˜ç»†æ•°æ®è®¿é—®å¯¹è±?
/// è´Ÿè´£å¤„ç†å…¥åº“å•æ˜ç»†è¡¨çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [InboundItem])
class InboundItemDao extends DatabaseAccessor<AppDatabase>
    with _$InboundItemDaoMixin {
  InboundItemDao(super.db);

  /// æ’å…¥å…¥åº“å•æ˜ç»?
  Future<int> insertInboundItem(InboundItemCompanion item) async {
    return await into(inboundItem).insert(item);
  }

  /// æ‰¹é‡æ’å…¥å…¥åº“å•æ˜ç»?
  Future<void> insertMultipleInboundItems(
    List<InboundItemCompanion> items,
  ) async {
    await batch((batch) {
      batch.insertAll(inboundItem, items);
    });
  }

  /// æ ¹æ®IDè·å–å…¥åº“å•æ˜ç»?
  Future<InboundItemData?> getInboundItemById(int id) {
    return (select(
      inboundItem,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®å…¥åº“å•IDè·å–æ‰€æœ‰æ˜ç»?
  Future<List<InboundItemData>> getInboundItemsByReceiptId(int receiptId) {
    return (select(
      inboundItem,
    )..where((t) => t.receiptId.equals(receiptId))).get();
  }

  /// ç›‘å¬å…¥åº“å•æ˜ç»†å˜åŒ?
  Stream<List<InboundItemData>> watchInboundItemsByReceiptId(int receiptId) {
    return (select(
      inboundItem,
    )..where((t) => t.receiptId.equals(receiptId))).watch();
  }

  /// æ›´æ–°å…¥åº“å•æ˜ç»?
  Future<bool> updateInboundItem(InboundItemCompanion item) async {
    final result = await (update(
      inboundItem,
    )..where((t) => t.id.equals(item.id.value))).write(item);
    return result > 0;
  }

  /// åˆ é™¤å…¥åº“å•æ˜ç»?
  Future<int> deleteInboundItem(int id) {
    return (delete(inboundItem)..where((t) => t.id.equals(id))).go();
  }

  /// åˆ é™¤å…¥åº“å•çš„æ‰€æœ‰æ˜ç»?
  Future<int> deleteInboundItemsByReceiptId(int receiptId) {
    return (delete(
      inboundItem,
    )..where((t) => t.receiptId.equals(receiptId))).go();
  }

  /// æ ¹æ®å•†å“IDè·å–å…¥åº“æ˜ç»†
  Future<List<InboundItemData>> getInboundItemsByProductId(int productId) {
    return (select(
      inboundItem,
    )..where((t) => t.productId.equals(productId))).get();
  }

  /// æ ¹æ®æ‰¹æ¬¡å·è·å–å…¥åº“æ˜ç»?
  Future<List<InboundItemData>> getInboundItemsByBatchNumber(int id) {
    return (select(
      inboundItem,
    )..where((t) => t.id.equals(id))).get();
  }

  /// è·å–å…¥åº“å•æ˜ç»†æ€»æ•°
  Future<int> getInboundItemCount(int receiptId) async {
    final result =
        await (selectOnly(inboundItem)
              ..where(inboundItem.receiptId.equals(receiptId))
              ..addColumns([inboundItem.id.count()]))
            .getSingle();
    return result.read(inboundItem.id.count()) ?? 0;
  }

  /// è·å–å…¥åº“å•æ€»æ•°é‡?
  Future<double> getInboundTotalQuantity(int receiptId) async {
    final result =
        await (selectOnly(inboundItem)
              ..where(inboundItem.receiptId.equals(receiptId))
              ..addColumns([inboundItem.quantity.sum().cast<double>()]))
            .getSingle();
    return result.read(inboundItem.quantity.sum().cast<double>()) ?? 0.0;
  }

  /// æ›¿æ¢å…¥åº“å•æ˜ç»†ï¼ˆåˆ é™¤æ—§çš„ï¼Œæ’å…¥æ–°çš„ï¼‰
  Future<void> replaceInboundItems(
    int receiptId,
    List<InboundItemCompanion> items,
  ) async {
    await transaction(() async {
      // åˆ é™¤ç°æœ‰æ˜ç»†
      await deleteInboundItemsByReceiptId(receiptId);
      // æ’å…¥æ–°æ˜ç»?
      if (items.isNotEmpty) {
        await insertMultipleInboundItems(items);
      }
    });
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inbound_item_dao.dart';

// ignore_for_file: type=lint
mixin _$InboundItemDaoMixin on DatabaseAccessor<AppDatabase> {
  $ShopTable get shop => attachedDatabase.shop;
  $SupplierTable get supplier => attachedDatabase.supplier;
  $PurchaseOrderTable get purchaseOrder => attachedDatabase.purchaseOrder;
  $InboundReceiptTable get inboundReceipt => attachedDatabase.inboundReceipt;
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $InboundItemTable get inboundItem => attachedDatabase.inboundItem;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/inbound_receipts_table.dart';

part 'inbound_receipt_dao.g.dart';

/// å…¥åº“å•æ•°æ®è®¿é—®å¯¹è±?
/// è´Ÿè´£å¤„ç†å…¥åº“å•è¡¨çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [InboundReceipt])
class InboundReceiptDao extends DatabaseAccessor<AppDatabase>
    with _$InboundReceiptDaoMixin {
  InboundReceiptDao(super.db);

  /// æ’å…¥å…¥åº“å?
  Future<int> insertInboundReceipt(InboundReceiptCompanion receipt) async {
    return await into(inboundReceipt).insert(receipt);
  }

  /// æ ¹æ®IDè·å–å…¥åº“å?
  Future<InboundReceiptData?> getInboundReceiptById(int id) {
    return (select(
      inboundReceipt,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  // /// æ ¹æ®å…¥åº“å•å·è·å–å…¥åº“å?
  // Future<InboundReceiptData?> getInboundReceiptByNumber(
  //   String receiptNumber,
  // ) {
  //   return (select(
  //     inboundReceipt,
  //   )..where((t) => t.receiptNumber.equals(receiptNumber))).getSingleOrNull();
  // }

  /// è·å–æ‰€æœ‰å…¥åº“å•
  Future<List<InboundReceiptData>> getAllInboundReceipts() {
    return select(inboundReceipt).get();
  }

  /// æ ¹æ®åº—é“ºIDè·å–å…¥åº“å?
  Future<List<InboundReceiptData>> getInboundReceiptsByShop(int shopId) {
    return (select(
      inboundReceipt,
    )..where((t) => t.shopId.equals(shopId))).get();
  }

  /// æ ¹æ®çŠ¶æ€è·å–å…¥åº“å•
  Future<List<InboundReceiptData>> getInboundReceiptsByStatus(String status) {
    return (select(
      inboundReceipt,
    )..where((t) => t.status.equals(status))).get();
  }

  /// ç›‘å¬æ‰€æœ‰å…¥åº“å•å˜åŒ–
  Stream<List<InboundReceiptData>> watchAllInboundReceipts() {
    return select(inboundReceipt).watch();
  }

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„å…¥åº“å•å˜åŒ–
  Stream<List<InboundReceiptData>> watchInboundReceiptsByShop(int shopId) {
    return (select(
      inboundReceipt,
    )..where((t) => t.shopId.equals(shopId))).watch();
  }

  /// æ›´æ–°å…¥åº“å?
  Future<bool> updateInboundReceipt(InboundReceiptCompanion receipt) async {
    final result = await (update(
      inboundReceipt,
    )..where((t) => t.id.equals(receipt.id.value))).write(receipt);
    return result > 0;
  }

  /// åˆ é™¤å…¥åº“å?
  Future<int> deleteInboundReceipt(int id) {
    return (delete(inboundReceipt)..where((t) => t.id.equals(id))).go();
  }

  /// è·å–å…¥åº“å•æ€»æ•°
  Future<int> getInboundReceiptCount() async {
    final result = await (selectOnly(
      inboundReceipt,
    )..addColumns([inboundReceipt.id.count()])).getSingle();
    return result.read(inboundReceipt.id.count()) ?? 0;
  }

  /// æ ¹æ®æ—¥æœŸèŒƒå›´è·å–å…¥åº“å?
  Future<List<InboundReceiptData>> getInboundReceiptsByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) {
    return (select(
      inboundReceipt,
    )..where((t) => t.createdAt.isBetweenValues(startDate, endDate))).get();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inbound_receipt_dao.dart';

// ignore_for_file: type=lint
mixin _$InboundReceiptDaoMixin on DatabaseAccessor<AppDatabase> {
  $ShopTable get shop => attachedDatabase.shop;
  $SupplierTable get supplier => attachedDatabase.supplier;
  $PurchaseOrderTable get purchaseOrder => attachedDatabase.purchaseOrder;
  $InboundReceiptTable get inboundReceipt => attachedDatabase.inboundReceipt;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/locations_table.dart';

part 'location_dao.g.dart';

/// è´§ä½æ•°æ®è®¿é—®å¯¹è±¡
/// è´Ÿè´£å¤„ç†è´§ä½è¡¨çš„æ•°æ®åº“æ“ä½?
@DriftAccessor(tables: [LocationsTable])
class LocationDao extends DatabaseAccessor<AppDatabase>
    with _$LocationDaoMixin {
  LocationDao(super.db);

  /// æ’å…¥è´§ä½
  Future<int> insertLocation(LocationsTableCompanion location) async {
    return await into(locationsTable).insert(location);
  }

  /// æ ¹æ®IDè·å–è´§ä½
  Future<LocationsTableData?> getLocationById(String id) {
    return (select(
      locationsTable,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®ç¼–ç è·å–è´§ä½
  Future<LocationsTableData?> getLocationByCode(String code, int shopId) {
    return (select(locationsTable)
          ..where((t) => t.code.equals(code) & t.shopId.equals(shopId)))
        .getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰è´§ä½?
  Future<List<LocationsTableData>> getAllLocations() {
    return select(locationsTable).get();
  }

  /// æ ¹æ®åº—é“ºIDè·å–è´§ä½
  Future<List<LocationsTableData>> getLocationsByShop(int shopId) {
    return (select(
      locationsTable,
    )..where((t) => t.shopId.equals(shopId))).get();
  }

  /// æ ¹æ®çŠ¶æ€è·å–è´§ä½?
  Future<List<LocationsTableData>> getLocationsByStatus(String status) {
    return (select(
      locationsTable,
    )..where((t) => t.status.equals(status))).get();
  }

  /// è·å–æ´»è·ƒè´§ä½
  Future<List<LocationsTableData>> getActiveLocationsByShop(int shopId) {
    return (select(
      locationsTable,
    )..where((t) => t.shopId.equals(shopId) & t.status.equals('active'))).get();
  }

  /// ç›‘å¬æ‰€æœ‰è´§ä½å˜åŒ?
  Stream<List<LocationsTableData>> watchAllLocations() {
    return select(locationsTable).watch();
  }

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„è´§ä½å˜åŒ?
  Stream<List<LocationsTableData>> watchLocationsByShop(int shopId) {
    return (select(
      locationsTable,
    )..where((t) => t.shopId.equals(shopId))).watch();
  }

  /// æ›´æ–°è´§ä½
  Future<bool> updateLocation(LocationsTableCompanion location) async {
    final result = await (update(
      locationsTable,
    )..where((t) => t.id.equals(location.id.value))).write(location);
    return result > 0;
  }

  /// åˆ é™¤è´§ä½
  Future<int> deleteLocation(String id) {
    return (delete(locationsTable)..where((t) => t.id.equals(id))).go();
  }

  /// æ£€æŸ¥è´§ä½ç¼–ç æ˜¯å¦å·²å­˜åœ¨ï¼ˆåŒä¸€åº—é“ºå†…ï¼‰
  Future<bool> isLocationCodeExists(
    String code,
    int shopId, [
    int? excludeId,
  ]) async {
    var query = select(locationsTable)
      ..where((t) => t.code.equals(code) & t.shopId.equals(shopId));

    if (excludeId != null) {
      query = query..where((t) => t.id.isNotValue(excludeId.toString()));
    }

    final result = await query.getSingleOrNull();
    return result != null;
  }

  /// æ ¹æ®åç§°æœç´¢è´§ä½
  Future<List<LocationsTableData>> searchLocationsByName(String searchTerm) {
    return (select(locationsTable)..where(
          (t) => t.name.contains(searchTerm) | t.code.contains(searchTerm),
        ))
        .get();
  }

  /// è·å–è´§ä½æ€»æ•°
  Future<int> getLocationCount() async {
    final result = await (selectOnly(
      locationsTable,
    )..addColumns([locationsTable.id.count()])).getSingle();
    return result.read(locationsTable.id.count()) ?? 0;
  }

  /// æ‰¹é‡æ’å…¥è´§ä½
  Future<void> insertMultipleLocations(
    List<LocationsTableCompanion> locations,
  ) async {
    await batch((batch) {
      batch.insertAll(locationsTable, locations);
    });
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'location_dao.dart';

// ignore_for_file: type=lint
mixin _$LocationDaoMixin on DatabaseAccessor<AppDatabase> {
  $LocationsTableTable get locationsTable => attachedDatabase.locationsTable;
}
/// å…¥åº“å•æ˜ç»?é¢†åŸŸæ¨¡å‹ï¼ˆfreezedï¼?
/// å¯¹åº”è¡? InboundItem (lib/core/database/inbound_receipt_items_table.dart)
library;
import 'package:freezed_annotation/freezed_annotation.dart';

part 'inbound_item.freezed.dart';
part 'inbound_item.g.dart';

@freezed
abstract class InboundItemModel with _$InboundItemModel {
  const InboundItemModel._();

  @Assert('quantity > 0', 'quantity must be > 0')
  const factory InboundItemModel({
    /// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
    int? id,

    /// æ‰€å±å…¥åº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼?
    int? receiptId,

    /// å•†å“IDï¼ˆå¿…å¡«ï¼‰
    required int productId,



    /// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
    int? batchId,

    /// æ•°é‡ï¼? 0ï¼?
    required int quantity,
  }) = _InboundItemModel;

  factory InboundItemModel.fromJson(Map<String, dynamic> json) =>
      _$InboundItemModelFromJson(json);

  /// ç”Ÿæˆç”¨äºåˆ¤å®šåŒä¸€å…¥åº“å•ä¸­çš„â€œå”¯ä¸€æ€§é”®â€?
  /// å”¯ä¸€æ€§ä¸è¡¨çº¦æŸä¸€è‡´ï¼š
  /// - å½?id éç©ºï¼šå”¯ä¸€é”?= (receiptId, productId, unitId, id)
  /// - å½?id ä¸ºç©ºï¼šå”¯ä¸€é”?= (receiptId, productId, unitId, null)
  String uniqueKey({int? overrideReceiptId}) {
    final rid = overrideReceiptId ?? receiptId;
    return '${rid ?? 'null'}#$productId#${id ?? 'null'}';
  }

  /// å¢åŠ æ•°é‡ï¼Œè¿”å›æ–°å®ä¾‹
  InboundItemModel increase(int delta) {
    assert(delta > 0, 'delta must be > 0');
  return copyWith(quantity: quantity + delta);
  }

  /// è®¾ç½®/å›å¡«æ‰€å±å…¥åº“å•ID
  InboundItemModel attachToReceipt(int rid) => copyWith(receiptId: rid);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inbound_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$InboundItemModel {

/// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
 int? get id;/// æ‰€å±å…¥åº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼? int? get receiptId;/// å•†å“IDï¼ˆå¿…å¡«ï¼‰
 int get productId;/// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
 int? get batchId;/// æ•°é‡ï¼? 0ï¼? int get quantity;
/// Create a copy of InboundItemModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InboundItemModelCopyWith<InboundItemModel> get copyWith => _$InboundItemModelCopyWithImpl<InboundItemModel>(this as InboundItemModel, _$identity);

  /// Serializes this InboundItemModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InboundItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.receiptId, receiptId) || other.receiptId == receiptId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,receiptId,productId,batchId,quantity);

@override
String toString() {
  return 'InboundItemModel(id: $id, receiptId: $receiptId, productId: $productId, batchId: $batchId, quantity: $quantity)';
}


}

/// @nodoc
abstract mixin class $InboundItemModelCopyWith<$Res>  {
  factory $InboundItemModelCopyWith(InboundItemModel value, $Res Function(InboundItemModel) _then) = _$InboundItemModelCopyWithImpl;
@useResult
$Res call({
 int? id, int? receiptId, int productId, int? batchId, int quantity
});




}
/// @nodoc
class _$InboundItemModelCopyWithImpl<$Res>
    implements $InboundItemModelCopyWith<$Res> {
  _$InboundItemModelCopyWithImpl(this._self, this._then);

  final InboundItemModel _self;
  final $Res Function(InboundItemModel) _then;

/// Create a copy of InboundItemModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? receiptId = freezed,Object? productId = null,Object? batchId = freezed,Object? quantity = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,receiptId: freezed == receiptId ? _self.receiptId : receiptId // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _InboundItemModel extends InboundItemModel {
  const _InboundItemModel({this.id, this.receiptId, required this.productId, this.batchId, required this.quantity}): assert(quantity > 0, 'quantity must be > 0'),super._();
  factory _InboundItemModel.fromJson(Map<String, dynamic> json) => _$InboundItemModelFromJson(json);

/// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
@override final  int? id;
/// æ‰€å±å…¥åº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼?@override final  int? receiptId;
/// å•†å“IDï¼ˆå¿…å¡«ï¼‰
@override final  int productId;
/// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
@override final  int? batchId;
/// æ•°é‡ï¼? 0ï¼?@override final  int quantity;

/// Create a copy of InboundItemModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InboundItemModelCopyWith<_InboundItemModel> get copyWith => __$InboundItemModelCopyWithImpl<_InboundItemModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InboundItemModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InboundItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.receiptId, receiptId) || other.receiptId == receiptId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,receiptId,productId,batchId,quantity);

@override
String toString() {
  return 'InboundItemModel(id: $id, receiptId: $receiptId, productId: $productId, batchId: $batchId, quantity: $quantity)';
}


}

/// @nodoc
abstract mixin class _$InboundItemModelCopyWith<$Res> implements $InboundItemModelCopyWith<$Res> {
  factory _$InboundItemModelCopyWith(_InboundItemModel value, $Res Function(_InboundItemModel) _then) = __$InboundItemModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int? receiptId, int productId, int? batchId, int quantity
});




}
/// @nodoc
class __$InboundItemModelCopyWithImpl<$Res>
    implements _$InboundItemModelCopyWith<$Res> {
  __$InboundItemModelCopyWithImpl(this._self, this._then);

  final _InboundItemModel _self;
  final $Res Function(_InboundItemModel) _then;

/// Create a copy of InboundItemModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? receiptId = freezed,Object? productId = null,Object? batchId = freezed,Object? quantity = null,}) {
  return _then(_InboundItemModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,receiptId: freezed == receiptId ? _self.receiptId : receiptId // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inbound_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_InboundItemModel _$InboundItemModelFromJson(Map<String, dynamic> json) =>
    _InboundItemModel(
      id: (json['id'] as num?)?.toInt(),
      receiptId: (json['receiptId'] as num?)?.toInt(),
      productId: (json['productId'] as num).toInt(),
      batchId: (json['batchId'] as num?)?.toInt(),
      quantity: (json['quantity'] as num).toInt(),
    );

Map<String, dynamic> _$InboundItemModelToJson(_InboundItemModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'receiptId': instance.receiptId,
      'productId': instance.productId,
      'batchId': instance.batchId,
      'quantity': instance.quantity,
    };
/// å…¥åº“å?é¢†åŸŸæ¨¡å‹ï¼ˆfreezedï¼?
/// å¯¹åº”è¡? InboundReceipt (lib/core/database/inbound_receipts_table.dart)
library;

import 'package:freezed_annotation/freezed_annotation.dart';
import 'inbound_item.dart';

part 'inbound_receipt.freezed.dart';
part 'inbound_receipt.g.dart';

@freezed
abstract class InboundReceiptModel with _$InboundReceiptModel {
  const InboundReceiptModel._();

  const factory InboundReceiptModel({
    /// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
    int? id,

    /// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
    required int shopId,

    /// æ¥æºï¼ˆå¦‚: æ‰‹å·¥ã€æ–°å»ºã€æ¥è‡ªé‡‡è´­å•ç­‰ï¼‰
    required String source,

    /// å…³è”é‡‡è´­å•IDï¼ˆå¯ç©ºï¼‰
    int? purchaseOrderId,

    /// çŠ¶æ€ï¼špreset, draft, completed
    @Default(InboundReceiptStatus.preset) String status,

    /// å¤‡æ³¨
    String? remarks,

    /// åˆ›å»º/æ›´æ–°æ—¶é—´
    required DateTime createdAt,
    required DateTime updatedAt,

    /// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼?
    @Default(<InboundItemModel>[]) List<InboundItemModel> items,
  }) = _InboundReceiptModel;

  factory InboundReceiptModel.fromJson(Map<String, dynamic> json) {
    final model = _$InboundReceiptModelFromJson(json);
    // Handle items if present in JSON
    if (json.containsKey('items') && json['items'] is List) {
      final items = _itemsFromJson(json['items'] as List);
      return model.copyWith(items: items);
    }
    return model;
  }
  
  @override
  Map<String, dynamic> toJson() {
    final json = _$InboundReceiptModelToJson(this as _InboundReceiptModel);
    json['items'] = _itemsToJson(items);
    return json;
  }

  /// çŠ¶æ€è¾…åŠ?
  bool get isPreset => status == InboundReceiptStatus.preset;
  bool get isDraft => status == InboundReceiptStatus.draft;
  bool get isCompleted => status == InboundReceiptStatus.completed;

  /// å·¥å‚æ–¹æ³•ï¼šåˆ›å»ºç©ºè‰ç¨¿
  factory InboundReceiptModel.createDraft({
    required int shopId,
    required String source,
    int? purchaseOrderId,
    DateTime? now,
  }) {
    final t = now ?? DateTime.now();
    return InboundReceiptModel(
      shopId: shopId,
      source: source,
      purchaseOrderId: purchaseOrderId,
      status: InboundReceiptStatus.preset,
      createdAt: t,
      updatedAt: t,
      items: const [],
    );
  }

  /// æ·»åŠ æˆ–åˆå¹¶æ˜ç»†ï¼ˆéµå¾ªè¡¨çš„å”¯ä¸€æ€§çº¦æŸï¼‰
  InboundReceiptModel upsertItem(InboundItemModel item) {
    final map = <String, InboundItemModel>{
      for (final it in items) it.uniqueKey(overrideReceiptId: id): it,
    };
    final key = item.uniqueKey(overrideReceiptId: id);
    if (map.containsKey(key)) {
      map[key] = map[key]!.increase(item.quantity);
    } else {
      map[key] = item;
    }
    return copyWith(items: map.values.toList(growable: false));
  }

  /// ç§»é™¤æ˜ç»†ï¼ˆæŒ‰å”¯ä¸€æ€§é”®ï¼?
  InboundReceiptModel removeItem(InboundItemModel item) {
    final key = item.uniqueKey(overrideReceiptId: id);
    final next = items
        .where((e) => e.uniqueKey(overrideReceiptId: id) != key)
        .toList();
    return copyWith(items: next);
  }

  /// æ›´æ–°æŸæ¡æ˜ç»†ï¼ˆæŒ‰å”¯ä¸€æ€§é”®å®šä½ï¼?
  InboundReceiptModel updateItem(InboundItemModel item) {
    final key = item.uniqueKey(overrideReceiptId: id);
    final next = items
        .map((e) => e.uniqueKey(overrideReceiptId: id) == key ? item : e)
        .toList();
    return copyWith(items: next);
  }

  int get totalQuantity => items.fold(0, (sum, it) => sum + it.quantity);

  @override
  String toString() =>
      'InboundReceiptModel(id: ${id?.toString() ?? 'null'}, shopId: $shopId, status: $status, items: ${items.length})';
}

/// çŠ¶æ€å¸¸é‡é›†ä¸­å®šä¹‰ï¼Œé¿å…ç¡¬ç¼–ç ?
class InboundReceiptStatus {
  static const String preset = 'preset';
  static const String draft = 'draft';
  static const String completed = 'completed';
}

/// JSON serialization helpers for items list
List<Map<String, dynamic>> _itemsToJson(List<InboundItemModel> items) {
  return items.map((item) => item.toJson()).toList();
}

List<InboundItemModel> _itemsFromJson(List<dynamic> json) {
  return json.map((item) => InboundItemModel.fromJson(item as Map<String, dynamic>)).toList();
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inbound_receipt.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$InboundReceiptModel {

/// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
 int? get id;/// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
 int get shopId;/// æ¥æºï¼ˆå¦‚: æ‰‹å·¥ã€æ–°å»ºã€æ¥è‡ªé‡‡è´­å•ç­‰ï¼‰
 String get source;/// å…³è”é‡‡è´­å•IDï¼ˆå¯ç©ºï¼‰
 int? get purchaseOrderId;/// çŠ¶æ€ï¼špreset, draft, completed
 String get status;/// å¤‡æ³¨
 String? get remarks;/// åˆ›å»º/æ›´æ–°æ—¶é—´
 DateTime get createdAt; DateTime get updatedAt;/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼?@JsonKey(toJson: _itemsToJson, fromJson: _itemsFromJson) List<InboundItemModel> get items;
/// Create a copy of InboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InboundReceiptModelCopyWith<InboundReceiptModel> get copyWith => _$InboundReceiptModelCopyWithImpl<InboundReceiptModel>(this as InboundReceiptModel, _$identity);

  /// Serializes this InboundReceiptModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InboundReceiptModel&&(identical(other.id, id) || other.id == id)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.source, source) || other.source == source)&&(identical(other.purchaseOrderId, purchaseOrderId) || other.purchaseOrderId == purchaseOrderId)&&(identical(other.status, status) || other.status == status)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt)&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,shopId,source,purchaseOrderId,status,remarks,createdAt,updatedAt,const DeepCollectionEquality().hash(items));



}

/// @nodoc
abstract mixin class $InboundReceiptModelCopyWith<$Res>  {
  factory $InboundReceiptModelCopyWith(InboundReceiptModel value, $Res Function(InboundReceiptModel) _then) = _$InboundReceiptModelCopyWithImpl;
@useResult
$Res call({
 int? id, int shopId, String source, int? purchaseOrderId, String status, String? remarks, DateTime createdAt, DateTime updatedAt,@JsonKey(toJson: _itemsToJson, fromJson: _itemsFromJson) List<InboundItemModel> items
});




}
/// @nodoc
class _$InboundReceiptModelCopyWithImpl<$Res>
    implements $InboundReceiptModelCopyWith<$Res> {
  _$InboundReceiptModelCopyWithImpl(this._self, this._then);

  final InboundReceiptModel _self;
  final $Res Function(InboundReceiptModel) _then;

/// Create a copy of InboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? shopId = null,Object? source = null,Object? purchaseOrderId = freezed,Object? status = null,Object? remarks = freezed,Object? createdAt = null,Object? updatedAt = null,Object? items = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,source: null == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String,purchaseOrderId: freezed == purchaseOrderId ? _self.purchaseOrderId : purchaseOrderId // ignore: cast_nullable_to_non_nullable
as int?,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as String,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,updatedAt: null == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<InboundItemModel>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _InboundReceiptModel extends InboundReceiptModel {
  const _InboundReceiptModel({this.id, required this.shopId, required this.source, this.purchaseOrderId, this.status = InboundReceiptStatus.preset, this.remarks, required this.createdAt, required this.updatedAt, @JsonKey(toJson: _itemsToJson, fromJson: _itemsFromJson) final  List<InboundItemModel> items = const <InboundItemModel>[]}): _items = items,super._();
  factory _InboundReceiptModel.fromJson(Map<String, dynamic> json) => _$InboundReceiptModelFromJson(json);

/// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
@override final  int? id;
/// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
@override final  int shopId;
/// æ¥æºï¼ˆå¦‚: æ‰‹å·¥ã€æ–°å»ºã€æ¥è‡ªé‡‡è´­å•ç­‰ï¼‰
@override final  String source;
/// å…³è”é‡‡è´­å•IDï¼ˆå¯ç©ºï¼‰
@override final  int? purchaseOrderId;
/// çŠ¶æ€ï¼špreset, draft, completed
@override@JsonKey() final  String status;
/// å¤‡æ³¨
@override final  String? remarks;
/// åˆ›å»º/æ›´æ–°æ—¶é—´
@override final  DateTime createdAt;
@override final  DateTime updatedAt;
/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼? final  List<InboundItemModel> _items;
/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼?@override@JsonKey(toJson: _itemsToJson, fromJson: _itemsFromJson) List<InboundItemModel> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of InboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InboundReceiptModelCopyWith<_InboundReceiptModel> get copyWith => __$InboundReceiptModelCopyWithImpl<_InboundReceiptModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InboundReceiptModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InboundReceiptModel&&(identical(other.id, id) || other.id == id)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.source, source) || other.source == source)&&(identical(other.purchaseOrderId, purchaseOrderId) || other.purchaseOrderId == purchaseOrderId)&&(identical(other.status, status) || other.status == status)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt)&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,shopId,source,purchaseOrderId,status,remarks,createdAt,updatedAt,const DeepCollectionEquality().hash(_items));



}

/// @nodoc
abstract mixin class _$InboundReceiptModelCopyWith<$Res> implements $InboundReceiptModelCopyWith<$Res> {
  factory _$InboundReceiptModelCopyWith(_InboundReceiptModel value, $Res Function(_InboundReceiptModel) _then) = __$InboundReceiptModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int shopId, String source, int? purchaseOrderId, String status, String? remarks, DateTime createdAt, DateTime updatedAt,@JsonKey(toJson: _itemsToJson, fromJson: _itemsFromJson) List<InboundItemModel> items
});




}
/// @nodoc
class __$InboundReceiptModelCopyWithImpl<$Res>
    implements _$InboundReceiptModelCopyWith<$Res> {
  __$InboundReceiptModelCopyWithImpl(this._self, this._then);

  final _InboundReceiptModel _self;
  final $Res Function(_InboundReceiptModel) _then;

/// Create a copy of InboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? shopId = null,Object? source = null,Object? purchaseOrderId = freezed,Object? status = null,Object? remarks = freezed,Object? createdAt = null,Object? updatedAt = null,Object? items = null,}) {
  return _then(_InboundReceiptModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,source: null == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String,purchaseOrderId: freezed == purchaseOrderId ? _self.purchaseOrderId : purchaseOrderId // ignore: cast_nullable_to_non_nullable
as int?,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as String,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,updatedAt: null == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<InboundItemModel>,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inbound_receipt.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_InboundReceiptModel _$InboundReceiptModelFromJson(Map<String, dynamic> json) =>
    _InboundReceiptModel(
      id: (json['id'] as num?)?.toInt(),
      shopId: (json['shopId'] as num).toInt(),
      source: json['source'] as String,
      purchaseOrderId: (json['purchaseOrderId'] as num?)?.toInt(),
      status: json['status'] as String? ?? InboundReceiptStatus.preset,
      remarks: json['remarks'] as String?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      items: json['items'] == null
          ? const <InboundItemModel>[]
          : _itemsFromJson(json['items'] as List),
    );

Map<String, dynamic> _$InboundReceiptModelToJson(
  _InboundReceiptModel instance,
) => <String, dynamic>{
  'id': instance.id,
  'shopId': instance.shopId,
  'source': instance.source,
  'purchaseOrderId': instance.purchaseOrderId,
  'status': instance.status,
  'remarks': instance.remarks,
  'createdAt': instance.createdAt.toIso8601String(),
  'updatedAt': instance.updatedAt.toIso8601String(),
  'items': _itemsToJson(instance.items),
};
/// è´§ä½é¢†åŸŸæ¨¡å‹
/// è¡¨ç¤ºä»“åº“è´§ä½ä¿¡æ¯
class Location {
  final String id;
  final String code;
  final String name;
  final String? description;
  final int shopId;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Location({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.shopId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });

  /// è´§ä½çŠ¶æ€å¸¸é‡?
  static const String statusActive = 'active';
  static const String statusInactive = 'inactive';

  /// çŠ¶æ€æ˜¾ç¤ºåç§°æ˜ å°?
  static const Map<String, String> statusNames = {
    statusActive: 'æ´»è·ƒ',
    statusInactive: 'åœç”¨',
  };

  /// è·å–çŠ¶æ€æ˜¾ç¤ºåç§?
  String get statusDisplayName => statusNames[status] ?? status;

  /// æ˜¯å¦æ´»è·ƒ
  bool get isActive => status == statusActive;

  /// æ˜¯å¦åœç”¨
  bool get isInactive => status == statusInactive;

  /// å¤åˆ¶å¹¶æ›´æ–°è´§ä½?
  Location copyWith({
    String? id,
    String? code,
    String? name,
    String? description,
    int? shopId,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Location(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      shopId: shopId ?? this.shopId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// åˆ›å»ºæ–°è´§ä½?
  factory Location.create({
    required String code,
    required String name,
    String? description,
    required int shopId,
  }) {
    final now = DateTime.now();
    // ä½¿ç”¨å¾®ç§’ã€å¯¹è±¡å“ˆå¸Œç å’Œéšæœºæ•°ç¡®ä¿IDå”¯ä¸€æ€?
    final uniqueId = 'location_${now.microsecondsSinceEpoch}_${Object().hashCode}';
    return Location(
      id: uniqueId,
      code: code,
      name: name,
      description: description,
      shopId: shopId,
      status: statusActive,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// è·å–å®Œæ•´æ˜¾ç¤ºåç§°ï¼ˆç¼–ç ?- åç§°ï¼?
  String get fullDisplayName => '$code - $name';

  @override
  String toString() => fullDisplayName;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Location && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
// Inbound Domain Model Barrel File
export 'inbound_item.dart';
export 'inbound_receipt.dart';
export 'location.dart';
import '../model/inbound_item.dart';

/// å…¥åº“å•æ˜ç»†ä»“å‚¨æ¥å?
/// å®šä¹‰å…¥åº“å•æ˜ç»†ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒƒ
abstract class IInboundItemRepository {
  /// æ·»åŠ å…¥åº“å•æ˜ç»?
  Future<int> addInboundItem(InboundItemModel item);

  /// æ‰¹é‡æ·»åŠ å…¥åº“å•æ˜ç»?
  Future<void> addMultipleInboundItems(List<InboundItemModel> items);

  /// æ ¹æ®IDè·å–å…¥åº“å•æ˜ç»?
  Future<InboundItemModel?> getInboundItemById(int id);

  /// æ ¹æ®å…¥åº“å•IDè·å–æ‰€æœ‰æ˜ç»?
  Future<List<InboundItemModel>> getInboundItemsByReceiptId(int receiptId);

  /// ç›‘å¬å…¥åº“å•æ˜ç»†å˜åŒ?
  Stream<List<InboundItemModel>> watchInboundItemsByReceiptId(int receiptId);

  /// æ›´æ–°å…¥åº“å•æ˜ç»?
  Future<bool> updateInboundItem(InboundItemModel item);

  /// åˆ é™¤å…¥åº“å•æ˜ç»?
  Future<int> deleteInboundItem(int id);

  /// åˆ é™¤å…¥åº“å•çš„æ‰€æœ‰æ˜ç»?
  Future<int> deleteInboundItemsByReceiptId(int receiptId);

  /// æ ¹æ®å•†å“IDè·å–å…¥åº“æ˜ç»†
  Future<List<InboundItemModel>> getInboundItemsByProductId(int productId);

  /// æ ¹æ®æ‰¹æ¬¡å·è·å–å…¥åº“æ˜ç»?
  Future<List<InboundItemModel>> getInboundItemsByBatchNumber(int id);

  /// æ ¹æ®è´§ä½IDè·å–å…¥åº“æ˜ç»†
  Future<List<InboundItemModel>> getInboundItemsByLocationId(String locationId);

  /// è·å–å…¥åº“å•æ˜ç»†æ€»æ•°
  Future<int> getInboundItemCount(int receiptId);

  /// è·å–å…¥åº“å•æ€»æ•°é‡?
  Future<double> getInboundTotalQuantity(int receiptId);

  /// æ›¿æ¢å…¥åº“å•æ˜ç»†ï¼ˆåˆ é™¤æ—§çš„ï¼Œæ’å…¥æ–°çš„ï¼‰
  Future<void> replaceInboundItems(int receiptId, List<InboundItemModel> items);
}
import '../model/inbound_receipt.dart';

/// å…¥åº“å•ä»“å‚¨æ¥å?
/// å®šä¹‰å…¥åº“å•ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒƒ
abstract class IInboundReceiptRepository {
  /// æ·»åŠ å…¥åº“å?
  Future<int> addInboundReceipt(InboundReceiptModel receipt);

  /// æ ¹æ®IDè·å–å…¥åº“å?
  Future<InboundReceiptModel?> getInboundReceiptById(int id);

  /// æ ¹æ®å…¥åº“å•å·è·å–å…¥åº“å?
  Future<InboundReceiptModel?> getInboundReceiptByNumber(String receiptNumber);

  /// è·å–æ‰€æœ‰å…¥åº“å•
  Future<List<InboundReceiptModel>> getAllInboundReceipts();

  /// æ ¹æ®åº—é“ºIDè·å–å…¥åº“å?
  Future<List<InboundReceiptModel>> getInboundReceiptsByShop(int shopId);

  /// æ ¹æ®çŠ¶æ€è·å–å…¥åº“å•
  Future<List<InboundReceiptModel>> getInboundReceiptsByStatus(String status);

  /// ç›‘å¬æ‰€æœ‰å…¥åº“å•å˜åŒ–
  Stream<List<InboundReceiptModel>> watchAllInboundReceipts();

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„å…¥åº“å•å˜åŒ–
  Stream<List<InboundReceiptModel>> watchInboundReceiptsByShop(int shopId);

  /// æ›´æ–°å…¥åº“å?
  Future<bool> updateInboundReceipt(InboundReceiptModel receipt);

  /// åˆ é™¤å…¥åº“å?
  Future<int> deleteInboundReceipt(int id);

  /// ç”Ÿæˆæ–°çš„å…¥åº“å•å·
  Future<String> generateReceiptNumber(DateTime date);

  /// æ£€æŸ¥å…¥åº“å•å·æ˜¯å¦å·²å­˜åœ¨
  Future<bool> isReceiptNumberExists(String receiptNumber);

  /// è·å–å…¥åº“å•æ€»æ•°
  Future<int> getInboundReceiptCount();

  /// æ ¹æ®æ—¥æœŸèŒƒå›´è·å–å…¥åº“å?
  Future<List<InboundReceiptModel>> getInboundReceiptsByDateRange(
    DateTime startDate,
    DateTime endDate,
  );
}
import '../model/location.dart';

/// è´§ä½ä»“å‚¨æ¥å£
/// å®šä¹‰è´§ä½ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class ILocationRepository {
  /// æ·»åŠ è´§ä½
  Future<int> addLocation(Location location);

  /// æ ¹æ®IDè·å–è´§ä½
  Future<Location?> getLocationById(String id);

  /// æ ¹æ®ç¼–ç è·å–è´§ä½
  Future<Location?> getLocationByCode(String code, int shopId);

  /// è·å–æ‰€æœ‰è´§ä½?
  Future<List<Location>> getAllLocations();

  /// æ ¹æ®åº—é“ºIDè·å–è´§ä½
  Future<List<Location>> getLocationsByShop(int shopId);

  /// æ ¹æ®çŠ¶æ€è·å–è´§ä½?
  Future<List<Location>> getLocationsByStatus(String status);

  /// è·å–æ´»è·ƒè´§ä½
  Future<List<Location>> getActiveLocationsByShop(int shopId);

  /// ç›‘å¬æ‰€æœ‰è´§ä½å˜åŒ?
  Stream<List<Location>> watchAllLocations();

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„è´§ä½å˜åŒ?
  Stream<List<Location>> watchLocationsByShop(int shopId);

  /// æ›´æ–°è´§ä½
  Future<bool> updateLocation(Location location);

  /// åˆ é™¤è´§ä½
  Future<int> deleteLocation(String id);

  /// æ£€æŸ¥è´§ä½ç¼–ç æ˜¯å¦å·²å­˜åœ¨ï¼ˆåŒä¸€åº—é“ºå†…ï¼‰
  Future<bool> isLocationCodeExists(
    String code,
    int shopId, [
    int? excludeId,
  ]);

  /// æ ¹æ®åç§°æœç´¢è´§ä½
  Future<List<Location>> searchLocationsByName(String searchTerm);

  /// è·å–è´§ä½æ€»æ•°
  Future<int> getLocationCount();

  /// æ‰¹é‡æ·»åŠ è´§ä½
  Future<void> addMultipleLocations(List<Location> locations);
}
import 'dart:async';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:collection/collection.dart'; // å¯¼å…¥ collection åŒ?
import '../../../product/domain/model/product.dart';
import '../../../../core/constants/app_routes.dart';
import '../../application/provider/inbound_list_provider.dart';
import '../../../purchase/application/provider/supplier_providers.dart';
import '../../application/service/inbound_service.dart';
import '../../../purchase/domain/model/supplier.dart';
import '../../../inventory/application/provider/shop_providers.dart';
import '../../../inventory/domain/model/shop.dart';
import '../../../inventory/presentation/providers/inbound_records_provider.dart';
import '../../../inventory/presentation/providers/inventory_query_providers.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../../product/presentation/screens/product_selection_screen.dart';
import '../widgets/inbound_item_card.dart';
import '../../../../core/utils/snackbar_helper.dart';
import '../../../../core/utils/sound_helper.dart';
import '../../../../core/widgets/universal_barcode_scanner.dart';
import '../../../../core/models/scanned_product_payload.dart';
import '../../../../core/widgets/custom_date_picker.dart';

enum InboundMode { purchase, nonPurchase }

/// æ–°å»ºå…¥åº“å•é¡µé?
class CreateInboundScreen extends ConsumerStatefulWidget {
  final ScannedProductPayload? payload;
  const CreateInboundScreen({super.key, this.payload});

  @override
  ConsumerState<CreateInboundScreen> createState() =>
      _CreateInboundScreenState();
}

class _CreateInboundScreenState extends ConsumerState<CreateInboundScreen> {
  final _remarksController = TextEditingController();
  final _supplierController = TextEditingController();
  final _sourceController = TextEditingController(); // ä¸?æ¥æº'æ–°å¢Controller

  InboundMode _currentMode = InboundMode.purchase; // é»˜è®¤æ˜¯é‡‡è´­æ¨¡å¼?
  Supplier? _selectedSupplier;
  Shop? _selectedShop;
  bool _isProcessing = false;
  String? _lastScannedBarcode;

  final FocusNode _shopFocusNode = FocusNode();
  final FocusNode _supplierFocusNode = FocusNode();
  final List<FocusNode> _quantityFocusNodes = [];
  final List<FocusNode> _amountFocusNodes = [];

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(inboundListProvider.notifier).clear();
      // æ¥æ”¶æ¥è‡ªé¦–é¡µæˆ–å…¶ä»–é¡µé¢çš„æ‰«ç è´§å“ï¼Œè‡ªåŠ¨æ·»åŠ åˆ°å…¥åº“æ¸…å•
      final p = widget.payload;
      if (p != null) {
        try {
          ref
              .read(inboundListProvider.notifier)
              .addOrUpdateItem(
                product: p.product,
                unitId: p.unitId,
                unitName: p.unitName,
                conversionRate: p.conversionRate,
                barcode: p.barcode,
                wholesalePriceInCents: p.wholesalePriceInCents,
              );
          // å¯é€‰ï¼šæç¤ºå·²æ·»åŠ?
          // showAppSnackBar(context, message: 'å·²æ·»åŠ ï¼š${p.product.name}');
        } catch (_) {}
      }
    });
  }

  @override
  void dispose() {
    _remarksController.dispose();
    _supplierController.dispose();
    _sourceController.dispose();
    _shopFocusNode.dispose();
    _supplierFocusNode.dispose();
    for (var node in _quantityFocusNodes) {
      node.dispose();
    }
    for (var node in _amountFocusNodes) {
      node.dispose();
    }
    super.dispose();
  }

  void _ensureFocusNodes(int itemCount) {
    while (_quantityFocusNodes.length < itemCount) {
      _quantityFocusNodes.add(FocusNode());
    }
    while (_amountFocusNodes.length < itemCount) {
      _amountFocusNodes.add(FocusNode());
    }
  }

  Future<void> _handleNextStep(int index) async {
    final inboundItems = ref.read(inboundListProvider);
    if (index >= inboundItems.length) return;

    final item = inboundItems[index];
    final productAsync = ref.read(productByIdProvider(item.productId));

    productAsync.when(
      data: (product) async {
        if (product?.enableBatchManagement == true) {
          _amountFocusNodes[index].unfocus();
          final pickedDate = await _selectProductionDate(item);
          if (pickedDate != null) {
            final updatedItem = item.copyWith(productionDate: pickedDate);
            ref.read(inboundListProvider.notifier).updateItem(updatedItem);
          }
        }
        _moveToNextQuantity(index);
      },
      loading: () => _moveToNextQuantity(index),
      error: (_, __) => _moveToNextQuantity(index),
    );
  }

  void _moveToNextQuantity(int index) {
    final itemCount = ref.read(inboundListProvider).length;
    if (index + 1 < itemCount) {
      _quantityFocusNodes[index + 1].requestFocus();
    }
  }

  Future<DateTime?> _selectProductionDate(InboundItemState item) async {
    return await CustomDatePicker.show(
      context: context,
      initialDate: item.productionDate ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      title: 'é€‰æ‹©ç”Ÿäº§æ—¥æœŸ',
    );
  }

  void _addManualProduct() async {
    final result = await Navigator.of(context).push<List<dynamic>>(
      MaterialPageRoute(builder: (context) => const ProductSelectionScreen()),
    );

    // å¦‚æœæ²¡æœ‰è¿”å›ç»“æœæˆ–ç»“æœä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›?
    if (result == null || result.isEmpty) return;

    try {
      // æ ¸å¿ƒä¿®å¤ï¼?
      // ä½¿ç”¨ `ref.read(provider.future)` æ¥å¼‚æ­¥ç­‰å¾…æ•°æ®åŠ è½½å®Œæˆã€?
      // è¿™å¯ä»¥ç¡®ä¿æ— è®?`allProductsWithUnitProvider` æ˜¯å¦å·²ç¼“å­˜æ•°æ®ï¼Œ
      // æˆ‘ä»¬éƒ½èƒ½åœ¨è·å–åˆ°æ•°æ®åå†æ‰§è¡Œåç»­é€»è¾‘ï¼Œä»è€Œä¿®å¤é¦–æ¬¡åŠ è½½æ—¶æ•°æ®æœªå°±ç»ªçš„bugã€?
      final List<
        ({
          ProductModel product,
          int unitId,
          String unitName,
          int conversionRate,
          int? sellingPriceInCents,
          int? wholesalePriceInCents,
        })
      >
      productsWithUnit = await ref.read(allProductsWithUnitProvider.future);

      final selectedProducts = productsWithUnit
          .where((p) => result.contains(p.product.id))
          .toList();

      for (final p in selectedProducts) {
        ref
            .read(inboundListProvider.notifier)
            .addOrUpdateItem(
              product: p.product,
              unitId: p.unitId,
              unitName: p.unitName,
              conversionRate: p.conversionRate,
              wholesalePriceInCents: p.wholesalePriceInCents,
            );
      }
    } catch (e) {
      // æ•è·å¹¶å¤„ç†å¯èƒ½çš„å¼‚å¸¸
      if (!mounted) return;
      showAppSnackBar(
        context,
        message: 'æ·»åŠ è´§å“å¤±è´¥: ${e.toString()}',
        isError: true,
      );
    }
  }

  void _scanToAddProduct() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => Scaffold(
          body: SafeArea(
            child: UniversalBarcodeScanner(
              config: const BarcodeScannerConfig(
                title: 'æ‰«ç æ·»åŠ è´§å“',
                subtitle: 'æ‰«æè´§å“æ¡ç ä»¥æ·»åŠ å…¥åº“å•',
              ),
              onBarcodeScanned: _handleSingleProductScan,
            ),
          ),
        ),
      ),
    );
  }

  void _continuousScan() {
    _lastScannedBarcode = null; // é‡ç½®ä¸Šæ¬¡æ‰«æçš„æ¡ç ?
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => Scaffold(
          body: SafeArea(
            child: UniversalBarcodeScanner(
              config: const BarcodeScannerConfig(
                title: 'è¿ç»­æ‰«ç ',
                subtitle: 'å°†æ¡ç å¯¹å‡†æ‰«ææ¡†ï¼Œè‡ªåŠ¨è¿ç»­æ·»åŠ?,
                continuousMode: true, // å¯ç”¨è¿ç»­æ‰«ç æ¨¡å¼
                continuousDelay: 1500, // è®¾ç½®æ‰«ç é—´éš”
              ),
              onBarcodeScanned: _handleContinuousProductScan,
            ),
          ),
        ),
      ),
    );
  }

  /// å¯¹å…¥åº“é¡¹ç›®è¿›è¡Œé¢„å¤„ç†ï¼Œåˆå¹¶ç›¸åŒè´§å“çš„ä¸åŒå•ä½
  Future<List<InboundItemState>> _getMergedInboundItems() async {
    final originalItems = ref.read(inboundListProvider);
    // ä½¿ç”¨ a Map æ¥åˆå¹¶è´§å“ï¼Œé”®ä¸ºè´§å“ID
    final Map<int, InboundItemState> mergedItemsMap = {};

    for (final item in originalItems) {
      // å¼‚æ­¥è·å–å®Œæ•´çš„è´§å“ä¿¡æ?
      final product = await ref.read(
        productByIdProvider(item.productId).future,
      );
      if (product == null) continue; // å¦‚æœæ‰¾ä¸åˆ°è´§å“ï¼Œåˆ™è·³è¿?

      // è®¡ç®—å½“å‰é¡¹ç›®ä»¥åŸºæœ¬å•ä½ï¼ˆå¦‚â€œåŒ…â€ï¼‰è®¡çš„æ€»æ•°é‡?
      // conversionRate æ˜¯æŒ‡ä¸€ä¸ªå¤§å•ä½ï¼ˆå¦‚â€œæ¡â€ï¼‰ç­‰äºå¤šå°‘ä¸ªåŸºæœ¬å•ä½ï¼ˆå¦‚â€œåŒ…â€ï¼‰
      final baseUnitQuantity = item.quantity * item.conversionRate;

      if (mergedItemsMap.containsKey(item.productId)) {
        // å¦‚æœå·²å­˜åœ¨ç›¸åŒè´§å“ï¼Œè¿›è¡Œåˆå¹¶
        final existingItem = mergedItemsMap[item.productId]!;

        // ç´¯åŠ åŸºæœ¬å•ä½æ•°é‡
        final newTotalBaseQuantity =
            (existingItem.quantity * existingItem.conversionRate) +
            baseUnitQuantity;

        // è®¡ç®—åŠ æƒå¹³å‡å•ä»·ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼?
        // (æ—§æ€»ä»· + æ–°æ€»ä»·) / æ–°æ€»æ•°é‡?
        final totalCost =
            (existingItem.quantity *
                existingItem.conversionRate *
                existingItem.unitPriceInCents) +
            (baseUnitQuantity * item.unitPriceInCents);

        final newUnitPrice = (totalCost / newTotalBaseQuantity).round();

        // æ›´æ–° Map ä¸­çš„é¡¹ç›®
        // æŸ¥æ‰¾åŸºæœ¬å•ä½çš„åç§?
        final baseUnitName = originalItems
            .firstWhere(
              (i) => i.productId == item.productId && i.conversionRate == 1,
              orElse: () => item, // å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™ä½¿ç”¨å½“å‰å•ä½åä½œä¸ºåå¤‡
            )
            .unitName;

        // æ³¨æ„ï¼šåˆå¹¶åçš„é¡¹ç›®å°†ç»Ÿä¸€ä½¿ç”¨åŸºæœ¬å•ä½ï¼Œå› æ­?conversionRate è®¾ä¸º 1
        mergedItemsMap[item.productId] = existingItem.copyWith(
          quantity: newTotalBaseQuantity,
          unitPriceInCents: newUnitPrice,
          conversionRate: 1, // åˆå¹¶åç»Ÿä¸€ä¸ºåŸºæœ¬å•ä½?
          unitName: baseUnitName, // ä½¿ç”¨è´§å“çš„åŸºæœ¬å•ä½å
        );
      } else {
        // å¦‚æœæ˜¯æ–°è´§å“ï¼Œç›´æ¥æ·»åŠ å…¥Map
        // å¦‚æœå½“å‰å•ä½ä¸æ˜¯åŸºæœ¬å•ä½ï¼Œåˆ™è½¬æ¢ä¸ºåŸºæœ¬å•ä½?
        if (item.conversionRate > 1) {
          final baseUnitName = originalItems
              .firstWhere(
                (i) => i.productId == item.productId && i.conversionRate == 1,
                orElse: () => item,
              )
              .unitName;
          mergedItemsMap[item.productId] = item.copyWith(
            quantity: baseUnitQuantity,
            unitPriceInCents: (item.unitPriceInCents / item.conversionRate)
                .round(),
            conversionRate: 1,
            unitName: baseUnitName,
          );
        } else {
          // å¦‚æœå·²ç»æ˜¯åŸºæœ¬å•ä½ï¼Œç›´æ¥æ·»åŠ 
          mergedItemsMap[item.productId] = item;
        }
      }
    }
    // è¿”å›åˆå¹¶åçš„å€¼åˆ—è¡?
    return mergedItemsMap.values.toList();
  }

  void _confirmInbound() async {
    if (_isProcessing) return;
    if (!_validateForm()) return;

    setState(() => _isProcessing = true);

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        final theme = Theme.of(context);
        return AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(color: theme.colorScheme.primary),
              const SizedBox(width: 24),
              Text('æ­£åœ¨å¤„ç†...', style: theme.textTheme.titleMedium),
            ],
          ),
        );
      },
    );

    try {
      final inboundService = ref.read(inboundServiceProvider);
      final String source;
      final int? supplierId;
      final String? supplierName;
      final bool isPurchaseMode = _currentMode == InboundMode.purchase;

      if (isPurchaseMode) {
        source = 'é‡‡è´­';
        if (_selectedSupplier != null) {
          supplierId = _selectedSupplier!.id;
          supplierName = _selectedSupplier!.name;
        } else {
          supplierId = null;
          supplierName = _supplierController.text.trim();
        }
      } else {
        // éé‡‡è´­æ¨¡å¼?
        source = _sourceController.text.trim().isEmpty
            ? 'éé‡‡è´?
            : _sourceController.text.trim();
        supplierId = null;
        supplierName = null;
      }

      // è·å–åˆå¹¶åçš„å…¥åº“é¡¹ç›®åˆ—è¡¨
      final mergedInboundItems = await _getMergedInboundItems();

      final receiptNumber = await inboundService.processOneClickInbound(
        shopId: _selectedShop!.id!,
        inboundItems: mergedInboundItems, // ä½¿ç”¨åˆå¹¶åçš„åˆ—è¡¨
        remarks: _remarksController.text.isNotEmpty
            ? _remarksController.text
            : null,
        // æ–°å¢å’Œä¿®æ”¹çš„å‚æ•°
        source: source,
        isPurchaseMode: isPurchaseMode,
        supplierId: supplierId,
        supplierName: supplierName,
      );

      Navigator.of(context).pop();
      showAppSnackBar(context, message: 'âœ?ä¸€é”®å…¥åº“æˆåŠŸï¼å…¥åº“å•å·ï¼?receiptNumber');

      // æ ¸å¿ƒä¿®å¤ï¼šä½¿å…¥åº“è®°å½•å’Œåº“å­˜æŸ¥è¯¢çš„Providerå¤±æ•ˆï¼Œä»¥ä¾¿åœ¨å¯¼èˆªååˆ·æ–°æ•°æ?
      ref.invalidate(inboundRecordsProvider);
      ref.invalidate(inventoryQueryProvider);

      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          // ä½¿ç”¨ go è€Œä¸æ˜?push, ä»¥æ›¿æ¢å½“å‰é¡µé¢ï¼Œè€Œä¸æ˜¯å †å?
          context.go(AppRoutes.inventoryInboundRecords);
        }
      });
    } catch (e, st) {
      Navigator.of(context).pop();
      // æ‰“å°è¯¦ç»†å †æ ˆä»¥å®šä½çœŸæ­£çš„æŠ›é”™ä½ç½®
      debugPrint('â?ä¸€é”®å…¥åº“å¤±è´? $e');
      debugPrintStack(stackTrace: st);
      showAppSnackBar(
        context,
        message: 'â?ä¸€é”®å…¥åº“å¤±è´? ${e.toString()}',
        isError: true,
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }

  void _handleSingleProductScan(String barcode) async {
    showAppSnackBar(context, message: 'æ­£åœ¨æŸ¥è¯¢è´§å“ä¿¡æ¯...');

    try {
      final productOperations = ref.read(productOperationsProvider.notifier);
      final result = await productOperations.getProductWithUnitByBarcode(
        barcode,
      );

      if (!mounted) return;

      // æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½å…ˆå…³é—­æ‰«ç é¡µé?
      Navigator.of(context).pop();

      if (result != null) {
        ref
            .read(inboundListProvider.notifier)
            .addOrUpdateItem(
              product: result.product,
              unitId: result.unitId,
              unitName: result.unitName,
              conversionRate: result.conversionRate,
              barcode: barcode,
              wholesalePriceInCents: result.wholesalePriceInCents,
            );
        // æˆåŠŸæ·»åŠ å•†å“åæ’­æ”¾éŸ³æ•?
        HapticFeedback.lightImpact();
        SoundHelper.playSuccessSound();
      } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°äº§å“ï¼Œæ˜¾ç¤ºå¯¹è¯æ¡†
        _showProductNotFoundDialog(barcode);
      }
    } catch (e) {
      if (!mounted) return;
      // å…³é—­æ‰«ç é¡µé¢
      Navigator.of(context).pop();
      // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      showAppSnackBar(context, message: 'â?æŸ¥è¯¢è´§å“å¤±è´¥: $e', isError: true);
    }
  }

  void _handleContinuousProductScan(String barcode) async {
    // è¿ç»­æ‰«ç å»é‡ï¼šå¦‚æœæ¡ç ä¸ä¸Šä¸€ä¸ªç›¸åŒï¼Œåˆ™å¿½ç•?
    if (barcode == _lastScannedBarcode) {
      return;
    }

    // åœ¨è¿ç»­æ‰«ç æ¨¡å¼ä¸‹ï¼Œä¸æ˜¾ç¤ºå…¨å±€çš„åŠ è½½æç¤ºï¼Œè€Œæ˜¯å¿«é€Ÿåé¦?
    HapticFeedback.lightImpact();
    showAppSnackBar(context, message: 'æ¡ç : $barcode...');

    try {
      final productOperations = ref.read(productOperationsProvider.notifier);
      final result = await productOperations.getProductWithUnitByBarcode(
        barcode,
      );

      if (!mounted) return;

      if (result != null) {
        ref
            .read(inboundListProvider.notifier)
            .addOrUpdateItem(
              product: result.product,
              unitId: result.unitId,
              unitName: result.unitName,
              conversionRate: result.conversionRate,
              barcode: barcode,
              wholesalePriceInCents: result.wholesalePriceInCents,
            );
        _lastScannedBarcode = barcode; // ä»…åœ¨æˆåŠŸæ—¶æ›´æ–°ä¸Šä¸€ä¸ªæ¡ç ?
        // æˆåŠŸæ·»åŠ å•†å“åæ’­æ”¾éŸ³æ•?
        SoundHelper.playSuccessSound();
        // æˆåŠŸæ·»åŠ åç»™äºˆä¸€ä¸ªæ›´æ˜ç¡®çš„æç¤?
        showAppSnackBar(context, message: 'âœ?${result.product.name} å·²æ·»åŠ?);
      } else {
        _lastScannedBarcode = null; // å¦‚æœæœªæ‰¾åˆ°ï¼Œåˆ™å…è®¸ç«‹å³é‡æ‰?
        // æœªæ‰¾åˆ°è´§å“æ—¶ç»™äºˆä¸€ä¸ªå¤±è´¥æç¤?
        showAppSnackBar(
          context,
          message: 'â?æœªæ‰¾åˆ°æ¡ç å¯¹åº”çš„è´§å“: $barcode',
          isError: true,
        );
      }
    } catch (e) {
      if (!mounted) return;
      _lastScannedBarcode = null; // å¦‚æœå‡ºé”™ï¼Œåˆ™å…è®¸ç«‹å³é‡æ‰«
      showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
    }
  }

  void _showProductNotFoundDialog(String barcode) {
    showDialog(
      context: context,
      builder: (context) {
        final theme = Theme.of(context);
        final textTheme = theme.textTheme;
        return AlertDialog(
          title: Text('è´§å“æœªæ‰¾åˆ?, style: textTheme.titleLarge),
          content: Text(
            'æ¡ç  $barcode å¯¹åº”çš„è´§å“æœªåœ¨ç³»ç»Ÿä¸­æ‰¾åˆ°ã€?,
            style: textTheme.bodyMedium,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('ç¡®å®š'),
            ),
          ],
        );
      },
    );
  }

  bool _validateForm() {
    if (_currentMode == InboundMode.purchase) {
      if (_selectedSupplier == null &&
          _supplierController.text.trim().isEmpty) {
        showAppSnackBar(context, message: 'è¯·é€‰æ‹©æˆ–è¾“å…¥ä¾›åº”å•†åç§°', isError: true);
        return false;
      }
    }
    if (_selectedShop == null) {
      showAppSnackBar(context, message: 'è¯·é€‰æ‹©å…¥åº“åº—é“º', isError: true);
      return false;
    }
    final inboundItems = ref.read(inboundListProvider);
    if (inboundItems.isEmpty) {
      showAppSnackBar(context, message: 'è¯·å…ˆæ·»åŠ è´§å“', isError: true);
      return false;
    }
    for (final item in inboundItems) {
      if (item.quantity <= 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„æ•°é‡å¿…é¡»å¤§äº?',
          isError: true,
        );
        return false;
      }
      if (_currentMode == InboundMode.purchase && item.unitPriceInCents < 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„å•ä»·ä¸èƒ½ä¸ºè´Ÿæ•°',
          isError: true,
        );
        return false;
      }
      // é‡‡è´­æ¨¡å¼ä¸‹ï¼Œå•ä»·ä¸èƒ½ä¸?
      if (_currentMode == InboundMode.purchase && item.unitPriceInCents == 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„å•ä»·ä¸èƒ½ä¸º0',
          isError: true,
        );
        return false;
      }
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;

    final inboundItemIds = ref.watch(
      inboundListProvider.select((items) => items.map((e) => e.id).toList()),
    );
    final totals = ref.watch(inboundTotalsProvider);
    final totalVarieties = totals['varieties']?.toInt() ?? 0;
    final totalQuantity = totals['quantity']?.toInt() ?? 0;
    final totalAmount = totals['amount'] ?? 0.0;

    _ensureFocusNodes(inboundItemIds.length);

    final canPop = context.canPop();
    return PopScope(
      canPop: canPop,
      onPopInvoked: (bool didPop) {
        if (!didPop) {
          context.go('/');
        }
      },
      child: GestureDetector(
        onTap: () => FocusManager.instance.primaryFocus?.unfocus(),
        behavior: HitTestBehavior.opaque,
        child: Scaffold(
          appBar: AppBar(
            leading: !canPop
                ? IconButton(
                    icon: const Icon(Icons.arrow_back),
                    onPressed: () => context.go('/'),
                    tooltip: 'è¿”å›',
                  )
                : null,
            title: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(_currentMode == InboundMode.purchase ? 'é‡‡è´­å…¥åº“' : 'éé‡‡è´­å…¥åº?),
                IconButton(
                  icon: const Icon(Icons.swap_horiz_outlined),
                  tooltip: 'åˆ‡æ¢æ¨¡å¼',
                  onPressed: () {
                    setState(() {
                      _currentMode = _currentMode == InboundMode.purchase
                          ? InboundMode.nonPurchase
                          : InboundMode.purchase;
                    });
                  },
                ),
              ],
            ),
            actions: [const SizedBox(width: 8)],
          ),
          body: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildHeaderSection(theme, textTheme),
                const SizedBox(height: 0),
                if (inboundItemIds.isEmpty)
                  _buildEmptyState(theme, textTheme)
                else
                  ...inboundItemIds.asMap().entries.map((entry) {
                    final index = entry.key;
                    final itemId = entry.value;
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 0),
                      child: InboundItemCard(
                        key: ValueKey(itemId),
                        itemId: itemId,
                        showPriceInfo:
                            _currentMode == InboundMode.purchase, // æ–°å¢
                        quantityFocusNode: _quantityFocusNodes.length > index
                            ? _quantityFocusNodes[index]
                            : null,
                        amountFocusNode: _amountFocusNodes.length > index
                            ? _amountFocusNodes[index]
                            : null,
                        onAmountSubmitted: () => _handleNextStep(index),
                      ),
                    );
                  }),
                const SizedBox(height: 0),
                _buildActionButtons(theme, textTheme),
                const SizedBox(height: 4),
                _buildTotalsBar(
                  theme,
                  textTheme,
                  totalVarieties,
                  totalQuantity,
                  totalAmount,
                ),
                const SizedBox(height: 4),
                _buildBottomAppBar(theme, textTheme),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(ThemeData theme, TextTheme textTheme) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 123, horizontal: 24),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
      ),
      child: Column(
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 56,
            color: theme.colorScheme.onSurfaceVariant.withOpacity(0.5),
          ),
          const SizedBox(height: 16),
          Text(
            'æš‚æ— è´§å“',
            style: textTheme.titleLarge?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'è¯·ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®æ·»åŠ è´§å“åˆ°å…¥åº“å?,
            style: textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant.withOpacity(0.7),
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(ThemeData theme, TextTheme textTheme) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _addManualProduct,
            icon: const Icon(Icons.add, size: 18),
            label: Text('æ·»åŠ è´§å“', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _scanToAddProduct,
            icon: const Icon(Icons.camera_alt_outlined, size: 18),
            label: Text('æ‰«ç æ·»åŠ ', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _continuousScan,
            icon: const Icon(Icons.qr_code_scanner, size: 18),
            label: Text('è¿ç»­æ‰«ç ', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTotalsBar(
    ThemeData theme,
    TextTheme textTheme,
    int totalVarieties,
    int totalQuantity,
    double totalAmount,
  ) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 5),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
        border: Border(
          top: BorderSide(color: theme.colorScheme.outline.withOpacity(0.3)),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          _buildTotalItem(textTheme, 'å“ç§', totalVarieties.toString()),
          _buildTotalItem(textTheme, 'æ€»æ•°', totalQuantity.toString()),
          if (_currentMode == InboundMode.purchase)
            _buildTotalItem(
              textTheme,
              'æ€»é‡‘é¢?,
              'Â¥${totalAmount.toStringAsFixed(2)}',
              isAmount: true,
            ),
        ],
      ),
    );
  }

  Widget _buildTotalItem(
    TextTheme textTheme,
    String label,
    String value, {
    bool isAmount = false,
  }) {
    return RichText(
      text: TextSpan(
        style: textTheme.bodyMedium?.copyWith(
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        ),
        children: [
          TextSpan(text: '$label: '),
          TextSpan(
            text: value,
            style: textTheme.bodyLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: isAmount
                  ? Theme.of(context).colorScheme.primary
                  : Theme.of(context).colorScheme.onSurface,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBottomAppBar(ThemeData theme, TextTheme textTheme) {
    return ElevatedButton.icon(
      onPressed: _isProcessing ? null : _confirmInbound,
      icon: _isProcessing
          ? const SizedBox(
              width: 24,
              height: 0, // ä¿®å¤ï¼šå°†é«˜åº¦ä»?0 æ”¹ä¸º 24
              child: CircularProgressIndicator(
                strokeWidth: 3,
                color: Colors.white,
              ),
            )
          : const Icon(Icons.check_circle_outline, size: 24),
      label: Text(
        _isProcessing ? 'æ­£åœ¨å…¥åº“...' : 'ä¸€é”®å…¥åº?,
        style: textTheme.titleMedium?.copyWith(
          color: theme.colorScheme.onPrimary,
          fontWeight: FontWeight.bold,
        ),
      ),
      style: ElevatedButton.styleFrom(
        // ä¿®æ”¹ï¼šä½¿ç”?padding è°ƒæ•´æŒ‰é’®é«˜åº¦
        padding: const EdgeInsets.symmetric(vertical: 0),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
      ),
    );
  }

  Widget _buildHeaderSection(ThemeData theme, TextTheme textTheme) {
    final allShopsAsync = ref.watch(allShopsProvider);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 2,
              child: allShopsAsync.when(
                data: (shops) {
                  if (_selectedShop == null) {
                    final defaultShop = shops.firstWhereOrNull(
                      (shop) => shop.name == 'é•¿å±±çš„åº—',
                    );
                    if (defaultShop != null) {
                      WidgetsBinding.instance.addPostFrameCallback((_) {
                        if (mounted) {
                          setState(() {
                            _selectedShop = defaultShop;
                          });
                        }
                      });
                    }
                  }
                  return DropdownButtonFormField<Shop>(
                    key: const Key('shop_dropdown'),
                    focusNode: _shopFocusNode,
                    value: _selectedShop,
                    decoration: const InputDecoration(
                      isDense: true,
                      contentPadding: EdgeInsets.symmetric(vertical: 0),
                    ),
                    items: shops
                        .map(
                          (shop) => DropdownMenuItem(
                            value: shop,
                            child: Text(shop.name),
                          ),
                        )
                        .toList(),
                    onChanged: (value) {
                      setState(() {
                        _selectedShop = value;
                      });
                    },
                  );
                },
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (err, stack) => Text('æ— æ³•åŠ è½½åº—é“º: $err'),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              flex: 5,
              child: _currentMode == InboundMode.purchase
                  ? Row(
                      crossAxisAlignment: CrossAxisAlignment.baseline,
                      textBaseline: TextBaseline.alphabetic,
                      children: [
                        Text('ä¾›åº”å•?', style: const TextStyle(fontSize: 17)),
                        const SizedBox(width: 8),
                        Expanded(
                          child: TypeAheadField<Supplier>(
                            key: const Key('supplier_typeahead'),
                            controller: _supplierController,
                            focusNode: _supplierFocusNode,
                            suggestionsCallback: (pattern) async {
                              return await ref.read(
                                searchSuppliersProvider(pattern).future,
                              );
                            },
                            itemBuilder: (context, suggestion) {
                              return ListTile(
                                title: Text(suggestion.name),
                                contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 16.0,
                                ),
                              );
                            },
                            onSelected: (suggestion) {
                              setState(() {
                                _selectedSupplier = suggestion;
                                _supplierController.text = suggestion.name;
                              });
                              // ç§»é™¤ç„¦ç‚¹è½¬ç§»ï¼Œè®©ç”¨æˆ·è‡ªç„¶æ“ä½œ
                              _supplierFocusNode.unfocus();
                            },
                            builder: (context, controller, focusNode) {
                              return TextField(
                                controller: controller,
                                focusNode: focusNode,
                                decoration: const InputDecoration(
                                  hintText: 'æœç´¢æˆ–é€‰æ‹©',
                                  isDense: true,
                                  contentPadding: EdgeInsets.symmetric(
                                    vertical: 0,
                                  ),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.baseline,
                      textBaseline: TextBaseline.alphabetic,
                      children: [
                        Text('æ¥æº:', style: const TextStyle(fontSize: 17)),
                        const SizedBox(width: 8),
                        Expanded(
                          child: TextFormField(
                            controller: _sourceController,
                            style: const TextStyle(fontSize: 15.5),
                            decoration: const InputDecoration(
                              hintText: 'è¾“å…¥è´§å“æ¥æº (å¯é€?',
                              isDense: true,
                              contentPadding: EdgeInsets.symmetric(vertical: 0),
                            ),
                          ),
                        ),
                      ],
                    ),
            ),
          ],
        ),
        const SizedBox(height: 5),
        // Divider(color: theme.colorScheme.outline.withOpacity(0.5)),
      ],
    );
  }
}
// Inbound Screens Barrel File
export 'create_inbound_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../../../core/widgets/custom_date_picker.dart';
import '../../../../core/widgets/cached_image_widget.dart';
import '../../application/provider/inbound_list_provider.dart';

/// å…¥åº“å•å•†å“é¡¹å¡ç‰‡
/// æ˜¾ç¤ºå•†å“ä¿¡æ¯ã€ä»·æ ¼ã€æ•°é‡å’Œé‡‘é¢è¾“å…¥ç­?
class InboundItemCard extends ConsumerStatefulWidget {
  final String itemId;
  final FocusNode? quantityFocusNode;
  final FocusNode? amountFocusNode;
  final VoidCallback? onAmountSubmitted;
  final bool showPriceInfo;

  const InboundItemCard({
    // ä½¿ç”¨ValueKeyç¡®ä¿Widgetä¸æ•°æ®é¡¹çš„æ­£ç¡®ç»‘å®?
    required super.key,
    required this.itemId,
    this.quantityFocusNode,
    this.amountFocusNode,
    this.onAmountSubmitted,
    this.showPriceInfo = true,
  });

  @override
  ConsumerState<InboundItemCard> createState() => _InboundItemCardState();
}

class _InboundItemCardState extends ConsumerState<InboundItemCard> {
  final _unitPriceController = TextEditingController();
  final _quantityController = TextEditingController();
  final _amountController = TextEditingController();

  // ä¸ºå†…éƒ¨ç®¡ç†çš„æ–‡æœ¬æ¡†åˆ›å»ºFocusNode
  final _unitPriceFocusNode = FocusNode();

  bool _isUpdatingFromAmount = false; // æ ‡è®°æ˜¯å¦ä»é‡‘é¢æ›´æ–°å…¶ä»–å­—æ®?

  void _onUnitPriceFocusChange() {
    if (_unitPriceFocusNode.hasFocus) {
      // è·å–ç„¦ç‚¹æ—¶æ¸…ç©ºï¼Œæ–¹ä¾¿é‡æ–°è¾“å…¥
      _unitPriceController.clear();
    } else {
      // å¤±å»ç„¦ç‚¹æ—¶ï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ™æ¢å¤ä¸ºåŸæ¥çš„å€?
      if (_unitPriceController.text.isEmpty) {
        final item = ref
            .read(inboundListProvider)
            .firstWhere((it) => it.id == widget.itemId);
        _unitPriceController.text = (item.unitPriceInCents / 100)
            .toStringAsFixed(2);
      }
    }
  }

  void _onQuantityFocusChange() {
    if (widget.quantityFocusNode?.hasFocus == true) {
      _quantityController.clear();
    } else {
      if (_quantityController.text.isEmpty) {
        final item = ref
            .read(inboundListProvider)
            .firstWhere((it) => it.id == widget.itemId);
        _quantityController.text = item.quantity.toStringAsFixed(0);
      }
    }
  }

  void _onAmountFocusChange() {
    if (widget.amountFocusNode?.hasFocus == true) {
      _amountController.clear();
    } else {
      if (_amountController.text.isEmpty) {
        final item = ref
            .read(inboundListProvider)
            .firstWhere((it) => it.id == widget.itemId);
        _amountController.text = (item.amountInCents / 100).toStringAsFixed(2);
      }
    }
  }

  @override
  void initState() {
    super.initState();
    // ç›‘å¬å™¨åœ¨initStateä¸­æ·»åŠ?
    _unitPriceFocusNode.addListener(_onUnitPriceFocusChange);
    widget.quantityFocusNode?.addListener(_onQuantityFocusChange);
    widget.amountFocusNode?.addListener(_onAmountFocusChange);
  }

  @override
  void didUpdateWidget(InboundItemCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    // å¦‚æœFocusNodeå®ä¾‹å‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦é‡æ–°æ·»åŠ ç›‘å¬å™¨
    if (widget.quantityFocusNode != oldWidget.quantityFocusNode) {
      oldWidget.quantityFocusNode?.removeListener(_onQuantityFocusChange);
      widget.quantityFocusNode?.addListener(_onQuantityFocusChange);
    }
    if (widget.amountFocusNode != oldWidget.amountFocusNode) {
      oldWidget.amountFocusNode?.removeListener(_onAmountFocusChange);
      widget.amountFocusNode?.addListener(_onAmountFocusChange);
    }
  }

  @override
  void dispose() {
    _unitPriceController.dispose();
    _quantityController.dispose();
    _amountController.dispose();
    _unitPriceFocusNode.removeListener(_onUnitPriceFocusChange);
    _unitPriceFocusNode.dispose(); // æ¸…ç†æœ¬åœ°FocusNode
    widget.quantityFocusNode?.removeListener(_onQuantityFocusChange);
    widget.amountFocusNode?.removeListener(_onAmountFocusChange);
    super.dispose();
  }

  void _updateItem(InboundItemState item, {DateTime? newProductionDate}) {
    final unitPrice = (double.tryParse(_unitPriceController.text) ?? 0.0) * 100;
    final quantity = int.tryParse(_quantityController.text) ?? 0;
    final amount = unitPrice * quantity / 100;

    if (!_isUpdatingFromAmount) {
      _amountController.text = (amount / 100).toStringAsFixed(2);
    }

    final updatedItem = item.copyWith(
      unitPriceInCents: unitPrice.toInt(),
      quantity: quantity,
      productionDate: newProductionDate ?? item.productionDate,
    );

    ref.read(inboundListProvider.notifier).updateItem(updatedItem);
  }

  void _updateFromAmount(InboundItemState item) {
    final amount = (double.tryParse(_amountController.text) ?? 0.0) * 100;
    final quantity = int.tryParse(_quantityController.text) ?? 1;

    if (quantity > 0) {
      final unitPriceInCents = amount / quantity;

      _isUpdatingFromAmount = true;
      _unitPriceController.text = (unitPriceInCents / 100).toStringAsFixed(2);

      final updatedItem = item.copyWith(
        unitPriceInCents: unitPriceInCents.toInt(),
        quantity: quantity,
      );

      ref.read(inboundListProvider.notifier).updateItem(updatedItem);

      _isUpdatingFromAmount = false;
    }
  }

  Future<void> _selectProductionDate(InboundItemState item) async {
    final DateTime? picked = await CustomDatePicker.show(
      context: context,
      initialDate: item.productionDate ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      title: 'é€‰æ‹©ç”Ÿäº§æ—¥æœŸ',
    );

    if (picked != null && picked != item.productionDate) {
      _updateItem(item, newProductionDate: picked);
    }
  }

  String _formatDate(DateTime? date) {
    if (date == null) return 'è¯·é€‰æ‹©æ—¥æœŸ';
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    // è®¢é˜…å•ä¸ªitemçš„çŠ¶æ€ï¼Œå½“è¿™ä¸ªitemå˜åŒ–æ—¶ï¼Œåªæœ‰è¿™ä¸ªcardä¼šé‡å»?
    final item = ref.watch(
      inboundListProvider.select(
        (items) => items.firstWhere((it) => it.id == widget.itemId),
      ),
    );

    // --- åŒæ­¥Controllerä¸State ---
    // åªæœ‰åœ¨éç„¦ç‚¹ä¸”æ–‡æœ¬ä¸åŒæ—¶æ‰æ›´æ–°ï¼Œé¿å…è¦†ç›–ç”¨æˆ·è¾“å…¥
    if (!_unitPriceFocusNode.hasFocus &&
        _unitPriceController.text !=
            (item.unitPriceInCents / 100).toStringAsFixed(2)) {
      _unitPriceController.text = (item.unitPriceInCents / 100).toStringAsFixed(
        2,
      );
    }
    if (widget.quantityFocusNode?.hasFocus == false &&
        _quantityController.text != item.quantity.toStringAsFixed(0)) {
      _quantityController.text = item.quantity.toStringAsFixed(0);
    }
    if (widget.amountFocusNode?.hasFocus == false &&
        !_isUpdatingFromAmount &&
        _amountController.text !=
            (item.amountInCents / 100).toStringAsFixed(2)) {
      _amountController.text = (item.amountInCents / 100).toStringAsFixed(2);
    }
    // --------------------------

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: BorderSide(
          color: Colors.blue.shade300,
          width: 1.5,
        ),
      ),
      child: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.all(3),
            child: Consumer(
              builder: (context, ref, _) {
                // å°†product providerçš„ç›‘å¬æå‡åˆ°é¡¶å±‚ï¼Œä»¥ä¾¿åœ¨å¤šä¸ªåœ°æ–¹å…±äº«å…¶çŠ¶æ€?
                final productAsync = ref.watch(
                  productByIdProvider(item.productId),
                );

                return productAsync.when(
                  loading: () => const SizedBox(
                    height: 80,
                    child: Center(child: CircularProgressIndicator()),
                  ),
                  error: (e, st) => SizedBox(
                    height: 80,
                    child: Center(
                      child: Icon(Icons.error, color: Colors.red, size: 30),
                    ),
                  ),
                  data: (product) {
                    // æ ¹æ®äº§å“æ˜¯å¦éœ€è¦æ‰¹æ¬¡ç®¡ç†ï¼Œå†³å®šæ—¥æœŸé€‰æ‹©å™¨æ˜¯å¦å¯è§?
                    final bool isDatePickerVisible =
                        product?.enableBatchManagement == true;

                    // æ ¹æ®æ—¥æœŸé€‰æ‹©å™¨çš„å¯è§æ€§ï¼ŒåŠ¨æ€è°ƒæ•´å‚ç›´å¯¹é½æ–¹å¼?
                    return Row(
                      crossAxisAlignment: isDatePickerVisible
                          ? CrossAxisAlignment.start
                          : CrossAxisAlignment.center,
                      children: [
                        // --- å·¦ä¾§å›¾ç‰‡ ---
                        SizedBox(
                          width: 60,
                          height: 80,
                          child: product?.image?.isNotEmpty == true
                              ? CachedImageWidget(
                                  imagePath: product!.image!,
                                  fit: BoxFit.cover,
                                )
                              : const Center(
                                  child: Icon(
                                    Icons.image_outlined,
                                    color: Colors.grey,
                                    size: 30,
                                  ),
                                ),
                        ),
                        const SizedBox(width: 8),

                        // --- å³ä¾§ä¿¡æ¯åˆ?---
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // ç¬¬ä¸€è¡Œï¼šå•†å“åç§° + (æ•°é‡) + å•ä½
                              Row(
                                crossAxisAlignment: CrossAxisAlignment.center,
                                children: [
                                  SizedBox(
                                    width: 120,
                                    child: Text(
                                      item.productName,
                                      style: const TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w500,
                                      ),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  if (!widget.showPriceInfo) ...[
                                    const SizedBox(width: 8),
                                    SizedBox(
                                      width: 60,
                                      height: 30,
                                      child: TextFormField(
                                        controller: _quantityController,
                                        focusNode: widget.quantityFocusNode,
                                        keyboardType:
                                            const TextInputType.numberWithOptions(
                                              decimal: false,
                                            ),
                                        textAlign: TextAlign.center,
                                        textInputAction: TextInputAction.next,
                                        decoration: const InputDecoration(
                                          hintText: 'æ•°é‡',
                                          border: OutlineInputBorder(),
                                          contentPadding: EdgeInsets.zero,
                                        ),
                                        onChanged: (value) => _updateItem(item),
                                        onFieldSubmitted: (value) =>
                                            widget.onAmountSubmitted?.call(),
                                      ),
                                    ),
                                  ],
                                  const Spacer(),
                                  Text(
                                    item.unitName,
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey[600],
                                    ),
                                  ),
                                  const SizedBox(width: 55),
                                ],
                              ),

                              const SizedBox(height: 3),

                              // ç¬¬äºŒè¡Œï¼šä»·æ ¼ã€æ•°é‡ã€é‡‘é¢?(ä»…é‡‡è´­å…¥åº?
                              if (widget.showPriceInfo)
                                Row(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Expanded(
                                      flex: 6,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'å•ä»·',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: TextFormField(
                                              controller: _unitPriceController,
                                              focusNode: _unitPriceFocusNode,
                                              keyboardType:
                                                  const TextInputType.numberWithOptions(
                                                    decimal: true,
                                                  ),
                                              decoration: const InputDecoration(
                                                border: OutlineInputBorder(),
                                                contentPadding:
                                                    EdgeInsets.symmetric(
                                                      horizontal: 12,
                                                      vertical: 0,
                                                    ),
                                                prefixText: 'Â¥',
                                              ),
                                              onChanged: (value) =>
                                                  _updateItem(item),
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                    const SizedBox.square(dimension: 12.0),
                                    Expanded(
                                      flex: 3,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'æ•°é‡',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: TextFormField(
                                              controller: _quantityController,
                                              focusNode:
                                                  widget.quantityFocusNode,
                                              keyboardType:
                                                  const TextInputType.numberWithOptions(
                                                    decimal: false,
                                                  ),
                                              textInputAction:
                                                  TextInputAction.next,
                                              decoration: const InputDecoration(
                                                border: OutlineInputBorder(),
                                                contentPadding:
                                                    EdgeInsets.symmetric(
                                                      horizontal: 12,
                                                      vertical: 0,
                                                    ),
                                              ),
                                              onChanged: (value) =>
                                                  _updateItem(item),
                                              onFieldSubmitted: (value) {
                                                if (widget.amountFocusNode !=
                                                    null) {
                                                  widget.amountFocusNode!
                                                      .requestFocus();
                                                  WidgetsBinding.instance
                                                      .addPostFrameCallback((
                                                        _,
                                                      ) {
                                                        _amountController
                                                            .clear();
                                                      });
                                                }
                                              },
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                    const SizedBox.square(dimension: 12.0),
                                    Expanded(
                                      flex: 7,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'é‡‘é¢',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: TextFormField(
                                              controller: _amountController,
                                              focusNode: widget.amountFocusNode,
                                              keyboardType:
                                                  const TextInputType.numberWithOptions(
                                                    decimal: true,
                                                  ),
                                              textInputAction:
                                                  TextInputAction.done,
                                              decoration: const InputDecoration(
                                                border: OutlineInputBorder(),
                                                contentPadding:
                                                    EdgeInsets.symmetric(
                                                      horizontal: 12,
                                                      vertical: 0,
                                                    ),
                                                prefixText: 'Â¥',
                                              ),
                                              onChanged: (value) =>
                                                  _updateFromAmount(item),
                                              onFieldSubmitted: (value) =>
                                                  widget.onAmountSubmitted
                                                      ?.call(),
                                              // style: const TextStyle(
                                              //   fontWeight: FontWeight.w500,
                                              // ),
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ],
                                ),

                              const SizedBox(height: 6),

                              // ç¬¬ä¸‰è¡Œï¼šç”Ÿäº§æ—¥æœŸ (æ¡ä»¶æ˜¾ç¤º)
                              if (isDatePickerVisible)
                                Row(
                                  children: [
                                    const Text(
                                      'ç”Ÿäº§æ—¥æœŸ',
                                      style: TextStyle(fontSize: 12),
                                    ),
                                    const SizedBox(width: 12),
                                    Expanded(
                                      child: InkWell(
                                        onTap: () =>
                                            _selectProductionDate(item),
                                        child: Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 12,
                                            vertical: 4,
                                          ),
                                          decoration: BoxDecoration(
                                            border: Border.all(
                                              color: Colors.grey.shade300,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              4,
                                            ),
                                          ),
                                          child: Row(
                                            children: [
                                              Text(
                                                _formatDate(
                                                  item.productionDate,
                                                ),
                                                style: TextStyle(
                                                  fontSize: 12,
                                                  color:
                                                      item.productionDate ==
                                                          null
                                                      ? Colors.grey[600]
                                                      : Colors.black,
                                                  fontWeight: FontWeight.w500,
                                                ),
                                              ),
                                              const Spacer(),
                                              Icon(
                                                Icons.calendar_today,
                                                size: 12,
                                                color: Colors.grey[600],
                                              ),
                                            ],
                                          ),
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                );
              },
            ),
          ),
          Positioned(
            top: -15,
            right: -15,
            child: IconButton(
              onPressed: () => ref
                  .read(inboundListProvider.notifier)
                  .removeItem(widget.itemId),
              icon: const Icon(Icons.close, size: 18),
              style: IconButton.styleFrom(
                backgroundColor: Colors.red.shade50,
                foregroundColor: Colors.red,
                minimumSize: const Size(24, 24),
                padding: EdgeInsets.zero,
              ),
              tooltip: 'åˆ é™¤',
            ),
          ),
        ],
      ),
    );
  }
}
// Inbound Widgets Barrel File
export 'inbound_item_card.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/core/database/database.dart';
import '../domain/model/inventory.dart';
import '../domain/model/inventory_transaction.dart';
import '../domain/repository/i_inventory_repository.dart';
import '../domain/repository/i_inventory_transaction_repository.dart';
import '../data/repository/inventory_repository.dart';
import '../data/repository/inventory_transaction_repository.dart';

/// åº“å­˜åº”ç”¨æœåŠ¡
/// æä¾›åº“å­˜ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘æ“ä½œ
class InventoryService {
  final IInventoryRepository _inventoryRepository;
  final IInventoryTransactionRepository _transactionRepository;
  final AppDatabase _db;

  InventoryService(this._inventoryRepository, this._transactionRepository, this._db);

  /// å…¥åº“æ“ä½œ
  /// å¢åŠ åº“å­˜æ•°é‡å¹¶è®°å½•å…¥åº“æµæ°?
  Future<bool> inbound({
    required int productId,
    required int shopId,
    int? batchId,
    required int quantity,
    DateTime? time,
  }) async {
    try {
      // äº‹åŠ¡å†…ï¼šå˜æ›´åº“å­˜ + å†™æµæ°?
      return await _db.transaction(() async {
      // æŒ?äº§å“+åº—é“º+æ‰¹æ¬¡ ç»´åº¦æ£€æŸ¥åº“å­˜æ˜¯å¦å­˜åœ?
      var inventory = await _inventoryRepository
          .getInventoryByProductShopAndBatch(productId, shopId, batchId);

      if (inventory == null) {
        // å¦‚æœåº“å­˜ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°åº“å­˜è®°å½?
        inventory = StockModel.create(
          productId: productId,
          quantity: quantity,
          shopId: shopId,
          batchId: batchId,
        );
        await _inventoryRepository.addInventory(inventory);
      } else {
        // å¦‚æœåº“å­˜å­˜åœ¨ï¼Œå¢åŠ åº“å­˜æ•°é‡?
        final ok = await _inventoryRepository.addInventoryQuantityByBatch(
          productId,
          shopId,
          batchId,
          quantity,
        );
        if (!ok) return false; // æ²¡æœ‰åŒ¹é…è¡Œï¼ˆä¾‹å¦‚è®°å½•ä¸å­˜åœ¨ï¼‰
      }

      // è®°å½•å…¥åº“æµæ°´
      final transaction = InventoryTransactionModel.createInbound(
        productId: productId,
        quantity: quantity,
        shopId: shopId,
        batchId: batchId,
      );
      await _transactionRepository.addTransaction(transaction);
      return true;
      });
    } catch (e) {
      print('ğŸ“¦ åº“å­˜æœåŠ¡ï¼šå…¥åº“æ“ä½œå¤±è´? $e');
      return false;
    }
  }

  /// å‡ºåº“æ“ä½œ
  /// å‡å°‘åº“å­˜æ•°é‡å¹¶è®°å½•å‡ºåº“æµæ°?
  Future<bool> outbound({
    required int productId,
    required int shopId,
    required int quantity,
    int? batchId,
    DateTime? time,
  }) async {
    try {
  return await _db.transaction(() async {
        // æ£€æŸ¥åº“å­˜è®°å½•æ˜¯å¦å­˜åœ?
        var inventory = await _inventoryRepository
            .getInventoryByProductShopAndBatch(productId, shopId, batchId);
        
        if (inventory == null) {
          // å¦‚æœåº“å­˜è®°å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºåˆå§‹åº“å­˜ä¸?çš„è®°å½?
          print('ğŸ“¦ åº“å­˜æœåŠ¡ï¼šäº§å“?$productId åœ¨åº—é“?$shopId çš„åº“å­˜è®°å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºåˆå§‹è®°å½?);
          inventory = StockModel.create(
            productId: productId,
            quantity: 0,
            shopId: shopId,
            batchId: batchId,
          );
          await _inventoryRepository.addInventory(inventory);
        }
        
        // å‡å°‘åº“å­˜æ•°é‡ï¼ˆå…è®¸è´Ÿåº“å­˜ï¼?
        final ok = batchId != null
            ? await _inventoryRepository.subtractInventoryQuantityByBatch(
                productId,
                shopId,
                batchId,
                quantity,
              )
            : await _inventoryRepository.subtractInventoryQuantity(
                productId,
                shopId,
                quantity,
              );
        if (!ok) return false;

        // è®°å½•å‡ºåº“æµæ°´
        final transaction = InventoryTransactionModel.createOutbound(
          productId: productId,
          quantity: quantity,
          shopId: shopId,
          batchId: batchId,
        );
        await _transactionRepository.addTransaction(transaction);
        return true;
      });
    } catch (e) {
      print('ğŸ“¦ åº“å­˜æœåŠ¡ï¼šå‡ºåº“æ“ä½œå¤±è´? $e');
      return false;
    }
  }

  /// åº“å­˜è°ƒæ•´
  /// è°ƒæ•´åº“å­˜æ•°é‡å¹¶è®°å½•è°ƒæ•´æµæ°?
  Future<bool> adjust({
    required int productId,
    required int shopId,
    required int adjustQuantity,
    DateTime? time,
  }) async {
    try {
  return await _db.transaction(() async {
        // å…è®¸è´Ÿåº“å­˜ï¼šç›´æ¥åœ¨ç°æœ‰æ•°é‡ä¸Šè°ƒæ•´
        final ok = adjustQuantity >= 0
            ? await _inventoryRepository.addInventoryQuantity(
                productId,
                shopId,
                adjustQuantity,
              )
            : await _inventoryRepository.subtractInventoryQuantity(
                productId,
                shopId,
                -adjustQuantity,
              );
        if (!ok) return false;

        // è®°å½•è°ƒæ•´æµæ°´
        final transaction = InventoryTransactionModel.createAdjustment(
          productId: productId,
          quantity: adjustQuantity,
          shopId: shopId,
        );
        await _transactionRepository.addTransaction(transaction);
        return true;
      });
    } catch (e) {
      print('ğŸ“¦ åº“å­˜æœåŠ¡ï¼šåº“å­˜è°ƒæ•´å¤±è´? $e');
      return false;
    }
  }

  /// è·å–åº“å­˜ä¿¡æ¯
  Future<StockModel?> getInventory(int productId, int shopId) async {
    return await _inventoryRepository.getInventoryByProductAndShop(
      productId,
      shopId,
    );
  }

  /// è·å–åº—é“ºæ‰€æœ‰åº“å­?
  Future<List<StockModel>> getShopInventory(int shopId) async {
    return await _inventoryRepository.getInventoryByShop(shopId);
  }

  /// è·å–äº§å“åœ¨æ‰€æœ‰åº—é“ºçš„åº“å­˜
  Future<List<StockModel>> getProductInventory(int productId) async {
    return await _inventoryRepository.getInventoryByProduct(productId);
  }

  /// è·å–ä½åº“å­˜é¢„è­¦åˆ—è¡?
  Future<List<StockModel>> getLowStockInventory(
    int shopId,
    int warningLevel,
  ) async {
    return await _inventoryRepository.getLowStockInventory(
      shopId,
      warningLevel,
    );
  }

  /// è·å–ç¼ºè´§äº§å“åˆ—è¡¨
  Future<List<StockModel>> getOutOfStockInventory(int shopId) async {
    return await _inventoryRepository.getOutOfStockInventory(shopId);
  }

  /// è·å–åº“å­˜æµæ°´
  Future<List<InventoryTransactionModel>> getTransactions({
    int? productId,
    int? shopId,
    String? type,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    if (startDate != null && endDate != null) {
      return await _transactionRepository.getTransactionsByDateRange(
        startDate,
        endDate,
        shopId: shopId,
        productId: productId,
      );
    }

    if (productId != null && shopId != null) {
      return await _transactionRepository.getTransactionsByProductAndShop(
        productId,
        shopId,
      );
    }

    if (productId != null) {
      return await _transactionRepository.getTransactionsByProduct(productId);
    }

    if (shopId != null) {
      return await _transactionRepository.getTransactionsByShop(shopId);
    }

    if (type != null) {
      return await _transactionRepository.getTransactionsByType(type);
    }

    return await _transactionRepository.getAllTransactions();
  }
  /// åº“å­˜è°ƒæ•´çš„ä¸šåŠ¡é€»è¾‘
  ///
  /// [productId] äº§å“ID
  /// [quantity] è°ƒæ•´åçš„æ•°é‡
  /// [shopId] åº—é“ºID
  Future<void> adjustInventory({
    required int productId,
    required int quantity,
    required int shopId,
  }) async {
    // ä»¥â€œç›®æ ‡é‡-å½“å‰é‡â€ä¸ºè°ƒæ•´é¢ï¼Œå¤ç”¨ adjustï¼ˆå…è®¸è´Ÿåº“å­˜ï¼?
    final inventory = await _inventoryRepository.getInventoryByProductAndShop(
      productId,
      shopId,
    );
    final currentQuantity = inventory?.quantity ?? 0;
    final diff = quantity - currentQuantity;
    if (diff == 0) return;
    await adjust(
      productId: productId,
      shopId: shopId,
      adjustQuantity: diff,
    );
  }
}

/// åº“å­˜æœåŠ¡ Provider
final inventoryServiceProvider = Provider<InventoryService>((ref) {
  final inventoryRepository = ref.watch(inventoryRepositoryProvider);
  final transactionRepository = ref.watch(
    inventoryTransactionRepositoryProvider,
  );
  final db = ref.watch(appDatabaseProvider);
  return InventoryService(inventoryRepository, transactionRepository, db);
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';

/// æ ¹æ®æ‰¹æ¬¡å·è·å–æ‰¹æ¬¡ä¿¡æ?
final batchByNumberProvider =
    FutureProvider.family<ProductBatchData?, int>((ref, id) async {
  final db = ref.watch(appDatabaseProvider);
  return db.batchDao.getBatchByNumber(id);
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/shop.dart';
import '../../domain/repository/i_shop_repository.dart';
import '../../data/repository/shop_repository.dart';

/// åº—é“ºæ“ä½œçŠ¶æ€?
enum ShopOperationStatus { initial, loading, success, error }

/// åº—é“ºæ§åˆ¶å™¨çŠ¶æ€?
class ShopControllerState {
  final ShopOperationStatus status;
  final String? errorMessage;
  final Shop? lastOperatedShop;

  const ShopControllerState({
    this.status = ShopOperationStatus.initial,
    this.errorMessage,
    this.lastOperatedShop,
  });

  ShopControllerState copyWith({
    ShopOperationStatus? status,
    String? errorMessage,
    Shop? lastOperatedShop,
  }) {
    return ShopControllerState(
      status: status ?? this.status,
      errorMessage: errorMessage,
      lastOperatedShop: lastOperatedShop ?? this.lastOperatedShop,
    );
  }

  bool get isLoading => status == ShopOperationStatus.loading;
  bool get isError => status == ShopOperationStatus.error;
  bool get isSuccess => status == ShopOperationStatus.success;
}

/// åº—é“ºæ§åˆ¶å™?- ç®¡ç†åº—é“ºçš„å¢åˆ æ”¹æ“ä½œ
class ShopController extends StateNotifier<ShopControllerState> {
  final IShopRepository _repository;

  ShopController(this._repository) : super(const ShopControllerState());

  /// æ·»åŠ åº—é“º
  Future<void> addShop(Shop shop) async {
    state = state.copyWith(status: ShopOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹æ·»åŠ åº—é“?- ${shop.name}');

      // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨
      final exists = await _repository.isShopNameExists(shop.name);
      if (exists) {
        throw Exception('åº—é“ºåç§°å·²å­˜åœ?);
      }

      await _repository.addShop(shop);

      state = state.copyWith(
        status: ShopOperationStatus.success,
        lastOperatedShop: shop,
      );

      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºæ·»åŠ æˆåŠŸ');
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºæ·»åŠ å¤±è´¥: $e');
      state = state.copyWith(
        status: ShopOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// æ›´æ–°åº—é“º
  Future<void> updateShop(Shop shop) async {
    state = state.copyWith(status: ShopOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹æ›´æ–°åº—é“?- ${shop.name}');

      // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨ï¼ˆæ’é™¤å½“å‰åº—é“ºï¼‰
      final exists = await _repository.isShopNameExists(shop.name, shop.id);
      if (exists) {
        throw Exception('åº—é“ºåç§°å·²å­˜åœ?);
      }

      final success = await _repository.updateShop(shop);
      if (!success) {
        throw Exception('æ›´æ–°åº—é“ºå¤±è´¥');
      }

      state = state.copyWith(
        status: ShopOperationStatus.success,
        lastOperatedShop: shop,
      );

      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºæ›´æ–°æˆåŠŸ');
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºæ›´æ–°å¤±è´¥: $e');
      state = state.copyWith(
        status: ShopOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// åˆ é™¤åº—é“º
  Future<void> deleteShop(int id) async {
    state = state.copyWith(status: ShopOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹åˆ é™¤åº—é“ºID: $id');

      final deletedCount = await _repository.deleteShop(id);
      if (deletedCount == 0) {
        throw Exception('åˆ é™¤åº—é“ºå¤±è´¥ï¼Œåº—é“ºä¸å­˜åœ¨');
      }

      state = state.copyWith(status: ShopOperationStatus.success);

      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºåˆ é™¤æˆåŠŸ');
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šåº—é“ºåˆ é™¤å¤±è´¥: $e');
      state = state.copyWith(
        status: ShopOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// é‡ç½®çŠ¶æ€?
  void resetState() {
    state = const ShopControllerState();
  }
}

// =============================================================================
// Riverpod æä¾›è€…å®šä¹?
// =============================================================================

/// åº—é“ºæ§åˆ¶å™¨æä¾›è€?
final shopControllerProvider =
    StateNotifierProvider<ShopController, ShopControllerState>((ref) {
      final repository = ref.watch(shopRepositoryProvider);
      return ShopController(repository);
    });

/// è·å–æ‰€æœ‰åº—é“ºæä¾›è€?
final allShopsProvider = StreamProvider<List<Shop>>((ref) {
  final repository = ref.watch(shopRepositoryProvider);
  return repository.watchAllShops();
});

/// æ ¹æ®IDè·å–åº—é“ºæä¾›è€?
final shopByIdProvider = FutureProvider.family<Shop?, int>((ref, id) {
  final repository = ref.watch(shopRepositoryProvider);
  return repository.getShopById(id);
});

/// æ ¹æ®åç§°æœç´¢åº—é“ºæä¾›è€?
final searchShopsProvider = FutureProvider.family<List<Shop>, String>((
  ref,
  searchTerm,
) {
  final repository = ref.watch(shopRepositoryProvider);
  if (searchTerm.isEmpty) {
    return repository.getAllShops();
  }
  return repository.searchShopsByName(searchTerm);
});

/// åº—é“ºæ•°é‡æä¾›è€?
final shopCountProvider = FutureProvider<int>((ref) {
  final repository = ref.watch(shopRepositoryProvider);
  return repository.getShopCount();
});

/// æ£€æŸ¥åº—é“ºåç§°æ˜¯å¦å­˜åœ¨æä¾›è€?
final shopNameExistsProvider =
    FutureProvider.family<bool, Map<String, String?>>((ref, params) {
      final repository = ref.watch(shopRepositoryProvider);
      final name = params['name']!;
      final excludeIdString = params['excludeId'];
      final excludeId = excludeIdString == null || excludeIdString.isEmpty
          ? null
          : int.tryParse(excludeIdString);
      return repository.isShopNameExists(name, excludeId);
    });

/// å½“å‰é€‰ä¸­çš„åº—é“ºIDæä¾›è€?
final selectedShopIdProvider = StateProvider<int?>((ref) => null);

/// å½“å‰æ´»è·ƒåº—é“ºæä¾›è€?
final activeShopProvider = Provider<Shop?>((ref) {
  final selectedShopId = ref.watch(selectedShopIdProvider);
  if (selectedShopId == null) return null;

  final shopAsync = ref.watch(shopByIdProvider(selectedShopId));
  return shopAsync.when(
    data: (shop) => shop,
    loading: () => null,
    error: (error, stackTrace) => null,
  );
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart' as drift;
import '../../../../core/database/database.dart';

/// ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼è®¡ç®—æœåŠ¡
/// è´Ÿè´£è®¡ç®—å’Œæ›´æ–°åº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼
class WeightedAveragePriceService {
  final AppDatabase _database;

  WeightedAveragePriceService(this._database);

  /// è®¡ç®—å¹¶æ›´æ–°ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  /// å½“æœ‰æ–°çš„å…¥åº“æ—¶è°ƒç”¨æ­¤æ–¹æ³•
  /// æ³¨æ„ï¼šæ­¤æ–¹æ³•åªæ›´æ–°å¹³å‡ä»·æ ¼ï¼Œä¸æ›´æ–°åº“å­˜æ•°é‡ï¼ˆåº“å­˜æ•°é‡ç”?InventoryService.inbound è´Ÿè´£ï¼?
  Future<void> updateWeightedAveragePrice({
    required int productId,
    required int shopId,
    required int? batchId,
    required int inboundQuantity,
    required int inboundUnitPriceInCents,
  }) async {
    await _database.transaction(() async {
      // è·å–å½“å‰åº“å­˜ä¿¡æ¯
      final currentStock = await _database.inventoryDao
          .getInventoryByProductShopAndBatch(productId, shopId, batchId);

      if (currentStock == null) {
        // å¦‚æœæ²¡æœ‰ç°æœ‰åº“å­˜ï¼Œä¸åšä»»ä½•æ“ä½?
        // åº“å­˜è®°å½•ä¼šç”± InventoryService.inbound åˆ›å»º
        // è¿™é‡Œåªéœ€è¦åœ¨åº“å­˜åˆ›å»ºåæ›´æ–°å¹³å‡ä»·æ ¼å³å?
        return;
      } else {
        // è®¡ç®—æ–°çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼
        final currentQuantity = currentStock.quantity;
        final currentAveragePrice = currentStock.averageUnitPriceInCents;

        // ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼å…¬å¼ï¼?
        // æ–°å¹³å‡ä»·æ ?= (ç°æœ‰åº“å­˜æ•°é‡ Ã— ç°æœ‰å¹³å‡ä»·æ ¼ + å…¥åº“æ•°é‡ Ã— å…¥åº“å•ä»·) Ã· (ç°æœ‰åº“å­˜æ•°é‡ + å…¥åº“æ•°é‡)
        final totalValue =
            (currentQuantity * currentAveragePrice) +
            (inboundQuantity * inboundUnitPriceInCents);
        final totalQuantity = currentQuantity + inboundQuantity;

        final newAveragePrice = totalQuantity > 0
            ? (totalValue / totalQuantity).round()
            : 0;

        // åªæ›´æ–°å¹³å‡ä»·æ ¼ï¼Œä¸æ›´æ–°åº“å­˜æ•°é‡?
        await _database.inventoryDao.updateInventory(
          StockCompanion(
            id: drift.Value(currentStock.id),
            averageUnitPriceInCents: drift.Value(newAveragePrice),
            updatedAt: drift.Value(DateTime.now()),
          ),
        );
      }
    });
  }

  /// å‡ºåº“æ—¶æ›´æ–°ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  /// å‡ºåº“ä¸æ”¹å˜å¹³å‡ä»·æ ¼ï¼Œåªå‡å°‘æ•°é‡?
  Future<void> updateOnOutbound({
    required int productId,
    required int shopId,
    required int? batchId,
    required int outboundQuantity,
  }) async {
    final currentStock = await _database.inventoryDao
        .getInventoryByProductShopAndBatch(productId, shopId, batchId);

    if (currentStock != null) {
      final newQuantity = currentStock.quantity - outboundQuantity;

      await _database.inventoryDao.updateInventory(
        StockCompanion(
          id: drift.Value(currentStock.id),
          quantity: drift.Value(newQuantity),
          updatedAt: drift.Value(DateTime.now()),
        ),
      );
    }
  }

  /// è·å–æŒ‡å®šåº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  Future<int> getWeightedAveragePrice({
    required int productId,
    required int shopId,
    int? batchId,
  }) async {
    final stock = await _database.inventoryDao
        .getInventoryByProductShopAndBatch(productId, shopId, batchId);

    return stock?.averageUnitPriceInCents ?? 0;
  }

  /// æ‰¹é‡é‡æ–°è®¡ç®—æ‰€æœ‰åº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼
  /// åŸºäºå†å²å…¥åº“è®°å½•é‡æ–°è®¡ç®—ï¼Œç”¨äºæ•°æ®ä¿®å¤?
  Future<void> recalculateAllWeightedAveragePrices() async {
    await _database.transaction(() async {
      // è·å–æ‰€æœ‰åº“å­˜è®°å½?
      final allStocks = await _database.inventoryDao.getAllInventory();

      for (final stock in allStocks) {
        await _recalculateStockWeightedAveragePrice(
          productId: stock.productId,
          shopId: stock.shopId,
          batchId: stock.batchId,
        );
      }
    });
  }

  /// é‡æ–°è®¡ç®—å•ä¸ªåº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  Future<void> _recalculateStockWeightedAveragePrice({
    required int productId,
    required int shopId,
    int? batchId,
  }) async {
    // è·å–è¯¥åº“å­˜çš„æ‰€æœ‰å…¥åº“è®°å½•ï¼ŒæŒ‰æ—¶é—´æ’åº?
    final inboundRecords = await _getInboundRecordsForStock(
      productId: productId,
      shopId: shopId,
      batchId: batchId,
    );

    if (inboundRecords.isEmpty) return;

    int cumulativeQuantity = 0;
    int weightedAveragePrice = 0;

    // æŒ‰æ—¶é—´é¡ºåºé‡æ–°è®¡ç®—ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
    for (final record in inboundRecords) {
      final inboundQuantity = record['quantity'] as int;
      final inboundPrice = record['unitPriceInCents'] as int;

      if (cumulativeQuantity == 0) {
        // ç¬¬ä¸€æ¬¡å…¥åº?
        weightedAveragePrice = inboundPrice;
      } else {
        // è®¡ç®—æ–°çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼
        final totalValue =
            (cumulativeQuantity * weightedAveragePrice) +
            (inboundQuantity * inboundPrice);
        final totalQuantity = cumulativeQuantity + inboundQuantity;
        weightedAveragePrice = (totalValue / totalQuantity).round();
      }

      cumulativeQuantity += inboundQuantity;
    }

    // æ›´æ–°åº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
    final currentStock = await _database.inventoryDao
        .getInventoryByProductShopAndBatch(productId, shopId, batchId);

    if (currentStock != null) {
      await _database.inventoryDao.updateInventory(
        StockCompanion(
          id: drift.Value(currentStock.id),
          averageUnitPriceInCents: drift.Value(weightedAveragePrice),
          updatedAt: drift.Value(DateTime.now()),
        ),
      );
    }
  }

  /// è·å–æŒ‡å®šåº“å­˜çš„å…¥åº“è®°å½?
  Future<List<Map<String, dynamic>>> _getInboundRecordsForStock({
    required int productId,
    required int shopId,
    int? batchId,
  }) async {
    final batchCondition = batchId != null
        ? 'AND ii.batch_id = $batchId'
        : 'AND ii.batch_id IS NULL';

    final result = await _database
        .customSelect(
          '''
      SELECT ii.quantity, ii.unit_price_in_cents, ir.created_at
      FROM inbound_item ii
      JOIN inbound_receipt ir ON ii.receipt_id = ir.id
      WHERE ii.product_id = ? AND ir.shop_id = ? $batchCondition
      ORDER BY ir.created_at ASC
      ''',
          variables: [
            drift.Variable.withInt(productId),
            drift.Variable.withInt(shopId),
          ],
        )
        .get();

    return result
        .map(
          (row) => {
            'quantity': row.read<int>('quantity'),
            'unitPriceInCents': row.read<int>('unit_price_in_cents'),
            'createdAt': row.read<DateTime>('created_at'),
          },
        )
        .toList();
  }
}

/// ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼æœåŠ¡æä¾›è€?
final weightedAveragePriceServiceProvider =
    Provider<WeightedAveragePriceService>((ref) {
      final database = ref.watch(appDatabaseProvider);
      return WeightedAveragePriceService(database);
    });
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/inventory_table.dart';

part 'inventory_dao.g.dart';

@DriftAccessor(tables: [Stock])
class InventoryDao extends DatabaseAccessor<AppDatabase>
    with _$InventoryDaoMixin {
  InventoryDao(super.db);

  /// æ’å…¥åº“å­˜è®°å½•
  Future<int> insertInventory(StockCompanion inventory) {
    return into(stock).insert(inventory);
  }

  /// æ ¹æ®IDè·å–åº“å­˜
  Future<StockData?> getInventoryById(int id) {
    return (select(
      stock,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®äº§å“IDå’Œåº—é“ºIDè·å–åº“å­˜
  Future<StockData?> getInventoryByProductAndShop(
    int productId,
    int shopId,
  ) {
    // æ³¨æ„ï¼šåŒä¸€ productId + shopId å¯èƒ½å­˜åœ¨å¤šæ¡è®°å½•ï¼ˆä¸å?batchIdï¼‰ã€?
    // ä¸ºé¿å…?getSingleOrNull åœ¨å¤šè¡Œæ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œè¿™é‡Œé™å®šåªå–ä¸€æ¡ã€?
    return (select(stock)
          ..where(
            (t) => t.productId.equals(productId) & t.shopId.equals(shopId),
          )
          ..limit(1))
        .getSingleOrNull();
  }

  /// æ ¹æ®äº§å“ã€åº—é“ºä¸æ‰¹æ¬¡è·å–åº“å­˜ï¼ˆbatchId å¯ä¸ºç©ºï¼‰
  Future<StockData?> getInventoryByProductShopAndBatch(
    int productId,
    int shopId,
    int? batchId,
  ) {
    final query = select(stock)
      ..where((t) => t.productId.equals(productId) & t.shopId.equals(shopId));

    if (batchId == null) {
      query.where((t) => t.batchId.isNull());
    } else {
      query.where((t) => t.batchId.equals(batchId));
    }

    return query.getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰åº“å­?
  Future<List<StockData>> getAllInventory() async {
    try {
      return await select(stock).get();
    } catch (e) {
      print('ğŸ“¦ DAOå±‚ï¼šè·å–æ‰€æœ‰åº“å­˜æ•°æ®å¤±è´? $e');
      // å¦‚æœæ ‡å‡†æŸ¥è¯¢å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨åŸå§?SQL è¿‡æ»¤æœ‰é—®é¢˜çš„è®°å½•
      try {
        final result = await customSelect(
          'SELECT id, product_id, batch_id, quantity, average_unit_price_in_cents, shop_id, '
          'datetime(COALESCE(created_at, CURRENT_TIMESTAMP)) as created_at, '
          'datetime(COALESCE(updated_at, CURRENT_TIMESTAMP)) as updated_at '
          'FROM stock WHERE id IS NOT NULL AND product_id IS NOT NULL',
          readsFrom: {stock},
        ).get();
        
        return result.map((row) {
          final createdAtStr = row.readNullable<String>('created_at');
          final updatedAtStr = row.readNullable<String>('updated_at');

          return StockData(
            id: row.read<int>('id'),
            productId: row.read<int>('product_id'),
            batchId: row.readNullable<int>('batch_id'),
            quantity: row.read<int>('quantity'),
            averageUnitPriceInCents: row.read<int>('average_unit_price_in_cents'),
            shopId: row.read<int>('shop_id'),
            createdAt: DateTime.tryParse(createdAtStr ?? '') ?? DateTime.now(),
            updatedAt: DateTime.tryParse(updatedAtStr ?? '') ?? DateTime.now(),
          );
        }).toList();
      } catch (e2) {
        print('ğŸ“¦ DAOå±‚ï¼šå¤‡ç”¨æŸ¥è¯¢ä¹Ÿå¤±è´? $e2');
        return [];
      }
    }
  }

  /// æ ¹æ®åº—é“ºIDè·å–åº“å­˜åˆ—è¡¨
  Future<List<StockData>> getInventoryByShop(int shopId) {
    return (select(
      stock,
    )..where((t) => t.shopId.equals(shopId))).get();
  }

  /// æ ¹æ®äº§å“IDè·å–åº“å­˜åˆ—è¡¨
  Future<List<StockData>> getInventoryByProduct(int productId) {
    return (select(
      stock,
    )..where((t) => t.productId.equals(productId))).get();
  }

  /// ç›‘å¬æ‰€æœ‰åº“å­˜å˜åŒ?
  Stream<List<StockData>> watchAllInventory() {
    return select(stock).watch();
  }

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„åº“å­˜å˜åŒ?
  Stream<List<StockData>> watchInventoryByShop(int shopId) {
    return (select(
      stock,
    )..where((t) => t.shopId.equals(shopId))).watch();
  }

  /// ç›‘å¬æŒ‡å®šäº§å“çš„åº“å­˜å˜åŒ?
  Stream<List<StockData>> watchInventoryByProduct(int productId) {
    return (select(
      stock,
    )..where((t) => t.productId.equals(productId))).watch();
  }

  /// æ›´æ–°åº“å­˜
  Future<bool> updateInventory(StockCompanion inventory) async {
    final result = await (update(
      stock,
    )..where((t) => t.id.equals(inventory.id.value))).write(inventory);
    return result > 0;
  }

  /// åˆ é™¤åº“å­˜è®°å½•
  Future<int> deleteInventory(int id) {
    return (delete(stock)..where((t) => t.id.equals(id))).go();
  }

  /// æ ¹æ®äº§å“å’Œåº—é“ºåˆ é™¤åº“å­?
  Future<int> deleteInventoryByProductAndShop(int productId, int shopId) {
    return (delete(stock)..where(
          (t) => t.productId.equals(productId) & t.shopId.equals(shopId),
        ))
        .go();
  }

  /// æ›´æ–°åº“å­˜æ•°é‡
  Future<bool> updateInventoryQuantity(
    int productId,
    int shopId,
    int quantity,
  ) async {
    final result =
        await (update(stock)..where(
              (t) => t.productId.equals(productId) & t.shopId.equals(shopId),
            ))
            .write(
              StockCompanion(
                quantity: Value(quantity),
                updatedAt: Value(DateTime.now()),
              ),
            );
    return result > 0;
  }

  /// åŸå­å¢åŠ åº“å­˜æ•°é‡ï¼ˆå…è®¸è´Ÿåº“å­˜ï¼Œå•SQLæ›´æ–°ï¼?
  Future<int> incrementQuantity(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  ) async {
    if (batchId == null) {
      return await customUpdate(
  // Use milliseconds since epoch for updated_at to match Drift's int-backed DateTime
  'UPDATE stock SET quantity = quantity + ?, updated_at = CAST(strftime(\'%s\', \'now\') AS INTEGER) * 1000 '
        'WHERE product_id = ? AND shop_id = ? AND batch_id IS NULL',
        variables: [
          Variable.withInt(amount),
          Variable.withInt(productId),
          Variable.withInt(shopId),
        ],
        updates: {stock},
      );
    } else {
      return await customUpdate(
  // Use milliseconds since epoch for updated_at to match Drift's int-backed DateTime
  'UPDATE stock SET quantity = quantity + ?, updated_at = CAST(strftime(\'%s\', \'now\') AS INTEGER) * 1000 '
        'WHERE product_id = ? AND shop_id = ? AND batch_id = ?',
        variables: [
          Variable.withInt(amount),
          Variable.withInt(productId),
          Variable.withInt(shopId),
          Variable.withInt(batchId),
        ],
        updates: {stock},
      );
    }
  }

  /// åŸå­å‡å°‘åº“å­˜æ•°é‡ï¼ˆå…è®¸è´Ÿåº“å­˜ï¼Œä¸å?>=0 çº¦æŸï¼?
  Future<int> decrementQuantity(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  ) async {
    if (batchId == null) {
      return await customUpdate(
  // Use milliseconds since epoch for updated_at to match Drift's int-backed DateTime
  'UPDATE stock SET quantity = quantity - ?, updated_at = CAST(strftime(\'%s\', \'now\') AS INTEGER) * 1000 '
        'WHERE product_id = ? AND shop_id = ? AND batch_id IS NULL',
        variables: [
          Variable.withInt(amount),
          Variable.withInt(productId),
          Variable.withInt(shopId),
        ],
        updates: {stock},
      );
    } else {
      return await customUpdate(
  // Use milliseconds since epoch for updated_at to match Drift's int-backed DateTime
  'UPDATE stock SET quantity = quantity - ?, updated_at = CAST(strftime(\'%s\', \'now\') AS INTEGER) * 1000 '
        'WHERE product_id = ? AND shop_id = ? AND batch_id = ?',
        variables: [
          Variable.withInt(amount),
          Variable.withInt(productId),
          Variable.withInt(shopId),
          Variable.withInt(batchId),
        ],
        updates: {stock},
      );
    }
  }

  /// æŒ‰æ‰¹æ¬¡æ›´æ–°åº“å­˜æ•°é‡ï¼ˆbatchId å¯ä¸ºç©ºï¼‰
  Future<bool> updateInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int quantity,
  ) async {
    final updater = update(stock)
      ..where((t) => t.productId.equals(productId) & t.shopId.equals(shopId));

    if (batchId == null) {
      updater.where((t) => t.batchId.isNull());
    } else {
      updater.where((t) => t.batchId.equals(batchId));
    }

    final result = await updater.write(
      StockCompanion(
        quantity: Value(quantity),
        updatedAt: Value(DateTime.now()),
      ),
    );
    return result > 0;
  }

  /// è·å–ä½åº“å­˜äº§å“åˆ—è¡?
  Future<List<StockData>> getLowStockInventory(
    int shopId,
    int warningLevel,
  ) {
    return (select(stock)..where(
          (t) =>
              t.shopId.equals(shopId) &
              t.quantity.isSmallerOrEqualValue(warningLevel),
        ))
        .get();
  }

  /// è·å–ç¼ºè´§äº§å“åˆ—è¡¨
  Future<List<StockData>> getOutOfStockInventory(int shopId) {
    return (select(stock)..where(
          (t) => t.shopId.equals(shopId) & t.quantity.isSmallerOrEqualValue(0),
        ))
        .get();
  }

  /// è·å–åº“å­˜æ€»æ•°é‡ï¼ˆæŒ‰åº—é“ºï¼‰
  Future<double> getTotalInventoryByShop(int shopId) async {
    final result =
        await (selectOnly(stock)
              ..addColumns([stock.quantity.sum().cast<double>()])
              ..where(stock.shopId.equals(shopId)))
            .getSingle();
    return result.read(stock.quantity.sum().cast<double>()) ?? 0.0;
  }

  /// è·å–åº“å­˜æ€»æ•°é‡ï¼ˆæŒ‰äº§å“ï¼‰
  Future<double> getTotalInventoryByProduct(int productId) async {
    final result =
        await (selectOnly(stock)
              ..addColumns([stock.quantity.sum().cast<double>()])
              ..where(stock.productId.equals(productId)))
            .getSingle();
    return result.read(stock.quantity.sum().cast<double>()) ?? 0.0;
  }

  /// æ£€æŸ¥åº“å­˜æ˜¯å¦å­˜åœ?
  Future<bool> inventoryExists(int productId, int shopId) async {
    // ä½¿ç”¨å—é™æŸ¥è¯¢åˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼Œé¿å…å› å¤šæ¡è®°å½•å¯¼è‡´çš„å•è¡Œè¯»å–å¼‚å¸?
    final rows = await (select(stock)
          ..where(
            (t) => t.productId.equals(productId) & t.shopId.equals(shopId),
          )
          ..limit(1))
        .get();
    return rows.isNotEmpty;
  }

  /// è·å–åº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  Future<int> getAverageUnitPrice(int productId, int shopId, int? batchId) async {
    final stock = await getInventoryByProductShopAndBatch(productId, shopId, batchId);
    return stock?.averageUnitPriceInCents ?? 0;
  }

  /// æ›´æ–°åº“å­˜çš„ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ?
  Future<bool> updateAverageUnitPrice(
    int productId,
    int shopId,
    int? batchId,
    int averageUnitPriceInCents,
  ) async {
    final updater = update(stock)
      ..where((t) => t.productId.equals(productId) & t.shopId.equals(shopId));

    if (batchId == null) {
      updater.where((t) => t.batchId.isNull());
    } else {
      updater.where((t) => t.batchId.equals(batchId));
    }

    final result = await updater.write(
      StockCompanion(
        averageUnitPriceInCents: Value(averageUnitPriceInCents),
        updatedAt: Value(DateTime.now()),
      ),
    );
    return result > 0;
  }

  /// è·å–åº“å­˜æ€»ä»·å€¼ï¼ˆæ•°é‡ Ã— ç§»åŠ¨åŠ æƒå¹³å‡ä»·æ ¼ï¼?
  Future<double> getTotalInventoryValue(int shopId) async {
    final result = await customSelect(
      'SELECT SUM(quantity * average_unit_price_in_cents) as total_value FROM stock WHERE shop_id = ?',
      variables: [Variable.withInt(shopId)],
      readsFrom: {stock},
    ).getSingleOrNull();
    
    final totalValueInCents = result?.read<int>('total_value') ?? 0;
    return totalValueInCents / 100.0; // è½¬æ¢ä¸ºå…ƒ
  }

  /// è·å–æŒ‡å®šäº§å“çš„åº“å­˜æ€»ä»·å€?
  Future<double> getProductInventoryValue(int productId) async {
    final result = await customSelect(
      'SELECT SUM(quantity * average_unit_price_in_cents) as total_value FROM stock WHERE product_id = ?',
      variables: [Variable.withInt(productId)],
      readsFrom: {stock},
    ).getSingleOrNull();
    
    final totalValueInCents = result?.read<int>('total_value') ?? 0;
    return totalValueInCents / 100.0; // è½¬æ¢ä¸ºå…ƒ
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inventory_dao.dart';

// ignore_for_file: type=lint
mixin _$InventoryDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ShopTable get shop => attachedDatabase.shop;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $StockTable get stock => attachedDatabase.stock;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/inventory_transactions_table.dart';

part 'inventory_transaction_dao.g.dart';

@DriftAccessor(tables: [InventoryTransaction])
class InventoryTransactionDao extends DatabaseAccessor<AppDatabase>
    with _$InventoryTransactionDaoMixin {
  InventoryTransactionDao(super.db);

  /// æ’å…¥åº“å­˜æµæ°´è®°å½•
  Future<int> insertTransaction(
    InventoryTransactionCompanion transaction,
  ) {
    return into(inventoryTransaction).insert(transaction);
  }

  /// æ ¹æ®IDè·å–åº“å­˜æµæ°´
  Future<InventoryTransactionData?> getTransactionById(int id) {
    return (select(
      inventoryTransaction,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰åº“å­˜æµæ°?
  Future<List<InventoryTransactionData>> getAllTransactions() {
    return (select(
      inventoryTransaction,
    )..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).get();
  }

  /// æ ¹æ®äº§å“IDè·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionData>> getTransactionsByProduct(
    int productId,
  ) {
    return (select(inventoryTransaction)
          ..where((t) => t.productId.equals(productId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }

  /// æ ¹æ®åº—é“ºIDè·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionData>> getTransactionsByShop(
    int shopId,
  ) {
    return (select(inventoryTransaction)
          ..where((t) => t.shopId.equals(shopId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }

  /// æ ¹æ®æµæ°´ç±»å‹è·å–è®°å½•
  Future<List<InventoryTransactionData>> getTransactionsByType(
    String type,
  ) {
    return (select(inventoryTransaction)
          ..where((t) => t.transactionType.equals(type))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }

  /// æ ¹æ®äº§å“å’Œåº—é“ºè·å–æµæ°´è®°å½?
  Future<List<InventoryTransactionData>> getTransactionsByProductAndShop(
    int productId,
    int shopId,
  ) {
    return (select(inventoryTransaction)
          ..where(
            (t) => t.productId.equals(productId) & t.shopId.equals(shopId),
          )
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }

  /// æ ¹æ®æ—¶é—´èŒƒå›´è·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionData>> getTransactionsByDateRange(
    DateTime startDate,
    DateTime endDate, {
    int? shopId,
    int? productId,
  }) {
    var query = select(inventoryTransaction)
      ..where((t) => t.createdAt.isBetweenValues(startDate, endDate));

    if (shopId != null) {
      query = query..where((t) => t.shopId.equals(shopId));
    }

    if (productId != null) {
      query = query..where((t) => t.productId.equals(productId));
    }

    return (query..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).get();
  }

  /// ç›‘å¬æ‰€æœ‰åº“å­˜æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionData>> watchAllTransactions() {
    return (select(
      inventoryTransaction,
    )..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).watch();
  }

  /// ç›‘å¬æŒ‡å®šäº§å“çš„æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionData>> watchTransactionsByProduct(
    int productId,
  ) {
    return (select(inventoryTransaction)
          ..where((t) => t.productId.equals(productId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .watch();
  }

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionData>> watchTransactionsByShop(
    int shopId,
  ) {
    return (select(inventoryTransaction)
          ..where((t) => t.shopId.equals(shopId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .watch();
  }

  /// æ›´æ–°åº“å­˜æµæ°´
  Future<bool> updateTransaction(
    InventoryTransactionCompanion transaction,
  ) async {
    final result = await (update(
      inventoryTransaction,
    )..where((t) => t.id.equals(transaction.id.value))).write(transaction);
    return result > 0;
  }

  /// åˆ é™¤åº“å­˜æµæ°´è®°å½•
  Future<int> deleteTransaction(int id) {
    return (delete(
      inventoryTransaction,
    )..where((t) => t.id.equals(id))).go();
  }

  /// æ ¹æ®äº§å“åˆ é™¤ç›¸å…³æµæ°´
  Future<int> deleteTransactionsByProduct(int productId) {
    return (delete(
      inventoryTransaction,
    )..where((t) => t.productId.equals(productId))).go();
  }

  /// æ ¹æ®åº—é“ºåˆ é™¤ç›¸å…³æµæ°´
  Future<int> deleteTransactionsByShop(int shopId) {
    return (delete(
      inventoryTransaction,
    )..where((t) => t.shopId.equals(shopId))).go();
  }

  /// è·å–æœ€è¿‘çš„æµæ°´è®°å½•
  Future<List<InventoryTransactionData>> getRecentTransactions(
    int limit, {
    int? shopId,
    int? productId,
  }) {
    var query = select(inventoryTransaction);

    if (shopId != null) {
      query = query..where((t) => t.shopId.equals(shopId));
    }

    if (productId != null) {
      query = query..where((t) => t.productId.equals(productId));
    }

    return (query
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)])
          ..limit(limit))
        .get();
  }

  /// è·å–æµæ°´æ€»æ•°
  Future<int> getTransactionCount({
    int? shopId,
    int? productId,
    String? type,
  }) async {
    var query = selectOnly(inventoryTransaction)
      ..addColumns([inventoryTransaction.id.count()]);

    if (shopId != null) {
      query = query..where(inventoryTransaction.shopId.equals(shopId));
    }

    if (productId != null) {
      query = query
        ..where(inventoryTransaction.productId.equals(productId));
    }

    if (type != null) {
      query = query..where(inventoryTransaction.transactionType.equals(type));
    }

    final result = await query.getSingle();
    return result.read(inventoryTransaction.id.count()) ?? 0;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inventory_transaction_dao.dart';

// ignore_for_file: type=lint
mixin _$InventoryTransactionDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ShopTable get shop => attachedDatabase.shop;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $InventoryTransactionTable get inventoryTransaction =>
      attachedDatabase.inventoryTransaction;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/shops_table.dart';

part 'shop_dao.g.dart';

@DriftAccessor(tables: [Shop])
class ShopDao extends DatabaseAccessor<AppDatabase> with _$ShopDaoMixin {
  ShopDao(super.db);

  /// æ’å…¥åº—é“º
  Future<int> insertShop(ShopCompanion shop) {
    return into(db.shop).insert(shop);
  }

  /// æ ¹æ®IDè·å–åº—é“º
  Future<ShopData?> getShopById(int id) {
    return (select(
      shop,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®åç§°è·å–åº—é“º
  Future<ShopData?> getShopByName(String name) {
    return (select(
      shop,
    )..where((t) => t.name.equals(name))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰åº—é“?
  Future<List<ShopData>> getAllShops() {
    return select(shop).get();
  }

  /// ç›‘å¬æ‰€æœ‰åº—é“ºå˜åŒ?
  Stream<List<ShopData>> watchAllShops() {
    return select(shop).watch();
  }

  /// æ›´æ–°åº—é“º
  Future<bool> updateShop(ShopCompanion shop) async {
    final result = await (update(
      db.shop,
    )..where((t) => t.id.equals(shop.id.value))).write(shop);
    return result > 0;
  }

  /// åˆ é™¤åº—é“º
  Future<int> deleteShop(int id) {
    return (delete(shop)..where((t) => t.id.equals(id))).go();
  }

  /// æ ¹æ®åç§°æœç´¢åº—é“ºï¼ˆæ¨¡ç³Šæœç´¢ï¼‰
  Future<List<ShopData>> searchShopsByName(String searchTerm) {
    return (select(
      shop,
    )..where((t) => t.name.like('%$searchTerm%'))).get();
  }

  /// æ ¹æ®åº—é•¿æœç´¢åº—é“ºï¼ˆæ¨¡ç³Šæœç´¢ï¼‰
  Future<List<ShopData>> searchShopsByManager(String managerName) {
    return (select(
      shop,
    )..where((t) => t.manager.like('%$managerName%'))).get();
  }

  /// æ£€æŸ¥åº—é“ºåç§°æ˜¯å¦å­˜åœ¨ï¼ˆæ’é™¤æŒ‡å®šIDï¼?
  Future<bool> isShopNameExists(String name, [int? excludeId]) async {
    var query = select(shop)..where((t) => t.name.equals(name));

    if (excludeId != null) {
      query = query..where((t) => t.id.isNotValue(excludeId));
    }

    final result = await query.getSingleOrNull();
    return result != null;
  }

  /// è·å–åº—é“ºæ•°é‡
  Future<int> getShopCount() async {
    final result = await (selectOnly(
      shop,
    )..addColumns([shop.id.count()])).getSingle();
    return result.read(shop.id.count()) ?? 0;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'shop_dao.dart';

// ignore_for_file: type=lint
mixin _$ShopDaoMixin on DatabaseAccessor<AppDatabase> {
  $ShopTable get shop => attachedDatabase.shop;
}
import '../../domain/repository/i_inventory_repository.dart';
import '../../domain/model/inventory.dart';
import '../../../../core/database/database.dart';
import '../dao/inventory_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// åº“å­˜ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„åº“å­˜æ•°æ®è®¿é—®å±‚å®ç?
class InventoryRepository implements IInventoryRepository {
  final InventoryDao _inventoryDao;

  InventoryRepository(AppDatabase database)
    : _inventoryDao = database.inventoryDao;

  @override
  Future<int> addInventory(StockModel inventory) async {
    try {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ·»åŠ åº“å­˜è®°å½•ï¼ŒID: ${inventory.id}');
      // æ–°å¢æ—¶ä¸åº”å¼ºåˆ¶æºå¸¦è‡ªå¢ä¸»é”?ID
      final companion = StockCompanion(
        productId: Value(inventory.productId),
        quantity: Value(inventory.quantity),
        shopId: Value(inventory.shopId),
        batchId: Value(inventory.batchId),
        createdAt: inventory.createdAt != null
            ? Value(inventory.createdAt!)
            : const Value.absent(),
        updatedAt: Value(inventory.updatedAt ?? DateTime.now()),
      );
      return await _inventoryDao.insertInventory(companion);
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ·»åŠ åº“å­˜è®°å½•å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<StockModel?> getInventoryById(int id) async {
    try {
      final data = await _inventoryDao.getInventoryById(id);
      return data != null ? _dataToInventory(data) : null;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<StockModel?> getInventoryByProductAndShop(
    int productId,
    int shopId,
  ) async {
    try {
      final data = await _inventoryDao.getInventoryByProductAndShop(
        productId,
        shopId,
      );
      return data != null ? _dataToInventory(data) : null;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“å’Œåº—é“ºè·å–åº“å­˜å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<StockModel?> getInventoryByProductShopAndBatch(
    int productId,
    int shopId,
    int? batchId,
  ) async {
    try {
      final data = await _inventoryDao.getInventoryByProductShopAndBatch(
        productId,
        shopId,
        batchId,
      );
      return data != null ? _dataToInventory(data) : null;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“/åº—é“º/æ‰¹æ¬¡è·å–åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<StockModel>> getAllInventory() async {
    try {
      final dataList = await _inventoryDao.getAllInventory();
      return dataList.map(_dataToInventory).toList();
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰åº“å­˜å¤±è´? $e');
      // è¿”å›ç©ºåˆ—è¡¨è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸?
      return [];
    }
  }

  @override
  Future<List<StockModel>> getInventoryByShop(int shopId) async {
    try {
      final dataList = await _inventoryDao.getInventoryByShop(shopId);
      return dataList.map(_dataToInventory).toList();
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ ¹æ®åº—é“ºè·å–åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<StockModel>> getInventoryByProduct(int productId) async {
    try {
      final dataList = await _inventoryDao.getInventoryByProduct(productId);
      return dataList.map(_dataToInventory).toList();
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“è·å–åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Stream<List<StockModel>> watchAllInventory() {
    try {
      return _inventoryDao.watchAllInventory().map(
        (dataList) => dataList.map(_dataToInventory).toList(),
      );
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šç›‘å¬æ‰€æœ‰åº“å­˜å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<StockModel>> watchInventoryByShop(int shopId) {
    try {
      return _inventoryDao
          .watchInventoryByShop(shopId)
          .map((dataList) => dataList.map(_dataToInventory).toList());
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šç›‘å¬åº—é“ºåº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Stream<List<StockModel>> watchInventoryByProduct(int productId) {
    try {
      return _inventoryDao
          .watchInventoryByProduct(productId)
          .map((dataList) => dataList.map(_dataToInventory).toList());
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šç›‘å¬äº§å“åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateInventory(StockModel inventory) async {
    try {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ›´æ–°åº“å­˜ï¼ŒID: ${inventory.id}');
      return await _inventoryDao.updateInventory(
        _inventoryToCompanion(inventory),
      );
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ›´æ–°åº“å­˜å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteInventory(int id) async {
    try {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜è®°å½•ï¼ŒID: $id');
      return await _inventoryDao.deleteInventory(id);
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜è®°å½•å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteInventoryByProductAndShop(
    int productId,
    int shopId,
  ) async {
    try {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜è®°å½•ï¼Œäº§å“ID: $productId, åº—é“ºID: $shopId');
      return await _inventoryDao.deleteInventoryByProductAndShop(
        productId,
        shopId,
      );
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜è®°å½•å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateInventoryQuantity(
    int productId,
    int shopId,
    int quantity,
  ) async {
    try {
      return await _inventoryDao.updateInventoryQuantity(
        productId,
        shopId,
        quantity,
      );
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ›´æ–°åº“å­˜æ•°é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int quantity,
  ) async {
    try {
      return await _inventoryDao.updateInventoryQuantityByBatch(
        productId,
        shopId,
        batchId,
        quantity,
      );
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæŒ‰æ‰¹æ¬¡æ›´æ–°åº“å­˜æ•°é‡å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> addInventoryQuantity(
    int productId,
    int shopId,
    int amount,
  ) async {
    try {
      final affected = await _inventoryDao.incrementQuantity(
        productId,
        shopId,
        null,
        amount,
      );
      return affected > 0;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šå¢åŠ åº“å­˜æ•°é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> addInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  ) async {
    try {
      final affected = await _inventoryDao.incrementQuantity(
        productId,
        shopId,
        batchId,
        amount,
      );
      return affected > 0;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæŒ‰æ‰¹æ¬¡å¢åŠ åº“å­˜æ•°é‡å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> subtractInventoryQuantity(
    int productId,
    int shopId,
    int amount,
  ) async {
    try {
      final affected = await _inventoryDao.decrementQuantity(
        productId,
        shopId,
        null,
        amount,
      );
      return affected > 0;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šå‡å°‘åº“å­˜æ•°é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> subtractInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  ) async {
    try {
      final affected = await _inventoryDao.decrementQuantity(
        productId,
        shopId,
        batchId,
        amount,
      );
      return affected > 0;
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæŒ‰æ‰¹æ¬¡å‡å°‘åº“å­˜æ•°é‡å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<StockModel>> getLowStockInventory(
    int shopId,
    int warningLevel,
  ) async {
    try {
      final dataList = await _inventoryDao.getLowStockInventory(
        shopId,
        warningLevel,
      );
      return dataList.map(_dataToInventory).toList();
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šè·å–ä½åº“å­˜äº§å“å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<StockModel>> getOutOfStockInventory(int shopId) async {
    try {
      final dataList = await _inventoryDao.getOutOfStockInventory(shopId);
      return dataList.map(_dataToInventory).toList();
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šè·å–ç¼ºè´§äº§å“å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<double> getTotalInventoryByShop(int shopId) async {
    try {
      return await _inventoryDao.getTotalInventoryByShop(shopId);
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šè·å–åº—é“ºåº“å­˜æ€»é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<double> getTotalInventoryByProduct(int productId) async {
    try {
      return await _inventoryDao.getTotalInventoryByProduct(productId);
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šè·å–äº§å“åº“å­˜æ€»é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> inventoryExists(int productId, int shopId) async {
    try {
      return await _inventoryDao.inventoryExists(productId, shopId);
    } catch (e) {
      print('ğŸ“¦ ä»“å‚¨å±‚ï¼šæ£€æŸ¥åº“å­˜æ˜¯å¦å­˜åœ¨å¤±è´? $e');
      rethrow;
    }
  }

  /// å°†Inventoryæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companionå¯¹è±¡
  StockCompanion _inventoryToCompanion(StockModel inventory) {
    return StockCompanion(
      // å¯¹äºæ›´æ–°ç­‰éœ€è¦æŒ‡å®šè¡Œçš„åœºæ™¯ï¼Œid éœ€ç”±è°ƒç”¨æ–¹é€šè¿‡ where å­å¥æ§åˆ¶ï¼›æ­¤å¤„é¿å…å¼ºåˆ¶è¦æ±?
      id: inventory.id != null ? Value(inventory.id!) : const Value.absent(),
      productId: Value(inventory.productId),
      quantity: Value(inventory.quantity),
      shopId: Value(inventory.shopId),
      batchId: Value(inventory.batchId),
      createdAt: inventory.createdAt != null
          ? Value(inventory.createdAt!)
          : const Value.absent(),
      updatedAt: Value(inventory.updatedAt ?? DateTime.now()),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºInventoryæ¨¡å‹
  StockModel _dataToInventory(StockData data) {
    try {
      return StockModel(
        id: data.id,
        productId: data.productId,
        quantity: data.quantity,
        shopId: data.shopId,
        batchId: data.batchId,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
      );
    } catch (e) {
      print('ğŸ“¦ æ•°æ®è½¬æ¢å¤±è´¥: $e');
      print('ğŸ“¦ åŸå§‹æ•°æ®: id=${data.id}, productId=${data.productId}, quantity=${data.quantity}');
      rethrow;
    }
  }
}

/// Inventory Repository Provider
final inventoryRepositoryProvider = Provider<IInventoryRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return InventoryRepository(database);
});
import '../../domain/repository/i_inventory_transaction_repository.dart';
import '../../domain/model/inventory_transaction.dart';
import '../../../../core/database/database.dart';
import '../dao/inventory_transaction_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// åº“å­˜æµæ°´ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„åº“å­˜æµæ°´æ•°æ®è®¿é—®å±‚å®ç?
class InventoryTransactionRepository
    implements IInventoryTransactionRepository {
  final InventoryTransactionDao _transactionDao;

  InventoryTransactionRepository(AppDatabase database)
    : _transactionDao = database.inventoryTransactionDao;

  @override
  Future<int> addTransaction(InventoryTransactionModel transaction) async {
    try {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ·»åŠ åº“å­˜æµæ°´è®°å½•ï¼ŒID: ${transaction.id}');
      return await _transactionDao.insertTransaction(
        _transactionToCompanion(transaction),
      );
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ·»åŠ åº“å­˜æµæ°´è®°å½•å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<InventoryTransactionModel?> getTransactionById(int id) async {
    try {
      final data = await _transactionDao.getTransactionById(id);
      return data != null ? _dataToTransaction(data) : null;
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getAllTransactions() async {
    try {
      final dataList = await _transactionDao.getAllTransactions();
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰åº“å­˜æµæ°´å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getTransactionsByProduct(
    int productId,
  ) async {
    try {
      final dataList = await _transactionDao.getTransactionsByProduct(
        productId,
      );
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“è·å–åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getTransactionsByShop(
    int shopId,
  ) async {
    try {
      final dataList = await _transactionDao.getTransactionsByShop(shopId);
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®åº—é“ºè·å–åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getTransactionsByType(String type) async {
    try {
      final dataList = await _transactionDao.getTransactionsByType(
        _normalizeTypeToDbCode(type),
      );
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®ç±»å‹è·å–åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getTransactionsByProductAndShop(
    int productId,
    int shopId,
  ) async {
    try {
      final dataList = await _transactionDao.getTransactionsByProductAndShop(
        productId,
        shopId,
      );
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“å’Œåº—é“ºè·å–åº“å­˜æµæ°´å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getTransactionsByDateRange(
    DateTime startDate,
    DateTime endDate, {
    int? shopId,
    int? productId,
  }) async {
    try {
      final dataList = await _transactionDao.getTransactionsByDateRange(
        startDate,
        endDate,
        shopId: shopId,
        productId: productId,
      );
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ ¹æ®æ—¶é—´èŒƒå›´è·å–åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Stream<List<InventoryTransactionModel>> watchAllTransactions() {
    try {
      return _transactionDao.watchAllTransactions().map(
        (dataList) => dataList.map(_dataToTransaction).toList(),
      );
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šç›‘å¬æ‰€æœ‰åº“å­˜æµæ°´å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<InventoryTransactionModel>> watchTransactionsByProduct(
    int productId,
  ) {
    try {
      return _transactionDao
          .watchTransactionsByProduct(productId)
          .map((dataList) => dataList.map(_dataToTransaction).toList());
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šç›‘å¬äº§å“åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Stream<List<InventoryTransactionModel>> watchTransactionsByShop(int shopId) {
    try {
      return _transactionDao
          .watchTransactionsByShop(shopId)
          .map((dataList) => dataList.map(_dataToTransaction).toList());
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šç›‘å¬åº—é“ºåº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateTransaction(InventoryTransactionModel transaction) async {
    try {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ›´æ–°åº“å­˜æµæ°´ï¼ŒID: ${transaction.id}');
      return await _transactionDao.updateTransaction(
        _transactionToCompanion(transaction),
      );
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šæ›´æ–°åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteTransaction(int id) async {
    try {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜æµæ°´è®°å½•ï¼ŒID: $id');
      return await _transactionDao.deleteTransaction(id);
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šåˆ é™¤åº“å­˜æµæ°´è®°å½•å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteTransactionsByProduct(int productId) async {
    try {
      return await _transactionDao.deleteTransactionsByProduct(productId);
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“ç›¸å…³åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteTransactionsByShop(int shopId) async {
    try {
      return await _transactionDao.deleteTransactionsByShop(shopId);
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šåˆ é™¤åº—é“ºç›¸å…³åº“å­˜æµæ°´å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getInboundTransactions({
    int? shopId,
    int? productId,
  }) async {
  // ä½¿ç”¨æ•°æ®åº“çŸ­ç ï¼Œé¿å… name ä¸?DB å­˜å‚¨ä¸ä¸€è‡?
  return getTransactionsByType(InventoryTransactionType.inbound.toDbCode);
  }

  @override
  Future<List<InventoryTransactionModel>> getOutboundTransactions({
    int? shopId,
    int? productId,
  }) async {
  return getTransactionsByType(InventoryTransactionType.outbound.toDbCode);
  }

  @override
  Future<List<InventoryTransactionModel>> getAdjustmentTransactions({
    int? shopId,
    int? productId,
  }) async {
  return getTransactionsByType(InventoryTransactionType.adjustment.toDbCode);
  }

  @override
  Future<Map<String, double>> getTransactionSummaryByDateRange(
    DateTime startDate,
    DateTime endDate, {
    int? shopId,
    int? productId,
  }) async {
    try {
      final transactions = await getTransactionsByDateRange(
        startDate,
        endDate,
        shopId: shopId,
        productId: productId,
      );

      final summary = <String, double>{};
      for (final transaction in transactions) {
        summary[transaction.type.name] =
            (summary[transaction.type.name] ?? 0.0) + transaction.quantity;
      }

      return summary;
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šè·å–åº“å­˜æµæ°´æ±‡æ€»å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<InventoryTransactionModel>> getRecentTransactions(
    int limit, {
    int? shopId,
    int? productId,
  }) async {
    try {
      final dataList = await _transactionDao.getRecentTransactions(
        limit,
        shopId: shopId,
        productId: productId,
      );
      return dataList.map(_dataToTransaction).toList();
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šè·å–æœ€è¿‘åº“å­˜æµæ°´å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<int> getTransactionCount({
    int? shopId,
    int? productId,
    String? type,
  }) async {
    try {
      return await _transactionDao.getTransactionCount(
        shopId: shopId,
        productId: productId,
  type: type == null ? null : _normalizeTypeToDbCode(type),
      );
    } catch (e) {
      print('ğŸ“‹ ä»“å‚¨å±‚ï¼šè·å–åº“å­˜æµæ°´æ•°é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  /// å°†InventoryTransactionæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companionå¯¹è±¡
  InventoryTransactionCompanion _transactionToCompanion(
    InventoryTransactionModel transaction,
  ) {
    return InventoryTransactionCompanion(
      id: transaction.id == null ? const Value.absent() : Value(transaction.id!),
      productId: Value(transaction.productId),
    // æ•°æ®åº“å­˜çš?type å­—æ®µä½¿ç”¨çŸ­ç ï¼ˆin/out/adjust/transfer/returnï¼?
    transactionType: Value(transaction.type.toDbCode),
      quantity: Value(transaction.quantity),
      shopId: Value(transaction.shopId),
    batchId: transaction.batchId != null
      ? Value(transaction.batchId!)
      : const Value.absent(),
      createdAt: transaction.createdAt != null
          ? Value(transaction.createdAt!)
          : const Value.absent(),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºInventoryTransactionæ¨¡å‹
  InventoryTransactionModel _dataToTransaction(InventoryTransactionData data) {
    return InventoryTransactionModel(
      id: data.id,
      productId: data.productId,
  type: inventoryTransactionTypeFromDbCode(data.transactionType),
      quantity: data.quantity,
      shopId: data.shopId,
  batchId: data.batchId,
      createdAt: data.createdAt,
    );
  }

  /// å°†å¤–éƒ¨ä¼ å…¥çš„ç±»å‹å­—ç¬¦ä¸²æ ‡å‡†åŒ–ä¸ºæ•°æ®åº“çŸ­ç 
  /// æ”¯æŒä¼ å…¥ enum.nameï¼ˆå¦‚ 'inbound'ï¼‰æˆ–å·²æ˜¯çŸ­ç ï¼ˆå¦‚ 'in'ï¼?
  String _normalizeTypeToDbCode(String type) {
    final t = type.toLowerCase();
    switch (t) {
      case 'in':
      case 'inbound':
        return 'in';
      case 'out':
      case 'outbound':
        return 'out';
      case 'adjust':
      case 'adjustment':
        return 'adjust';
      case 'transfer':
        return 'transfer';
      case 'return':
      case 'returned':
        return 'return';
      default:
        return t;
    }
  }
}

/// InventoryTransaction Repository Provider
final inventoryTransactionRepositoryProvider =
    Provider<IInventoryTransactionRepository>((ref) {
      final database = ref.watch(appDatabaseProvider);
      return InventoryTransactionRepository(database);
    });
import '../../domain/repository/i_shop_repository.dart';
import '../../domain/model/shop.dart';
import '../../../../core/database/database.dart';
import '../dao/shop_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// åº—é“ºä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„åº—é“ºæ•°æ®è®¿é—®å±‚å®ç?
class ShopRepository implements IShopRepository {
  final ShopDao _shopDao;

  ShopRepository(AppDatabase database) : _shopDao = database.shopDao;

  @override
  Future<int> addShop(Shop shop) async {
    try {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ·»åŠ åº—é“ºï¼ŒID: ${shop.id}, åç§°: ${shop.name}');
      return await _shopDao.insertShop(_shopToCompanion(shop));
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ·»åŠ åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<Shop?> getShopById(int id) async {
    try {
      final data = await _shopDao.getShopById(id);
      return data != null ? _dataToShop(data) : null;
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<Shop?> getShopByName(String name) async {
    try {
      final data = await _shopDao.getShopByName(name);
      return data != null ? _dataToShop(data) : null;
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ ¹æ®åç§°è·å–åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<Shop>> getAllShops() async {
    try {
      final dataList = await _shopDao.getAllShops();
      return dataList.map(_dataToShop).toList();
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰åº—é“ºå¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<Shop>> watchAllShops() {
    try {
      return _shopDao.watchAllShops().map(
        (dataList) => dataList.map(_dataToShop).toList(),
      );
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šç›‘å¬æ‰€æœ‰åº—é“ºå¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateShop(Shop shop) async {
    try {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ›´æ–°åº—é“ºï¼ŒID: ${shop.id}');
      return await _shopDao.updateShop(_shopToCompanion(shop));
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ›´æ–°åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteShop(int id) async {
    try {
      print('ğŸª ä»“å‚¨å±‚ï¼šåˆ é™¤åº—é“ºï¼ŒID: $id');
      return await _shopDao.deleteShop(id);
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šåˆ é™¤åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> isShopNameExists(String name, [int? excludeId]) async {
    try {
      return await _shopDao.isShopNameExists(name, excludeId);
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ£€æŸ¥åº—é“ºåç§°æ˜¯å¦å­˜åœ¨å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<Shop>> searchShopsByName(String searchTerm) async {
    try {
      final dataList = await _shopDao.searchShopsByName(searchTerm);
      return dataList.map(_dataToShop).toList();
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ ¹æ®åç§°æœç´¢åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<Shop>> searchShopsByManager(String managerName) async {
    try {
      final dataList = await _shopDao.searchShopsByManager(managerName);
      return dataList.map(_dataToShop).toList();
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šæ ¹æ®åº—é•¿æœç´¢åº—é“ºå¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> getShopCount() async {
    try {
      return await _shopDao.getShopCount();
    } catch (e) {
      print('ğŸª ä»“å‚¨å±‚ï¼šè·å–åº—é“ºæ•°é‡å¤±è´¥: $e');
      rethrow;
    }
  }

  /// å°†Shopæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companionå¯¹è±¡
  ShopCompanion _shopToCompanion(Shop shop) {
    return ShopCompanion(
      id: shop.id == null ? const Value.absent() : Value(shop.id!),
      name: Value(shop.name),
      manager: Value(shop.manager),
      createdAt: shop.createdAt != null
          ? Value(shop.createdAt!)
          : const Value.absent(),
      updatedAt: Value(shop.updatedAt ?? DateTime.now()),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºShopæ¨¡å‹
  Shop _dataToShop(ShopData data) {
    return Shop(
      id: data.id,
      name: data.name,
      manager: data.manager,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
    );
  }
}

/// Shop Repository Provider
final shopRepositoryProvider = Provider<IShopRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return ShopRepository(database);
});
import 'package:freezed_annotation/freezed_annotation.dart';

part 'aggregated_inventory.freezed.dart';
part 'aggregated_inventory.g.dart';

/// èšåˆåçš„åº“å­˜é¡?
/// ç”¨äºåœ¨æœªç­›é€‰åº—é“ºæ—¶å±•ç¤ºåŒä¸€è´§å“çš„æ±‡æ€»ä¿¡æ?
@freezed
abstract class AggregatedInventoryItem with _$AggregatedInventoryItem {
  const factory AggregatedInventoryItem({
    required int productId,
    required String productName,
    String? productImage,
    required int totalQuantity,
    required String unit,
    int? categoryId,
    required String categoryName,
    required List<InventoryDetail> details,
    required double totalValue, // æ€»ä»·å€¼ï¼ˆå…ƒï¼‰
  }) = _AggregatedInventoryItem;

  const AggregatedInventoryItem._();

  factory AggregatedInventoryItem.fromJson(Map<String, dynamic> json) =>
      _$AggregatedInventoryItemFromJson(json);

  /// ä»åŸå§‹åº“å­˜æ•°æ®åˆ—è¡¨åˆ›å»ºèšåˆé¡¹
  ///
  /// [inventoryItems] ç›¸åŒè´§å“çš„æ‰€æœ‰åº“å­˜è®°å½?
  factory AggregatedInventoryItem.fromInventoryList(
    List<Map<String, dynamic>> inventoryItems,
  ) {
    if (inventoryItems.isEmpty) {
      throw ArgumentError('åº“å­˜åˆ—è¡¨ä¸èƒ½ä¸ºç©º');
    }

    final firstItem = inventoryItems.first;

    // è®¡ç®—æ€»åº“å­˜æ•°é‡?
    final totalQuantity = inventoryItems.fold<int>(
      0,
      (sum, item) => sum + (item['quantity'] as int? ?? 0),
    );

    // è®¡ç®—æ€»ä»·å€¼ï¼ˆæ•°é‡ Ã— è¿›è´§ä»·æ ¼ï¼Œä»·æ ¼ä»åˆ†è½¬æ¢ä¸ºå…ƒï¼‰
    final totalValue = inventoryItems.fold<double>(
      0,
      (sum, item) =>
          sum +
          (item['quantity'] as num? ?? 0) *
              (item['purchasePrice'] as num? ?? 0) /
              100,
    );

    // æ„å»ºè¯¦ç»†è®°å½•åˆ—è¡¨
    final details = inventoryItems
        .map((item) => InventoryDetail.fromMap(item))
        .toList();

    return AggregatedInventoryItem(
      productId: firstItem['productId'] as int,
      productName: firstItem['productName'] as String,
      productImage: firstItem['productImage'] as String?,
      totalQuantity: totalQuantity,
      unit: firstItem['unit'] as String? ?? 'ä¸?,
      categoryId: firstItem['categoryId'] as int?,
      categoryName: firstItem['categoryName'] as String? ?? 'æœªåˆ†ç±?,
      details: details,
      totalValue: totalValue,
    );
  }

  /// è·å–æœ€çŸ­å‰©ä½™ä¿è´¨æœŸï¼ˆå¤©æ•°ï¼‰
  /// å¦‚æœæ²¡æœ‰ä¿è´¨æœŸä¿¡æ¯ï¼Œè¿”å›null
  int? get minRemainingDays {
    final daysWithShelfLife = details
        .where((d) => d.remainingDays != null)
        .map((d) => d.remainingDays!)
        .toList();

    if (daysWithShelfLife.isEmpty) return null;

    return daysWithShelfLife.reduce((a, b) => a < b ? a : b);
  }

  /// æ˜¯å¦æœ‰å³å°†è¿‡æœŸçš„æ‰¹æ¬¡ï¼ˆå‰©ä½™ä¿è´¨æœŸ <= 30å¤©ï¼‰
  bool get hasExpiringSoon {
    final minDays = minRemainingDays;
    return minDays != null && minDays <= 30;
  }

  /// æ˜¯å¦æœ‰å·²è¿‡æœŸçš„æ‰¹æ¬?
  bool get hasExpired {
    final minDays = minRemainingDays;
    return minDays != null && minDays <= 0;
  }

  /// æ˜¯å¦å¯å±•å¼€ï¼ˆåˆ¤æ–­æ˜¯å¦æœ‰å¤šæ¡è®°å½•ï¼?
  /// ä»…å½“æœ?æ¡æˆ–ä»¥ä¸Šè®°å½•æ—¶æ‰éœ€è¦å±•å¼€/æ”¶èµ·åŠŸèƒ½
  bool get isExpandable => details.length > 1;
}

/// åº“å­˜è¯¦ç»†ä¿¡æ¯
/// è¡¨ç¤ºå•ä¸ªåº—é“º-æ‰¹æ¬¡ç»„åˆçš„åº“å­˜è®°å½?
@freezed
abstract class InventoryDetail with _$InventoryDetail {
  const factory InventoryDetail({
    required int stockId,
    required int shopId,
    required String shopName,
    required int quantity,
    int? batchId,
    String? batchNumber,
    DateTime? productionDate,
    int? shelfLifeDays,
    String? shelfLifeUnit,
    int? remainingDays,
    int? purchasePrice, // è¿›è´§ä»·æ ¼ï¼ˆåˆ†ï¼?
  }) = _InventoryDetail;

  const InventoryDetail._();

  factory InventoryDetail.fromJson(Map<String, dynamic> json) =>
      _$InventoryDetailFromJson(json);

  /// ä»åŸå§‹åº“å­˜æ•°æ®Mapåˆ›å»ºè¯¦ç»†è®°å½•
  factory InventoryDetail.fromMap(Map<String, dynamic> map) {
    // è®¡ç®—å‰©ä½™ä¿è´¨æœŸå¤©æ•?
    int? remainingDays;
    if (map['productionDate'] != null && map['shelfLifeDays'] != null) {
      try {
        final productionDate = map['productionDate'] is String
            ? DateTime.parse(map['productionDate'] as String)
            : map['productionDate'] as DateTime;

        final shelfLifeValue = map['shelfLifeDays'] as int;
        final shelfLifeUnit = map['shelfLifeUnit'] as String?;
        
        // æ ¹æ®å•ä½å°†ä¿è´¨æœŸè½¬æ¢ä¸ºå¤©æ•?
        int shelfLifeInDays;
        if (shelfLifeUnit == 'years') {
          shelfLifeInDays = shelfLifeValue * 365;
        } else if (shelfLifeUnit == 'months') {
          shelfLifeInDays = shelfLifeValue * 30;
        } else {
          // é»˜è®¤ä¸ºå¤©
          shelfLifeInDays = shelfLifeValue;
        }
        
        final expiryDate = productionDate.add(Duration(days: shelfLifeInDays));

        // è®¡ç®—å‰©ä½™å¤©æ•°ï¼šå°†å½“å‰æ—¥æœŸå’Œè¿‡æœŸæ—¥æœŸéƒ½å½’é›¶åˆ°åˆå¤œï¼Œç„¶åè®¡ç®—å¤©æ•°å·?
        final now = DateTime.now();
        final today = DateTime(now.year, now.month, now.day);
        final expiry = DateTime(
          expiryDate.year,
          expiryDate.month,
          expiryDate.day,
        );
        remainingDays = expiry.difference(today).inDays;
      } catch (e) {
        // å¦‚æœæ—¥æœŸè§£æå¤±è´¥ï¼Œä¿æŒä¸ºnull
        remainingDays = null;
      }
    }

    return InventoryDetail(
      stockId: map['id'] as int,
      shopId: map['shopId'] as int,
      shopName: map['shopName'] as String? ?? 'æœªçŸ¥åº—é“º',
      quantity: map['quantity'] as int? ?? 0,
      batchId: map['batchNumber'] as int?,
      batchNumber: map['batchNumber']?.toString(),
      productionDate: map['productionDate'] != null
          ? (map['productionDate'] is String
                ? DateTime.tryParse(map['productionDate'] as String)
                : map['productionDate'] as DateTime?)
          : null,
      shelfLifeDays: map['shelfLifeDays'] as int?,
      shelfLifeUnit: map['shelfLifeUnit'] as String?,
      remainingDays: remainingDays,
      purchasePrice: map['purchasePrice'] as int?,
    );
  }

  /// è·å–ç”Ÿäº§æ—¥æœŸæ˜¾ç¤ºæ–‡æœ¬
  String get batchDisplayText {
    if (productionDate != null) {
      return _formatDate(productionDate!);
    }
    return '-';
  }

  /// è·å–å‰©ä½™ä¿è´¨æœŸæ˜¾ç¤ºæ–‡æœ?
  String get remainingDaysDisplayText {
    if (remainingDays == null) return '-';

    if (remainingDays! < 0) {
      return 'å·²è¿‡æœ?{-remainingDays!}å¤?;
    } else if (remainingDays! == 0) {
      return 'ä»Šå¤©è¿‡æœŸ';
    } else {
      return 'å‰©ä½™$remainingDayså¤?;
    }
  }

  /// è·å–ä¿è´¨æœŸçŠ¶æ€é¢œè‰?
  /// è¿”å›é¢œè‰²ä»£ç ï¼šred(å·²è¿‡æœ?, orange(7å¤©å†…), yellow(30å¤©å†…), green(æ­£å¸¸)
  String get shelfLifeColorStatus {
    if (remainingDays == null) return 'normal';

    if (remainingDays! <= 0) {
      return 'expired'; // çº¢è‰²
    } else if (remainingDays! <= 7) {
      return 'critical'; // æ©™è‰²
    } else if (remainingDays! <= 30) {
      return 'warning'; // é»„è‰²
    } else {
      return 'normal'; // ç»¿è‰²/æ­£å¸¸
    }
  }

  /// æ˜¯å¦å³å°†è¿‡æœŸï¼?0å¤©å†…ï¼?
  bool get isExpiringSoon {
    return remainingDays != null && remainingDays! > 0 && remainingDays! <= 30;
  }

  /// æ˜¯å¦å·²è¿‡æœ?
  bool get isExpired {
    return remainingDays != null && remainingDays! <= 0;
  }

  /// æ ¼å¼åŒ–æ—¥æœŸä¸º yyyy-MM-dd
  static String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'aggregated_inventory.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AggregatedInventoryItem {

 int get productId; String get productName; String? get productImage; int get totalQuantity; String get unit; int? get categoryId; String get categoryName; List<InventoryDetail> get details; double get totalValue;
/// Create a copy of AggregatedInventoryItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AggregatedInventoryItemCopyWith<AggregatedInventoryItem> get copyWith => _$AggregatedInventoryItemCopyWithImpl<AggregatedInventoryItem>(this as AggregatedInventoryItem, _$identity);

  /// Serializes this AggregatedInventoryItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AggregatedInventoryItem&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.productName, productName) || other.productName == productName)&&(identical(other.productImage, productImage) || other.productImage == productImage)&&(identical(other.totalQuantity, totalQuantity) || other.totalQuantity == totalQuantity)&&(identical(other.unit, unit) || other.unit == unit)&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.categoryName, categoryName) || other.categoryName == categoryName)&&const DeepCollectionEquality().equals(other.details, details)&&(identical(other.totalValue, totalValue) || other.totalValue == totalValue));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,productId,productName,productImage,totalQuantity,unit,categoryId,categoryName,const DeepCollectionEquality().hash(details),totalValue);

@override
String toString() {
  return 'AggregatedInventoryItem(productId: $productId, productName: $productName, productImage: $productImage, totalQuantity: $totalQuantity, unit: $unit, categoryId: $categoryId, categoryName: $categoryName, details: $details, totalValue: $totalValue)';
}


}

/// @nodoc
abstract mixin class $AggregatedInventoryItemCopyWith<$Res>  {
  factory $AggregatedInventoryItemCopyWith(AggregatedInventoryItem value, $Res Function(AggregatedInventoryItem) _then) = _$AggregatedInventoryItemCopyWithImpl;
@useResult
$Res call({
 int productId, String productName, String? productImage, int totalQuantity, String unit, int? categoryId, String categoryName, List<InventoryDetail> details, double totalValue
});




}
/// @nodoc
class _$AggregatedInventoryItemCopyWithImpl<$Res>
    implements $AggregatedInventoryItemCopyWith<$Res> {
  _$AggregatedInventoryItemCopyWithImpl(this._self, this._then);

  final AggregatedInventoryItem _self;
  final $Res Function(AggregatedInventoryItem) _then;

/// Create a copy of AggregatedInventoryItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? productId = null,Object? productName = null,Object? productImage = freezed,Object? totalQuantity = null,Object? unit = null,Object? categoryId = freezed,Object? categoryName = null,Object? details = null,Object? totalValue = null,}) {
  return _then(_self.copyWith(
productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,productName: null == productName ? _self.productName : productName // ignore: cast_nullable_to_non_nullable
as String,productImage: freezed == productImage ? _self.productImage : productImage // ignore: cast_nullable_to_non_nullable
as String?,totalQuantity: null == totalQuantity ? _self.totalQuantity : totalQuantity // ignore: cast_nullable_to_non_nullable
as int,unit: null == unit ? _self.unit : unit // ignore: cast_nullable_to_non_nullable
as String,categoryId: freezed == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int?,categoryName: null == categoryName ? _self.categoryName : categoryName // ignore: cast_nullable_to_non_nullable
as String,details: null == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as List<InventoryDetail>,totalValue: null == totalValue ? _self.totalValue : totalValue // ignore: cast_nullable_to_non_nullable
as double,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _AggregatedInventoryItem extends AggregatedInventoryItem {
  const _AggregatedInventoryItem({required this.productId, required this.productName, this.productImage, required this.totalQuantity, required this.unit, this.categoryId, required this.categoryName, required final  List<InventoryDetail> details, required this.totalValue}): _details = details,super._();
  factory _AggregatedInventoryItem.fromJson(Map<String, dynamic> json) => _$AggregatedInventoryItemFromJson(json);

@override final  int productId;
@override final  String productName;
@override final  String? productImage;
@override final  int totalQuantity;
@override final  String unit;
@override final  int? categoryId;
@override final  String categoryName;
 final  List<InventoryDetail> _details;
@override List<InventoryDetail> get details {
  if (_details is EqualUnmodifiableListView) return _details;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_details);
}

@override final  double totalValue;

/// Create a copy of AggregatedInventoryItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AggregatedInventoryItemCopyWith<_AggregatedInventoryItem> get copyWith => __$AggregatedInventoryItemCopyWithImpl<_AggregatedInventoryItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AggregatedInventoryItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AggregatedInventoryItem&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.productName, productName) || other.productName == productName)&&(identical(other.productImage, productImage) || other.productImage == productImage)&&(identical(other.totalQuantity, totalQuantity) || other.totalQuantity == totalQuantity)&&(identical(other.unit, unit) || other.unit == unit)&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.categoryName, categoryName) || other.categoryName == categoryName)&&const DeepCollectionEquality().equals(other._details, _details)&&(identical(other.totalValue, totalValue) || other.totalValue == totalValue));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,productId,productName,productImage,totalQuantity,unit,categoryId,categoryName,const DeepCollectionEquality().hash(_details),totalValue);

@override
String toString() {
  return 'AggregatedInventoryItem(productId: $productId, productName: $productName, productImage: $productImage, totalQuantity: $totalQuantity, unit: $unit, categoryId: $categoryId, categoryName: $categoryName, details: $details, totalValue: $totalValue)';
}


}

/// @nodoc
abstract mixin class _$AggregatedInventoryItemCopyWith<$Res> implements $AggregatedInventoryItemCopyWith<$Res> {
  factory _$AggregatedInventoryItemCopyWith(_AggregatedInventoryItem value, $Res Function(_AggregatedInventoryItem) _then) = __$AggregatedInventoryItemCopyWithImpl;
@override @useResult
$Res call({
 int productId, String productName, String? productImage, int totalQuantity, String unit, int? categoryId, String categoryName, List<InventoryDetail> details, double totalValue
});




}
/// @nodoc
class __$AggregatedInventoryItemCopyWithImpl<$Res>
    implements _$AggregatedInventoryItemCopyWith<$Res> {
  __$AggregatedInventoryItemCopyWithImpl(this._self, this._then);

  final _AggregatedInventoryItem _self;
  final $Res Function(_AggregatedInventoryItem) _then;

/// Create a copy of AggregatedInventoryItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? productId = null,Object? productName = null,Object? productImage = freezed,Object? totalQuantity = null,Object? unit = null,Object? categoryId = freezed,Object? categoryName = null,Object? details = null,Object? totalValue = null,}) {
  return _then(_AggregatedInventoryItem(
productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,productName: null == productName ? _self.productName : productName // ignore: cast_nullable_to_non_nullable
as String,productImage: freezed == productImage ? _self.productImage : productImage // ignore: cast_nullable_to_non_nullable
as String?,totalQuantity: null == totalQuantity ? _self.totalQuantity : totalQuantity // ignore: cast_nullable_to_non_nullable
as int,unit: null == unit ? _self.unit : unit // ignore: cast_nullable_to_non_nullable
as String,categoryId: freezed == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int?,categoryName: null == categoryName ? _self.categoryName : categoryName // ignore: cast_nullable_to_non_nullable
as String,details: null == details ? _self._details : details // ignore: cast_nullable_to_non_nullable
as List<InventoryDetail>,totalValue: null == totalValue ? _self.totalValue : totalValue // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}


/// @nodoc
mixin _$InventoryDetail {

 int get stockId; int get shopId; String get shopName; int get quantity; int? get batchId; String? get batchNumber; DateTime? get productionDate; int? get shelfLifeDays; String? get shelfLifeUnit; int? get remainingDays; int? get purchasePrice;
/// Create a copy of InventoryDetail
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InventoryDetailCopyWith<InventoryDetail> get copyWith => _$InventoryDetailCopyWithImpl<InventoryDetail>(this as InventoryDetail, _$identity);

  /// Serializes this InventoryDetail to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InventoryDetail&&(identical(other.stockId, stockId) || other.stockId == stockId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.shopName, shopName) || other.shopName == shopName)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.batchNumber, batchNumber) || other.batchNumber == batchNumber)&&(identical(other.productionDate, productionDate) || other.productionDate == productionDate)&&(identical(other.shelfLifeDays, shelfLifeDays) || other.shelfLifeDays == shelfLifeDays)&&(identical(other.shelfLifeUnit, shelfLifeUnit) || other.shelfLifeUnit == shelfLifeUnit)&&(identical(other.remainingDays, remainingDays) || other.remainingDays == remainingDays)&&(identical(other.purchasePrice, purchasePrice) || other.purchasePrice == purchasePrice));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,stockId,shopId,shopName,quantity,batchId,batchNumber,productionDate,shelfLifeDays,shelfLifeUnit,remainingDays,purchasePrice);

@override
String toString() {
  return 'InventoryDetail(stockId: $stockId, shopId: $shopId, shopName: $shopName, quantity: $quantity, batchId: $batchId, batchNumber: $batchNumber, productionDate: $productionDate, shelfLifeDays: $shelfLifeDays, shelfLifeUnit: $shelfLifeUnit, remainingDays: $remainingDays, purchasePrice: $purchasePrice)';
}


}

/// @nodoc
abstract mixin class $InventoryDetailCopyWith<$Res>  {
  factory $InventoryDetailCopyWith(InventoryDetail value, $Res Function(InventoryDetail) _then) = _$InventoryDetailCopyWithImpl;
@useResult
$Res call({
 int stockId, int shopId, String shopName, int quantity, int? batchId, String? batchNumber, DateTime? productionDate, int? shelfLifeDays, String? shelfLifeUnit, int? remainingDays, int? purchasePrice
});




}
/// @nodoc
class _$InventoryDetailCopyWithImpl<$Res>
    implements $InventoryDetailCopyWith<$Res> {
  _$InventoryDetailCopyWithImpl(this._self, this._then);

  final InventoryDetail _self;
  final $Res Function(InventoryDetail) _then;

/// Create a copy of InventoryDetail
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? stockId = null,Object? shopId = null,Object? shopName = null,Object? quantity = null,Object? batchId = freezed,Object? batchNumber = freezed,Object? productionDate = freezed,Object? shelfLifeDays = freezed,Object? shelfLifeUnit = freezed,Object? remainingDays = freezed,Object? purchasePrice = freezed,}) {
  return _then(_self.copyWith(
stockId: null == stockId ? _self.stockId : stockId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,shopName: null == shopName ? _self.shopName : shopName // ignore: cast_nullable_to_non_nullable
as String,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,batchNumber: freezed == batchNumber ? _self.batchNumber : batchNumber // ignore: cast_nullable_to_non_nullable
as String?,productionDate: freezed == productionDate ? _self.productionDate : productionDate // ignore: cast_nullable_to_non_nullable
as DateTime?,shelfLifeDays: freezed == shelfLifeDays ? _self.shelfLifeDays : shelfLifeDays // ignore: cast_nullable_to_non_nullable
as int?,shelfLifeUnit: freezed == shelfLifeUnit ? _self.shelfLifeUnit : shelfLifeUnit // ignore: cast_nullable_to_non_nullable
as String?,remainingDays: freezed == remainingDays ? _self.remainingDays : remainingDays // ignore: cast_nullable_to_non_nullable
as int?,purchasePrice: freezed == purchasePrice ? _self.purchasePrice : purchasePrice // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _InventoryDetail extends InventoryDetail {
  const _InventoryDetail({required this.stockId, required this.shopId, required this.shopName, required this.quantity, this.batchId, this.batchNumber, this.productionDate, this.shelfLifeDays, this.shelfLifeUnit, this.remainingDays, this.purchasePrice}): super._();
  factory _InventoryDetail.fromJson(Map<String, dynamic> json) => _$InventoryDetailFromJson(json);

@override final  int stockId;
@override final  int shopId;
@override final  String shopName;
@override final  int quantity;
@override final  int? batchId;
@override final  String? batchNumber;
@override final  DateTime? productionDate;
@override final  int? shelfLifeDays;
@override final  String? shelfLifeUnit;
@override final  int? remainingDays;
@override final  int? purchasePrice;

/// Create a copy of InventoryDetail
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InventoryDetailCopyWith<_InventoryDetail> get copyWith => __$InventoryDetailCopyWithImpl<_InventoryDetail>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InventoryDetailToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InventoryDetail&&(identical(other.stockId, stockId) || other.stockId == stockId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.shopName, shopName) || other.shopName == shopName)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.batchNumber, batchNumber) || other.batchNumber == batchNumber)&&(identical(other.productionDate, productionDate) || other.productionDate == productionDate)&&(identical(other.shelfLifeDays, shelfLifeDays) || other.shelfLifeDays == shelfLifeDays)&&(identical(other.shelfLifeUnit, shelfLifeUnit) || other.shelfLifeUnit == shelfLifeUnit)&&(identical(other.remainingDays, remainingDays) || other.remainingDays == remainingDays)&&(identical(other.purchasePrice, purchasePrice) || other.purchasePrice == purchasePrice));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,stockId,shopId,shopName,quantity,batchId,batchNumber,productionDate,shelfLifeDays,shelfLifeUnit,remainingDays,purchasePrice);

@override
String toString() {
  return 'InventoryDetail(stockId: $stockId, shopId: $shopId, shopName: $shopName, quantity: $quantity, batchId: $batchId, batchNumber: $batchNumber, productionDate: $productionDate, shelfLifeDays: $shelfLifeDays, shelfLifeUnit: $shelfLifeUnit, remainingDays: $remainingDays, purchasePrice: $purchasePrice)';
}


}

/// @nodoc
abstract mixin class _$InventoryDetailCopyWith<$Res> implements $InventoryDetailCopyWith<$Res> {
  factory _$InventoryDetailCopyWith(_InventoryDetail value, $Res Function(_InventoryDetail) _then) = __$InventoryDetailCopyWithImpl;
@override @useResult
$Res call({
 int stockId, int shopId, String shopName, int quantity, int? batchId, String? batchNumber, DateTime? productionDate, int? shelfLifeDays, String? shelfLifeUnit, int? remainingDays, int? purchasePrice
});




}
/// @nodoc
class __$InventoryDetailCopyWithImpl<$Res>
    implements _$InventoryDetailCopyWith<$Res> {
  __$InventoryDetailCopyWithImpl(this._self, this._then);

  final _InventoryDetail _self;
  final $Res Function(_InventoryDetail) _then;

/// Create a copy of InventoryDetail
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? stockId = null,Object? shopId = null,Object? shopName = null,Object? quantity = null,Object? batchId = freezed,Object? batchNumber = freezed,Object? productionDate = freezed,Object? shelfLifeDays = freezed,Object? shelfLifeUnit = freezed,Object? remainingDays = freezed,Object? purchasePrice = freezed,}) {
  return _then(_InventoryDetail(
stockId: null == stockId ? _self.stockId : stockId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,shopName: null == shopName ? _self.shopName : shopName // ignore: cast_nullable_to_non_nullable
as String,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,batchNumber: freezed == batchNumber ? _self.batchNumber : batchNumber // ignore: cast_nullable_to_non_nullable
as String?,productionDate: freezed == productionDate ? _self.productionDate : productionDate // ignore: cast_nullable_to_non_nullable
as DateTime?,shelfLifeDays: freezed == shelfLifeDays ? _self.shelfLifeDays : shelfLifeDays // ignore: cast_nullable_to_non_nullable
as int?,shelfLifeUnit: freezed == shelfLifeUnit ? _self.shelfLifeUnit : shelfLifeUnit // ignore: cast_nullable_to_non_nullable
as String?,remainingDays: freezed == remainingDays ? _self.remainingDays : remainingDays // ignore: cast_nullable_to_non_nullable
as int?,purchasePrice: freezed == purchasePrice ? _self.purchasePrice : purchasePrice // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'aggregated_inventory.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_AggregatedInventoryItem _$AggregatedInventoryItemFromJson(
  Map<String, dynamic> json,
) => _AggregatedInventoryItem(
  productId: (json['productId'] as num).toInt(),
  productName: json['productName'] as String,
  productImage: json['productImage'] as String?,
  totalQuantity: (json['totalQuantity'] as num).toInt(),
  unit: json['unit'] as String,
  categoryId: (json['categoryId'] as num?)?.toInt(),
  categoryName: json['categoryName'] as String,
  details: (json['details'] as List<dynamic>)
      .map((e) => InventoryDetail.fromJson(e as Map<String, dynamic>))
      .toList(),
  totalValue: (json['totalValue'] as num).toDouble(),
);

Map<String, dynamic> _$AggregatedInventoryItemToJson(
  _AggregatedInventoryItem instance,
) => <String, dynamic>{
  'productId': instance.productId,
  'productName': instance.productName,
  'productImage': instance.productImage,
  'totalQuantity': instance.totalQuantity,
  'unit': instance.unit,
  'categoryId': instance.categoryId,
  'categoryName': instance.categoryName,
  'details': instance.details,
  'totalValue': instance.totalValue,
};

_InventoryDetail _$InventoryDetailFromJson(Map<String, dynamic> json) =>
    _InventoryDetail(
      stockId: (json['stockId'] as num).toInt(),
      shopId: (json['shopId'] as num).toInt(),
      shopName: json['shopName'] as String,
      quantity: (json['quantity'] as num).toInt(),
      batchId: (json['batchId'] as num?)?.toInt(),
      batchNumber: json['batchNumber'] as String?,
      productionDate: json['productionDate'] == null
          ? null
          : DateTime.parse(json['productionDate'] as String),
      shelfLifeDays: (json['shelfLifeDays'] as num?)?.toInt(),
      shelfLifeUnit: json['shelfLifeUnit'] as String?,
      remainingDays: (json['remainingDays'] as num?)?.toInt(),
      purchasePrice: (json['purchasePrice'] as num?)?.toInt(),
    );

Map<String, dynamic> _$InventoryDetailToJson(_InventoryDetail instance) =>
    <String, dynamic>{
      'stockId': instance.stockId,
      'shopId': instance.shopId,
      'shopName': instance.shopName,
      'quantity': instance.quantity,
      'batchId': instance.batchId,
      'batchNumber': instance.batchNumber,
      'productionDate': instance.productionDate?.toIso8601String(),
      'shelfLifeDays': instance.shelfLifeDays,
      'shelfLifeUnit': instance.shelfLifeUnit,
      'remainingDays': instance.remainingDays,
      'purchasePrice': instance.purchasePrice,
    };
/// æ‰¹æ¬¡æ¨¡å‹
/// ç”¨äºæ‰¹æ¬¡ç®¡ç†åŠŸèƒ½çš„æ•°æ®æ¨¡å?
class BatchModel {
  /// ä¸»é”® - æ‰¹æ¬¡å·ï¼Œæ— ä¸šåŠ¡æ„ä¹?
  final int? id;
  final int productId;
  /// ä»…ä½¿ç”¨åˆ°â€œæ—¥æœŸâ€ç²’åº¦ï¼ˆ00:00:00ï¼‰ï¼Œé¿å…æ—¶é—´éƒ¨åˆ†å½±å“å”¯ä¸€æ€?
  final DateTime productionDate;
  final int totalInboundQuantity;
  final int shopId;
  final DateTime createdAt;
  final DateTime updatedAt;

  const BatchModel({
    this.id,
    required this.productId,
    required this.productionDate,
    required this.totalInboundQuantity,
    required this.shopId,
    required this.createdAt,
    required this.updatedAt,
  }) : assert(totalInboundQuantity >= 0, 'totalInboundQuantity ä¸èƒ½ä¸ºè´Ÿæ•?);

  /// åˆ›å»ºæ–°æ‰¹æ¬?
  factory BatchModel.create({
    required int productId,
    required DateTime productionDate,
    required int totalInboundQuantity,
    required int shopId,
  }) {
    final now = DateTime.now().toUtc();
    return BatchModel(
      productId: productId,
      productionDate: _dateOnlyUtc(productionDate),
      totalInboundQuantity: totalInboundQuantity,
      shopId: shopId,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// å¤åˆ¶æ‰¹æ¬¡å¹¶æ›´æ–°æŒ‡å®šå­—æ®?
  BatchModel copyWith({
    int? id,
    int? productId,
    DateTime? productionDate,
    int? totalInboundQuantity,
    int? shopId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return BatchModel(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      productionDate: productionDate != null
          ? _dateOnlyUtc(productionDate)
          : this.productionDate,
      totalInboundQuantity: totalInboundQuantity ?? this.totalInboundQuantity,
      shopId: shopId ?? this.shopId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// JSON åºåˆ—åŒ?
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'productionDate': productionDate.toIso8601String(),
        'totalInboundQuantity': totalInboundQuantity,
        'shopId': shopId,
        'createdAt': createdAt.toIso8601String(),
        'updatedAt': updatedAt.toIso8601String(),
      };

  factory BatchModel.fromJson(Map<String, dynamic> json) => BatchModel(
        id: json['id'] as int?,
        productId: json['productId'] as int,
        productionDate: _dateOnlyUtc(DateTime.parse(json['productionDate'] as String)),
        totalInboundQuantity: json['totalInboundQuantity'] as int,
        shopId: json['shopId'] as int,
        createdAt: DateTime.parse(json['createdAt'] as String),
        updatedAt: DateTime.parse(json['updatedAt'] as String),
      );

  @override
  String toString() {
    return 'Batch(id: $id, productId: $productId, productionDate: $productionDate, totalInboundQuantity: $totalInboundQuantity, shopId: $shopId)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! BatchModel) return false;

    // è‹¥åŒæ–¹å‡æœ‰ä¸»é”®ï¼Œåˆ™ä»¥ä¸»é”®åˆ¤ç­‰
    if (id != null && other.id != null) {
      return id == other.id;
    }

    // å¦åˆ™ä½¿ç”¨ä¸šåŠ¡å”¯ä¸€é”®ï¼ˆäº§å“+æ—¥æœŸ+åº—é“ºï¼‰åˆ¤ç­?
    return productId == other.productId &&
        _sameDate(productionDate, other.productionDate) &&
        shopId == other.shopId;
  }

  @override
  int get hashCode {
    if (id != null) return id.hashCode;
    // ä¸šåŠ¡é”®å“ˆå¸Œï¼šç¡®ä¿ä¸?== ä¸€è‡?
    final d = productionDate.toUtc();
    final dateOnly = DateTime.utc(d.year, d.month, d.day);
    return Object.hash(productId, dateOnly.millisecondsSinceEpoch, shopId);
  }

  // å°†ä»»æ„æ—¶é—´æ ‡å‡†åŒ–ä¸?UTC çš„â€œæ—¥æœ?00:00:00â€?
  static DateTime _dateOnlyUtc(DateTime dt) {
    final u = dt.toUtc();
    return DateTime.utc(u.year, u.month, u.day);
  }

  static bool _sameDate(DateTime a, DateTime b) {
    final ua = a.toUtc();
    final ub = b.toUtc();
    return ua.year == ub.year && ua.month == ub.month && ua.day == ub.day;
  }
}
import 'package:freezed_annotation/freezed_annotation.dart';

part 'inventory.freezed.dart';
part 'inventory.g.dart';

/// åº“å­˜é¢†åŸŸæ¨¡å‹
/// è¡¨ç¤ºäº§å“åœ¨åº—é“ºçš„åº“å­˜ä¿¡æ¯
@freezed
abstract class StockModel with _$StockModel {
  const factory StockModel({
    int? id,
    required int productId,
    required int quantity,
    required int shopId,
    int? batchId,
    @Default(0) int averageUnitPriceInCents,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _StockModel;

  const StockModel._();
  factory StockModel.fromJson(Map<String, dynamic> json) =>
      _$StockModelFromJson(json);

  /// åˆ›å»ºæ–°åº“å­˜è®°å½?
  factory StockModel.create({
    required int productId,
    required int quantity,
    required int shopId,
    int? batchId,
  }) {
    final now = DateTime.now();
    return StockModel(
      id: null,
      productId: productId,
      quantity: quantity,
      shopId: shopId,
      batchId: batchId,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// æ›´æ–°åº“å­˜æ•°é‡
  StockModel updateQuantity(int newQuantity) {
    return copyWith(quantity: newQuantity, updatedAt: DateTime.now());
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inventory.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$StockModel {

 int? get id; int get productId; int get quantity; int get shopId; int? get batchId; int get averageUnitPriceInCents; DateTime? get createdAt; DateTime? get updatedAt;
/// Create a copy of StockModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StockModelCopyWith<StockModel> get copyWith => _$StockModelCopyWithImpl<StockModel>(this as StockModel, _$identity);

  /// Serializes this StockModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StockModel&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.averageUnitPriceInCents, averageUnitPriceInCents) || other.averageUnitPriceInCents == averageUnitPriceInCents)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,quantity,shopId,batchId,averageUnitPriceInCents,createdAt,updatedAt);

@override
String toString() {
  return 'StockModel(id: $id, productId: $productId, quantity: $quantity, shopId: $shopId, batchId: $batchId, averageUnitPriceInCents: $averageUnitPriceInCents, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class $StockModelCopyWith<$Res>  {
  factory $StockModelCopyWith(StockModel value, $Res Function(StockModel) _then) = _$StockModelCopyWithImpl;
@useResult
$Res call({
 int? id, int productId, int quantity, int shopId, int? batchId, int averageUnitPriceInCents, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class _$StockModelCopyWithImpl<$Res>
    implements $StockModelCopyWith<$Res> {
  _$StockModelCopyWithImpl(this._self, this._then);

  final StockModel _self;
  final $Res Function(StockModel) _then;

/// Create a copy of StockModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? productId = null,Object? quantity = null,Object? shopId = null,Object? batchId = freezed,Object? averageUnitPriceInCents = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,averageUnitPriceInCents: null == averageUnitPriceInCents ? _self.averageUnitPriceInCents : averageUnitPriceInCents // ignore: cast_nullable_to_non_nullable
as int,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _StockModel extends StockModel {
  const _StockModel({this.id, required this.productId, required this.quantity, required this.shopId, this.batchId, this.averageUnitPriceInCents = 0, this.createdAt, this.updatedAt}): super._();
  factory _StockModel.fromJson(Map<String, dynamic> json) => _$StockModelFromJson(json);

@override final  int? id;
@override final  int productId;
@override final  int quantity;
@override final  int shopId;
@override final  int? batchId;
@override@JsonKey() final  int averageUnitPriceInCents;
@override final  DateTime? createdAt;
@override final  DateTime? updatedAt;

/// Create a copy of StockModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StockModelCopyWith<_StockModel> get copyWith => __$StockModelCopyWithImpl<_StockModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StockModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StockModel&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.averageUnitPriceInCents, averageUnitPriceInCents) || other.averageUnitPriceInCents == averageUnitPriceInCents)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,quantity,shopId,batchId,averageUnitPriceInCents,createdAt,updatedAt);

@override
String toString() {
  return 'StockModel(id: $id, productId: $productId, quantity: $quantity, shopId: $shopId, batchId: $batchId, averageUnitPriceInCents: $averageUnitPriceInCents, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class _$StockModelCopyWith<$Res> implements $StockModelCopyWith<$Res> {
  factory _$StockModelCopyWith(_StockModel value, $Res Function(_StockModel) _then) = __$StockModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int productId, int quantity, int shopId, int? batchId, int averageUnitPriceInCents, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class __$StockModelCopyWithImpl<$Res>
    implements _$StockModelCopyWith<$Res> {
  __$StockModelCopyWithImpl(this._self, this._then);

  final _StockModel _self;
  final $Res Function(_StockModel) _then;

/// Create a copy of StockModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? productId = null,Object? quantity = null,Object? shopId = null,Object? batchId = freezed,Object? averageUnitPriceInCents = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_StockModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,averageUnitPriceInCents: null == averageUnitPriceInCents ? _self.averageUnitPriceInCents : averageUnitPriceInCents // ignore: cast_nullable_to_non_nullable
as int,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inventory.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_StockModel _$StockModelFromJson(Map<String, dynamic> json) => _StockModel(
  id: (json['id'] as num?)?.toInt(),
  productId: (json['productId'] as num).toInt(),
  quantity: (json['quantity'] as num).toInt(),
  shopId: (json['shopId'] as num).toInt(),
  batchId: (json['batchId'] as num?)?.toInt(),
  averageUnitPriceInCents:
      (json['averageUnitPriceInCents'] as num?)?.toInt() ?? 0,
  createdAt: json['createdAt'] == null
      ? null
      : DateTime.parse(json['createdAt'] as String),
  updatedAt: json['updatedAt'] == null
      ? null
      : DateTime.parse(json['updatedAt'] as String),
);

Map<String, dynamic> _$StockModelToJson(_StockModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'productId': instance.productId,
      'quantity': instance.quantity,
      'shopId': instance.shopId,
      'batchId': instance.batchId,
      'averageUnitPriceInCents': instance.averageUnitPriceInCents,
      'createdAt': instance.createdAt?.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'inventory_transaction.freezed.dart';
part 'inventory_transaction.g.dart';

/// åº“å­˜æµæ°´ç±»å‹
enum InventoryTransactionType {
  /// å…¥åº“
  @JsonValue('in')
  inbound,

  /// å‡ºåº“
  @JsonValue('out')
  outbound,

  /// è°ƒæ•´
  @JsonValue('adjust')
  adjustment,

  /// è°ƒæ‹¨
  @JsonValue('transfer')
  transfer,

  /// é€€è´?
  @JsonValue('return')
  returned,
}

extension InventoryTransactionTypeExtension on InventoryTransactionType {
  String get displayName {
    switch (this) {
      case InventoryTransactionType.inbound:
        return 'å…¥åº“';
      case InventoryTransactionType.outbound:
        return 'å‡ºåº“';
      case InventoryTransactionType.adjustment:
        return 'è°ƒæ•´';
      case InventoryTransactionType.transfer:
        return 'è°ƒæ‹¨';
      case InventoryTransactionType.returned:
        return 'é€€è´?;
    }
  }

  /// å°†æšä¸¾æ˜ å°„ä¸ºæ•°æ®åº“å­—æ®µå…è®¸çš„çŸ­ç 
  String get toDbCode {
    switch (this) {
      case InventoryTransactionType.inbound:
        return 'in';
      case InventoryTransactionType.outbound:
        return 'out';
      case InventoryTransactionType.adjustment:
        return 'adjust';
      case InventoryTransactionType.transfer:
        return 'transfer';
      case InventoryTransactionType.returned:
        return 'return';
    }
  }
}

/// ä»æ•°æ®åº“çŸ­ç è¿˜åŸä¸ºæšä¸¾å€?
InventoryTransactionType inventoryTransactionTypeFromDbCode(String code) {
  switch (code) {
    case 'in':
      return InventoryTransactionType.inbound;
    case 'out':
      return InventoryTransactionType.outbound;
    case 'adjust':
      return InventoryTransactionType.adjustment;
    case 'transfer':
      return InventoryTransactionType.transfer;
    case 'return':
      return InventoryTransactionType.returned;
    default:
      // å…œåº•ï¼šæŒ‰å…¥åº“å¤„ç†
      return InventoryTransactionType.inbound;
  }
}


/// åº“å­˜æµæ°´é¢†åŸŸæ¨¡å‹
/// è¡¨ç¤ºåº“å­˜å˜åŠ¨çš„å†å²è®°å½?
@freezed
abstract class InventoryTransactionModel with _$InventoryTransactionModel {
  const factory InventoryTransactionModel({
    int? id,
    required int productId,
    required InventoryTransactionType type,
    required int quantity,
    required int shopId,
    int? batchId, 
    DateTime? createdAt,
  }) = _InventoryTransactionModel;

  const InventoryTransactionModel._();

  factory InventoryTransactionModel.fromJson(Map<String, dynamic> json) =>
      _$InventoryTransactionModelFromJson(json);

  /// åˆ›å»ºå…¥åº“æµæ°´
  factory InventoryTransactionModel.createInbound({
    required int productId,
    required int quantity,
    required int shopId,
    int? batchId,
  }) {
    return InventoryTransactionModel(
      id: null,
      productId: productId,
      type: InventoryTransactionType.inbound,
      quantity: quantity,
      shopId: shopId,
      batchId: batchId,
      createdAt: DateTime.now(),
    );
  }

  /// åˆ›å»ºå‡ºåº“æµæ°´
  factory InventoryTransactionModel.createOutbound({
    required int productId,
    required int quantity,
    required int shopId,
    int? batchId,
  }) {
    return InventoryTransactionModel(
      id: null,
      productId: productId,
      type: InventoryTransactionType.outbound,
      quantity: quantity,
      shopId: shopId,
      batchId: batchId,
      createdAt: DateTime.now(),
    );
  }

  /// åˆ›å»ºè°ƒæ•´æµæ°´
  factory InventoryTransactionModel.createAdjustment({
    required int productId,
    required int quantity,
    required int shopId,
    int? batchId,
  }) {
    return InventoryTransactionModel(
      id: null,
      productId: productId,
      type: InventoryTransactionType.adjustment,
      quantity: quantity,
      shopId: shopId,
      batchId: batchId,
      createdAt: DateTime.now(),
    );
  }

  /// è·å–æµæ°´ç±»å‹æ˜¾ç¤ºåç§°
  String get typeDisplayName => type.displayName;

  /// æ˜¯å¦ä¸ºå…¥åº?
  bool get isInbound => type == InventoryTransactionType.inbound;

  /// æ˜¯å¦ä¸ºå‡ºåº?
  bool get isOutbound => type == InventoryTransactionType.outbound;

  /// æ˜¯å¦ä¸ºè°ƒæ•?
  bool get isAdjustment => type == InventoryTransactionType.adjustment;

  /// æ˜¯å¦ä¸ºè°ƒæ‹?
  bool get isTransfer => type == InventoryTransactionType.transfer;

  /// æ˜¯å¦ä¸ºé€€è´?
  bool get isReturn => type == InventoryTransactionType.returned;
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inventory_transaction.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$InventoryTransactionModel {

 int? get id; int get productId; InventoryTransactionType get type; int get quantity; int get shopId; int? get batchId; DateTime? get createdAt;
/// Create a copy of InventoryTransactionModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InventoryTransactionModelCopyWith<InventoryTransactionModel> get copyWith => _$InventoryTransactionModelCopyWithImpl<InventoryTransactionModel>(this as InventoryTransactionModel, _$identity);

  /// Serializes this InventoryTransactionModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InventoryTransactionModel&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.type, type) || other.type == type)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,type,quantity,shopId,batchId,createdAt);

@override
String toString() {
  return 'InventoryTransactionModel(id: $id, productId: $productId, type: $type, quantity: $quantity, shopId: $shopId, batchId: $batchId, createdAt: $createdAt)';
}


}

/// @nodoc
abstract mixin class $InventoryTransactionModelCopyWith<$Res>  {
  factory $InventoryTransactionModelCopyWith(InventoryTransactionModel value, $Res Function(InventoryTransactionModel) _then) = _$InventoryTransactionModelCopyWithImpl;
@useResult
$Res call({
 int? id, int productId, InventoryTransactionType type, int quantity, int shopId, int? batchId, DateTime? createdAt
});




}
/// @nodoc
class _$InventoryTransactionModelCopyWithImpl<$Res>
    implements $InventoryTransactionModelCopyWith<$Res> {
  _$InventoryTransactionModelCopyWithImpl(this._self, this._then);

  final InventoryTransactionModel _self;
  final $Res Function(InventoryTransactionModel) _then;

/// Create a copy of InventoryTransactionModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? productId = null,Object? type = null,Object? quantity = null,Object? shopId = null,Object? batchId = freezed,Object? createdAt = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as InventoryTransactionType,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _InventoryTransactionModel extends InventoryTransactionModel {
  const _InventoryTransactionModel({this.id, required this.productId, required this.type, required this.quantity, required this.shopId, this.batchId, this.createdAt}): super._();
  factory _InventoryTransactionModel.fromJson(Map<String, dynamic> json) => _$InventoryTransactionModelFromJson(json);

@override final  int? id;
@override final  int productId;
@override final  InventoryTransactionType type;
@override final  int quantity;
@override final  int shopId;
@override final  int? batchId;
@override final  DateTime? createdAt;

/// Create a copy of InventoryTransactionModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InventoryTransactionModelCopyWith<_InventoryTransactionModel> get copyWith => __$InventoryTransactionModelCopyWithImpl<_InventoryTransactionModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InventoryTransactionModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InventoryTransactionModel&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.type, type) || other.type == type)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,type,quantity,shopId,batchId,createdAt);

@override
String toString() {
  return 'InventoryTransactionModel(id: $id, productId: $productId, type: $type, quantity: $quantity, shopId: $shopId, batchId: $batchId, createdAt: $createdAt)';
}


}

/// @nodoc
abstract mixin class _$InventoryTransactionModelCopyWith<$Res> implements $InventoryTransactionModelCopyWith<$Res> {
  factory _$InventoryTransactionModelCopyWith(_InventoryTransactionModel value, $Res Function(_InventoryTransactionModel) _then) = __$InventoryTransactionModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int productId, InventoryTransactionType type, int quantity, int shopId, int? batchId, DateTime? createdAt
});




}
/// @nodoc
class __$InventoryTransactionModelCopyWithImpl<$Res>
    implements _$InventoryTransactionModelCopyWith<$Res> {
  __$InventoryTransactionModelCopyWithImpl(this._self, this._then);

  final _InventoryTransactionModel _self;
  final $Res Function(_InventoryTransactionModel) _then;

/// Create a copy of InventoryTransactionModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? productId = null,Object? type = null,Object? quantity = null,Object? shopId = null,Object? batchId = freezed,Object? createdAt = freezed,}) {
  return _then(_InventoryTransactionModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as InventoryTransactionType,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'inventory_transaction.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_InventoryTransactionModel _$InventoryTransactionModelFromJson(
  Map<String, dynamic> json,
) => _InventoryTransactionModel(
  id: (json['id'] as num?)?.toInt(),
  productId: (json['productId'] as num).toInt(),
  type: $enumDecode(_$InventoryTransactionTypeEnumMap, json['type']),
  quantity: (json['quantity'] as num).toInt(),
  shopId: (json['shopId'] as num).toInt(),
  batchId: (json['batchId'] as num?)?.toInt(),
  createdAt: json['createdAt'] == null
      ? null
      : DateTime.parse(json['createdAt'] as String),
);

Map<String, dynamic> _$InventoryTransactionModelToJson(
  _InventoryTransactionModel instance,
) => <String, dynamic>{
  'id': instance.id,
  'productId': instance.productId,
  'type': _$InventoryTransactionTypeEnumMap[instance.type]!,
  'quantity': instance.quantity,
  'shopId': instance.shopId,
  'batchId': instance.batchId,
  'createdAt': instance.createdAt?.toIso8601String(),
};

const _$InventoryTransactionTypeEnumMap = {
  InventoryTransactionType.inbound: 'in',
  InventoryTransactionType.outbound: 'out',
  InventoryTransactionType.adjustment: 'adjust',
  InventoryTransactionType.transfer: 'transfer',
  InventoryTransactionType.returned: 'return',
};
import 'package:freezed_annotation/freezed_annotation.dart';

part 'shop.freezed.dart';
part 'shop.g.dart';

/// åº—é“ºé¢†åŸŸæ¨¡å‹
/// è¡¨ç¤ºåº—é“ºçš„ä¸šåŠ¡å®ä½?
@freezed
abstract class Shop with _$Shop {
  const factory Shop({
    int? id,
    required String name,
    required String manager,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _Shop;

  const Shop._();

  factory Shop.fromJson(Map<String, dynamic> json) => _$ShopFromJson(json);

  /// åˆ›å»ºæ–°åº—é“?
  factory Shop.create({required String name, required String manager}) {
    final now = DateTime.now();
    return Shop(
      id: null,
      name: name,
      manager: manager,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// å¤åˆ¶å¹¶æ›´æ–°åº—é“ºä¿¡æ?
  Shop updateInfo({String? name, String? manager}) {
    return copyWith(
      name: name ?? this.name,
      manager: manager ?? this.manager,
      updatedAt: DateTime.now(),
    );
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shop.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Shop {

 int? get id; String get name; String get manager; DateTime? get createdAt; DateTime? get updatedAt;
/// Create a copy of Shop
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShopCopyWith<Shop> get copyWith => _$ShopCopyWithImpl<Shop>(this as Shop, _$identity);

  /// Serializes this Shop to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Shop&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.manager, manager) || other.manager == manager)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,manager,createdAt,updatedAt);

@override
String toString() {
  return 'Shop(id: $id, name: $name, manager: $manager, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class $ShopCopyWith<$Res>  {
  factory $ShopCopyWith(Shop value, $Res Function(Shop) _then) = _$ShopCopyWithImpl;
@useResult
$Res call({
 int? id, String name, String manager, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class _$ShopCopyWithImpl<$Res>
    implements $ShopCopyWith<$Res> {
  _$ShopCopyWithImpl(this._self, this._then);

  final Shop _self;
  final $Res Function(Shop) _then;

/// Create a copy of Shop
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,Object? manager = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,manager: null == manager ? _self.manager : manager // ignore: cast_nullable_to_non_nullable
as String,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _Shop extends Shop {
  const _Shop({this.id, required this.name, required this.manager, this.createdAt, this.updatedAt}): super._();
  factory _Shop.fromJson(Map<String, dynamic> json) => _$ShopFromJson(json);

@override final  int? id;
@override final  String name;
@override final  String manager;
@override final  DateTime? createdAt;
@override final  DateTime? updatedAt;

/// Create a copy of Shop
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShopCopyWith<_Shop> get copyWith => __$ShopCopyWithImpl<_Shop>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShopToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Shop&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.manager, manager) || other.manager == manager)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,manager,createdAt,updatedAt);

@override
String toString() {
  return 'Shop(id: $id, name: $name, manager: $manager, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class _$ShopCopyWith<$Res> implements $ShopCopyWith<$Res> {
  factory _$ShopCopyWith(_Shop value, $Res Function(_Shop) _then) = __$ShopCopyWithImpl;
@override @useResult
$Res call({
 int? id, String name, String manager, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class __$ShopCopyWithImpl<$Res>
    implements _$ShopCopyWith<$Res> {
  __$ShopCopyWithImpl(this._self, this._then);

  final _Shop _self;
  final $Res Function(_Shop) _then;

/// Create a copy of Shop
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,Object? manager = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_Shop(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,manager: null == manager ? _self.manager : manager // ignore: cast_nullable_to_non_nullable
as String,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'shop.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Shop _$ShopFromJson(Map<String, dynamic> json) => _Shop(
  id: (json['id'] as num?)?.toInt(),
  name: json['name'] as String,
  manager: json['manager'] as String,
  createdAt: json['createdAt'] == null
      ? null
      : DateTime.parse(json['createdAt'] as String),
  updatedAt: json['updatedAt'] == null
      ? null
      : DateTime.parse(json['updatedAt'] as String),
);

Map<String, dynamic> _$ShopToJson(_Shop instance) => <String, dynamic>{
  'id': instance.id,
  'name': instance.name,
  'manager': instance.manager,
  'createdAt': instance.createdAt?.toIso8601String(),
  'updatedAt': instance.updatedAt?.toIso8601String(),
};
import '../model/inventory.dart';

/// åº“å­˜ä»“å‚¨æ¥å£
/// å®šä¹‰åº“å­˜ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IInventoryRepository {
  /// æ·»åŠ åº“å­˜è®°å½•
  Future<int> addInventory(StockModel inventory);

  /// æ ¹æ®IDè·å–åº“å­˜
  Future<StockModel?> getInventoryById(int id);

  /// æ ¹æ®äº§å“IDå’Œåº—é“ºIDè·å–åº“å­˜
  Future<StockModel?> getInventoryByProductAndShop(
    int productId,
    int shopId,
  );

  /// æ ¹æ®äº§å“IDã€åº—é“ºIDä¸æ‰¹æ¬¡IDï¼ˆå¯ç©ºï¼‰è·å–åº“å­˜
  Future<StockModel?> getInventoryByProductShopAndBatch(
    int productId,
    int shopId,
    int? batchId,
  );

  /// è·å–æ‰€æœ‰åº“å­?
  Future<List<StockModel>> getAllInventory();

  /// æ ¹æ®åº—é“ºIDè·å–åº“å­˜åˆ—è¡¨
  Future<List<StockModel>> getInventoryByShop(int shopId);

  /// æ ¹æ®äº§å“IDè·å–åº“å­˜åˆ—è¡¨
  Future<List<StockModel>> getInventoryByProduct(int productId);

  /// ç›‘å¬æ‰€æœ‰åº“å­˜å˜åŒ?
  Stream<List<StockModel>> watchAllInventory();

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„åº“å­˜å˜åŒ?
  Stream<List<StockModel>> watchInventoryByShop(int shopId);

  /// ç›‘å¬æŒ‡å®šäº§å“çš„åº“å­˜å˜åŒ?
  Stream<List<StockModel>> watchInventoryByProduct(int productId);

  /// æ›´æ–°åº“å­˜
  Future<bool> updateInventory(StockModel inventory);

  /// åˆ é™¤åº“å­˜è®°å½•
  Future<int> deleteInventory(int id);

  /// æ ¹æ®äº§å“å’Œåº—é“ºåˆ é™¤åº“å­?
  Future<int> deleteInventoryByProductAndShop(int productId, int shopId);

  /// æ›´æ–°åº“å­˜æ•°é‡
  Future<bool> updateInventoryQuantity(
    int productId,
    int shopId,
    int quantity,
  );

  /// æŒ‰æ‰¹æ¬¡æ›´æ–°åº“å­˜æ•°é‡ï¼ˆbatchId å¯ä¸º null è¡¨ç¤ºæ— æ‰¹æ¬¡ï¼‰
  Future<bool> updateInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int quantity,
  );

  /// å¢åŠ åº“å­˜æ•°é‡
  Future<bool> addInventoryQuantity(
    int productId,
    int shopId,
    int amount,
  );

  /// æŒ‰æ‰¹æ¬¡å¢åŠ åº“å­˜æ•°é‡ï¼ˆbatchId å¯ä¸º null è¡¨ç¤ºæ— æ‰¹æ¬¡ï¼‰
  Future<bool> addInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  );

  /// å‡å°‘åº“å­˜æ•°é‡
  Future<bool> subtractInventoryQuantity(
    int productId,
    int shopId,
    int amount,
  );

  /// æŒ‰æ‰¹æ¬¡å‡å°‘åº“å­˜æ•°é‡ï¼ˆbatchId å¯ä¸º null è¡¨ç¤ºæ— æ‰¹æ¬¡ï¼‰
  Future<bool> subtractInventoryQuantityByBatch(
    int productId,
    int shopId,
    int? batchId,
    int amount,
  );

  /// è·å–ä½åº“å­˜äº§å“åˆ—è¡?
  Future<List<StockModel>> getLowStockInventory(int shopId, int warningLevel);

  /// è·å–ç¼ºè´§äº§å“åˆ—è¡¨
  Future<List<StockModel>> getOutOfStockInventory(int shopId);

  /// è·å–åº“å­˜æ€»æ•°é‡ï¼ˆæŒ‰åº—é“ºï¼‰
  Future<double> getTotalInventoryByShop(int shopId);

  /// è·å–åº“å­˜æ€»æ•°é‡ï¼ˆæŒ‰äº§å“ï¼‰
  Future<double> getTotalInventoryByProduct(int productId);

  /// æ£€æŸ¥åº“å­˜æ˜¯å¦å­˜åœ?
  Future<bool> inventoryExists(int productId, int shopId);
}
import '../model/inventory_transaction.dart';

/// åº“å­˜æµæ°´ä»“å‚¨æ¥å£
/// å®šä¹‰åº“å­˜æµæ°´ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IInventoryTransactionRepository {
  /// æ·»åŠ åº“å­˜æµæ°´è®°å½•
  Future<int> addTransaction(InventoryTransactionModel transaction);

  /// æ ¹æ®IDè·å–åº“å­˜æµæ°´
  Future<InventoryTransactionModel?> getTransactionById(int id);

  /// è·å–æ‰€æœ‰åº“å­˜æµæ°?
  Future<List<InventoryTransactionModel>> getAllTransactions();

  /// æ ¹æ®äº§å“IDè·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getTransactionsByProduct(int productId);

  /// æ ¹æ®åº—é“ºIDè·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getTransactionsByShop(int shopId);

  /// æ ¹æ®æµæ°´ç±»å‹è·å–è®°å½•
  Future<List<InventoryTransactionModel>> getTransactionsByType(String type);

  /// æ ¹æ®äº§å“å’Œåº—é“ºè·å–æµæ°´è®°å½?
  Future<List<InventoryTransactionModel>> getTransactionsByProductAndShop(
    int productId,
    int shopId,
  );

  /// æ ¹æ®æ—¶é—´èŒƒå›´è·å–æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getTransactionsByDateRange(
    DateTime startDate,
    DateTime endDate, {
    int? shopId,
    int? productId,
  });

  /// ç›‘å¬æ‰€æœ‰åº“å­˜æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionModel>> watchAllTransactions();

  /// ç›‘å¬æŒ‡å®šäº§å“çš„æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionModel>> watchTransactionsByProduct(
    int productId,
  );

  /// ç›‘å¬æŒ‡å®šåº—é“ºçš„æµæ°´å˜åŒ?
  Stream<List<InventoryTransactionModel>> watchTransactionsByShop(int shopId);

  /// æ›´æ–°åº“å­˜æµæ°´
  Future<bool> updateTransaction(InventoryTransactionModel transaction);

  /// åˆ é™¤åº“å­˜æµæ°´è®°å½•
  Future<int> deleteTransaction(int id);

  /// æ ¹æ®äº§å“åˆ é™¤ç›¸å…³æµæ°´
  Future<int> deleteTransactionsByProduct(int productId);

  /// æ ¹æ®åº—é“ºåˆ é™¤ç›¸å…³æµæ°´
  Future<int> deleteTransactionsByShop(int shopId);

  /// è·å–å…¥åº“æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getInboundTransactions({
    int? shopId,
    int? productId,
  });

  /// è·å–å‡ºåº“æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getOutboundTransactions({
    int? shopId,
    int? productId,
  });

  /// è·å–è°ƒæ•´æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getAdjustmentTransactions({
    int? shopId,
    int? productId,
  });

  /// ç»Ÿè®¡æŒ‡å®šæœŸé—´çš„æµæ°´æ•°é‡?
  Future<Map<String, double>> getTransactionSummaryByDateRange(
    DateTime startDate,
    DateTime endDate, {
    int? shopId,
    int? productId,
  });

  /// è·å–æœ€è¿‘çš„æµæ°´è®°å½•
  Future<List<InventoryTransactionModel>> getRecentTransactions(
    int limit, {
    int? shopId,
    int? productId,
  });

  /// è·å–æµæ°´æ€»æ•°
  Future<int> getTransactionCount({
    int? shopId,
    int? productId,
    String? type,
  });
}
import '../model/shop.dart';

/// åº—é“ºä»“å‚¨æ¥å£
/// å®šä¹‰åº—é“ºç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IShopRepository {
  /// æ·»åŠ åº—é“º
  Future<int> addShop(Shop shop);

  /// æ ¹æ®IDè·å–åº—é“º
  Future<Shop?> getShopById(int id);

  /// æ ¹æ®åç§°è·å–åº—é“º
  Future<Shop?> getShopByName(String name);

  /// è·å–æ‰€æœ‰åº—é“?
  Future<List<Shop>> getAllShops();

  /// ç›‘å¬æ‰€æœ‰åº—é“ºå˜åŒ?
  Stream<List<Shop>> watchAllShops();

  /// æ›´æ–°åº—é“º
  Future<bool> updateShop(Shop shop);

  /// åˆ é™¤åº—é“º
  Future<int> deleteShop(int id);

  /// æ£€æŸ¥åº—é“ºåç§°æ˜¯å¦å·²å­˜åœ¨
  Future<bool> isShopNameExists(String name, [int? excludeId]);

  /// æ ¹æ®åç§°æœç´¢åº—é“º
  Future<List<Shop>> searchShopsByName(String searchTerm);

  /// æ ¹æ®åº—é•¿æœç´¢åº—é“º
  Future<List<Shop>> searchShopsByManager(String managerName);

  /// è·å–åº—é“ºæ•°é‡
  Future<int> getShopCount();
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../domain/model/inventory.dart';
import '../../domain/model/aggregated_inventory.dart';
import '../../domain/repository/i_inventory_repository.dart';
import '../../data/repository/inventory_repository.dart';
import '../../../product/domain/repository/i_product_repository.dart';
import '../../../product/data/repository/product_repository.dart';
import '../../../product/domain/repository/i_product_unit_repository.dart';
import '../../../product/data/repository/product_unit_repository.dart';
import '../../../product/domain/repository/i_unit_repository.dart';
import '../../../product/data/repository/unit_repository.dart';
import '../../application/provider/shop_providers.dart';
import '../../../product/application/category_notifier.dart';
import '../../../product/data/dao/batch_dao.dart';
import '../../../purchase/data/dao/purchase_dao.dart';

/// åº“å­˜æŸ¥è¯¢æœåŠ¡
/// æä¾›åº“å­˜ä¿¡æ¯çš„å¤åˆæŸ¥è¯¢åŠŸèƒ½ï¼ŒåŒ…å«äº§å“ã€å•ä½ã€åˆ†ç±»ç­‰è¯¦ç»†ä¿¡æ¯
class InventoryQueryService {
  final IInventoryRepository _inventoryRepository;
  final IProductRepository _productRepository;
  final IProductUnitRepository _productUnitRepository;
  final IUnitRepository _unitRepository;
  final BatchDao _batchDao;
  final PurchaseDao _purchaseDao;
  final Ref _ref;

  InventoryQueryService(
    this._inventoryRepository,
    this._productRepository,
    this._productUnitRepository,
    this._unitRepository,
    this._batchDao,
    this._purchaseDao,
    this._ref,
  );

  /// è·å–åº“å­˜è¯¦ç»†ä¿¡æ¯
  /// åŒ…å«äº§å“åç§°ã€å›¾ç‰‡ã€åº“å­˜æ•°é‡ã€å•ä½ã€åˆ†ç±»ã€åº—é“ºç­‰ä¿¡æ¯
  /// æ–°å…¥åº“çš„è®°å½•ä¼šæ˜¾ç¤ºåœ¨é¡¶éƒ¨
  Future<List<Map<String, dynamic>>> getInventoryWithDetails({
    String? shopFilter,
    String? categoryFilter,
    String? statusFilter,
  }) async {
    try {
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šå¼€å§‹è·å–åº“å­˜è¯¦ç»†ä¿¡æ?);

      // 1. è·å–æ‰€æœ‰åº“å­˜è®°å½?
      List<dynamic> inventoryList;
      if (shopFilter != null && shopFilter != 'æ‰€æœ‰ä»“åº?) {
        // TODO: æ ¹æ®åº—é“ºåç§°æŸ¥æ‰¾shopIdï¼Œç„¶åæŸ¥è¯¢è¯¥åº—é“ºçš„åº“å­?
        inventoryList = await _inventoryRepository.getAllInventory();
      } else {
        inventoryList = await _inventoryRepository.getAllInventory();
      }

      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åˆ° ${inventoryList.length} æ¡åº“å­˜è®°å½?);

      if (inventoryList.isEmpty) {
        return [];
      }

      // 2. è·å–æ‰€æœ‰ç›¸å…³çš„äº§å“ä¿¡æ¯
      final allProducts = await _productRepository.getAllProducts();
      final productMap = {for (var p in allProducts) p.id: p};
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åˆ° ${allProducts.length} ä¸ªäº§å“?);

      // 3. è·å–æ‰€æœ‰å•ä½ä¿¡æ?
      final allUnits = await _unitRepository.getAllUnits();
      final unitMap = {for (var u in allUnits) u.id: u};
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åˆ° ${allUnits.length} ä¸ªå•ä½?); // 4. è·å–æ‰€æœ‰åˆ†ç±»ä¿¡æ?
      final allCategories = await _ref.read(allCategoriesStreamProvider.future);
      final categoryMap = {for (var c in allCategories) c.id: c};
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åˆ° ${allCategories.length} ä¸ªåˆ†ç±?);

      // 5. è·å–æ‰€æœ‰åº—é“ºä¿¡æ?
      final allShops = await _ref.read(allShopsProvider.future);
      final shopMap = {for (var s in allShops) s.id: s};
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åˆ° ${allShops.length} ä¸ªåº—é“?);

      // 6. æ„å»ºè¯¦ç»†çš„åº“å­˜ä¿¡æ¯åˆ—è¡?
      final result = <Map<String, dynamic>>[];

      // å…ˆæŒ‰æ—¶é—´æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
      inventoryList.sort((a, b) {
        if (a.updatedAt != null && b.updatedAt != null) {
          return b.updatedAt!.compareTo(a.updatedAt!);
        }
        if (a.updatedAt != null) return -1;
        if (b.updatedAt != null) return 1;
        return 0;
      });

      for (final inventory in inventoryList) {
        final product = productMap[inventory.productId];
        if (product == null) {
          print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè­¦å‘?- æ‰¾ä¸åˆ°äº§å“ID: ${inventory.productId}');
          continue;
        }

        // è·å–äº§å“çš„åŸºç¡€å•ä½
        String unitName = 'ä¸?; // é»˜è®¤å•ä½
        try {
          final baseUnit = await _productUnitRepository.getBaseUnitForProduct(
            inventory.productId,
          );
          if (baseUnit != null) {
            final unit = unitMap[baseUnit.unitId];
            if (unit != null) {
              unitName = unit.name;
            }
          } else {
            // å¦‚æœæ²¡æœ‰é…ç½®äº§å“å•ä½ï¼Œä½¿ç”¨äº§å“ä¸»è¡¨çš„å•ä½
            final unit = unitMap[product.baseUnitId];
            if (unit != null) {
              unitName = unit.name;
            }
          }
        
        } catch (e) {
          print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–å•ä½å¤±è´? $e');
        }

        // è·å–åˆ†ç±»åç§°
        String? categoryName;
        if (product.categoryId != null) {
          final category = categoryMap[product.categoryId];
          categoryName = category?.name;
        }

        // è·å–åº—é“ºåç§°
        String shopName = 'æœªçŸ¥åº—é“º';
        final shop = shopMap[inventory.shopId];
        if (shop != null) {
          shopName = shop.name;
        }

        // åº”ç”¨ç­›é€‰æ¡ä»?
        bool shouldInclude = true;

        // åˆ†ç±»ç­›é€?
        if (categoryFilter != null && categoryFilter != 'æ‰€æœ‰åˆ†ç±?) {
          if (categoryName != categoryFilter) {
            shouldInclude = false;
          }
        }

        // åº—é“ºç­›é€?
        if (shopFilter != null && shopFilter != 'æ‰€æœ‰ä»“åº?) {
          if (shopName != shopFilter) {
            shouldInclude = false;
          }
        }

        // åº“å­˜çŠ¶æ€ç­›é€?
        if (statusFilter != null && statusFilter != 'åº“å­˜çŠ¶æ€?) {
          switch (statusFilter) {
            case 'æ­£å¸¸':
              if (inventory.quantity <= 10) shouldInclude = false;
              break;
            case 'ä½åº“å­?:
              if (inventory.quantity <= 0 || inventory.quantity > 10) {
                shouldInclude = false;
              }
              break;
            case 'ç¼ºè´§':
              if (inventory.quantity > 0) shouldInclude = false;
              break;
          }
        }

        if (!shouldInclude) continue;

        // è·å–æ‰¹æ¬¡ä¿¡æ¯
        ProductBatchData? batch;
        if (inventory.batchId != null) {
          try {
            batch = await _batchDao.getBatchByNumber(inventory.batchId!);
          } catch (e) {
            print('ğŸ“¦ è·å–æ‰¹æ¬¡ä¿¡æ¯å¤±è´¥ (batchId: ${inventory.batchId}): $e');
            batch = null; // å¦‚æœè·å–æ‰¹æ¬¡å¤±è´¥ï¼Œè®¾ä¸ºnull
          }
        }

        // æ„å»ºåº“å­˜é¡¹ç›®æ•°æ®
        final inventoryItem = {
          'id': inventory.id,
          'productName': product.name,
          'productImage': product.image,
          'quantity': inventory.quantity,
          'unit': unitName,
          'shopId': inventory.shopId,
          'shopName': shopName,
          'categoryId': product.categoryId,
          'categoryName': categoryName ?? 'æœªåˆ†ç±?,
          'productId': inventory.productId,
          'purchasePrice': await _purchaseDao.getLatestPurchasePrice(inventory.productId) ?? 0,
        };

        if (batch != null) {
          inventoryItem['batchNumber'] = batch.id;
          // å®‰å…¨å¤„ç†æ—¥æœŸï¼Œç¡®ä¿æ ¼å¼æ­£ç¡?
          try {
            inventoryItem['productionDate'] = batch.productionDate.toIso8601String();
                    } catch (e) {
            print('æ—¥æœŸè½¬æ¢å¤±è´¥: ${batch.productionDate}, é”™è¯¯: $e');
            // å¦‚æœæ—¥æœŸè½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨å½“å‰æ—¥æœŸä½œä¸ºé»˜è®¤å€?
            inventoryItem['productionDate'] = DateTime.now().toIso8601String();
          }
          inventoryItem['shelfLifeDays'] = product.shelfLife;
          inventoryItem['shelfLifeUnit'] = product.shelfLifeUnit.name;
        }

        result.add(inventoryItem);
      }

      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šç­›é€‰åå¾—åˆ° ${result.length} æ¡è®°å½?);
      return result;
    } catch (e) {
      print('ğŸ“¦ åº“å­˜æŸ¥è¯¢æœåŠ¡ï¼šè·å–åº“å­˜è¯¦ç»†ä¿¡æ¯å¤±è´? $e');
      print('ğŸ“¦ é”™è¯¯å †æ ˆ: ${e.toString()}');
      rethrow;
    }
  }

  /// è·å–èšåˆåçš„åº“å­˜æ•°æ®ï¼ˆæœªç­›é€‰åº—é“ºæ—¶ä½¿ç”¨ï¼?
  /// å°†ç›¸åŒè´§å“çš„å¤šæ¡åº“å­˜è®°å½•èšåˆä¸ºä¸€æ¡ï¼ŒåŒ…å«æ€»åº“å­˜å’Œè¯¦ç»†è®°å½•åˆ—è¡¨
  Future<List<AggregatedInventoryItem>> getAggregatedInventory({
    String? categoryFilter,
    String? statusFilter,
  }) async {
    try {
      print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šå¼€å§‹è·å–èšåˆåº“å­˜æ•°æ?);

      // 1. è·å–æ‰€æœ‰åº“å­˜è¯¦ç»†ä¿¡æ¯ï¼ˆä¸ä¼ å…¥åº—é“ºç­›é€‰ï¼‰
      final allInventory = await getInventoryWithDetails(
        categoryFilter: categoryFilter,
        statusFilter: statusFilter,
      );

      print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šè·å–åˆ° ${allInventory.length} æ¡åŸå§‹åº“å­˜è®°å½?);

      if (allInventory.isEmpty) {
        return [];
      }

      // 2. æŒ‰productIdåˆ†ç»„èšåˆ
      final Map<int, List<Map<String, dynamic>>> groupedByProduct = {};
      for (var item in allInventory) {
        final productId = item['productId'] as int;
        groupedByProduct.putIfAbsent(productId, () => []).add(item);
      }

      print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šæŒ‰è´§å“åˆ†ç»„åå¾—åˆ?${groupedByProduct.length} ä¸ªè´§å“?);

      // 3. æ„å»ºèšåˆæ•°æ®åˆ—è¡¨
      final result = <AggregatedInventoryItem>[];
      for (var entry in groupedByProduct.entries) {
        final items = entry.value;
        
        try {
          // ä½¿ç”¨å·¥å‚æ–¹æ³•åˆ›å»ºèšåˆé¡?
          final aggregatedItem = AggregatedInventoryItem.fromInventoryList(items);
          result.add(aggregatedItem);
        } catch (e) {
          print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šèšåˆè´§å“?${entry.key} å¤±è´¥: $e');
          // ç»§ç»­å¤„ç†å…¶ä»–è´§å“ï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
          continue;
        }
      }

      print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šæˆåŠŸèšå?${result.length} ä¸ªè´§å“?);
      return result;
    } catch (e) {
      print('ğŸ“¦ åº“å­˜èšåˆæœåŠ¡ï¼šè·å–èšåˆåº“å­˜æ•°æ®å¤±è´? $e');
      print('ğŸ“¦ é”™è¯¯å †æ ˆ: ${e.toString()}');
      rethrow;
    }
  }

  /// è°ƒæ•´åº“å­˜
  /// å¦‚æœæ‰¾åˆ°è®°å½•ï¼Œåˆ™æ›´æ–°å…¶æ•°é‡ï¼Œå¦åˆ™åˆ›å»ºæ–°è®°å½?
  Future<void> adjustStock({
    required int productId,
    required int shopId,
    required int newQuantity,
    int? batchId,
  }) async {
    try {
      print(
          'ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šå¼€å§‹è°ƒæ•´åº“å­?- Product: $productId, Shop: $shopId, Batch: $batchId, New Quantity: $newQuantity');

      final existingStock =
          await _inventoryRepository.getInventoryByProductShopAndBatch(
        productId,
        shopId,
        batchId,
      );

      if (existingStock != null) {
        print('ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šæ‰¾åˆ°ç°æœ‰åº“å­˜è®°å½•ï¼Œå‡†å¤‡æ›´æ–°');
        final updatedStock = existingStock.copyWith(
          quantity: newQuantity,
          updatedAt: DateTime.now(),
        );
        await _inventoryRepository.updateInventory(updatedStock);
        print('ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šåº“å­˜æ›´æ–°æˆåŠ?);
      } else {
        print('ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šæœªæ‰¾åˆ°ç°æœ‰åº“å­˜è®°å½•ï¼Œå‡†å¤‡åˆ›å»ºæ–°è®°å½•');
        final newStock = StockModel(
          productId: productId,
          shopId: shopId,
          quantity: newQuantity,
          batchId: batchId,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await _inventoryRepository.addInventory(newStock);
        print('ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šæ–°åº“å­˜è®°å½•åˆ›å»ºæˆåŠŸ');
      }
    } catch (e) {
      print('ğŸ“¦ åº“å­˜è°ƒæ•´æœåŠ¡ï¼šè°ƒæ•´åº“å­˜å¤±è´? $e');
      rethrow;
    }
  }
}

/// BatchDao Provider
final batchDaoProvider = Provider<BatchDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return db.batchDao;
});

/// åº“å­˜æŸ¥è¯¢æœåŠ¡ Provider
final purchaseDaoProvider = Provider<PurchaseDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return db.purchaseDao;
});

final inventoryQueryServiceProvider = Provider<InventoryQueryService>((ref) {
  final inventoryRepository = ref.watch(inventoryRepositoryProvider);
  final productRepository = ref.watch(productRepositoryProvider);
  final productUnitRepository = ref.watch(productUnitRepositoryProvider);
  final unitRepository = ref.watch(unitRepositoryProvider);
  final batchDao = ref.watch(batchDaoProvider);
  final purchaseDao = ref.watch(purchaseDaoProvider);

  return InventoryQueryService(
    inventoryRepository,
    productRepository,
    productUnitRepository,
    unitRepository,
    batchDao,
    purchaseDao,
    ref,
  );
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../../inbound/data/dao/inbound_item_dao.dart';

final inboundItemDaoProvider = Provider<InboundItemDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return db.inboundItemDao;
});

final inboundRecordsProvider =
    FutureProvider<List<InboundReceiptData>>((ref) async {
  final database = ref.read(appDatabaseProvider);
  final receipts = await database.inboundReceiptDao.getAllInboundReceipts();
  receipts.sort((a, b) => b.createdAt.compareTo(a.createdAt));
  return receipts;
});

final inboundRecordItemsProvider =
    FutureProvider.family<List<InboundItemData>, int>((
  ref,
  recordId,
) {
  final dao = ref.watch(inboundItemDaoProvider);
  return dao.getInboundItemsByReceiptId(recordId);
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../application/inventory_query_service.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../domain/model/aggregated_inventory.dart';

enum InventorySortType { none, byQuantity, byShelfLife }

/// åº“å­˜ç­›é€‰çŠ¶æ€?
class InventoryFilterState {
  final String selectedShop;
  final String selectedCategory;
  final String selectedStatus;
  final InventorySortType sortBy;

  const InventoryFilterState({
    this.selectedShop = 'æ‰€æœ‰ä»“åº?,
    this.selectedCategory = 'æ‰€æœ‰åˆ†ç±?,
    this.selectedStatus = 'åº“å­˜çŠ¶æ€?,
    this.sortBy = InventorySortType.none,
  });

  InventoryFilterState copyWith({
    String? selectedShop,
    String? selectedCategory,
    String? selectedStatus,
    InventorySortType? sortBy,
  }) {
    return InventoryFilterState(
      selectedShop: selectedShop ?? this.selectedShop,
      selectedCategory: selectedCategory ?? this.selectedCategory,
      selectedStatus: selectedStatus ?? this.selectedStatus,
      sortBy: sortBy ?? this.sortBy,
    );
  }
}

/// åº“å­˜ç­›é€‰çŠ¶æ€ç®¡ç†å™¨
class InventoryFilterNotifier extends StateNotifier<InventoryFilterState> {
  InventoryFilterNotifier() : super(const InventoryFilterState());

  void updateShop(String? shop) {
    if (shop == 'æ‰€æœ‰ä»“åº?) shop = null;
    state = state.copyWith(selectedShop: shop ?? 'æ‰€æœ‰ä»“åº?);
  }

  void updateCategory(String? category) {
    if (category == 'æ‰€æœ‰åˆ†ç±?) category = null;
    state = state.copyWith(selectedCategory: category ?? 'æ‰€æœ‰åˆ†ç±?);
  }

  void updateStatus(String? status) {
    if (status == 'åº“å­˜çŠ¶æ€?) status = null;
    state = state.copyWith(selectedStatus: status ?? 'åº“å­˜çŠ¶æ€?);
  }

  void updateSortBy(InventorySortType sortBy) {
    state = state.copyWith(sortBy: sortBy);
  }

  void reset() {
    state = const InventoryFilterState();
  }
}

/// åº“å­˜ç­›é€‰Provider
final inventoryFilterProvider =
    StateNotifierProvider<InventoryFilterNotifier, InventoryFilterState>((ref) {
      return InventoryFilterNotifier();
    });

/// åº“å­˜æŸ¥è¯¢æ•°æ®Provider - ä½¿ç”¨çœŸå®æ•°æ®åº“æŸ¥è¯?
/// æ·»åŠ å¯¹äº§å“æ•°æ®å˜åŒ–çš„ç›‘å¬ï¼Œç¡®ä¿äº§å“å›¾ç‰‡æ›´æ–°ååº“å­˜é¡µé¢èƒ½åŒæ­¥åˆ·æ–?
/// æ”¯æŒèšåˆæ¨¡å¼ï¼šæœªç­›é€‰åº—é“ºæ—¶è¿”å›èšåˆæ•°æ®ï¼Œç­›é€‰åº—é“ºæ—¶è¿”å›åŸå§‹æ•°æ®
final inventoryQueryProvider = FutureProvider<dynamic>((
  ref,
) async {
  final filterState = ref.watch(inventoryFilterProvider);
  final queryService = ref.watch(inventoryQueryServiceProvider);
  
  // ç›‘å¬äº§å“æ•°æ®å˜åŒ–ï¼Œç¡®ä¿äº§å“ä¿¡æ¯ï¼ˆåŒ…æ‹¬å›¾ç‰‡ï¼‰æ›´æ–°ååº“å­˜é¡µé¢èƒ½åŒæ­¥åˆ·æ–?
  ref.watch(productListStreamProvider);
  
  // å°†é»˜è®¤å€¼è½¬æ¢ä¸ºnullä¼ é€’ç»™æŸ¥è¯¢æœåŠ¡
  final shopFilter = filterState.selectedShop == 'æ‰€æœ‰ä»“åº?
      ? null
      : filterState.selectedShop;
  final categoryFilter = filterState.selectedCategory == 'æ‰€æœ‰åˆ†ç±?
      ? null
      : filterState.selectedCategory;
  final statusFilter = filterState.selectedStatus == 'åº“å­˜çŠ¶æ€?
      ? null
      : filterState.selectedStatus;

  final sortBy = filterState.sortBy;

  // åˆ¤æ–­æ˜¯å¦éœ€è¦èšåˆï¼šæœªç­›é€‰åº—é“ºæ—¶ä½¿ç”¨èšåˆæ¨¡å¼
  if (shopFilter == null) {
    // èšåˆæ¨¡å¼ï¼šè¿”å›èšåˆæ•°æ?
    final aggregatedData = await queryService.getAggregatedInventory(
      categoryFilter: categoryFilter,
      statusFilter: statusFilter,
    );

    // åº”ç”¨æ’åºåˆ°èšåˆæ•°æ?
    _applySortToAggregated(aggregatedData, sortBy);

    return aggregatedData;
  } else {
    // åŸå§‹æ¨¡å¼ï¼šè¿”å›åŸå§‹æ•°æ?
    final data = await queryService.getInventoryWithDetails(
      shopFilter: shopFilter,
      categoryFilter: categoryFilter,
      statusFilter: statusFilter,
    );

    // åº”ç”¨æ’åºåˆ°åŸå§‹æ•°æ?
    _applySortToOriginal(data, sortBy);

    return data;
  }
});

/// å¯¹èšåˆæ•°æ®åº”ç”¨æ’åº?
void _applySortToAggregated(
  List<AggregatedInventoryItem> data,
  InventorySortType sortBy,
) {
  if (sortBy == InventorySortType.byQuantity) {
    data.sort((a, b) => a.totalQuantity.compareTo(b.totalQuantity));
  } else if (sortBy == InventorySortType.byShelfLife) {
    // æŒ‰æœ€çŸ­å‰©ä½™ä¿è´¨æœŸæ’åº
    data.sort((a, b) {
      final aMinDays = a.minRemainingDays;
      final bMinDays = b.minRemainingDays;
      
      // æ²¡æœ‰ä¿è´¨æœŸä¿¡æ¯çš„æ’åœ¨åé¢
      if (aMinDays == null && bMinDays == null) return 0;
      if (aMinDays == null) return 1;
      if (bMinDays == null) return -1;
      
      return aMinDays.compareTo(bMinDays);
    });
  }
}

/// å¯¹åŸå§‹æ•°æ®åº”ç”¨æ’åº?
void _applySortToOriginal(
  List<Map<String, dynamic>> data,
  InventorySortType sortBy,
) {
  if (sortBy == InventorySortType.byQuantity) {
    data.sort((a, b) => (a['quantity'] as num).compareTo(b['quantity'] as num));
  } else if (sortBy == InventorySortType.byShelfLife) {
    final now = DateTime.now();
    final filteredData = data.where((item) {
      final productionDateStr = item['productionDate'];
      final shelfLifeDays = item['shelfLifeDays'];
      final shelfLifeUnit = item['shelfLifeUnit'];
      return productionDateStr is String &&
          productionDateStr.isNotEmpty &&
          shelfLifeDays is int &&
          shelfLifeUnit is String;
    }).toList();

    filteredData.sort((a, b) {
      try {
        // å®‰å…¨è§£ææ—¥æœŸå­—ç¬¦ä¸?
        final aDateStr = (a['productionDate'] as String).trim();
        final bDateStr = (b['productionDate'] as String).trim();
        
        // å°è¯•è§£ææ—¥æœŸï¼Œå¦‚æœå¤±è´¥åˆ™è·³è¿‡
        DateTime aProductionDate;
        DateTime bProductionDate;
        
        try {
          aProductionDate = DateTime.parse(aDateStr);
        } catch (e) {
          return 1; // è§£æå¤±è´¥çš„é¡¹æ’åœ¨åé¢
        }
        
        try {
          bProductionDate = DateTime.parse(bDateStr);
        } catch (e) {
          return -1; // è§£æå¤±è´¥çš„é¡¹æ’åœ¨åé¢
        }
        
        final aShelfLife = a['shelfLifeDays'] as int;
        final aShelfLifeUnit = a['shelfLifeUnit'] as String;
        
        // æ ¹æ®ä¿è´¨æœŸå•ä½è½¬æ¢ä¸ºå¤©æ•°
        int aShelfLifeInDays;
        switch (aShelfLifeUnit) {
          case 'days':
            aShelfLifeInDays = aShelfLife;
            break;
          case 'months':
            aShelfLifeInDays = aShelfLife * 30; // è¿‘ä¼¼å€?
            break;
          case 'years':
            aShelfLifeInDays = aShelfLife * 365; // è¿‘ä¼¼å€?
            break;
          default:
            aShelfLifeInDays = aShelfLife; // é»˜è®¤æŒ‰å¤©å¤„ç†
        }
        
        final aExpiryDate = aProductionDate.add(Duration(days: aShelfLifeInDays));
        final aRemaining = aExpiryDate.difference(now);

        final bShelfLife = b['shelfLifeDays'] as int;
        final bShelfLifeUnit = b['shelfLifeUnit'] as String;
        
        // æ ¹æ®ä¿è´¨æœŸå•ä½è½¬æ¢ä¸ºå¤©æ•°
        int bShelfLifeInDays;
        switch (bShelfLifeUnit) {
          case 'days':
            bShelfLifeInDays = bShelfLife;
            break;
          case 'months':
            bShelfLifeInDays = bShelfLife * 30; // è¿‘ä¼¼å€?
            break;
          case 'years':
            bShelfLifeInDays = bShelfLife * 365; // è¿‘ä¼¼å€?
            break;
          default:
            bShelfLifeInDays = bShelfLife; // é»˜è®¤æŒ‰å¤©å¤„ç†
        }
        
        final bExpiryDate = bProductionDate.add(Duration(days: bShelfLifeInDays));
        final bRemaining = bExpiryDate.difference(now);

        return aRemaining.compareTo(bRemaining);
      } catch (e) {
        // å¦‚æœè§£æå¤±è´¥ï¼Œåˆ™å°†è¯¥é¡¹æ’åœ¨åé?
        return 1;
      }
    });
    
    // å°†æ’åºåçš„æ•°æ®å¤åˆ¶å›åŸåˆ—è¡?
    data.clear();
    data.addAll(filteredData);
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../../outbound/data/dao/outbound_item_dao.dart';

final outboundItemDaoProvider = Provider<OutboundItemDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return db.outboundItemDao;
});

/// å®æ—¶ç›‘å¬æ‰€æœ‰å‡ºåº“è®°å½•ï¼Œæ•°æ®åº“æœ‰å˜åŒ–æ—¶è‡ªåŠ¨æ¨é€åˆ° UI
final outboundReceiptsProvider =
    StreamProvider<List<OutboundReceiptData>>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return database.outboundReceiptDao
      .watchAllOutboundReceipts()
      .map((receipts) {
    final sorted = List<OutboundReceiptData>.of(receipts)
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));
    return sorted;
  });
});

final outboundReceiptItemsProvider =
    FutureProvider.family<List<OutboundItemData>, int>((ref, recordId) {
  final dao = ref.watch(outboundItemDaoProvider);
  return dao.getOutboundItemsByReceiptId(recordId);
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../data/dao/inventory_transaction_dao.dart';
import '../../domain/model/inventory_transaction.dart';

final inventoryTransactionDaoProvider =
    Provider<InventoryTransactionDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return db.inventoryTransactionDao;
});

/// Provider to watch all outbound records, returning the full data objects.
final outboundRecordsProvider =
    FutureProvider<List<InventoryTransactionModel>>((ref) async {
  final dao = ref.watch(inventoryTransactionDaoProvider);
  final transactionsData = await dao.getAllTransactions();
  
  // Convert TableData to Domain Model
  final transactions = transactionsData.map((data) {
    return InventoryTransactionModel(
      id: data.id,
      productId: data.productId,
  // DB stores short codes: 'in' | 'out' | 'adjust' | 'transfer' | 'return'
  // Use converter to enum to avoid Bad state: No element
  type: inventoryTransactionTypeFromDbCode(data.transactionType),
      quantity: data.quantity,
      shopId: data.shopId,
      batchId: data.batchId,
      createdAt: data.createdAt,
    );
  }).toList();

  // Filter for outbound records
  final outboundTransactions = transactions
      .where((t) => t.isOutbound)
      .toList();
      
  // Sort by creation date descending
  outboundTransactions.sort((a, b) => b.createdAt!.compareTo(a.createdAt!));
  
  return outboundTransactions;
});
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../providers/inventory_query_providers.dart';
import '../widgets/inventory_filter_bar.dart';
import '../widgets/aggregated_inventory_card.dart';
import '../widgets/simple_inventory_card.dart';
import '../../domain/model/aggregated_inventory.dart';
import '../../../../core/widgets/cached_image_widget.dart';

/// åº“å­˜æŸ¥è¯¢é¡µé¢
/// å±•ç¤ºå•†å“åº“å­˜ä¿¡æ¯ï¼Œæ”¯æŒç­›é€‰åŠŸèƒ?
class InventoryQueryScreen extends ConsumerWidget {
  const InventoryQueryScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final inventoryAsyncValue = ref.watch(inventoryQueryProvider);
    final filterState = ref.watch(inventoryFilterProvider);
    final isAggregatedMode = filterState.selectedShop == 'æ‰€æœ‰ä»“åº?;

    return Scaffold(
      appBar: AppBar(
        title: const Text('åº“å­˜æŸ¥è¯¢'),
        centerTitle: true,
        leading: IconButton(
          onPressed: () => context.pop(),
          icon: const Icon(Icons.arrow_back),
          tooltip: 'è¿”å›',
        ),
        backgroundColor: Theme.of(context).colorScheme.surface,
        foregroundColor: Theme.of(context).colorScheme.onSurface,
        elevation: 0,
        actions: [
          PopupMenuButton<InventorySortType>(
            onSelected: (InventorySortType sortType) {
              ref.read(inventoryFilterProvider.notifier).updateSortBy(sortType);
            },
            itemBuilder: (BuildContext context) =>
                <PopupMenuEntry<InventorySortType>>[
                  const PopupMenuItem<InventorySortType>(
                    value: InventorySortType.byQuantity,
                    child: Text('æŒ‰åº“å­˜æ•°é‡æ’åº?),
                  ),
                  const PopupMenuItem<InventorySortType>(
                    value: InventorySortType.byShelfLife,
                    child: Text('æŒ‰å‰©ä½™ä¿è´¨æœŸæ’åº'),
                  ),
                  const PopupMenuItem<InventorySortType>(
                    value: InventorySortType.none,
                    child: Text('é»˜è®¤æ’åº'),
                  ),
                ],
            icon: const Icon(Icons.sort),
            tooltip: 'æ’åºæ–¹å¼',
          ),
        ],
      ),
      bottomNavigationBar: null,
      body: inventoryAsyncValue.when(
        data: (inventoryData) {
          if (isAggregatedMode) {
            // èšåˆæ¨¡å¼ï¼šä½¿ç”¨AggregatedInventoryCard
            final aggregatedList =
                inventoryData as List<AggregatedInventoryItem>;
            return _buildAggregatedView(aggregatedList);
          } else {
            // åŸå§‹æ¨¡å¼ï¼šä½¿ç”¨åŸæœ‰çš„å¡ç‰‡
            final inventoryList = inventoryData as List<Map<String, dynamic>>;
            return _buildOriginalView(inventoryList);
          }
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                'åŠ è½½åº“å­˜æ•°æ®å¤±è´¥',
                style: TextStyle(fontSize: 16, color: Colors.grey[700]),
              ),
              const SizedBox(height: 8),
              Text(
                error.toString(),
                style: const TextStyle(fontSize: 12, color: Colors.grey),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  ref.invalidate(inventoryQueryProvider);
                },
                child: const Text('é‡è¯•'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// æ„å»ºèšåˆæ¨¡å¼çš„è§†å›?
  Widget _buildAggregatedView(List<AggregatedInventoryItem> aggregatedList) {
    // è®¡ç®—æ€»æ•°é‡?
    final totalQuantity = aggregatedList.fold<int>(
      0,
      (sum, item) => sum + item.totalQuantity,
    );

    // è®¡ç®—æ€»ä»·å€?
    final totalValue = aggregatedList.fold<double>(
      0,
      (sum, item) => sum + item.totalValue,
    );

    return Column(
      children: [
        // ç­›é€‰æ 
        const InventoryFilterBar(),

        // Summary section
        if (aggregatedList.isNotEmpty)
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildSummaryItem('å“ç§', '${aggregatedList.length}'),
                _buildSummaryItem('æ€»æ•°', '$totalQuantity'),
                _buildSummaryItem('æ€»ä»·å€?, 'Â¥${totalValue.toStringAsFixed(2)}'),
              ],
            ),
          ),

        // èšåˆå•†å“åˆ—è¡¨
        Expanded(
          child: aggregatedList.isEmpty
              ? const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.inventory_2_outlined,
                        size: 64,
                        color: Colors.grey,
                      ),
                      SizedBox(height: 16),
                      Text(
                        'æš‚æ— åº“å­˜æ•°æ®',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                    ],
                  ),
                )
              : ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: aggregatedList.length,
                  itemBuilder: (context, index) {
                    final aggregatedItem = aggregatedList[index];
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 12),
                      child: aggregatedItem.isExpandable
                          ? AggregatedInventoryCard(item: aggregatedItem)
                          : SimpleInventoryCard(item: aggregatedItem),
                    );
                  },
                ),
        ),
      ],
    );
  }

  /// æ„å»ºåŸå§‹æ¨¡å¼çš„è§†å›?
  Widget _buildOriginalView(List<Map<String, dynamic>> inventoryList) {
    // è®¡ç®—æ€»æ•°é‡?
    final totalQuantity = inventoryList.fold<int>(
      0,
      (previousValue, element) =>
          previousValue + (element['quantity'] as num).toInt(),
    );

    // è®¡ç®—æ€»ä»·å€?
    final totalValue = inventoryList.fold<double>(
      0,
      (previousValue, element) =>
          previousValue +
          (element['quantity'] as num) *
              (element['purchasePrice'] as num? ?? 0) /
              100,
    );

    return Column(
      children: [
        // ç­›é€‰æ 
        const InventoryFilterBar(),

        // Summary section
        if (inventoryList.isNotEmpty)
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildSummaryItem('å“ç§', '${inventoryList.length}'),
                _buildSummaryItem('æ€»æ•°', '$totalQuantity'),
                _buildSummaryItem('æ€»ä»·å€?, 'Â¥${totalValue.toStringAsFixed(2)}'),
              ],
            ),
          ),

        // å•†å“åˆ—è¡¨
        Expanded(
          child: inventoryList.isEmpty
              ? const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.inventory_2_outlined,
                        size: 64,
                        color: Colors.grey,
                      ),
                      SizedBox(height: 16),
                      Text(
                        'æš‚æ— åº“å­˜æ•°æ®',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                    ],
                  ),
                )
              : ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: inventoryList.length,
                  itemBuilder: (context, index) {
                    final inventoryData = inventoryList[index];
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 12),
                      child: _buildInventoryCard(inventoryData),
                    );
                  },
                ),
        ),
      ],
    );
  }

  Widget _buildSummaryItem(String title, String value) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(title, style: const TextStyle(fontSize: 14, color: Colors.grey)),
        const SizedBox(width: 4),
        Text(
          value,
          style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
        ),
      ],
    );
  }

  /// æ„å»ºåº“å­˜å¡ç‰‡
  Widget _buildInventoryCard(Map<String, dynamic> inventoryData) {
    final productName = inventoryData['productName'] as String? ?? 'æœªçŸ¥å•†å“';
    final productImage = inventoryData['productImage'] as String?;
    final quantity = (inventoryData['quantity'] as num?)?.toInt() ?? 0;
    final unit = inventoryData['unit'] as String? ?? 'ä¸?;
    final shopName = inventoryData['shopName'] as String? ?? 'æœªçŸ¥åº—é“º';
    final categoryName = inventoryData['categoryName'] as String? ?? 'æœªåˆ†ç±?;

    // æ ¹æ®åº“å­˜æ•°é‡ç¡®å®šçŠ¶æ€?
    final stockStatus = _getStockStatus(quantity);

    // è®¡ç®—ä¿è´¨æœŸï¼ˆå¦‚æœæœ‰æ‰¹æ¬¡ä¿¡æ¯ï¼‰
    String? shelfLifeText;
    if (inventoryData['productionDate'] != null &&
        inventoryData['shelfLifeDays'] != null &&
        inventoryData['shelfLifeUnit'] != null) {
      try {
        final productionDate = DateTime.parse(
          inventoryData['productionDate'] as String,
        );
        final shelfLifeDays = inventoryData['shelfLifeDays'] as int;
        final shelfLifeUnit = inventoryData['shelfLifeUnit'] as String;

        int shelfLifeInDays;
        switch (shelfLifeUnit) {
          case 'days':
            shelfLifeInDays = shelfLifeDays;
            break;
          case 'months':
            shelfLifeInDays = shelfLifeDays * 30;
            break;
          case 'years':
            shelfLifeInDays = shelfLifeDays * 365;
            break;
          default:
            shelfLifeInDays = shelfLifeDays;
        }

        final expiryDate = productionDate.add(Duration(days: shelfLifeInDays));
        final remainingDays = expiryDate.difference(DateTime.now()).inDays;

        if (remainingDays <= 0) {
          shelfLifeText = 'å·²è¿‡æœ?;
        } else {
          shelfLifeText = 'å‰©ä½™: $remainingDays å¤?;
        }
      } catch (e) {
        // å¦‚æœæ—¥æœŸè§£æå¤±è´¥ï¼Œå¿½ç•¥ä¿è´¨æœŸæ˜¾ç¤º
        shelfLifeText = null;
      }
    }

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            // å•†å“å›¾ç‰‡
            productImage != null && productImage.isNotEmpty
                ? ProductThumbnailImage(imagePath: productImage)
                : Container(
                    width: 60,
                    height: 80,
                    decoration: BoxDecoration(
                      color: Colors.grey.shade100,
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Icon(
                      Icons.image_outlined,
                      color: Colors.grey.shade400,
                      size: 30,
                    ),
                  ),
            const SizedBox(width: 16),

            // å•†å“ä¿¡æ¯å’Œåº“å­?
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // å•†å“åç§°
                  Text(
                    productName,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // åˆ†ç±»å’Œåº—é“ºä¿¡æ?
                  Text(
                    '$categoryName Â· $shopName',
                    style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                  ),

                  if (shelfLifeText != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      shelfLifeText,
                      style: TextStyle(
                        fontSize: 12,
                        color: shelfLifeText == 'å·²è¿‡æœ?
                            ? Colors.red
                            : Colors.grey[600],
                      ),
                    ),
                  ],
                  const SizedBox(height: 12),

                  // åº“å­˜ä¿¡æ¯
                  Row(
                    children: [
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.baseline,
                        textBaseline: TextBaseline.alphabetic,
                        children: [
                          Text(
                            '$quantity',
                            style: const TextStyle(
                              fontSize: 20,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            unit,
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                      const Spacer(),

                      // åº“å­˜çŠ¶æ€æŒ‡ç¤ºå™¨
                      _buildStatusIndicator(stockStatus),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// æ ¹æ®åº“å­˜æ•°é‡è·å–çŠ¶æ€?
  _StockStatus _getStockStatus(int quantity) {
    if (quantity <= 0) {
      return _StockStatus.outOfStock;
    } else if (quantity <= 10) {
      return _StockStatus.lowStock;
    } else {
      return _StockStatus.normal;
    }
  }

  /// æ„å»ºçŠ¶æ€æŒ‡ç¤ºå™¨
  Widget _buildStatusIndicator(_StockStatus status) {
    switch (status) {
      case _StockStatus.outOfStock:
        return Container(
          width: 12,
          height: 12,
          decoration: const BoxDecoration(
            color: Colors.red,
            shape: BoxShape.circle,
          ),
        );
      case _StockStatus.lowStock:
        return Container(
          width: 12,
          height: 12,
          decoration: const BoxDecoration(
            color: Colors.orange,
            shape: BoxShape.circle,
          ),
        );
      case _StockStatus.normal:
        return const SizedBox.shrink();
    }
  }
}

/// åº“å­˜çŠ¶æ€æšä¸?
enum _StockStatus { normal, lowStock, outOfStock }
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/constants/app_routes.dart';
import '../widgets/inbound_record_card.dart';
import '../providers/inbound_records_provider.dart';
import '../providers/outbound_receipts_provider.dart';
import '../widgets/outbound_record_card.dart';

/// åº“å­˜è®°å½•é¡µé¢
/// å±•ç¤ºæ‰€æœ‰å…¥åº“å’Œå‡ºåº“è®°å½•ï¼Œæ”¯æŒæŸ¥çœ‹è¯¦æƒ?
class InventoryRecordsScreen extends ConsumerStatefulWidget {
  const InventoryRecordsScreen({super.key});

  @override
  ConsumerState<InventoryRecordsScreen> createState() =>
      _InventoryRecordsScreenState();
}

class _InventoryRecordsScreenState extends ConsumerState<InventoryRecordsScreen> {
  bool _isOutboundView = false; // false: å…¥åº“è®°å½•, true: å‡ºåº“è®°å½•

  @override
  Widget build(BuildContext context) {
    final inboundRecordsAsync = ref.watch(inboundRecordsProvider);
  final outboundRecordsAsync = ref.watch(outboundReceiptsProvider);

    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) {
        if (didPop) return;
        context.go('/');
      },
      child: Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () => context.go('/'), // å¯¼èˆªåˆ°åº”ç”¨é¦–é¡?
            tooltip: 'è¿”å›é¦–é¡µ',
          ),
          title: Text(_isOutboundView ? 'å‡ºåº“è®°å½•' : 'å…¥åº“è®°å½•'),
          centerTitle: true,
          backgroundColor: Theme.of(context).colorScheme.surface,
          foregroundColor: Theme.of(context).colorScheme.onSurface,
          elevation: 0,
          actions: [
            TextButton(
              onPressed: () {
                setState(() {
                  _isOutboundView = !_isOutboundView;
                });
              },
              child: Text(_isOutboundView ? 'çœ‹å…¥åº? : 'çœ‹å‡ºåº?),
            ),
          ],
        ),
        body: _isOutboundView
            ? outboundRecordsAsync.when(
                data: (records) => records.isEmpty
                    ? const Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.outbox_outlined,
                              size: 64,
                              color: Colors.grey,
                            ),
                            SizedBox(height: 16),
                            Text(
                              'æš‚æ— å‡ºåº“è®°å½•',
                              style: TextStyle(
                                fontSize: 16,
                                color: Colors.grey,
                              ),
                            ),
                          ],
                        ),
                      )
                    : ListView.builder(
                        padding: const EdgeInsets.all(16),
                        itemCount: records.length,
                        itemBuilder: (context, index) {
                          final record = records[index];
                          return Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: OutboundRecordCard(record: record),
                          );
                        },
                      ),
                loading: () =>
                    const Center(child: CircularProgressIndicator()),
                error: (error, stackTrace) => Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(
                        Icons.error_outline,
                        size: 64,
                        color: Colors.red,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'åŠ è½½å¤±è´¥ï¼?error',
                        style:
                            const TextStyle(fontSize: 16, color: Colors.red),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
            onPressed: () =>
              ref.refresh(outboundReceiptsProvider),
                        child: const Text('é‡è¯•'),
                      ),
                    ],
                  ),
                ),
              )
            : Column(
                children: [
                  // è®°å½•åˆ—è¡¨
                  Expanded(
                    child: inboundRecordsAsync.when(
                      data: (records) => records.isEmpty
                          ? const Center(
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(
                                    Icons.inventory_outlined,
                                    size: 64,
                                    color: Colors.grey,
                                  ),
                                  SizedBox(height: 16),
                                  Text(
                                    'æš‚æ— å…¥åº“è®°å½•',
                                    style: TextStyle(
                                      fontSize: 16,
                                      color: Colors.grey,
                                    ),
                                  ),
                                ],
                              ),
                            )
                          : ListView.builder(
                              padding: const EdgeInsets.all(16),
                              itemCount: records.length,
                              itemBuilder: (context, index) {
                                final record = records[index];
                                return Padding(
                                  padding: const EdgeInsets.only(bottom: 12),
                                  child: InboundRecordCard(
                                    record: record,
                                  ),
                                );
                              },
                            ),
                      loading: () =>
                          const Center(child: CircularProgressIndicator()),
                      error: (error, stackTrace) => Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(
                              Icons.error_outline,
                              size: 64,
                              color: Colors.red,
                            ),
                            const SizedBox(height: 16),
                            Text(
                              'åŠ è½½å¤±è´¥ï¼?error',
                              style: const TextStyle(
                                  fontSize: 16, color: Colors.red),
                              textAlign: TextAlign.center,
                            ),
                            const SizedBox(height: 16),
                            ElevatedButton(
                              onPressed: () =>
                                  ref.refresh(inboundRecordsProvider),
                              child: const Text('é‡è¯•'),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ],
              ),
        // æ‚¬æµ®æ“ä½œæŒ‰é’® - æŸ¥è¯¢åº“å­˜
        floatingActionButton: FloatingActionButton.extended(
          onPressed: () => context.push(AppRoutes.inventoryQuery),
          icon: const Icon(Icons.search),
          label: const Text('æŸ¥è¯¢åº“å­˜'),
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary,
        ),
      ),
    );
  }
}
// åº“å­˜åŠŸèƒ½ç›¸å…³é¡µé¢ç»Ÿä¸€å¯¼å‡º
export 'inventory_query_screen.dart';
export 'inventory_records_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/features/inventory/application/provider/shop_providers.dart';
import 'package:stocko_app/features/product/data/repository/product_repository.dart';
import 'package:stocko_app/features/inventory/domain/model/shop.dart';
import 'package:stocko_app/features/inventory/presentation/application/inventory_query_service.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';
import 'package:stocko_app/features/inventory/domain/model/batch.dart' as bm;
import 'package:stocko_app/core/utils/snackbar_helper.dart';
import 'package:stocko_app/features/inventory/presentation/providers/inventory_query_providers.dart';
import 'package:stocko_app/features/inventory/data/repository/inventory_repository.dart';

class AdjustInventoryDialog extends ConsumerStatefulWidget {
  final ProductModel product;

  const AdjustInventoryDialog({
    super.key,
    required this.product,
  });

  @override
  _AdjustInventoryDialogState createState() => _AdjustInventoryDialogState();
}

class _AdjustInventoryDialogState extends ConsumerState<AdjustInventoryDialog> {
  final _quantityController = TextEditingController();
  Shop? _selectedShop;
  bm.BatchModel? _selectedBatch;
  List<bm.BatchModel>? _batches;
  bool _isFetchingBatches = false;
  bool _isFetchingInventory = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _quantityController.dispose();
    super.dispose();
  }

  Future<void> _loadCurrentInventory() async {
    if (_selectedShop == null || widget.product.id == null) return;
    
    setState(() => _isFetchingInventory = true);
    try {
      final inventory = await ref
          .read(inventoryRepositoryProvider)
          .getInventoryByProductShopAndBatch(
            widget.product.id!,
            _selectedShop!.id!,
            widget.product.enableBatchManagement ? _selectedBatch?.id : null,
          );
      
      if (mounted) {
        setState(() {
          _quantityController.text = inventory?.quantity.toString() ?? '0';
        });
      }
    } catch (e) {
      if (mounted) {
        showAppSnackBar(context, message: 'è·å–åº“å­˜æ•°é‡å¤±è´¥: $e', isError: true);
      }
    } finally {
      if (mounted) {
        setState(() => _isFetchingInventory = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool batchManaged = widget.product.enableBatchManagement;
    final shopsAsyncValue = ref.watch(allShopsProvider);

    return AlertDialog(
      title: Text('è°ƒæ•´åº“å­˜: ${widget.product.name}'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          shopsAsyncValue.when(
            data: (shops) => DropdownButtonFormField<Shop>(
              value: _selectedShop,
              onChanged: (Shop? newShop) async {
                setState(() {
                  _selectedShop = newShop;
                  _batches = null;
                  _selectedBatch = null;
                  _quantityController.text = '';
                });
                if (newShop != null) {
                  if (batchManaged) {
                    setState(() => _isFetchingBatches = true);
                    try {
                      final productId = widget.product.id;
                      final shopId = newShop.id;

                      if (productId == null || shopId == null) {
                        // Handle error case where IDs are null
                        showAppSnackBar(context,
                            message: 'äº§å“æˆ–åº—é“ºIDæ— æ•ˆ', isError: true);
                        return;
                      }

                      final batches = await ref
                          .read(productRepositoryProvider)
                          .getBatchesByProductAndShop(productId, shopId);
                      if (mounted) {
                        setState(() {
                          _batches = batches;
                          _selectedBatch = batches.isNotEmpty ? batches.first : null;
                        });
                      }
                    } catch (e) {
                      if (mounted) {
                        showAppSnackBar(context,
                            message: 'è·å–æ‰¹æ¬¡å¤±è´¥: $e', isError: true);
                      }
                    } finally {
                      if (mounted) {
                        setState(() => _isFetchingBatches = false);
                      }
                    }
                  } else {
                    // å¦‚æœä¸å¯ç”¨æ‰¹æ¬¡ç®¡ç†ï¼Œç›´æ¥è·å–å½“å‰åº“å­˜
                    await _loadCurrentInventory();
                  }
                }
              },
              items: shops.map<DropdownMenuItem<Shop>>((Shop shop) {
                return DropdownMenuItem<Shop>(
                  value: shop,
                  child: Text(shop.name),
                );
              }).toList(),
              decoration: const InputDecoration(
                labelText: 'é€‰æ‹©åº—é“º',
                border: OutlineInputBorder(),
              ),
            ),
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (err, stack) => Text('æ— æ³•åŠ è½½åº—é“º: $err'),
          ),
          const SizedBox(height: 16),
          if (batchManaged && _selectedShop != null)
            _isFetchingBatches
                ? const Center(child: CircularProgressIndicator())
                : (_batches != null && _batches!.isNotEmpty)
                    ? DropdownButtonFormField<bm.BatchModel>(
                        value: _selectedBatch,
                        onChanged: (bm.BatchModel? newValue) async {
                          setState(() {
                            _selectedBatch = newValue;
                          });
                          // é€‰æ‹©æ‰¹æ¬¡åè·å–å½“å‰åº“å­?
                          await _loadCurrentInventory();
                        },
                        items: _batches!.map<DropdownMenuItem<bm.BatchModel>>(
                            (bm.BatchModel batch) {
                          return DropdownMenuItem<bm.BatchModel>(
                            value: batch,
                            child: Text(
                                'ç”Ÿäº§æ—¥æœŸ: ${batch.productionDate.toLocal().toString().split(' ')[0]}'),
                          );
                        }).toList(),
                        decoration: const InputDecoration(
                          labelText: 'é€‰æ‹©æ‰¹æ¬¡',
                          border: OutlineInputBorder(),
                        ),
                      )
                    : const Text('è¯¥åº—é“ºæ— æ­¤è´§å“çš„æ‰¹æ¬¡ä¿¡æ¯'),
          const SizedBox(height: 16),
          _isFetchingInventory
              ? const Center(child: CircularProgressIndicator())
              : TextField(
                  controller: _quantityController,
                  keyboardType: TextInputType.number,
                  enabled: !batchManaged || (batchManaged && _batches != null && _batches!.isNotEmpty),
                  decoration: const InputDecoration(
                    labelText: 'è°ƒæ•´æ•°é‡',
                    border: OutlineInputBorder(),
                  ),
                ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        TextButton(
          onPressed: () async {
            final newQuantity = int.tryParse(_quantityController.text);
            if (_selectedShop == null) {
              showAppSnackBar(context, message: 'è¯·é€‰æ‹©ä¸€ä¸ªåº—é“?, isError: true);
              return;
            }
            if (newQuantity == null) {
              showAppSnackBar(context, message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°é‡', isError: true);
              return;
            }
            if (widget.product.id == null) {
              showAppSnackBar(context, message: 'äº§å“IDæ— æ•ˆ', isError: true);
              return;
            }

            try {
              await ref
                  .read(inventoryQueryServiceProvider)
                  .adjustStock(
                    productId: widget.product.id!,
                    shopId: _selectedShop!.id!,
                    newQuantity: newQuantity,
                    batchId: (batchManaged ? _selectedBatch?.id : null),
                  );
              showAppSnackBar(context, message: 'åº“å­˜è°ƒæ•´æˆåŠŸ');
              ref.invalidate(inventoryQueryProvider);
              Navigator.of(context).pop();
            } catch (e) {
              showAppSnackBar(context, message: 'åº“å­˜è°ƒæ•´å¤±è´¥: $e', isError: true);
            }
          },
          child: const Text('ç¡®è®¤'),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import '../../domain/model/aggregated_inventory.dart';
import '../../../../core/widgets/cached_image_widget.dart';

/// èšåˆåº“å­˜å¡ç‰‡ç»„ä»¶
/// ç”¨äºåœ¨æœªç­›é€‰åº—é“ºæ—¶å±•ç¤ºåŒä¸€è´§å“çš„æ±‡æ€»ä¿¡æ?
/// æ”¯æŒå±•å¼€/æ”¶èµ·æŸ¥çœ‹è¯¦ç»†åº“å­˜æ˜ç»†
class AggregatedInventoryCard extends StatefulWidget {
  final AggregatedInventoryItem item;

  const AggregatedInventoryCard({super.key, required this.item});

  @override
  State<AggregatedInventoryCard> createState() =>
      _AggregatedInventoryCardState();
}

class _AggregatedInventoryCardState extends State<AggregatedInventoryCard>
    with SingleTickerProviderStateMixin {
  bool _isExpanded = false;
  late AnimationController _animationController;
  late Animation<double> _expandAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _expandAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _toggleExpanded() {
    setState(() {
      _isExpanded = !_isExpanded;
      if (_isExpanded) {
        _animationController.forward();
      } else {
        _animationController.reverse();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    // æ–­è¨€ï¼šæ­¤ç»„ä»¶ä»…ç”¨äºå¯å±•å¼€çš„é¡¹ï¼ˆå¤šæ¡è®°å½•ï¼‰
    assert(
      widget.item.isExpandable,
      'AggregatedInventoryCard should only be used for items with multiple records',
    );

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Column(
        children: [
          // æ”¶èµ·çŠ¶æ€ï¼šæ˜¾ç¤ºè´§å“åŸºæœ¬ä¿¡æ¯å’Œæ€»åº“å­?
          _buildCollapsedHeader(context),

          // å±•å¼€çŠ¶æ€ï¼šæ˜¾ç¤ºè¯¦ç»†åº“å­˜åˆ—è¡¨
          if (_isExpanded)
            SizeTransition(
              sizeFactor: _expandAnimation,
              child: _buildExpandedDetails(context),
            ),
        ],
      ),
    );
  }

  /// æ„å»ºæ”¶èµ·çŠ¶æ€çš„å¤´éƒ¨
  Widget _buildCollapsedHeader(BuildContext context) {
    return InkWell(
      onTap: _toggleExpanded,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            // å•†å“å›¾ç‰‡
            _buildProductImage(),
            const SizedBox(width: 16),

            // å•†å“ä¿¡æ¯
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // å•†å“åç§°
                  Text(
                    widget.item.productName,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // åˆ†ç±»ä¿¡æ¯
                  Text(
                    widget.item.categoryName,
                    style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                  ),

                  // å¦‚æœæœ‰å³å°†è¿‡æœŸæˆ–å·²è¿‡æœŸçš„æ‰¹æ¬¡ï¼Œæ˜¾ç¤ºè­¦å‘?
                  if (widget.item.hasExpired ||
                      widget.item.hasExpiringSoon) ...[
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Icon(
                          Icons.warning_amber_rounded,
                          size: 14,
                          color: widget.item.hasExpired
                              ? Colors.red
                              : Colors.orange,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          widget.item.hasExpired ? 'å«å·²è¿‡æœŸæ‰¹æ¬¡' : 'å«å³å°†è¿‡æœŸæ‰¹æ¬?,
                          style: TextStyle(
                            fontSize: 12,
                            color: widget.item.hasExpired
                                ? Colors.red
                                : Colors.orange,
                          ),
                        ),
                      ],
                    ),
                  ],

                  const SizedBox(height: 12),

                  // æ€»åº“å­˜ï¼ˆé†’ç›®æ˜¾ç¤ºï¼?
                  Row(
                    children: [
                      Text(
                        '${widget.item.totalQuantity}',
                        style: TextStyle(
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                          color: Theme.of(context).primaryColor,
                        ),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        widget.item.unit,
                        style: TextStyle(fontSize: 14, color: Colors.grey[600]),
                      ),
                      const SizedBox(width: 8),
                      // æ˜¾ç¤ºè¯¦ç»†è®°å½•æ•°é‡
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 2,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.grey[200],
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          '${widget.item.details.length}æ¡è®°å½?,
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[700],
                          ),
                        ),
                      ),
                      const Spacer(),

                      // å±•å¼€/æ”¶èµ·å›¾æ ‡
                      AnimatedRotation(
                        turns: _isExpanded ? 0.5 : 0,
                        duration: const Duration(milliseconds: 300),
                        child: Icon(Icons.expand_more, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// æ„å»ºå•†å“å›¾ç‰‡
  Widget _buildProductImage() {
    if (widget.item.productImage != null &&
        widget.item.productImage!.isNotEmpty) {
      return ProductThumbnailImage(imagePath: widget.item.productImage!);
    } else {
      return Container(
        width: 60,
        height: 80,
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Icon(
          Icons.image_outlined,
          color: Colors.grey.shade400,
          size: 30,
        ),
      );
    }
  }

  /// æ„å»ºå±•å¼€çŠ¶æ€çš„è¯¦ç»†ä¿¡æ¯
  Widget _buildExpandedDetails(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        border: Border(top: BorderSide(color: Colors.grey.shade300)),
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(12),
          bottomRight: Radius.circular(12),
        ),
      ),
      child: Column(
        children: [
          // è¡¨å¤´
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            decoration: BoxDecoration(color: Colors.grey.shade100),
            child: Row(
              children: [
                Expanded(
                  flex: 2,
                  child: Text(
                    'åº—é“º',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey[700],
                    ),
                  ),
                ),
                Expanded(
                  flex: 2,
                  child: Text(
                    'ç”Ÿäº§æ—¥æœŸ',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey[700],
                    ),
                  ),
                ),
                Expanded(
                  flex: 2,
                  child: Text(
                    'å‰©ä½™ä¿è´¨æœ?,
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey[700],
                    ),
                  ),
                ),
                Expanded(
                  flex: 1,
                  child: Text(
                    'æ•°é‡',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey[700],
                    ),
                    textAlign: TextAlign.right,
                  ),
                ),
              ],
            ),
          ),

          // è¯¦ç»†è®°å½•åˆ—è¡¨
          ListView.separated(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: widget.item.details.length,
            separatorBuilder: (_, __) =>
                Divider(height: 1, color: Colors.grey.shade300),
            itemBuilder: (context, index) {
              final detail = widget.item.details[index];
              return _buildDetailRow(context, detail);
            },
          ),
        ],
      ),
    );
  }

  /// æ„å»ºå•æ¡è¯¦ç»†è®°å½•è¡?
  Widget _buildDetailRow(BuildContext context, InventoryDetail detail) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          // åº—é“ºåç§°
          Expanded(
            flex: 2,
            child: Text(
              detail.shopName,
              style: const TextStyle(fontSize: 13),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),

          // ç”Ÿäº§æ—¥æœŸ
          Expanded(
            flex: 2,
            child: Text(
              detail.batchDisplayText,
              style: TextStyle(fontSize: 13, color: Colors.grey[700]),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),

          // å‰©ä½™ä¿è´¨æœ?
          Expanded(
            flex: 2,
            child: GestureDetector(
              onLongPress: () {
                // é•¿æŒ‰æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                    title: const Text('è°ƒè¯•ä¿¡æ¯'),
                    content: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('ç”Ÿäº§æ—¥æœŸ: ${detail.productionDate}'),
                        Text('ä¿è´¨æœŸå¤©æ•? ${detail.shelfLifeDays}'),
                        Text('ä¿è´¨æœŸå•ä½? ${detail.shelfLifeUnit}'),
                        Text('è®¡ç®—çš„å‰©ä½™å¤©æ•? ${detail.remainingDays}'),
                        Text('æ˜¾ç¤ºæ–‡æœ¬: ${detail.remainingDaysDisplayText}'),
                      ],
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.pop(context),
                        child: const Text('å…³é—­'),
                      ),
                    ],
                  ),
                );
              },
              child: Text(
                detail.remainingDaysDisplayText,
                style: TextStyle(
                  fontSize: 13,
                  color: _getShelfLifeColor(detail),
                  fontWeight: detail.isExpired || detail.isExpiringSoon
                      ? FontWeight.w600
                      : FontWeight.normal,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ),

          // åº“å­˜æ•°é‡
          Expanded(
            flex: 1,
            child: Text(
              '${detail.quantity}${widget.item.unit}',
              style: const TextStyle(fontSize: 13, fontWeight: FontWeight.w500),
              textAlign: TextAlign.right,
            ),
          ),
        ],
      ),
    );
  }

  /// è·å–ä¿è´¨æœŸé¢œè‰?
  Color _getShelfLifeColor(InventoryDetail detail) {
    switch (detail.shelfLifeColorStatus) {
      case 'expired':
        return Colors.red;
      case 'critical':
        return Colors.orange;
      case 'warning':
        return Colors.amber.shade700;
      case 'normal':
      default:
        return Colors.grey.shade700;
    }
  }
}
import 'package:flutter/material.dart';
import '../../domain/model/aggregated_inventory.dart';

/// è°ƒè¯•ç”¨ï¼šæ˜¾ç¤ºåº“å­˜è¯¦ç»†ä¿¡æ¯çš„åŸå§‹æ•°æ?
class DebugInventoryDetail extends StatelessWidget {
  final InventoryDetail detail;

  const DebugInventoryDetail({super.key, required this.detail});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'è°ƒè¯•ä¿¡æ¯',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.red,
              ),
            ),
            const Divider(),
            _buildRow('åº—é“ºåç§°', detail.shopName),
            _buildRow('ç”Ÿäº§æ—¥æœŸ', detail.productionDate?.toString() ?? 'null'),
            _buildRow('ä¿è´¨æœŸæ•°å€?, detail.shelfLifeDays?.toString() ?? 'null'),
            _buildRow('ä¿è´¨æœŸå•ä½?, detail.shelfLifeUnit ?? 'null'),
            _buildRow('è®¡ç®—çš„å‰©ä½™å¤©æ•?, detail.remainingDays?.toString() ?? 'null'),
            _buildRow('æ˜¾ç¤ºæ–‡æœ¬', detail.remainingDaysDisplayText),
            const Divider(),
            Text(
              'å¦‚æœæ˜¾ç¤ºä¸å¯¹ï¼Œè¯·æ£€æŸ¥æ•°æ®åº“ä¸­çš„å®é™…å€?,
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey[600],
                fontStyle: FontStyle.italic,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 120,
            child: Text(
              '$label:',
              style: const TextStyle(
                fontWeight: FontWeight.w600,
                fontSize: 14,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontSize: 14),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../../core/database/database.dart';
import '../providers/inbound_records_provider.dart';
import 'inbound_record_item_tile.dart';

// This might need to be created if it doesn't exist.
// For now, let's create a simple one.
final shopByIdProvider =
    FutureProvider.family<ShopData?, int>((ref, id) {
  final database = ref.watch(appDatabaseProvider);
  return database.shopDao.getShopById(id);
});


/// Inbound Record Card
/// Displays a single inbound record with an expandable list of items.
class InboundRecordCard extends ConsumerWidget {
  final InboundReceiptData record;

  const InboundRecordCard({super.key, required this.record});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final itemsAsync = ref.watch(inboundRecordItemsProvider(record.id));
    final shopAsync = ref.watch(shopByIdProvider(record.shopId));

    final dateFormatter = DateFormat('yyyy-MM-dd');
    final formattedDate = dateFormatter.format(record.createdAt);

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: ExpansionTile(
        title: Text(
          'å•å·: ${record.id}',
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('æ—¥æœŸ: $formattedDate'),
            shopAsync.when(
              data: (shop) => Text('åº—é“º: ${shop?.name ?? 'æœªçŸ¥'}'),
              loading: () => const Text('åº—é“º: åŠ è½½ä¸?..'),
              error: (_, _) => const Text('åº—é“º: åŠ è½½å¤±è´¥'),
            ),
            if (record.source.isNotEmpty) Text('æ¥æº: ${record.source}'),
          ],
        ),
        trailing: itemsAsync.when(
          data: (items) {
            final totalQuantity = items.fold<double>(
              0,
              (sum, item) => sum + item.quantity,
            );
            return Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${items.length} ç§?,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                  '${totalQuantity.toStringAsFixed(totalQuantity.truncateToDouble() == totalQuantity ? 0 : 1)} ä»?,
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            );
          },
          loading: () => const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          error: (_, __) => const Icon(Icons.error, color: Colors.red),
        ),
        children: [
          itemsAsync.when(
            data: (items) => Column(
              children: items
                  .map((item) => InboundRecordItemTile(item: item))
                  .toList(),
            ),
            loading: () => const Padding(
              padding: EdgeInsets.all(16.0),
              child: Center(child: CircularProgressIndicator()),
            ),
            error: (e, s) => Padding(
              padding: const EdgeInsets.all(16.0),
              child: Center(child: Text('åŠ è½½æ˜ç»†å¤±è´¥: $e')),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';
import '../../../product/application/provider/product_providers.dart';

class InboundRecordItemTile extends ConsumerWidget {
  final InboundItemData item;

  const InboundRecordItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productAsync = ref.watch(productByIdProvider(item.productId));
    // é¢„ç•™æ‰¹æ¬¡ä¿¡æ¯æŸ¥è¯¢ï¼Œæœªæ¥å¯èƒ½ä½¿ç”?
    // final batchAsync = ref.watch(batchByNumberProvider(item.id));

    return ListTile(
      contentPadding: const EdgeInsets.only(
        left: 3,
        right: 16,
        top: 0,
        bottom: 0,
      ),
      minVerticalPadding: 0,
      dense: true,
      visualDensity: const VisualDensity(horizontal: 0, vertical: -4),
      minLeadingWidth: 0,
      title: Row(
        children: [
          Text(' ${item.id}  ', style: const TextStyle(fontSize: 14)),
          const SizedBox(width: 6),
          Expanded(
            child: productAsync.when(
              data: (product) => Text(
                product?.name ?? 'è´§å“ID: ${item.productId}',
                style: const TextStyle(fontSize: 16),
              ),
              loading: () => const Text('åŠ è½½ä¸?..'),
              error: (err, stack) => Text(
                'åŠ è½½è´§å“å¤±è´¥',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ),
          ),
        ],
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            'æ•°é‡: ${item.quantity.toStringAsFixed(item.quantity.truncateToDouble() == item.quantity ? 0 : 2)}',
          ),
          
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/inventory_query_providers.dart';
import '../../application/provider/shop_providers.dart';
import '../../../product/application/category_service.dart';

/// åˆ†ç±»æµæä¾›è€?
final categoriesStreamProvider = StreamProvider((ref) {
  final categoryService = ref.watch(categoryServiceProvider);
  return categoryService.watchAllCategories();
});

/// åº“å­˜ç­›é€‰æ 
/// æä¾›ä»“åº“ã€åˆ†ç±»ã€åº“å­˜çŠ¶æ€ç­‰ç­›é€‰é€‰é¡¹
class InventoryFilterBar extends ConsumerWidget {
  const InventoryFilterBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final filterState = ref.watch(inventoryFilterProvider);
    final shopsAsync = ref.watch(allShopsProvider);
    final categoriesAsync = ref.watch(categoriesStreamProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor, width: 1),
        ),
      ),
      child: Row(
        children: [
          // æ‰€æœ‰ä»“åº“ç­›é€?- ä½¿ç”¨åº—é“ºè¡¨æ•°æ?
          Expanded(
            child: shopsAsync.when(
              data: (shops) {
                // æ„å»ºåº—é“ºä¸‹æ‹‰é€‰é¡¹
                final shopItems = ['æ‰€æœ‰ä»“åº?, ...shops.map((shop) => shop.name)];
                return _buildFilterDropdown(
                  context: context,
                  value: filterState.selectedShop,
                  items: shopItems,
                  onChanged: (value) {
                    ref
                        .read(inventoryFilterProvider.notifier)
                        .updateShop(value);
                  },
                );
              },
              loading: () => _buildFilterDropdown(
                context: context,
                value: 'æ‰€æœ‰ä»“åº?,
                items: const ['æ‰€æœ‰ä»“åº?],
                onChanged: (_) {}, // åŠ è½½æ—¶ç¦ç”?
              ),
              error: (error, stackTrace) => _buildFilterDropdown(
                context: context,
                value: 'æ‰€æœ‰ä»“åº?,
                items: const ['æ‰€æœ‰ä»“åº?],
                onChanged: (_) {}, // é”™è¯¯æ—¶ç¦ç”?
              ),
            ),
          ),
          const SizedBox(width: 12),

          // æ‰€æœ‰åˆ†ç±»ç­›é€?
          Expanded(
            child: categoriesAsync.when(
              data: (categories) {
                final categoryItems = ['æ‰€æœ‰åˆ†ç±?, ...categories.map((cat) => cat.name)];
                return _buildFilterDropdown(
                  context: context,
                  value: filterState.selectedCategory,
                  items: categoryItems,
                  onChanged: (value) {
                    ref
                        .read(inventoryFilterProvider.notifier)
                        .updateCategory(value);
                  },
                );
              },
              loading: () => _buildFilterDropdown(
                context: context,
                value: 'æ‰€æœ‰åˆ†ç±?,
                items: const ['æ‰€æœ‰åˆ†ç±?],
                onChanged: (_) {},
              ),
              error: (error, stackTrace) => _buildFilterDropdown(
                context: context,
                value: 'æ‰€æœ‰åˆ†ç±?,
                items: const ['æ‰€æœ‰åˆ†ç±?],
                onChanged: (_) {},
              ),
            ),
          ),
          const SizedBox(width: 12),

          // åº“å­˜çŠ¶æ€ç­›é€?
          Expanded(
            child: _buildFilterDropdown(
              context: context,
              value: filterState.selectedStatus,
              items: const ['åº“å­˜çŠ¶æ€?, 'æ­£å¸¸', 'ä½åº“å­?, 'ç¼ºè´§'],
              onChanged: (value) {
                ref.read(inventoryFilterProvider.notifier).updateStatus(value);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFilterDropdown({
    required BuildContext context,
    required String? value,
    required List<String> items,
    required ValueChanged<String?> onChanged,
  }) {
    return Container(
      height: 40,
      decoration: BoxDecoration(
        border: Border.all(color: Theme.of(context).dividerColor),
        borderRadius: BorderRadius.circular(8),
        color: Theme.of(context).cardColor,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: (value != null && items.contains(value)) ? value : items.first,
          isExpanded: true,
          items: items.map((String item) {
            return DropdownMenuItem<String>(
              value: item,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                child: Text(
                  item,
                  style: TextStyle(
                    fontSize: 14,
                    color: Theme.of(context).textTheme.bodyMedium?.color,
                  ),
                ),
              ),
            );
          }).toList(),
          onChanged: onChanged,
          icon: Padding(
            padding: const EdgeInsets.only(right: 8),
            child: Icon(
              Icons.keyboard_arrow_down,
              color: Theme.of(context).iconTheme.color,
              size: 20,
            ),
          ),
          dropdownColor: Theme.of(context).cardColor,
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:stocko_app/core/widgets/cached_image_widget.dart';
import 'package:stocko_app/features/inventory/domain/model/inventory.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';

/// åº“å­˜å•†å“å¡ç‰‡
/// å±•ç¤ºå•ä¸ªå•†å“çš„åº“å­˜ä¿¡æ?
class InventoryItemCard extends StatelessWidget {
  final StockModel inventory;

  const InventoryItemCard({super.key, required this.inventory});

  @override
  Widget build(BuildContext context) {
    final product = ProductModel.fromJson(inventory.toJson()['product']);
    final quantity = inventory.quantity;
    final productName = product.name;
    final productImage = product.image;
    final unit = 'ä»?; // Assuming 'ä»? as a default, will need to be updated with actual data if available

    // æ ¹æ®åº“å­˜æ•°é‡ç¡®å®šçŠ¶æ€?
    final stockStatus = _getStockStatus(quantity);

    // è®¡ç®—ä¿è´¨æœ?
    String? shelfLifeText;
    if (product.shelfLife != null && product.shelfLife! > 0) {
      // NOTE: This logic assumes `createdAt` of the stock is the production date.
      // This might not be accurate. A dedicated `productionDate` on the batch/stock would be better.
      final productionDate = inventory.createdAt ?? DateTime.now();
      int shelfLifeInDays;
      switch (product.shelfLifeUnit) {
        case ShelfLifeUnit.days:
          shelfLifeInDays = product.shelfLife!;
          break;
        case ShelfLifeUnit.months:
          shelfLifeInDays = product.shelfLife! * 30; // Approximate
          break;
        case ShelfLifeUnit.years:
          shelfLifeInDays = product.shelfLife! * 365; // Approximate
          break;
      }
      final expiryDate = productionDate.add(Duration(days: shelfLifeInDays));
      final remainingDays = expiryDate.difference(DateTime.now()).inDays;

      if (remainingDays <= 0) {
        shelfLifeText = 'å·²è¿‡æœ?;
      } else {
        shelfLifeText = 'å‰©ä½™: $remainingDays å¤?;
      }
    }

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            // å•†å“å›¾ç‰‡
            productImage != null
                ? ProductThumbnailImage(imagePath: productImage)
                : Container(
                    width: 60,
                    height: 80,
                    decoration: BoxDecoration(
                      color: Colors.grey.shade100,
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Icon(
                      Icons.image_outlined,
                      color: Colors.grey.shade400,
                      size: 30,
                    ),
                  ),
            const SizedBox(width: 16),

            // å•†å“ä¿¡æ¯å’Œåº“å­?
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // å•†å“åç§°
                  Text(
                    productName,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (shelfLifeText != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      shelfLifeText,
                      style: TextStyle(
                        fontSize: 12,
                        color: shelfLifeText == 'å·²è¿‡æœ?
                            ? Colors.red
                            : Colors.grey[600],
                      ),
                    ),
                  ],
                  const SizedBox(height: 12),

                  // åº“å­˜ä¿¡æ¯
                  Row(
                    children: [
                      
                      const SizedBox(width: 8),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.baseline,
                        textBaseline: TextBaseline.alphabetic,
                        children: [
                          Text(
                            '$quantity',
                            style: const TextStyle(
                              fontSize: 20,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            unit,
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                      const Spacer(),

                      // åº“å­˜çŠ¶æ€æŒ‡ç¤ºå™¨
                      _buildStatusIndicator(stockStatus),
                    ],
                  ),
                  const SizedBox(height: 8),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// æ ¹æ®åº“å­˜æ•°é‡è·å–çŠ¶æ€?
  _StockStatus _getStockStatus(int quantity) {
    if (quantity <= 0) {
      return _StockStatus.outOfStock;
    } else if (quantity <= 10) {
      // å‡è®¾ä½åº“å­˜é˜ˆå€¼ä¸º10
      return _StockStatus.lowStock;
    } else {
      return _StockStatus.normal;
    }
  }

  /// æ„å»ºçŠ¶æ€æŒ‡ç¤ºå™¨
  Widget _buildStatusIndicator(_StockStatus status) {
    Widget indicator;

    switch (status) {
      case _StockStatus.outOfStock:
        indicator = Container(
          width: 12,
          height: 12,
          decoration: const BoxDecoration(
            color: Colors.red,
            shape: BoxShape.circle,
          ),
        );
        break;
      case _StockStatus.lowStock:
        indicator = Container(
          width: 12,
          height: 12,
          decoration: const BoxDecoration(
            color: Colors.orange,
            shape: BoxShape.circle,
          ),
        );
        break;
      case _StockStatus.normal:
        indicator = const SizedBox.shrink(); // æ­£å¸¸åº“å­˜ä¸æ˜¾ç¤ºæŒ‡ç¤ºå™¨
        break;
    }

    return indicator;
  }
}

/// åº“å­˜çŠ¶æ€æšä¸?
enum _StockStatus {
  normal, // æ­£å¸¸
  lowStock, // ä½åº“å­?
  outOfStock, // ç¼ºè´§
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../../core/database/database.dart';
import 'inbound_record_card.dart';
import '../providers/outbound_receipts_provider.dart';
import 'outbound_record_item_tile.dart';

class OutboundRecordCard extends ConsumerWidget {
  final OutboundReceiptData record;

  const OutboundRecordCard({super.key, required this.record});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final itemsAsync = ref.watch(outboundReceiptItemsProvider(record.id));
    final shopAsync = ref.watch(shopByIdProvider(record.shopId));

    final dateFormatter = DateFormat('yyyy-MM-dd');
    final formattedDate = dateFormatter.format(record.createdAt);

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: ExpansionTile(
        shape: const RoundedRectangleBorder(
          side: BorderSide(color: Colors.transparent),
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),

        title: Text(
          'å•å·: ${record.id}',
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('æ—¥æœŸ: $formattedDate'),
            shopAsync.when(
              data: (shop) => Text('åº—é“º: ${shop?.name ?? 'æœªçŸ¥'}'),
              loading: () => const Text('åº—é“º: åŠ è½½ä¸?..'),
              error: (_, __) => const Text('åº—é“º: åŠ è½½å¤±è´¥'),
            ),
            if (record.reason.isNotEmpty) Text('åŸå› : ${record.reason}'),
          ],
        ),
        trailing: itemsAsync.when(
          data: (items) {
            final totalQuantity = items.fold<int>(
              0,
              (sum, it) => sum + it.quantity,
            );
            return Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${items.length} ç§?,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                Text(
                  '$totalQuantity ä»?,
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            );
          },
          loading: () => const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          error: (_, __) => const Icon(Icons.error, color: Colors.red),
        ),
        children: [
          itemsAsync.when(
            data: (items) => Column(
              children: items
                  .map((item) => OutboundRecordItemTile(item: item))
                  .toList(),
            ),
            loading: () => const Padding(
              padding: EdgeInsets.all(16.0),
              child: Center(child: CircularProgressIndicator()),
            ),
            error: (e, s) => Padding(
              padding: const EdgeInsets.all(16.0),
              child: Center(child: Text('åŠ è½½æ˜ç»†å¤±è´¥: $e')),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../../../core/database/database.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../application/provider/batch_providers.dart';

class OutboundRecordItemTile extends ConsumerWidget {
  final OutboundItemData item;

  const OutboundRecordItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productAsync = ref.watch(productByIdProvider(item.productId));
    final batchAsync = item.batchId != null
        ? ref.watch(batchByNumberProvider(item.batchId!))
        : null;

    return ListTile(
  contentPadding: const EdgeInsets.only(left: 3, right: 16, top: 0, bottom: 0),
  minVerticalPadding: 0,
  dense: true,
  visualDensity: const VisualDensity(horizontal: 0, vertical: -4),
  minLeadingWidth: 0,
      title: Row(
        children: [
            Text(' ${item.id}  ', style: const TextStyle(fontSize: 14)),
            const SizedBox(width: 6),
            Expanded(
              child: productAsync.when(
                data: (product) => Text(product?.name ?? 'è´§å“ID: ${item.productId}', style: const TextStyle(fontSize: 16)),
                loading: () => const Text('åŠ è½½ä¸?..'),
                error: (err, stack) => Text(
                  'åŠ è½½è´§å“å¤±è´¥',
                  style: TextStyle(color: Theme.of(context).colorScheme.error),
                ),
              ),
            ),
          ],
      ),
      trailing: Column(
        mainAxisSize: MainAxisSize.min, // é¿å… trailing æ‹‰ä¼¸å¯¼è‡´æ•´ä½“å˜é«˜
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text('æ•°é‡: ${item.quantity}') ,
          if (batchAsync != null)
            batchAsync.when(
              data: (batch) {
                if (batch?.productionDate == null) {
                  return const SizedBox.shrink();
                }
                return Text(
                  'ç”Ÿäº§æ—¥æœŸ: ${DateFormat('yyyy-MM-dd').format(batch!.productionDate)}',
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                );
              },
              loading: () => const SizedBox(
                  width: 12,
                  height: 12,
                  child: CircularProgressIndicator(strokeWidth: 2)),
              error: (e, s) => const SizedBox.shrink(),
            ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../domain/model/aggregated_inventory.dart';
import '../../../../core/widgets/cached_image_widget.dart';

/// ç®€å•åº“å­˜å¡ç‰‡ç»„ä»?
/// ç”¨äºå±•ç¤ºå•æ¡è®°å½•çš„è´§å“ï¼ˆä¸å¯å±•å¼€ï¼?
/// æ ·å¼ä¸åŸå§‹å¡ç‰‡ä¸€è‡?
class SimpleInventoryCard extends StatelessWidget {
  final AggregatedInventoryItem item;

  const SimpleInventoryCard({
    super.key,
    required this.item,
  });

  @override
  Widget build(BuildContext context) {
    // æ–­è¨€ï¼šæ­¤ç»„ä»¶ä»…ç”¨äºå•æ¡è®°å½?
    assert(
      !item.isExpandable,
      'SimpleInventoryCard should only be used for items with single record',
    );

    final detail = item.details.first; // åªæœ‰ä¸€æ¡è®°å½?

    return Card(
      elevation: 2,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            // å•†å“å›¾ç‰‡
            _buildProductImage(),
            const SizedBox(width: 16),

            // å•†å“ä¿¡æ¯
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // å•†å“åç§°
                  Text(
                    item.productName,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // åˆ†ç±»å’Œåº—é“ºä¿¡æ?
                  Text(
                    '${item.categoryName} Â· ${detail.shopName}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),

                  // ä¿è´¨æœŸä¿¡æ?
                  if (detail.remainingDays != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      detail.remainingDaysDisplayText,
                      style: TextStyle(
                        fontSize: 12,
                        color: _getShelfLifeColor(detail),
                        fontWeight: detail.isExpired || detail.isExpiringSoon
                            ? FontWeight.w600
                            : FontWeight.normal,
                      ),
                    ),
                  ],

                  const SizedBox(height: 12),

                  // åº“å­˜æ•°é‡ï¼ˆæ— å±•å¼€å›¾æ ‡ï¼Œæ ·å¼ä¸åŸå§‹å¡ç‰‡ä¸€è‡´ï¼‰
                  Row(
                    children: [
                      Text(
                        '${item.totalQuantity}',
                        style: const TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        item.unit,
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey[600],
                        ),
                      ),
                      const Spacer(),

                      // åº“å­˜çŠ¶æ€æŒ‡ç¤ºå™¨
                      _buildStatusIndicator(item.totalQuantity),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// æ„å»ºå•†å“å›¾ç‰‡
  Widget _buildProductImage() {
    if (item.productImage != null && item.productImage!.isNotEmpty) {
      return ProductThumbnailImage(imagePath: item.productImage!);
    } else {
      return Container(
        width: 60,
        height: 80,
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Icon(
          Icons.image_outlined,
          color: Colors.grey.shade400,
          size: 30,
        ),
      );
    }
  }

  /// è·å–ä¿è´¨æœŸé¢œè‰?
  Color _getShelfLifeColor(InventoryDetail detail) {
    switch (detail.shelfLifeColorStatus) {
      case 'expired':
        return Colors.red;
      case 'critical':
        return Colors.orange;
      case 'warning':
        return Colors.amber.shade700;
      case 'normal':
      default:
        return Colors.grey.shade700;
    }
  }

  /// æ„å»ºçŠ¶æ€æŒ‡ç¤ºå™¨
  Widget _buildStatusIndicator(int quantity) {
    if (quantity <= 0) {
      return Container(
        width: 12,
        height: 12,
        decoration: const BoxDecoration(
          color: Colors.red,
          shape: BoxShape.circle,
        ),
      );
    } else if (quantity <= 10) {
      return Container(
        width: 12,
        height: 12,
        decoration: const BoxDecoration(
          color: Colors.orange,
          shape: BoxShape.circle,
        ),
      );
    } else {
      return const SizedBox.shrink();
    }
  }
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/outbound_receipt_items_table.dart';

part 'outbound_item_dao.g.dart';

@DriftAccessor(tables: [OutboundItem])
class OutboundItemDao extends DatabaseAccessor<AppDatabase>
    with _$OutboundItemDaoMixin {
  OutboundItemDao(super.db);

  /// æ ¹æ®å‡ºåº“å•IDè·å–æ‰€æœ‰æ˜ç»?
  Future<List<OutboundItemData>> getOutboundItemsByReceiptId(int receiptId) {
    return (select(outboundItem)
          ..where((t) => t.receiptId.equals(receiptId)))
        .get();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'outbound_item_dao.dart';

// ignore_for_file: type=lint
mixin _$OutboundItemDaoMixin on DatabaseAccessor<AppDatabase> {
  $ShopTable get shop => attachedDatabase.shop;
  $CustomersTable get customers => attachedDatabase.customers;
  $SalesTransactionTable get salesTransaction =>
      attachedDatabase.salesTransaction;
  $OutboundReceiptTable get outboundReceipt => attachedDatabase.outboundReceipt;
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $OutboundItemTable get outboundItem => attachedDatabase.outboundItem;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/outbound_receipts_table.dart';

part 'outbound_receipt_dao.g.dart';

@DriftAccessor(tables: [OutboundReceipt])
class OutboundReceiptDao extends DatabaseAccessor<AppDatabase>
    with _$OutboundReceiptDaoMixin {
  OutboundReceiptDao(super.db);

  /// æ’å…¥å‡ºåº“å?
  Future<int> insertOutboundReceipt(OutboundReceiptCompanion receipt) async {
    return await into(outboundReceipt).insert(receipt);
  }

  /// æ ¹æ®IDè·å–å‡ºåº“å?
  Future<OutboundReceiptData?> getOutboundReceiptById(int id) {
    return (select(outboundReceipt)..where((t) => t.id.equals(id)))
        .getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰å‡ºåº“å•
  Future<List<OutboundReceiptData>> getAllOutboundReceipts() {
    return select(outboundReceipt).get();
  }

  /// æ ¹æ®åº—é“ºIDè·å–å‡ºåº“å?
  Future<List<OutboundReceiptData>> getOutboundReceiptsByShop(int shopId) {
    return (select(outboundReceipt)..where((t) => t.shopId.equals(shopId)))
        .get();
  }

  /// ç›‘å¬æ‰€æœ‰å‡ºåº“å•å˜åŒ–
  Stream<List<OutboundReceiptData>> watchAllOutboundReceipts() {
    return select(outboundReceipt).watch();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'outbound_receipt_dao.dart';

// ignore_for_file: type=lint
mixin _$OutboundReceiptDaoMixin on DatabaseAccessor<AppDatabase> {
  $ShopTable get shop => attachedDatabase.shop;
  $CustomersTable get customers => attachedDatabase.customers;
  $SalesTransactionTable get salesTransaction =>
      attachedDatabase.salesTransaction;
  $OutboundReceiptTable get outboundReceipt => attachedDatabase.outboundReceipt;
}
export 'outbound_receipt.dart';
export 'outbound_item.dart';
/// å‡ºåº“å•æ˜ç»?é¢†åŸŸæ¨¡å‹ï¼ˆfreezedï¼?
/// å¯¹åº”è¡? OutboundItem (lib/core/database/outbound_receipt_items_table.dart)
library;
import 'package:freezed_annotation/freezed_annotation.dart';

part 'outbound_item.freezed.dart';
part 'outbound_item.g.dart';

@freezed
abstract class OutboundItemModel with _$OutboundItemModel {
  const OutboundItemModel._();

  @Assert('quantity > 0', 'quantity must be > 0')
  const factory OutboundItemModel({
    /// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
    int? id,

    /// æ‰€å±å‡ºåº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼?
    int? receiptId,

    /// å•†å“IDï¼ˆå¿…å¡«ï¼‰
    required int productId,

    /// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
    int? batchId,

    /// æ•°é‡ï¼? 0ï¼?
    required int quantity,
  }) = _OutboundItemModel;

  factory OutboundItemModel.fromJson(Map<String, dynamic> json) =>
      _$OutboundItemModelFromJson(json);

  /// ç”Ÿæˆç”¨äºåˆ¤å®šåŒä¸€å‡ºåº“å•ä¸­çš„â€œå”¯ä¸€æ€§é”®â€?
  /// ä¸è¡¨çº¦æŸä¸€è‡´ï¼š
  /// - å½?batchId éç©ºï¼šå”¯ä¸€é”?= (receiptId, productId, batchId)
  /// - å½?batchId ä¸ºç©ºï¼šå”¯ä¸€é”?= (receiptId, productId)
  String uniqueKey({int? overrideReceiptId}) {
    final rid = overrideReceiptId ?? receiptId;
    final batchKey = batchId?.toString() ?? 'null';
    return '${rid ?? 'null'}#$productId#$batchKey';
  }

  /// å¢åŠ æ•°é‡ï¼Œè¿”å›æ–°å®ä¾‹
  OutboundItemModel increase(int delta) {
    assert(delta > 0, 'delta must be > 0');
    return copyWith(quantity: quantity + delta);
  }

  /// è®¾ç½®/å›å¡«æ‰€å±å‡ºåº“å•ID
  OutboundItemModel attachToReceipt(int rid) => copyWith(receiptId: rid);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'outbound_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OutboundItemModel {

/// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
 int? get id;/// æ‰€å±å‡ºåº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼? int? get receiptId;/// å•†å“IDï¼ˆå¿…å¡«ï¼‰
 int get productId;/// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
 int? get batchId;/// æ•°é‡ï¼? 0ï¼? int get quantity;
/// Create a copy of OutboundItemModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OutboundItemModelCopyWith<OutboundItemModel> get copyWith => _$OutboundItemModelCopyWithImpl<OutboundItemModel>(this as OutboundItemModel, _$identity);

  /// Serializes this OutboundItemModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OutboundItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.receiptId, receiptId) || other.receiptId == receiptId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,receiptId,productId,batchId,quantity);

@override
String toString() {
  return 'OutboundItemModel(id: $id, receiptId: $receiptId, productId: $productId, batchId: $batchId, quantity: $quantity)';
}


}

/// @nodoc
abstract mixin class $OutboundItemModelCopyWith<$Res>  {
  factory $OutboundItemModelCopyWith(OutboundItemModel value, $Res Function(OutboundItemModel) _then) = _$OutboundItemModelCopyWithImpl;
@useResult
$Res call({
 int? id, int? receiptId, int productId, int? batchId, int quantity
});




}
/// @nodoc
class _$OutboundItemModelCopyWithImpl<$Res>
    implements $OutboundItemModelCopyWith<$Res> {
  _$OutboundItemModelCopyWithImpl(this._self, this._then);

  final OutboundItemModel _self;
  final $Res Function(OutboundItemModel) _then;

/// Create a copy of OutboundItemModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? receiptId = freezed,Object? productId = null,Object? batchId = freezed,Object? quantity = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,receiptId: freezed == receiptId ? _self.receiptId : receiptId // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _OutboundItemModel extends OutboundItemModel {
  const _OutboundItemModel({this.id, this.receiptId, required this.productId, this.batchId, required this.quantity}): assert(quantity > 0, 'quantity must be > 0'),super._();
  factory _OutboundItemModel.fromJson(Map<String, dynamic> json) => _$OutboundItemModelFromJson(json);

/// å¯èƒ½å°šæœªæŒä¹…åŒ–ï¼Œå› è€Œä¸ºå¯ç©º
@override final  int? id;
/// æ‰€å±å‡ºåº“å•IDï¼ˆæ–°å»ºæ—¶å¯èƒ½ä¸ºç©ºï¼Œä¿å­˜åå›å¡«ï¼?@override final  int? receiptId;
/// å•†å“IDï¼ˆå¿…å¡«ï¼‰
@override final  int productId;
/// æ‰¹æ¬¡å·ï¼ˆå¯ç©ºï¼Œç©ºæ‰¹æ¬¡ä¸æœ‰æ‰¹æ¬¡çš„å”¯ä¸€æ€§ç­–ç•¥ä¸åŒï¼‰
@override final  int? batchId;
/// æ•°é‡ï¼? 0ï¼?@override final  int quantity;

/// Create a copy of OutboundItemModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OutboundItemModelCopyWith<_OutboundItemModel> get copyWith => __$OutboundItemModelCopyWithImpl<_OutboundItemModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OutboundItemModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OutboundItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.receiptId, receiptId) || other.receiptId == receiptId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,receiptId,productId,batchId,quantity);

@override
String toString() {
  return 'OutboundItemModel(id: $id, receiptId: $receiptId, productId: $productId, batchId: $batchId, quantity: $quantity)';
}


}

/// @nodoc
abstract mixin class _$OutboundItemModelCopyWith<$Res> implements $OutboundItemModelCopyWith<$Res> {
  factory _$OutboundItemModelCopyWith(_OutboundItemModel value, $Res Function(_OutboundItemModel) _then) = __$OutboundItemModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int? receiptId, int productId, int? batchId, int quantity
});




}
/// @nodoc
class __$OutboundItemModelCopyWithImpl<$Res>
    implements _$OutboundItemModelCopyWith<$Res> {
  __$OutboundItemModelCopyWithImpl(this._self, this._then);

  final _OutboundItemModel _self;
  final $Res Function(_OutboundItemModel) _then;

/// Create a copy of OutboundItemModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? receiptId = freezed,Object? productId = null,Object? batchId = freezed,Object? quantity = null,}) {
  return _then(_OutboundItemModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,receiptId: freezed == receiptId ? _self.receiptId : receiptId // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'outbound_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_OutboundItemModel _$OutboundItemModelFromJson(Map<String, dynamic> json) =>
    _OutboundItemModel(
      id: (json['id'] as num?)?.toInt(),
      receiptId: (json['receiptId'] as num?)?.toInt(),
      productId: (json['productId'] as num).toInt(),
      batchId: (json['batchId'] as num?)?.toInt(),
      quantity: (json['quantity'] as num).toInt(),
    );

Map<String, dynamic> _$OutboundItemModelToJson(_OutboundItemModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'receiptId': instance.receiptId,
      'productId': instance.productId,
      'batchId': instance.batchId,
      'quantity': instance.quantity,
    };
/// å‡ºåº“å?é¢†åŸŸæ¨¡å‹ï¼ˆfreezedï¼?
/// å¯¹åº”è¡? OutboundReceipt (lib/core/database/outbound_receipts_table.dart)
library;
import 'package:freezed_annotation/freezed_annotation.dart';
import 'outbound_item.dart';

part 'outbound_receipt.freezed.dart';
part 'outbound_receipt.g.dart';

@freezed
abstract class OutboundReceiptModel with _$OutboundReceiptModel {
  const OutboundReceiptModel._();

  const factory OutboundReceiptModel({
    /// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
    int? id,

    /// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
    required int shopId,

    /// åŸå› ï¼ˆå¦‚ï¼šé”€å”®å‡ºåº“ã€è°ƒæ‹¨ã€æŠ¥æŸç­‰ï¼?
    required String reason,

    /// å…³è”é”€å”®å•IDï¼ˆå¯ç©ºï¼‰
    int? salesTransactionId,

    /// åˆ›å»ºæ—¶é—´
    required DateTime createdAt,

    /// å¤‡æ³¨ï¼ˆé¢†åŸŸå±‚å¯é€‰ï¼‰
    String? remarks,

    /// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼?
    @Default(<OutboundItemModel>[]) List<OutboundItemModel> items,
  }) = _OutboundReceiptModel;

  factory OutboundReceiptModel.fromJson(Map<String, dynamic> json) =>
      _$OutboundReceiptModelFromJson(json);

  /// å·¥å‚æ–¹æ³•ï¼šåˆ›å»ºæ–°çš„å‡ºåº“å•è‰ç¨¿
  factory OutboundReceiptModel.createDraft({
    required int shopId,
    required String reason,
    int? salesTransactionId,
    DateTime? now,
  }) {
    final t = now ?? DateTime.now();
    return OutboundReceiptModel(
      shopId: shopId,
      reason: reason,
      salesTransactionId: salesTransactionId,
      createdAt: t,
      items: const [],
    );
  }

  /// åˆå¹¶æˆ–æ–°å¢ä¸€æ¡æ˜ç»†ï¼ˆéµå¾ªè¡¨çš„å”¯ä¸€æ€§ç­–ç•¥ï¼‰
  OutboundReceiptModel upsertItem(OutboundItemModel item) {
    final map = <String, OutboundItemModel>{
      for (final it in items) it.uniqueKey(overrideReceiptId: id): it
    };
    final key = item.uniqueKey(overrideReceiptId: id);
    if (map.containsKey(key)) {
      map[key] = map[key]!.increase(item.quantity);
    } else {
      map[key] = item;
    }
    return copyWith(items: map.values.toList(growable: false));
  }

  /// ç§»é™¤ä¸€æ¡æ˜ç»†ï¼ˆæŒ‰å”¯ä¸€é”®ï¼‰
  OutboundReceiptModel removeItem(OutboundItemModel item) {
    final key = item.uniqueKey(overrideReceiptId: id);
    final next = items
        .where((e) => e.uniqueKey(overrideReceiptId: id) != key)
        .toList();
    return copyWith(items: next);
  }

  /// æ›´æ–°æŸæ¡æ˜ç»†ï¼ˆæŒ‰å”¯ä¸€é”®å®šä½ï¼‰
  OutboundReceiptModel updateItem(OutboundItemModel item) {
    final key = item.uniqueKey(overrideReceiptId: id);
    final next = items
        .map((e) => e.uniqueKey(overrideReceiptId: id) == key ? item : e)
        .toList();
    return copyWith(items: next);
  }

  int get totalQuantity => items.fold(0, (sum, it) => sum + it.quantity);

  @override
  String toString() =>
      'OutboundReceiptModel(id: \'${id?.toString() ?? 'null'}\', shopId: $shopId, reason: $reason, items: ${items.length})';
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'outbound_receipt.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OutboundReceiptModel {

/// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
 int? get id;/// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
 int get shopId;/// åŸå› ï¼ˆå¦‚ï¼šé”€å”®å‡ºåº“ã€è°ƒæ‹¨ã€æŠ¥æŸç­‰ï¼? String get reason;/// å…³è”é”€å”®å•IDï¼ˆå¯ç©ºï¼‰
 int? get salesTransactionId;/// åˆ›å»ºæ—¶é—´
 DateTime get createdAt;/// å¤‡æ³¨ï¼ˆé¢†åŸŸå±‚å¯é€‰ï¼‰
 String? get remarks;/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼? List<OutboundItemModel> get items;
/// Create a copy of OutboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OutboundReceiptModelCopyWith<OutboundReceiptModel> get copyWith => _$OutboundReceiptModelCopyWithImpl<OutboundReceiptModel>(this as OutboundReceiptModel, _$identity);

  /// Serializes this OutboundReceiptModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OutboundReceiptModel&&(identical(other.id, id) || other.id == id)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.reason, reason) || other.reason == reason)&&(identical(other.salesTransactionId, salesTransactionId) || other.salesTransactionId == salesTransactionId)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,shopId,reason,salesTransactionId,createdAt,remarks,const DeepCollectionEquality().hash(items));



}

/// @nodoc
abstract mixin class $OutboundReceiptModelCopyWith<$Res>  {
  factory $OutboundReceiptModelCopyWith(OutboundReceiptModel value, $Res Function(OutboundReceiptModel) _then) = _$OutboundReceiptModelCopyWithImpl;
@useResult
$Res call({
 int? id, int shopId, String reason, int? salesTransactionId, DateTime createdAt, String? remarks, List<OutboundItemModel> items
});




}
/// @nodoc
class _$OutboundReceiptModelCopyWithImpl<$Res>
    implements $OutboundReceiptModelCopyWith<$Res> {
  _$OutboundReceiptModelCopyWithImpl(this._self, this._then);

  final OutboundReceiptModel _self;
  final $Res Function(OutboundReceiptModel) _then;

/// Create a copy of OutboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? shopId = null,Object? reason = null,Object? salesTransactionId = freezed,Object? createdAt = null,Object? remarks = freezed,Object? items = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as String,salesTransactionId: freezed == salesTransactionId ? _self.salesTransactionId : salesTransactionId // ignore: cast_nullable_to_non_nullable
as int?,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<OutboundItemModel>,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _OutboundReceiptModel extends OutboundReceiptModel {
  const _OutboundReceiptModel({this.id, required this.shopId, required this.reason, this.salesTransactionId, required this.createdAt, this.remarks, final  List<OutboundItemModel> items = const <OutboundItemModel>[]}): _items = items,super._();
  factory _OutboundReceiptModel.fromJson(Map<String, dynamic> json) => _$OutboundReceiptModelFromJson(json);

/// ä¸»é”®ï¼ˆè‰ç¨¿é˜¶æ®µå¯èƒ½ä¸ºç©ºï¼‰
@override final  int? id;
/// åº—é“ºIDï¼ˆå¿…å¡«ï¼‰
@override final  int shopId;
/// åŸå› ï¼ˆå¦‚ï¼šé”€å”®å‡ºåº“ã€è°ƒæ‹¨ã€æŠ¥æŸç­‰ï¼?@override final  String reason;
/// å…³è”é”€å”®å•IDï¼ˆå¯ç©ºï¼‰
@override final  int? salesTransactionId;
/// åˆ›å»ºæ—¶é—´
@override final  DateTime createdAt;
/// å¤‡æ³¨ï¼ˆé¢†åŸŸå±‚å¯é€‰ï¼‰
@override final  String? remarks;
/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼? final  List<OutboundItemModel> _items;
/// æ˜ç»†åˆ—è¡¨ï¼ˆä»…é¢†åŸŸå±‚ç»´æŠ¤ï¼Œä¸å¯¹åº”è¡¨å­—æ®µï¼?@override@JsonKey() List<OutboundItemModel> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of OutboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OutboundReceiptModelCopyWith<_OutboundReceiptModel> get copyWith => __$OutboundReceiptModelCopyWithImpl<_OutboundReceiptModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OutboundReceiptModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OutboundReceiptModel&&(identical(other.id, id) || other.id == id)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.reason, reason) || other.reason == reason)&&(identical(other.salesTransactionId, salesTransactionId) || other.salesTransactionId == salesTransactionId)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,shopId,reason,salesTransactionId,createdAt,remarks,const DeepCollectionEquality().hash(_items));



}

/// @nodoc
abstract mixin class _$OutboundReceiptModelCopyWith<$Res> implements $OutboundReceiptModelCopyWith<$Res> {
  factory _$OutboundReceiptModelCopyWith(_OutboundReceiptModel value, $Res Function(_OutboundReceiptModel) _then) = __$OutboundReceiptModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int shopId, String reason, int? salesTransactionId, DateTime createdAt, String? remarks, List<OutboundItemModel> items
});




}
/// @nodoc
class __$OutboundReceiptModelCopyWithImpl<$Res>
    implements _$OutboundReceiptModelCopyWith<$Res> {
  __$OutboundReceiptModelCopyWithImpl(this._self, this._then);

  final _OutboundReceiptModel _self;
  final $Res Function(_OutboundReceiptModel) _then;

/// Create a copy of OutboundReceiptModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? shopId = null,Object? reason = null,Object? salesTransactionId = freezed,Object? createdAt = null,Object? remarks = freezed,Object? items = null,}) {
  return _then(_OutboundReceiptModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as String,salesTransactionId: freezed == salesTransactionId ? _self.salesTransactionId : salesTransactionId // ignore: cast_nullable_to_non_nullable
as int?,createdAt: null == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<OutboundItemModel>,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'outbound_receipt.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_OutboundReceiptModel _$OutboundReceiptModelFromJson(
  Map<String, dynamic> json,
) => _OutboundReceiptModel(
  id: (json['id'] as num?)?.toInt(),
  shopId: (json['shopId'] as num).toInt(),
  reason: json['reason'] as String,
  salesTransactionId: (json['salesTransactionId'] as num?)?.toInt(),
  createdAt: DateTime.parse(json['createdAt'] as String),
  remarks: json['remarks'] as String?,
  items:
      (json['items'] as List<dynamic>?)
          ?.map((e) => OutboundItemModel.fromJson(e as Map<String, dynamic>))
          .toList() ??
      const <OutboundItemModel>[],
);

Map<String, dynamic> _$OutboundReceiptModelToJson(
  _OutboundReceiptModel instance,
) => <String, dynamic>{
  'id': instance.id,
  'shopId': instance.shopId,
  'reason': instance.reason,
  'salesTransactionId': instance.salesTransactionId,
  'createdAt': instance.createdAt.toIso8601String(),
  'remarks': instance.remarks,
  'items': instance.items,
};
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../domain/model/category.dart';
import 'category_service.dart';

/// ç±»åˆ«åˆ—è¡¨çŠ¶æ€?
class CategoryListState {
  final List<CategoryModel> categories;
  final bool isLoading;
  final String? error;

  const CategoryListState({
    this.categories = const [],
    this.isLoading = false,
    this.error,
  });

  CategoryListState copyWith({
    List<CategoryModel>? categories,
    bool? isLoading,
    String? error,
  }) {
    return CategoryListState(
      categories: categories ?? this.categories,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}

/// ç±»åˆ«åˆ—è¡¨çŠ¶æ€ç®¡ç†å™¨
class CategoryListNotifier extends StateNotifier<CategoryListState> {
  final CategoryService _categoryService;
  bool _disposed = false;

  CategoryListNotifier(this._categoryService)
    : super(const CategoryListState()) {
    loadCategories();
  }

  @override
  void dispose() {
    _disposed = true;
    super.dispose();
  }

  /// åŠ è½½æ‰€æœ‰ç±»åˆ?
  Future<void> loadCategories() async {
    if (_disposed) return;
    state = state.copyWith(isLoading: true, error: null);
    try {
      final categories = await _categoryService.getAllCategories();
      if (!_disposed) {
        state = state.copyWith(categories: categories, isLoading: false);
      }
    } catch (e) {
      if (!_disposed) {
        state = state.copyWith(isLoading: false, error: e.toString());
      }
    }
  }

  /// æ·»åŠ ç±»åˆ«
  Future<int> addCategory({required String name, int? parentId}) async {
    try {
      // final id = _categoryService.generateCategoryId();
      final newId = await _categoryService.addCategory(
        // id: id,
        name: name,
        parentId: parentId,
      );
      await loadCategories(); // é‡æ–°åŠ è½½åˆ—è¡¨
      return newId;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }
  }

  /// æ›´æ–°ç±»åˆ«
  Future<void> updateCategory({
    required int id,
    required String name,
    int? parentId,
  }) async {
    try {
      await _categoryService.updateCategory(
        id: id,
        name: name,
        parentId: parentId,
      );
      await loadCategories(); // é‡æ–°åŠ è½½åˆ—è¡¨
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }
  }

  /// åˆ é™¤ç±»åˆ« - ä»…åˆ é™¤å½“å‰ç±»åˆ«ï¼ˆä¿ç•™å­ç±»å’Œäº§å“ï¼‰
  Future<void> deleteCategoryOnly(int id) async {
    try {
      await _categoryService.deleteCategoryOnly(id);
      await loadCategories(); // é‡æ–°åŠ è½½åˆ—è¡¨
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }
  }

  /// çº§è”åˆ é™¤ç±»åˆ«åŠæ‰€æœ‰å…³è”å†…å®?
  Future<void> deleteCategoryCascade(int id) async {
    try {
      await _categoryService.deleteCategoryCascade(id);
      await loadCategories(); // é‡æ–°åŠ è½½åˆ—è¡¨
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }
  }

  /// åˆ é™¤ç±»åˆ«ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
  Future<void> deleteCategory(int id) async {
    try {
      await _categoryService.deleteCategory(id);
      await loadCategories(); // é‡æ–°åŠ è½½åˆ—è¡¨
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }
  }

  /// æ¸…é™¤é”™è¯¯
  void clearError() {
    state = state.copyWith(error: null);
  }
}

/// ç±»åˆ«åˆ—è¡¨ Provider
final categoryListProvider =
    StateNotifierProvider<CategoryListNotifier, CategoryListState>((ref) {
      final categoryService = ref.watch(categoryServiceProvider);
      return CategoryListNotifier(categoryService);
    });

/// æ ¹ç±»åˆ?Provider
final rootCategoriesProvider = StreamProvider<List<CategoryModel>>((ref) {
  final categoryService = ref.watch(categoryServiceProvider);
  return categoryService.watchRootCategories();
});

/// æŒ‡å®šçˆ¶ç±»åˆ«çš„å­ç±»åˆ?Provider
final subCategoriesProvider = StreamProvider.family<List<CategoryModel>, int>((
  ref,
  parentId,
) {
  final categoryService = ref.watch(categoryServiceProvider);
  return categoryService.watchSubCategories(parentId);
});

/// æ‰€æœ‰ç±»åˆ«çš„æµå¼ Provider
final allCategoriesStreamProvider = StreamProvider<List<CategoryModel>>((ref) {
  final categoryService = ref.watch(categoryServiceProvider);
  return categoryService.watchAllCategories();
});

/// è·å–æ‰€æœ‰ç±»åˆ«çš„åŒæ­¥ Provider (å…¼å®¹æ—§çš„ categoriesProvider)
final categoriesProvider = Provider<List<CategoryModel>>((ref) {
  final categoryListState = ref.watch(categoryListProvider);
  return categoryListState.categories;
});

/// æ ¹æ®IDè·å–ç±»åˆ«çš?Provider
final getCategoryByIdProvider = Provider.family<CategoryModel?, int>((
  ref,
  categoryId,
) {
  final categories = ref.watch(categoriesProvider);
  return categories.where((category) => category.id == categoryId).firstOrNull;
});

/// è·å–é¡¶çº§ç±»åˆ«ï¼ˆæ— çˆ¶çº§çš„ç±»åˆ«ï¼‰
final topLevelCategoriesProvider = Provider<List<CategoryModel>>((ref) {
  final categories = ref.watch(categoriesProvider);
  return categories.where((category) => category.parentId == null).toList();
});

/// æ ¹æ®çˆ¶çº§IDè·å–å­ç±»åˆ«çš„åŒæ­¥ Provider
final getSubCategoriesProvider = Provider.family<List<CategoryModel>, int>((
  ref,
  parentId,
) {
  final categories = ref.watch(categoriesProvider);
  return categories.where((category) => category.parentId == parentId).toList();
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/repository/category_repository.dart';
import '../data/repository/product_repository.dart';
import '../domain/model/category.dart';
import '../domain/model/product.dart';
import '../domain/repository/i_category_repository.dart';
import '../domain/repository/i_product_repository.dart';

/// ç±»åˆ«åº”ç”¨æœåŠ¡
/// å¤„ç†ç±»åˆ«ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘å’ŒçŠ¶æ€ç®¡ç?
class CategoryService {
  final ICategoryRepository _repository;
  final IProductRepository? _productRepository;

  CategoryService(this._repository, [this._productRepository]);

  /// æ·»åŠ æ–°ç±»åˆ?
  Future<int> addCategory({
    int? id,
    required String name,
    int? parentId,
  }) async {
    // éªŒè¯ç±»åˆ«åç§°
    if (name.trim().isEmpty) {
      throw Exception('ç±»åˆ«åç§°ä¸èƒ½ä¸ºç©º');
    }

    // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨
    final exists = await _repository.isCategoryNameExists(
      name.trim(),
      parentId,
    );
    if (exists) {
      throw Exception('åœ¨å½“å‰å±‚çº§ä¸‹ï¼Œç±»åˆ«åç§°å·²å­˜åœ¨');
    }

    // å¦‚æœæœ‰çˆ¶ç±»åˆ«ï¼ŒéªŒè¯çˆ¶ç±»åˆ«æ˜¯å¦å­˜åœ¨
    if (parentId != null && parentId>0) {
      final parentCategory = await _repository.getCategoryById(parentId);
      if (parentCategory == null) {
        throw Exception('çˆ¶ç±»åˆ«ä¸å­˜åœ¨');
      }
    }

    final category = CategoryModel(
      name: name.trim(),
      parentId: parentId,
    );

    return await _repository.addCategory(category);
  }

  /// æ›´æ–°ç±»åˆ«
  Future<void> updateCategory({
    required int id,
    required String name,
    int? parentId,
  }) async {
    // éªŒè¯ç±»åˆ«æ˜¯å¦å­˜åœ¨
    final existingCategory = await _repository.getCategoryById(id);
    if (existingCategory == null) {
      throw Exception('ç±»åˆ«ä¸å­˜åœ?);
    }

    // éªŒè¯ç±»åˆ«åç§°
    if (name.trim().isEmpty) {
      throw Exception('ç±»åˆ«åç§°ä¸èƒ½ä¸ºç©º');
    }

    // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨ï¼ˆæ’é™¤å½“å‰ç±»åˆ«ï¼‰
    final exists = await _repository.isCategoryNameExists(
      name.trim(),
      parentId,
      excludeId: id,
    );
    if (exists) {
      throw Exception('åœ¨å½“å‰å±‚çº§ä¸‹ï¼Œç±»åˆ«åç§°å·²å­˜åœ¨');
    }

    // å¦‚æœæœ‰çˆ¶ç±»åˆ«ï¼ŒéªŒè¯çˆ¶ç±»åˆ«æ˜¯å¦å­˜åœ¨ä¸”ä¸æ˜¯è‡ªå·±æˆ–å­ç±»åˆ?
    if (parentId != null && parentId>0) {
      if (parentId == id) {
        throw Exception('ä¸èƒ½å°†è‡ªå·±è®¾ä¸ºçˆ¶ç±»åˆ«');
      }

      final parentCategory = await _repository.getCategoryById(parentId);
      if (parentCategory == null) {
        throw Exception('çˆ¶ç±»åˆ«ä¸å­˜åœ¨');
      }

      // æ£€æŸ¥æ˜¯å¦ä¼šå½¢æˆå¾ªç¯å¼•ç”¨
      final path = await _repository.getCategoryPath(parentId);
      if (path.any((category) => category.id == id)) {
        throw Exception('ä¸èƒ½å°†å­ç±»åˆ«è®¾ä¸ºçˆ¶ç±»åˆ?);
      }
    }

    final updatedCategory = CategoryModel(
      name: name.trim(),
      parentId: parentId,
    );

    await _repository.updateCategory(updatedCategory);
  }

  /// åˆ é™¤ç±»åˆ« - ä»…åˆ é™¤å½“å‰ç±»åˆ«ï¼ˆä¿ç•™å­ç±»å’Œäº§å“ï¼‰
  Future<void> deleteCategoryOnly(int id) async {
    // éªŒè¯ç±»åˆ«æ˜¯å¦å­˜åœ¨
    final category = await _repository.getCategoryById(id);
    if (category == null) {
      throw Exception('ç±»åˆ«ä¸å­˜åœ?);
    }

    // è·å–å½“å‰ç±»åˆ«çš„æ‰€æœ‰å­ç±»åˆ«
    final allCategories = await _repository.getAllCategories();
    final subCategories = allCategories
        .where((cat) => cat.parentId == id)
        .toList();
    // å¤„ç†å…³è”åˆ°å½“å‰ç±»åˆ«çš„äº§å“
    if (_productRepository != null) {
      final relatedProducts = await _productRepository.getProductsByCondition(
        categoryId: id,
      );

      for (final product in relatedProducts) {
        // å°†äº§å“çš„ç±»åˆ«è®¾ç½®ä¸ºå½“å‰ç±»åˆ«çš„çˆ¶ç±»åˆ«ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™è®¾ä¸ºnull
        final updatedProduct = ProductModel(
          id: product.id,
          name: product.name,
          // barcode å­—æ®µå·²ç§»é™¤ï¼Œæ¡ç ç°åœ¨ç”±ç‹¬ç«‹çš„æ¡ç è¡¨ç®¡ç?
          sku: product.sku,
          image: product.image,
          categoryId: category.parentId, // è½¬ç§»åˆ°çˆ¶ç±»åˆ«æˆ–è®¾ä¸ºnull
          baseUnitId: product.baseUnitId,
          specification: product.specification,
          brand: product.brand,
          // ä½¿ç”¨ Money å­—æ®µè€Œé *InCents
          suggestedRetailPrice: product.suggestedRetailPrice,
          retailPrice: product.retailPrice,
          promotionalPrice: product.promotionalPrice,
          stockWarningValue: product.stockWarningValue,
          shelfLife: product.shelfLife,
          status: product.status,
          remarks: product.remarks,
          lastUpdated: DateTime.now(),
        );
        await _productRepository.updateProduct(updatedProduct);
      }
    }

    // å¤„ç†å­ç±»åˆ«çš„çˆ¶çº§å…³ç³»
    if (subCategories.isNotEmpty) {
      for (final subCategory in subCategories) {
        // å°†å­ç±»åˆ«çš„çˆ¶çº§è®¾ç½®ä¸ºå½“å‰ç±»åˆ«çš„çˆ¶çº?
        final updatedSubCategory = CategoryModel(
          id: subCategory.id,
          name: subCategory.name,
          parentId: category.parentId, // ç»§æ‰¿å½“å‰ç±»åˆ«çš„çˆ¶çº?
        );
        await _repository.updateCategory(updatedSubCategory);
      }
    }

    // åˆ é™¤å½“å‰ç±»åˆ«
    await _repository.deleteCategory(id);
  }

  /// çº§è”åˆ é™¤ç±»åˆ«åŠæ‰€æœ‰å…³è”å†…å®?
  Future<void> deleteCategoryCascade(int id) async {
    // éªŒè¯ç±»åˆ«æ˜¯å¦å­˜åœ¨
    final category = await _repository.getCategoryById(id);
    if (category == null) {
      throw Exception('ç±»åˆ«ä¸å­˜åœ?);
    }

    // é€’å½’è·å–æ‰€æœ‰å­ç±»åˆ«ï¼ˆåŒ…æ‹¬å¤šå±‚çº§åµŒå¥—ï¼?
    final allSubCategories = await _getAllDescendantCategories(id);

    // è·å–æ‰€æœ‰éœ€è¦åˆ é™¤çš„ç±»åˆ«IDï¼ˆåŒ…æ‹¬å½“å‰ç±»åˆ«ï¼‰
    final allCategoryIds = [id, ...allSubCategories.map((cat) => cat.id)];
    // åˆ é™¤æ‰€æœ‰å…³è”äº§å“?
    if (_productRepository != null) {
      for (final categoryId in allCategoryIds) {
        final relatedProducts = await _productRepository.getProductsByCondition(
          categoryId: categoryId,
        );
        for (final product in relatedProducts) {
          if (product.id != null) {
            await _productRepository.deleteProduct(product.id!);
          }
        }
      }
    }

    // æŒ‰å±‚çº§ä»æ·±åˆ°æµ…åˆ é™¤ç±»åˆ«ï¼ˆå…ˆåˆ é™¤å­ç±»åˆ«ï¼Œå†åˆ é™¤çˆ¶ç±»åˆ«ï¼‰
    final categoryLevels = <int, List<CategoryModel>>{};

    // ä¸ºå½“å‰ç±»åˆ«å’Œæ‰€æœ‰å­ç±»åˆ«è®¡ç®—å±‚çº§
    final currentCategory = category;
    final currentPath = await _repository.getCategoryPath(id);
    final currentLevel = currentPath.length;
    categoryLevels.putIfAbsent(currentLevel, () => []).add(currentCategory);

    for (final subCategory in allSubCategories) {
      if (subCategory.id != null) {
        final path = await _repository.getCategoryPath(subCategory.id!);
        final level = path.length;
        categoryLevels.putIfAbsent(level, () => []).add(subCategory);
      }
    }

    // ä»æœ€æ·±å±‚å¼€å§‹åˆ é™?
    final sortedLevels = categoryLevels.keys.toList()
      ..sort((a, b) => b.compareTo(a));

    for (final level in sortedLevels) {
      for (final categoryToDelete in categoryLevels[level]!) {
        if (categoryToDelete.id != null) {
          await _repository.deleteCategory(categoryToDelete.id!);
        }
      }
    }
  }

  /// é€’å½’è·å–æ‰€æœ‰åä»£ç±»åˆ?
  Future<List<CategoryModel>> _getAllDescendantCategories(int parentId) async {
    final allCategories = await _repository.getAllCategories();
    final result = <CategoryModel>[];

    // è·å–ç›´æ¥å­ç±»åˆ?
    final directSubCategories = allCategories
        .where((cat) => cat.parentId == parentId)
        .toList();

    for (final subCategory in directSubCategories) {
      result.add(subCategory);
      // é€’å½’è·å–å­ç±»åˆ«çš„å­ç±»åˆ?
      if (subCategory.id != null) {
        final descendants = await _getAllDescendantCategories(subCategory.id!);
        result.addAll(descendants);
      }
    }

    return result;
  }

  /// å…¼å®¹åŸæœ‰çš„åˆ é™¤æ–¹æ³•ï¼ˆä¿æŒå‘åå…¼å®¹ï¼?
  Future<void> deleteCategory(int id) async {
    // é»˜è®¤ä½¿ç”¨çº§è”åˆ é™¤æ¨¡å¼
    await deleteCategoryCascade(id);
  }

  /// è·å–æ‰€æœ‰ç±»åˆ?
  Future<List<CategoryModel>> getAllCategories() async {
    return await _repository.getAllCategories();
  }

  /// è·å–æ ¹ç±»åˆ?
  Future<List<CategoryModel>> getRootCategories() async {
    return await _repository.getRootCategories();
  }

  /// è·å–å­ç±»åˆ?
  Future<List<CategoryModel>> getSubCategories(int parentId) async {
    return await _repository.getCategoriesByParentId(parentId);
  }

  /// è·å–ç±»åˆ«è·¯å¾„
  Future<List<CategoryModel>> getCategoryPath(int categoryId) async {
    return await _repository.getCategoryPath(categoryId);
  }

  /// ç›‘å¬æ‰€æœ‰ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchAllCategories() {
    return _repository.watchAllCategories();
  }

  /// ç›‘å¬æ ¹ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchRootCategories() {
    return _repository.watchRootCategories();
  }

  /// ç›‘å¬å­ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchSubCategories(int parentId) {
    return _repository.watchCategoriesByParentId(parentId);
  }

  // /// ç”Ÿæˆæ–°çš„ç±»åˆ«ID
  // String generateCategoryId() {
  //   return 'cat_${DateTime.now().millisecondsSinceEpoch}';
  // }
}

/// CategoryModel Service Provider
final categoryServiceProvider = Provider<CategoryService>((ref) {
  final repository = ref.watch(categoryRepositoryProvider);
  final productRepository = ref.watch(productRepositoryProvider);
  return CategoryService(repository, productRepository);
});
import 'package:drift/drift.dart';

// å¯¼å…¥æ•°æ®åº“å®šä¹‰æ–‡ä»¶å’Œæ‰€æœ‰è¡¨
import '../../../core/database/database.dart';

import 'package:stocko_app/features/product/domain/model/product.dart';

/// ä¸€ä¸ªæœåŠ¡ç±»ï¼Œç”¨äºå¤„ç†ä»å¤–éƒ¨æ•°æ®æºæ‰¹é‡å¯¼å…¥å•†å“ã€?
class ProductImportService {
  final AppDatabase db;

  ProductImportService(this.db);

  /// æ ¹æ®åç§°å’Œå¯é€‰çš„çˆ¶IDæŸ¥æ‰¾æˆ–åˆ›å»ºä¸€ä¸ªåˆ†ç±»ï¼Œå¹¶è¿”å›å…¶IDã€?
  Future<int> _getOrCreateCategory(String name, {int? parentId}) async {
    // 1. å°è¯•æŸ¥æ‰¾å·²å­˜åœ¨çš„åˆ†ç±»
    final query = db.select(db.category)..where((tbl) => tbl.name.equals(name));

    if (parentId == null) {
      query.where((tbl) => tbl.parentId.isNull());
    } else {
      query.where((tbl) => tbl.parentId.equals(parentId));
    }

    final existingCategory = await query.getSingleOrNull();

    if (existingCategory != null) {
      return existingCategory.id; // 2. å¦‚æœæ‰¾åˆ°ï¼Œè¿”å›å…¶ID
    } else {
      // 3. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš?
      final companion = CategoryCompanion.insert(
        name: name,
        parentId: Value(parentId),
      );
      final newCategory = await db.into(db.category).insertReturning(companion);
      return newCategory.id;
    }
  }

  /// æ ¹æ®åç§°æŸ¥æ‰¾æˆ–åˆ›å»ºä¸€ä¸ªå•ä½ï¼Œå¹¶è¿”å›å…¶IDã€?
  Future<int> _getOrCreateUnit(String name) async {
    final existingUnit = await (db.select(
      db.unit,
    )..where((tbl) => tbl.name.equals(name))).getSingleOrNull();

    if (existingUnit != null) {
      return existingUnit.id;
    } else {
      final companion = UnitCompanion.insert(name: name);
      return await db.into(db.unit).insert(companion);
    }
  }

  double _parsePrice(String priceString) {
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ä»å­—ç¬¦ä¸²ä¸­æå–ä»·æ ¼æ•°å€?
    // è¿™ä¸ªè¡¨è¾¾å¼åŒ¹é…ç¬¬ä¸€ä¸ªå‡ºç°çš„æ•°å­—åºåˆ—ï¼ˆå¯ä»¥åŒ…å«ä¸€ä¸ªå°æ•°ç‚¹ï¼?
    final match = RegExp(r'\d+\.?\d*').firstMatch(priceString);
    if (match != null) {
      // group(0) è¿”å›æ•´ä¸ªåŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦?"50.00"
      return double.tryParse(match.group(0)!) ?? 0.0;
    }
    return 0.0;
  }

  /// ä»ä¸€ä¸ªåŸå§‹æ•°æ®Mapåˆ—è¡¨ä¸­æ‰¹é‡æ’å…¥å•†å“ã€?
  Future<String?> bulkInsertProducts(
    List<Map<String, dynamic>> rawProductsData,
  ) async {
    if (rawProductsData.isEmpty) return 'æ²¡æœ‰éœ€è¦å¯¼å…¥çš„æ•°æ®ã€?;

    // --- æ–°å¢æ­¥éª¤: é¢„æ£€æŸ¥æ¡ç å”¯ä¸€æ€?---
    final allBarcodes = <String>[];
    final duplicateBarcodesInFile = <String>{};
    final seenBarcodes = <String>{};

    for (final productData in rawProductsData) {
      final packBarcode = productData['åŒ…æ¡ç ?] as String?;
      final cartonBarcode = productData['æ¡æ¡ç ?] as String?;

      if (packBarcode != null && packBarcode.isNotEmpty) {
        if (seenBarcodes.contains(packBarcode)) {
          duplicateBarcodesInFile.add(packBarcode);
        }
        seenBarcodes.add(packBarcode);
        allBarcodes.add(packBarcode);
      }
      if (cartonBarcode != null &&
          cartonBarcode.isNotEmpty &&
          cartonBarcode != packBarcode) {
        if (seenBarcodes.contains(cartonBarcode)) {
          duplicateBarcodesInFile.add(cartonBarcode);
        }
        seenBarcodes.add(cartonBarcode);
        allBarcodes.add(cartonBarcode);
      }
    }

    if (duplicateBarcodesInFile.isNotEmpty) {
      return 'å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶ä¸­å‘ç°é‡å¤æ¡ç : ${duplicateBarcodesInFile.join(', ')}ã€‚è¯·ä¿®æ­£æ•°æ®åé‡è¯•ã€?;
    }

    // --- æ­¥éª¤ 1: é¢„å¤„ç†ï¼Œæ”¶é›†æ‰€æœ‰å”¯ä¸€çš„å“ç‰Œå’Œå•ä½åç§° ---
    final categoryNames = rawProductsData
        .map((data) => data['å“ç‰Œ'] as String)
        .toSet();
    final unitNames = {'åŒ?, 'æ?}; // æ ¹æ®éœ€æ±‚å›ºå®?

    // --- æ­¥éª¤ 2: ä¸€æ¬¡æ€§æŸ¥æ‰¾æˆ–åˆ›å»ºæ‰€æœ‰éœ€è¦çš„IDï¼Œå¹¶å­˜å…¥Map ---
    // --- æ­¥éª¤ 2: åˆ›å»ºå±‚çº§åˆ†ç±» ---
    // 2.1 é¦–å…ˆåˆ›å»ºæˆ–è·å–é¡¶çº§åˆ†ç±?çƒ?
    final rootCategoryName = 'çƒ?;
    final rootCategoryId = await _getOrCreateCategory(rootCategoryName);

    // 2.2 ç„¶åå°†æ–‡ä»¶ä¸­çš„å“ç‰Œä½œä¸?çƒ?çš„å­åˆ†ç±»
    final categoryIdMap = <String, int>{};
    for (final name in categoryNames) {
      // å°†å“ç‰Œä½œä¸ºäºŒçº§åˆ†ç±»ï¼Œçˆ¶çº§æ˜?çƒ?
      categoryIdMap[name] = await _getOrCreateCategory(
        name,
        parentId: rootCategoryId,
      );
    }

    final unitIdMap = <String, int>{};
    for (final name in unitNames) {
      unitIdMap[name] = await _getOrCreateUnit(name);
    }

    final packUnitId = unitIdMap['åŒ?]!;
    final cartonUnitId = unitIdMap['æ?]!;

    // --- å¤„ç†å·²å­˜åœ¨çš„æ¡ç ï¼šåˆ é™¤æ—§äº§å“æ•°æ®ä»¥ä¾¿è¦†ç›– ---
    if (allBarcodes.isNotEmpty) {
      final existingBarcodes = await (db.select(
        db.barcode,
      )..where((t) => t.barcodeValue.isIn(allBarcodes))).get();

      if (existingBarcodes.isNotEmpty) {
        // æ”¶é›†éœ€è¦åˆ é™¤çš„äº§å“ID
        final unitProductIds = existingBarcodes
            .map((b) => b.unitProductId)
            .toSet();

        // æŸ¥æ‰¾è¿™äº›unitProductå¯¹åº”çš„äº§å“ID
        final unitProducts = await (db.select(
          db.unitProduct,
        )..where((t) => t.id.isIn(unitProductIds))).get();

        final productIds = unitProducts.map((up) => up.productId).toSet();

        // åˆ é™¤æ—§çš„æ¡ç è®°å½•
        await (db.delete(
          db.barcode,
        )..where((t) => t.barcodeValue.isIn(allBarcodes))).go();

        // åˆ é™¤æ—§çš„å•ä½äº§å“è®°å½•
        await (db.delete(
          db.unitProduct,
        )..where((t) => t.productId.isIn(productIds))).go();

        // åˆ é™¤æ—§çš„äº§å“è®°å½•
        await (db.delete(db.product)..where((t) => t.id.isIn(productIds))).go();
      }
    }
    // --- é¢„æ£€æŸ¥ç»“æ?---

    // --- æ­¥éª¤ 3: æ‰§è¡Œé«˜æ•ˆçš„æ‰¹é‡æ’å…?---
    try {
      await db.batch((batch) {
        // --- æ–°å¢: æ”¹è¿›IDç”Ÿæˆç­–ç•¥ ---
        final baseTimestamp = DateTime.now().millisecondsSinceEpoch;
        int idOffset = 0;

        for (final productData in rawProductsData) {
          // ä½¿ç”¨åŸºç¡€æ—¶é—´æˆ³å’Œåç§»é‡ç”Ÿæˆå”¯ä¸€çš„ID
          final productId = baseTimestamp + idOffset;
          final productPackUnitId = baseTimestamp + idOffset + 1;
          final packBarcodeId = baseTimestamp + idOffset + 2;
          final productCartonUnitId = baseTimestamp + idOffset + 3;
          final cartonBarcodeId = baseTimestamp + idOffset + 4;

          final productName = productData['è´§å“åç§°'] as String;
          final brand = productData['å“ç‰Œ'] as String;
          final categoryId = categoryIdMap[brand]!; // ä»Mapä¸­å¿«é€Ÿè·å–ID

          final cartonSuggestedRetailPrice = _parsePrice(
            productData['å»ºè®®é›¶å”®ä»?] as String,
          );
          final cartonWholesalePrice = _parsePrice(
            productData['æ‰¹å‘ä»?] as String,
          );
          const conversionRate = 10;

          // æ’å…¥å•†å“ä¸»è®°å½?
          batch.insert(
            db.product,
            ProductCompanion.insert(
              id: Value(productId), // ä½¿ç”¨æ–°ID
              name: productName,
              brand: Value(brand),
              categoryId: Value(categoryId),
              baseUnitId: packUnitId, // åŸºç¡€å•ä½IDæ˜?åŒ?
              suggestedRetailPrice: Value(
                Money(
                  (cartonSuggestedRetailPrice * 100 / conversionRate).toInt(),
                ),
              ),
            ),
          );

          // æ’å…¥"åŒ?çš„å•ä½å’Œæ¡ç è®°å½•
          batch.insert(
            db.unitProduct,
            UnitProductCompanion.insert(
              id: Value(productPackUnitId), // ä½¿ç”¨æ–°ID
              productId: productId,
              unitId: packUnitId,
              conversionRate: 1, // åŸºæœ¬å•ä½æ¢ç®—ç‡ä¸º1
              sellingPriceInCents: Value(
                (cartonSuggestedRetailPrice * 100 / conversionRate).toInt(),
              ),
              wholesalePriceInCents: Value(
                (cartonWholesalePrice * 100 / conversionRate).toInt(),
              ),
            ),
          );
          final packBarcode = productData['åŒ…æ¡ç ?] as String?;
          if (packBarcode != null && packBarcode.isNotEmpty) {
            batch.insert(
              db.barcode,
              BarcodeCompanion.insert(
                id: Value(packBarcodeId), // ä½¿ç”¨æ–°ID
                unitProductId: productPackUnitId,
                barcodeValue: packBarcode,
              ),
            );
          }

          // æ’å…¥"æ?çš„å•ä½å’Œæ¡ç è®°å½•
          batch.insert(
            db.unitProduct,
            UnitProductCompanion.insert(
              id: Value(productCartonUnitId), // ä½¿ç”¨æ–°ID
              productId: productId,
              unitId: cartonUnitId,
              conversionRate: conversionRate,
              sellingPriceInCents: Value(
                (cartonSuggestedRetailPrice * 100).toInt(),
              ),
              wholesalePriceInCents: Value(
                (cartonWholesalePrice * 100).toInt(),
              ),
            ),
          );
          final cartonBarcode = productData['æ¡æ¡ç ?] as String?;
          if (cartonBarcode != null && cartonBarcode.isNotEmpty) {
            batch.insert(
              db.barcode,
              BarcodeCompanion.insert(
                id: Value(cartonBarcodeId), // ä½¿ç”¨æ–°ID
                unitProductId: productCartonUnitId,
                barcodeValue: cartonBarcode,
              ),
            );
          }
          // ä¸ºä¸‹ä¸€ä¸ªå•†å“å¢åŠ IDåç§»é‡?
          idOffset += 5;
        }
      });
      return 'æ‰¹é‡å¯¼å…¥ä»»åŠ¡å®Œæˆï¼ŒæˆåŠŸå¤„ç?${rawProductsData.length} æ¡è®°å½•ã€?;
    } catch (e, s) {
      // åœ¨é¢„æ£€æŸ¥åï¼Œæ­¤å¤„çš„ UNIQUE constraint é”™è¯¯ç†è®ºä¸Šä¸åº”å†å‘ç”Ÿ
      // ä½†ä¿ç•™ä»¥é˜²ä¸‡ä¸€
      print(
        '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>å¤„ç†å•†å“æ•°æ®æ—¶å‘ç”Ÿæ„å¤–é”™è¯? $e\n$s<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<',
      ); // ä¿ç•™å¼€å‘è€…æ—¥å¿?
      print(
        '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>æ—¥å¿—ç»“æŸ<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<',
      ); // ä¿ç•™å¼€å‘è€…æ—¥å¿?

      return 'å¯¼å…¥è¿‡ç¨‹ä¸­å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ—¥å¿—ã€?;
    }
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/barcode.dart';
import '../../domain/repository/i_barcode_repository.dart';
import '../../data/repository/barcode_repository.dart';
import '../../domain/model/product_unit.dart';
import '../../data/repository/product_unit_repository.dart';

/// æ¡ç æ“ä½œçŠ¶æ€?
enum BarcodeOperationStatus { initial, loading, success, error }

/// æ¡ç æ§åˆ¶å™¨çŠ¶æ€?
class BarcodeControllerState {
  final BarcodeOperationStatus status;
  final String? errorMessage;
  final List<BarcodeModel>? lastOperatedBarcodes;

  const BarcodeControllerState({
    this.status = BarcodeOperationStatus.initial,
    this.errorMessage,
    this.lastOperatedBarcodes,
  });

  BarcodeControllerState copyWith({
    BarcodeOperationStatus? status,
    String? errorMessage,
    List<BarcodeModel>? lastOperatedBarcodes,
  }) {
    return BarcodeControllerState(
      status: status ?? this.status,
      errorMessage: errorMessage,
      lastOperatedBarcodes: lastOperatedBarcodes ?? this.lastOperatedBarcodes,
    );
  }

  bool get isLoading => status == BarcodeOperationStatus.loading;
  bool get isSuccess => status == BarcodeOperationStatus.success;
  bool get isError => status == BarcodeOperationStatus.error;
}

/// æ¡ç æ§åˆ¶å™?
class BarcodeController extends StateNotifier<BarcodeControllerState> {
  final IBarcodeRepository _repository;

  BarcodeController(this._repository) : super(const BarcodeControllerState());

  /// æ·»åŠ æ¡ç 
  Future<void> addBarcode(BarcodeModel barcode) async {
    state = state.copyWith(status: BarcodeOperationStatus.loading);

    try {
      // æ£€æŸ¥æ¡ç æ˜¯å¦å·²å­˜åœ¨
      final exists = await _repository.barcodeExists(barcode.barcodeValue);
      if (exists) {
        state = state.copyWith(
          status: BarcodeOperationStatus.error,
          errorMessage: 'æ¡ç  ${barcode.barcodeValue} å·²å­˜åœ?,
        );
        return;
      }

      await _repository.addBarcode(barcode);
      state = state.copyWith(
        status: BarcodeOperationStatus.success,
        lastOperatedBarcodes: [barcode],
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'æ·»åŠ æ¡ç å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ‰¹é‡æ·»åŠ æ¡ç 
  Future<void> addMultipleBarcodes(List<BarcodeModel> barcodes) async {
    if (barcodes.isEmpty) return;

    state = state.copyWith(status: BarcodeOperationStatus.loading);

    try {
      // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„æ¡ç ?
      for (final barcode in barcodes) {
        final exists = await _repository.barcodeExists(barcode.barcodeValue);
        if (exists) {
          state = state.copyWith(
            status: BarcodeOperationStatus.error,
            errorMessage: 'æ¡ç  ${barcode.barcodeValue} å·²å­˜åœ?,
          );
          return;
        }
      }

      await _repository.addMultipleBarcodes(barcodes);
      state = state.copyWith(
        status: BarcodeOperationStatus.success,
        lastOperatedBarcodes: barcodes,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'æ‰¹é‡æ·»åŠ æ¡ç å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ›´æ–°æ¡ç 
  Future<void> updateBarcode(BarcodeModel barcode) async {
    state = state.copyWith(status: BarcodeOperationStatus.loading);

    try {
      final success = await _repository.updateBarcode(barcode);
      if (success) {
        state = state.copyWith(
          status: BarcodeOperationStatus.success,
          lastOperatedBarcodes: [barcode],
          errorMessage: null,
        );
      } else {
        state = state.copyWith(
          status: BarcodeOperationStatus.error,
          errorMessage: 'æ›´æ–°æ¡ç å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„è®°å½?,
        );
      }
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'æ›´æ–°æ¡ç å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// åˆ é™¤æ¡ç 
  Future<void> deleteBarcode(int id) async {
    state = state.copyWith(status: BarcodeOperationStatus.loading);

    try {
      final deletedCount = await _repository.deleteBarcode(id);
      if (deletedCount > 0) {
        state = state.copyWith(
          status: BarcodeOperationStatus.success,
          errorMessage: null,
        );
      } else {
        state = state.copyWith(
          status: BarcodeOperationStatus.error,
          errorMessage: 'åˆ é™¤æ¡ç å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„è®°å½?,
        );
      }
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'åˆ é™¤æ¡ç å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// åˆ é™¤äº§å“å•ä½çš„æ‰€æœ‰æ¡ç ?
  Future<void> deleteBarcodesByProductUnitId(int id) async {
    state = state.copyWith(status: BarcodeOperationStatus.loading);

    try {
      final deletedCount = await _repository.deleteBarcodesByProductUnitId(
        id,
      );
      state = state.copyWith(
        status: BarcodeOperationStatus.success,
        errorMessage: null,
      );
      print('åˆ é™¤äº?$deletedCount ä¸ªæ¡ç ?);
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'åˆ é™¤äº§å“å•ä½æ¡ç å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ ¹æ®æ¡ç å€¼è·å–æ¡ç ä¿¡æ?
  Future<BarcodeModel?> getBarcodeByValue(String barcode) async {
    try {
      return await _repository.getBarcodeByValue(barcode);
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'è·å–æ¡ç ä¿¡æ¯å¤±è´¥: ${e.toString()}',
      );
      return null;
    }
  }

  /// æ ¹æ®äº§å“å•ä½IDè·å–æ‰€æœ‰æ¡ç ?
  Future<List<BarcodeModel>> getBarcodesByProductUnitId(int? id) async {
    try {
      return await _repository.getBarcodesByProductUnitId(id);
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'è·å–äº§å“å•ä½æ¡ç å¤±è´¥: ${e.toString()}',
      );
      return [];
    }
  }

  /// æ£€æŸ¥æ¡ç æ˜¯å¦å­˜åœ?
  Future<bool> barcodeExists(String barcode) async {
    try {
      return await _repository.barcodeExists(barcode);
    } catch (e) {
      state = state.copyWith(
        status: BarcodeOperationStatus.error,
        errorMessage: 'æ£€æŸ¥æ¡ç æ˜¯å¦å­˜åœ¨å¤±è´? ${e.toString()}',
      );
      return false;
    }
  }

  /// æ¸…é™¤é”™è¯¯çŠ¶æ€?
  void clearError() {
    if (state.isError) {
      state = state.copyWith(
        status: BarcodeOperationStatus.initial,
        errorMessage: null,
      );
    }
  }
}

/// æ¡ç æ§åˆ¶å™?Provider
final barcodeControllerProvider =
    StateNotifierProvider<BarcodeController, BarcodeControllerState>((ref) {
      final repository = ref.watch(barcodeRepositoryProvider);
      return BarcodeController(repository);
    });

/// æ ¹æ®äº§å“å•ä½IDè·å–æ¡ç åˆ—è¡¨çš?Provider
final barcodesByProductUnitIdProvider =
    StreamProvider.family<List<BarcodeModel>, int>((ref, id) {
      final repository = ref.watch(barcodeRepositoryProvider);
      return repository.watchBarcodesByProductUnitId(id);
    });

/// è·å–æ‰€æœ‰æ¡ç çš„ Provider
final allBarcodesProvider = FutureProvider<List<BarcodeModel>>((ref) async {
  final repository = ref.watch(barcodeRepositoryProvider);
  return repository.getAllBarcodes();
});

/// æ ¹æ®è´§å“IDè·å–ä¸»æ¡ç çš„ Provider
final mainBarcodeProvider =
    FutureProvider.family<String?, int>((ref, productId) async {
  final productUnitRepo = ref.watch(productUnitRepositoryProvider);
  final barcodeRepo = ref.watch(barcodeRepositoryProvider);

  print('======== è°ƒè¯•æ—¥å¿—ï¼šmainBarcodeProvider å†…éƒ¨ ========');
  print('è´§å“ID: $productId');

  // 1. æŸ¥æ‰¾è´§å“çš„åŸºç¡€å•ä½é…ç½®
  final productUnits = await productUnitRepo.getProductUnitsByProductId(productId);
  print('æŸ¥æ‰¾åˆ°çš„è´§å“å•ä½é…ç½®: ${productUnits.map((e) => 'id: ${e.id}, rate: ${e.conversionRate}').toList()}');

  if (productUnits.isEmpty) {
    print('æœªæ‰¾åˆ°ä»»ä½•è´§å“å•ä½é…ç½®ï¼Œè¿”å› null');
    print('=============================================');
    return null; // æ²¡æœ‰å•ä½é…ç½®ï¼Œè‡ªç„¶æ²¡æœ‰æ¡ç ?
  }

  UnitProduct? baseProductUnit;
  try {
    baseProductUnit =
        productUnits.firstWhere((unit) => unit.conversionRate == 1.0);
    print('æ‰¾åˆ°åŸºç¡€å•ä½ (conversionRate == 1.0): id: ${baseProductUnit.id}');
  } catch (e) {
    // å¦‚æœæ²¡æœ‰ä¸¥æ ¼æ„ä¹‰ä¸Šçš„åŸºç¡€å•ä½ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªä½œä¸ºå¤‡é€?
    print('æœªæ‰¾åˆ°ä¸¥æ ¼çš„åŸºç¡€å•ä½ (conversionRate == 1.0)ï¼Œä½¿ç”¨åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå•ä½ä½œä¸ºå¤‡é€?);
    baseProductUnit = productUnits.first;
    print('å¤‡é€‰çš„åŸºç¡€å•ä½: id: ${baseProductUnit.id}');
  }
  final barcodes =
      await barcodeRepo.getBarcodesByProductUnitId(baseProductUnit.id);
  print('æ ¹æ®å•ä½ID ${baseProductUnit.id} æŸ¥æ‰¾åˆ°çš„æ¡ç : ${barcodes.map((e) => e.barcodeValue).toList()}');

  if (barcodes.isNotEmpty) {
    final barcodeValue = barcodes.first.barcodeValue;
    print('è¿”å›ç¬¬ä¸€ä¸ªæ¡ç ? $barcodeValue');
    print('=============================================');
    return barcodeValue;
  }

  print('æœªæ‰¾åˆ°ä»»ä½•æ¡ç ï¼Œè¿”å› null');
  print('=============================================');
  return null;
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart';

/// æ‰¹æ¬¡åˆ—è¡¨ï¼ˆæŒ‰äº§å“+åº—é“ºï¼?
final batchesByProductAndShopProvider = FutureProvider.family<
    List<ProductBatchData>, ({int productId, int shopId})>((ref, args) async {
  final db = ref.watch(appDatabaseProvider);
  return db.batchDao.getBatchesByProductAndShop(args.productId, args.shopId);
});
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/product.dart';
import '../../domain/model/category.dart';
import '../../data/repository/product_repository.dart'; // è¿™é‡ŒåŒ…å«äº?productRepositoryProvider
import '../category_notifier.dart';

// æ³¨æ„ï¼šè¿™ä¸ªæ–‡ä»¶å±•ç¤ºäº†ä½¿ç”¨ AsyncNotifier é‡æ„åçš„ä»£ç ç»“æ„
// è¿™æ˜¯ product_providers.dart çš„å®Œæ•´é‡æ„ç‰ˆæœ?

/// ä½¿ç”¨ä¼ ç»Ÿæ–¹å¼çš?AsyncNotifier ç¤ºä¾‹ï¼ˆä¸ä½¿ç”¨ä»£ç ç”Ÿæˆï¼?
/// äº§å“æ“ä½œçŠ¶æ€ç®¡ç?
class ProductOperationsNotifier extends AsyncNotifier<void> {
  @override
  FutureOr<void> build() {
    // åˆå§‹çŠ¶æ€?
    return null;
  }

  /// æ·»åŠ äº§å“
  Future<void> addProduct(ProductModel product) async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(productRepositoryProvider);
      await repository.addProduct(product);

      // åˆ·æ–°äº§å“åˆ—è¡¨
      ref.invalidate(allProductsProvider);
    });
  }

  /// æ›´æ–°äº§å“
  Future<void> updateProduct(ProductModel product) async {
    // æ£€æŸ¥äº§å“IDæ˜¯å¦ä¸ºç©º
    if (product.id == null || product.id! <= 0) {
      state = AsyncValue.error(Exception('äº§å“IDä¸èƒ½ä¸ºç©º'), StackTrace.current);
      return;
    }

    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(productRepositoryProvider);
      final success = await repository.updateProduct(product);

      if (!success) {
        throw Exception('æ›´æ–°äº§å“å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„äº§å“è®°å½?);
      }

      // åˆ·æ–°äº§å“åˆ—è¡¨
      ref.invalidate(allProductsProvider);
// ä½¿å¯¹åº”çš„ productByIdProvider æ— æ•ˆï¼Œä»¥ä¾¿è·å–æœ€æ–°æ•°æ?
      ref.invalidate(productByIdProvider(product.id!));
    });
  }

  /// åˆ é™¤äº§å“
  Future<void> deleteProduct(int productId) async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(productRepositoryProvider);
      await repository.deleteProduct(productId);

      // åˆ·æ–°äº§å“åˆ—è¡¨
      ref.invalidate(allProductsProvider);
    });
  }

  /// é‡ç½®çŠ¶æ€?
  void resetState() {
    state = const AsyncValue.data(null);
  }

  /// æ¸…é™¤é”™è¯¯çŠ¶æ€?
  void clearError() {
    if (state.hasError) {
      state = const AsyncValue.data(null);
    }
  }

  /// æ ¹æ®IDè·å–äº§å“
  Future<ProductModel?> getProductById(int productId) async {
    try {
      final repository = ref.read(productRepositoryProvider);
      return await repository.getProductById(productId);
    } catch (e) {
      state = AsyncValue.error(
        Exception('è·å–äº§å“å¤±è´¥: ${e.toString()}'),
        StackTrace.current,
      );
      return null;
    }
  }

  /// æ ¹æ®æ¡ç è·å–äº§å“
  Future<ProductModel?> getProductByBarcode(String barcode) async {
    try {
      final repository = ref.read(productRepositoryProvider);
      return await repository.getProductByBarcode(barcode);
    } catch (e) {
      state = AsyncValue.error(
        Exception('æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“å¤±è´¥: ${e.toString()}'),
        StackTrace.current,
      );
      return null;
    }
  }

  /// æ ¹æ®æ¡ç è·å–äº§å“åŠå…¶å•ä½ä¿¡æ¯
  Future<
    ({
      ProductModel product,
      int unitId,
      String unitName,
      int conversionRate,
      int? sellingPriceInCents,
      int? wholesalePriceInCents,
      int? averageUnitPriceInCents
    })?
  >
  getProductWithUnitByBarcode(String barcode) async {
    try {
      final repository = ref.read(productRepositoryProvider);
      final result = await repository.getProductWithUnitByBarcode(barcode);
      if (result == null) return null;
      return (
        product: result.product,
        unitId: result.unitId,
        unitName: result.unitName,
        conversionRate: result.conversionRate,
        sellingPriceInCents: result.sellingPriceInCents,
        wholesalePriceInCents: result.wholesalePriceInCents,
        averageUnitPriceInCents: result.averageUnitPriceInCents,
      );
    } catch (e, st) {
      state = AsyncValue.error(Exception('æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“åŠå•ä½å¤±è´? ${e.toString()}'), st);
      return null;
    }
  }
}

/// äº§å“åˆ—è¡¨ StreamNotifier
class ProductListNotifier extends StreamNotifier<List<ProductModel>> {
  @override
  Stream<List<ProductModel>> build() {
    final repository = ref.watch(productRepositoryProvider);
    return repository.watchAllProducts().map((products) {
      final sortedProducts = List.of(products);

      // æŒ?lastUpdated é™åºæ’åºï¼Œæœ€æ–°çš„äº§å“åœ¨æœ€å‰é¢
      sortedProducts.sort((a, b) {
        final aDate = a.lastUpdated;
        final bDate = b.lastUpdated;
        if (aDate == null && bDate == null) return 0;
        if (aDate == null) return 1;
        if (bDate == null) return -1;
        return bDate.compareTo(aDate);
      });

      // å¦‚æœåˆ—è¡¨é•¿åº¦å¤§äº3ï¼Œå°†æœ€æ–°çš„äº§å“ç§»åŠ¨åˆ°ç¬¬4ä½?
      if (sortedProducts.length > 3) {
        final latestProduct = sortedProducts.removeAt(0);
        sortedProducts.insert(3, latestProduct);
      }

      return sortedProducts;
    });
  }

  /// åˆ·æ–°äº§å“åˆ—è¡¨
  void refresh() {
    ref.invalidateSelf();
  }
}

/// é‡æ„åçš„ Providers
final productOperationsProvider =
    AsyncNotifierProvider<ProductOperationsNotifier, void>(() {
      return ProductOperationsNotifier();
    });

final productListStreamProvider =
    StreamNotifierProvider<ProductListNotifier, List<ProductModel>>(() {
      return ProductListNotifier();
    });

/// æ ¹æ®IDè·å–äº§å“
final productByIdProvider = FutureProvider.family<ProductModel?, int>((
  ref,
  productId,
) async {
  final repository = ref.watch(productRepositoryProvider);
  return repository.getProductById(productId);
});

/// æ ¹æ®æ¡ç è·å–äº§å“
final productByBarcodeProvider = FutureProvider.family<ProductModel?, String>((
  ref,
  barcode,
) async {
  final repository = ref.watch(productRepositoryProvider);
  return repository.getProductByBarcode(barcode);
});

/// ä¸ºäº†å…¼å®¹ç°æœ‰ä»£ç ï¼Œä¿ç•™åŸæœ‰çš„ provider åç§°
final allProductsProvider = productListStreamProvider;

/// ç”¨äºå­˜å‚¨å½“å‰é€‰ä¸­çš„åˆ†ç±»ID
final selectedCategoryIdProvider = StateProvider<int?>((ref) => null);

/// ç”¨äºå­˜å‚¨å½“å‰çš„æœç´¢å…³é”®å­—
final searchQueryProvider = StateProvider<String>((ref) => '');

/// æä¾›æ ¹æ®åˆ†ç±»ç­›é€‰å’Œå…³é”®å­—æœç´¢åçš„äº§å“åˆ—è¡?
final filteredProductsProvider = Provider<AsyncValue<List<ProductModel>>>((ref) {
  final selectedCategoryId = ref.watch(selectedCategoryIdProvider);
  final searchQuery = ref.watch(searchQueryProvider);
  final productsAsyncValue = ref.watch(allProductsProvider);
  final categoryListState = ref.watch(categoryListProvider);

  if (categoryListState.isLoading) {
    return const AsyncValue.loading();
  }

  if (categoryListState.error != null) {
    return AsyncValue.error(categoryListState.error!, StackTrace.current);
  }

  final allCategories = categoryListState.categories;

  return productsAsyncValue.when(
    data: (products) {
      var filteredList = products;

      // é»˜è®¤ç­›é€‰ï¼šå¦‚æœæœªé€‰æ‹©ä»»ä½•åˆ†ç±»ï¼Œåˆ™é»˜è®¤ä¸æ˜¾ç¤ºâ€œçƒŸâ€ç±»åˆ«åŠå…¶æ‰€æœ‰å­ç±»åˆ«
      if (selectedCategoryId == null) {
        // æŸ¥æ‰¾æ‰€æœ‰åä»£IDçš„è¾…åŠ©å‡½æ•?
        Set<int> getAllDescendantIds(
            int parentId, List<CategoryModel> categories) {
          final Set<int> descendantIds = {};
          final children =
              categories.where((c) => c.parentId == parentId).toList();
          for (final child in children) {
            if (child.id != null) {
              descendantIds.add(child.id!);
              descendantIds.addAll(
                  getAllDescendantIds(child.id!, categories));
            }
          }
          return descendantIds;
        }

        try {
          final tobaccoCategory =
              allCategories.firstWhere((c) => c.name == 'çƒ?);
          final idsToExclude = {tobaccoCategory.id!};
          if (tobaccoCategory.id != null) {
            idsToExclude.addAll(
                getAllDescendantIds(tobaccoCategory.id!, allCategories));
          }

          filteredList = filteredList
              .where((p) => !idsToExclude.contains(p.categoryId))
              .toList();
        } catch (e) {
          // æœªæ‰¾åˆ?"çƒ? ç±»åˆ«ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œ
        }
      }

      // æŒ‰åˆ†ç±»ç­›é€?
      if (selectedCategoryId != null) {
        filteredList = filteredList
            .where((p) => p.categoryId == selectedCategoryId)
            .toList();
      }

      // æŒ‰å…³é”®å­—æœç´¢
      if (searchQuery.isNotEmpty) {
        final lowerCaseQuery = searchQuery.toLowerCase();
        filteredList = filteredList
            .where((p) => p.name.toLowerCase().contains(lowerCaseQuery))
            .toList();
      }

      return AsyncValue.data(filteredList);
    },
    loading: () => const AsyncValue.loading(),
    error: (error, stack) => AsyncValue.error(error, stack),
  );
});

/// æä¾›æ‰€æœ‰äº§å“åŠå…¶å•ä½åç§°çš„æµ?
final allProductsWithUnitProvider =
    StreamProvider<
      List<
        ({
          ProductModel product,
          int unitId,
          String unitName,
          int conversionRate,
          int? sellingPriceInCents,
          int? wholesalePriceInCents
        })
      >
    >((ref) {
      final repository = ref.watch(productRepositoryProvider);
      return repository.watchAllProductsWithUnit().map((list) => list.map((e) => (
        product: e.product,
        unitId: e.unitId,
        unitName: e.unitName,
        conversionRate: e.conversionRate,
        sellingPriceInCents: e.sellingPriceInCents,
        wholesalePriceInCents: e.wholesalePriceInCents,
      )).toList());
    });
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/product_unit.dart';
import '../../domain/repository/i_product_unit_repository.dart';
import '../../data/repository/product_unit_repository.dart';

/// äº§å“å•ä½æ“ä½œçŠ¶æ€?
enum ProductUnitOperationStatus { initial, loading, success, error }

/// äº§å“å•ä½æ§åˆ¶å™¨çŠ¶æ€?
class ProductUnitControllerState {
  final ProductUnitOperationStatus status;
  final String? errorMessage;
  final List<UnitProduct>? lastOperatedProductUnits;

  const ProductUnitControllerState({
    this.status = ProductUnitOperationStatus.initial,
    this.errorMessage,
    this.lastOperatedProductUnits,
  });

  ProductUnitControllerState copyWith({
    ProductUnitOperationStatus? status,
    String? errorMessage,
    List<UnitProduct>? lastOperatedProductUnits,
  }) {
    return ProductUnitControllerState(
      status: status ?? this.status,
      errorMessage: errorMessage,
      lastOperatedProductUnits:
          lastOperatedProductUnits ?? this.lastOperatedProductUnits,
    );
  }

  bool get isLoading => status == ProductUnitOperationStatus.loading;
  bool get isError => status == ProductUnitOperationStatus.error;
  bool get isSuccess => status == ProductUnitOperationStatus.success;
}

/// äº§å“å•ä½æ§åˆ¶å™?- ç®¡ç†äº§å“å•ä½çš„å¢åˆ æ”¹æ“ä½œ
class ProductUnitController extends StateNotifier<ProductUnitControllerState> {
  final IProductUnitRepository _repository;
  final Ref _ref;

  ProductUnitController(this._repository, this._ref)
    : super(const ProductUnitControllerState());

  /// æ·»åŠ äº§å“å•ä½
  Future<void> addProductUnit(UnitProduct unitProduct) async {
    state = state.copyWith(status: ProductUnitOperationStatus.loading);

    try {
      await _repository.addProductUnit(unitProduct);
      state = state.copyWith(
        status: ProductUnitOperationStatus.success,
        lastOperatedProductUnits: [unitProduct],
        errorMessage: null,
      );

      // åˆ·æ–°ç›¸å…³çš„Provider
      _ref.invalidate(productUnitsProvider(unitProduct.productId));
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'æ·»åŠ äº§å“å•ä½å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ‰¹é‡æ·»åŠ äº§å“å•ä½
  Future<void> addMultipleProductUnits(List<UnitProduct> productUnits) async {
    if (productUnits.isEmpty) return;

    state = state.copyWith(status: ProductUnitOperationStatus.loading);

    try {
      await _repository.addMultipleProductUnits(productUnits);
      state = state.copyWith(
        status: ProductUnitOperationStatus.success,
        lastOperatedProductUnits: productUnits,
        errorMessage: null,
      );

      // åˆ·æ–°ç›¸å…³çš„Provider
      final productIds = productUnits.map((pu) => pu.productId).toSet();
      for (final productId in productIds) {
        _ref.invalidate(productUnitsProvider(productId));
      }
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'æ‰¹é‡æ·»åŠ äº§å“å•ä½å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ›´æ–°äº§å“å•ä½
  Future<void> updateProductUnit(UnitProduct unitProduct) async {
    state = state.copyWith(status: ProductUnitOperationStatus.loading);

    try {
      final success = await _repository.updateProductUnit(unitProduct);
      if (success) {
        state = state.copyWith(
          status: ProductUnitOperationStatus.success,
          lastOperatedProductUnits: [unitProduct],
          errorMessage: null,
        );

        // åˆ·æ–°ç›¸å…³çš„Provider
        _ref.invalidate(productUnitsProvider(unitProduct.productId));
      } else {
        state = state.copyWith(
          status: ProductUnitOperationStatus.error,
          errorMessage: 'æ›´æ–°äº§å“å•ä½å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„è®°å½?,
        );
      }
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'æ›´æ–°äº§å“å•ä½å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// åˆ é™¤äº§å“å•ä½
  Future<void> deleteProductUnit(int id, int productId) async {
    state = state.copyWith(status: ProductUnitOperationStatus.loading);

    try {
      final deletedCount = await _repository.deleteProductUnit(id);
      if (deletedCount > 0) {
        state = state.copyWith(
          status: ProductUnitOperationStatus.success,
          errorMessage: null,
        );

        // åˆ·æ–°ç›¸å…³çš„Provider
        _ref.invalidate(productUnitsProvider(productId));
      } else {
        state = state.copyWith(
          status: ProductUnitOperationStatus.error,
          errorMessage: 'åˆ é™¤äº§å“å•ä½å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„è®°å½?,
        );
      }
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'åˆ é™¤äº§å“å•ä½å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// æ›¿æ¢äº§å“çš„æ‰€æœ‰å•ä½é…ç½?
  Future<void> replaceProductUnits(
    int productId,
    List<UnitProduct> productUnits,
  ) async {
    print('ğŸ¯ ProductUnitController.replaceProductUnits - å¼€å§‹æ›¿æ¢äº§å“å•ä½é…ç½?);
    print('ğŸ¯ äº§å“ID: $productId');
    print('ğŸ¯ å•ä½æ•°é‡: ${productUnits.length}');
    for (int i = 0; i < productUnits.length; i++) {
      final unit = productUnits[i];
      print('ğŸ¯   [$i] å•ä½ID: ${unit.unitId}, æ¢ç®—ç? ${unit.conversionRate}');
    }
    
    state = state.copyWith(status: ProductUnitOperationStatus.loading);

    try {
      print('ğŸ’¾ è°ƒç”¨ä»“å‚¨å±‚æ›¿æ¢æ–¹æ³?..');
      await _repository.replaceProductUnits(productId, productUnits);
      print('âœ?ä»“å‚¨å±‚æ›¿æ¢æˆåŠ?);
      
      state = state.copyWith(
        status: ProductUnitOperationStatus.success,
        lastOperatedProductUnits: productUnits,
        errorMessage: null,
      );

      // åˆ·æ–°ç›¸å…³çš„Provider
      print('ğŸ”„ åˆ·æ–°äº§å“å•ä½åˆ—è¡¨...');
      _ref.invalidate(productUnitsProvider(productId));
      print('âœ?ProductUnitController.replaceProductUnits - æ›¿æ¢äº§å“å•ä½é…ç½®å®Œæˆ');
    } catch (e) {
      print('â?ProductUnitController.replaceProductUnits - æ›¿æ¢å¤±è´¥: $e');
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'æ›¿æ¢äº§å“å•ä½é…ç½®å¤±è´¥: ${e.toString()}',
      );
      rethrow;
    }
  }

  /// æ ¹æ®äº§å“IDè·å–äº§å“å•ä½
  Future<List<UnitProduct>> getProductUnitsByProductId(int productId) async {
    try {
      return await _repository.getProductUnitsByProductId(productId);
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'è·å–äº§å“å•ä½å¤±è´¥: ${e.toString()}',
      );
      return [];
    }
  }

  /// è·å–äº§å“çš„åŸºç¡€å•ä½
  Future<UnitProduct?> getBaseUnitForProduct(int productId) async {
    try {
      return await _repository.getBaseUnitForProduct(productId);
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'è·å–äº§å“åŸºç¡€å•ä½å¤±è´¥: ${e.toString()}',
      );
      return null;
    }
  }

  /// æ£€æŸ¥äº§å“æ˜¯å¦å·²é…ç½®æŸä¸ªå•ä½
  Future<bool> isUnitConfiguredForProduct(
    int productId,
    int unitId,
  ) async {
    try {
      return await _repository.isUnitConfiguredForProduct(productId, unitId);
    } catch (e) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.error,
        errorMessage: 'æ£€æŸ¥äº§å“å•ä½é…ç½®å¤±è´? ${e.toString()}',
      );
      return false;
    }
  }

  /// é‡ç½®çŠ¶æ€?
  void resetState() {
    state = const ProductUnitControllerState();
  }

  /// æ¸…é™¤é”™è¯¯çŠ¶æ€?
  void clearError() {
    if (state.isError) {
      state = state.copyWith(
        status: ProductUnitOperationStatus.initial,
        errorMessage: null,
      );
    }
  }
}

/// æ ¹æ®äº§å“IDè·å–äº§å“å•ä½åˆ—è¡¨çš„StreamProvider
final productUnitsProvider = StreamProvider.family<List<UnitProduct>, int>((
  ref,
  productId,
) {
  final repository = ref.watch(productUnitRepositoryProvider);
  return repository.watchProductUnitsByProductId(productId);
});

/// äº§å“å•ä½æ§åˆ¶å™¨Provider
final productUnitControllerProvider =
    StateNotifierProvider<ProductUnitController, ProductUnitControllerState>((
      ref,
    ) {
      final repository = ref.watch(productUnitRepositoryProvider);
      return ProductUnitController(repository, ref);
    });

/// æ ¹æ®äº§å“IDè·å–åŸºç¡€å•ä½çš„FutureProvider
final baseUnitProvider = FutureProvider.family<UnitProduct?, int>((
  ref,
  productId,
) {
  final repository = ref.watch(productUnitRepositoryProvider);
  return repository.getBaseUnitForProduct(productId);
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/auxiliary_unit_data.dart';

/// å•ä½ç¼–è¾‘é¡µé¢è¾…å•ä½æ•°æ®çŠ¶æ€?
class UnitEditFormState {
  /// è¾…å•ä½æ•°æ®åˆ—è¡?
  final List<AuxiliaryUnitData> auxiliaryUnits;

  /// è¾…å•ä½è®¡æ•°å™¨
  final int auxiliaryCounter;

  const UnitEditFormState({
    this.auxiliaryUnits = const [],
    this.auxiliaryCounter = 1,
  });

  UnitEditFormState copyWith({
    List<AuxiliaryUnitData>? auxiliaryUnits,
    int? auxiliaryCounter,
  }) {
    return UnitEditFormState(
      auxiliaryUnits: auxiliaryUnits ?? this.auxiliaryUnits,
      auxiliaryCounter: auxiliaryCounter ?? this.auxiliaryCounter,
    );
  }

  /// è·å–æŒ‡å®šIDçš„è¾…å•ä½æ•°æ®
  AuxiliaryUnitData? getAuxiliaryUnit(int id) {
    try {
      return auxiliaryUnits.firstWhere((unit) => unit.id == id);
    } catch (e) {
      return null;
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is UnitEditFormState &&
        _listEquals(other.auxiliaryUnits, auxiliaryUnits) &&
        other.auxiliaryCounter == auxiliaryCounter;
  }

  @override
  int get hashCode {
    return Object.hash(Object.hashAll(auxiliaryUnits), auxiliaryCounter);
  }

  /// æ¯”è¾ƒä¸¤ä¸ªåˆ—è¡¨æ˜¯å¦ç›¸ç­‰
  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

/// å•ä½ç¼–è¾‘é¡µé¢è¡¨å•çŠ¶æ€ç®¡ç†å™¨
class UnitEditFormNotifier extends Notifier<UnitEditFormState> {
  @override
  UnitEditFormState build() {
    return const UnitEditFormState();
  }

  /// æ·»åŠ æ–°çš„è¾…å•ä½?
  void addAuxiliaryUnit() {
    final newUnit = AuxiliaryUnitData.empty(state.auxiliaryCounter);
    final updatedUnits = [...state.auxiliaryUnits, newUnit];
    state = state.copyWith(
      auxiliaryUnits: updatedUnits,
      auxiliaryCounter: state.auxiliaryCounter + 1,
    );
  }

  /// åˆ é™¤æŒ‡å®šIDçš„è¾…å•ä½
  void removeAuxiliaryUnit(int id) {
    final updatedUnits = state.auxiliaryUnits
        .where((unit) => unit.id != id)
        .toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ›´æ–°è¾…å•ä½çš„å•ä½åç§°
  void updateAuxiliaryUnitName(int id, String unitName, {int? unitId}) {
    final updatedUnits = state.auxiliaryUnits.map((unit) {
      if (unit.id == id) {
        return unit.copyWith(unitName: unitName, unitId: unitId);
      }
      return unit;
    }).toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ›´æ–°è¾…å•ä½çš„æ¢ç®—ç?
  void updateAuxiliaryUnitConversionRate(int id, int conversionRate) {
    final updatedUnits = state.auxiliaryUnits.map((unit) {
      if (unit.id == id) {
        return unit.copyWith(conversionRate: conversionRate);
      }
      return unit;
    }).toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ›´æ–°è¾…å•ä½çš„æ¡ç 
  void updateAuxiliaryUnitBarcode(int id, String barcode) {
    final updatedUnits = state.auxiliaryUnits.map((unit) {
      if (unit.id == id) {
        return unit.copyWith(barcode: barcode);
      }
      return unit;
    }).toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ›´æ–°è¾…å•ä½çš„å»ºè®®é›¶å”®ä»?
  void updateAuxiliaryUnitRetailPrice(int id, String retailPriceInYuan) {
    // å°†å…ƒè½¬æ¢ä¸ºåˆ†å­˜å‚¨
    String retailPriceInCents = '';
    if (retailPriceInYuan.trim().isNotEmpty) {
      final priceInYuan = double.tryParse(retailPriceInYuan.trim());
      if (priceInYuan != null) {
        retailPriceInCents = (priceInYuan * 100).round().toString();
      }
    }
    
    final updatedUnits = state.auxiliaryUnits.map((unit) {
      if (unit.id == id) {
        return unit.copyWith(retailPriceInCents: retailPriceInCents);
      }
      return unit;
    }).toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ›´æ–°è¾…å•ä½çš„æ‰¹å‘ä»?
  void updateAuxiliaryUnitWholesalePrice(int id, String wholesalePriceInYuan) {
    // å°†å…ƒè½¬æ¢ä¸ºåˆ†å­˜å‚¨
    String wholesalePriceInCents = '';
    if (wholesalePriceInYuan.trim().isNotEmpty) {
      final priceInYuan = double.tryParse(wholesalePriceInYuan.trim());
      if (priceInYuan != null) {
        wholesalePriceInCents = (priceInYuan * 100).round().toString();
      }
    }
    
    final updatedUnits = state.auxiliaryUnits.map((unit) {
      if (unit.id == id) {
        return unit.copyWith(wholesalePriceInCents: wholesalePriceInCents);
      }
      return unit;
    }).toList();
    state = state.copyWith(auxiliaryUnits: updatedUnits);
  }

  /// æ‰¹é‡è®¾ç½®è¾…å•ä½æ•°æ®ï¼ˆç”¨äºåˆå§‹åŒ–ï¼‰
  void setAuxiliaryUnits(List<AuxiliaryUnitData> units, {int? counter}) {
    state = state.copyWith(
      auxiliaryUnits: units,
      auxiliaryCounter: counter ?? state.auxiliaryCounter,
    );
  }

  /// é‡ç½®å•ä½ç¼–è¾‘è¡¨å•
  void resetUnitEditForm() {
    state = const UnitEditFormState();
  }

  /// æ¸…é™¤è¾…å•ä½æ•°æ®ï¼Œä¿ç•™åŸºæœ¬å•ä½
  void clearAuxiliaryUnits() {
    state = state.copyWith(auxiliaryUnits: [], auxiliaryCounter: 1);
  }

  /// ä»ç°æœ‰çš„_AuxiliaryUnitåˆ—è¡¨åˆå§‹åŒ–æ•°æ?
  void initializeFromExisting(List<dynamic> existingUnits, int counter) {
    final auxiliaryUnits = <AuxiliaryUnitData>[];

    for (final unit in existingUnits) {
      if (unit is Map<String, dynamic>) {
        // ä»Mapåˆå§‹åŒ?
        auxiliaryUnits.add(AuxiliaryUnitData.fromJson(unit));
      } else {
        // ä»ç°æœ‰çš„_AuxiliaryUnitå¯¹è±¡åˆå§‹åŒ?
        final auxUnit = unit as dynamic;
        
        // å°†å…ƒè½¬æ¢ä¸ºåˆ†
        String retailPriceInCents = '';
        final retailPriceText = auxUnit.retailPriceController?.text as String? ?? '';
        if (retailPriceText.trim().isNotEmpty) {
          final priceInYuan = double.tryParse(retailPriceText.trim());
          if (priceInYuan != null) {
            retailPriceInCents = (priceInYuan * 100).round().toString();
          }
        }
        
        String wholesalePriceInCents = '';
        final wholesalePriceText = auxUnit.wholesalePriceController?.text as String? ?? '';
        if (wholesalePriceText.trim().isNotEmpty) {
          final priceInYuan = double.tryParse(wholesalePriceText.trim());
          if (priceInYuan != null) {
            wholesalePriceInCents = (priceInYuan * 100).round().toString();
          }
        }
        
        auxiliaryUnits.add(
          AuxiliaryUnitData(
            id: auxUnit.id as int,
            unitId: auxUnit.unit?.id as int?,
            unitName: auxUnit.unitController?.text as String? ?? '',
            conversionRate: auxUnit.conversionRate ?? 0,
            barcode: auxUnit.barcodeController?.text as String? ?? '',
            retailPriceInCents: retailPriceInCents,
            wholesalePriceInCents: wholesalePriceInCents,
          ),
        );
      }
    }

    state = UnitEditFormState(
      auxiliaryUnits: auxiliaryUnits,
      auxiliaryCounter: counter,
    );
  }
}

/// å•ä½ç¼–è¾‘é¡µé¢è¡¨å•çŠ¶æ€æä¾›è€…ï¼ˆä¿ç•™çŠ¶æ€ï¼Œçˆ¶é¡µç»“æŸæ—¶æ‰‹åŠ¨æ¸…ç†ï¼‰
final unitEditFormProvider =
    NotifierProvider<UnitEditFormNotifier, UnitEditFormState>(() {
      return UnitEditFormNotifier();
    });
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/unit.dart';
import '../../domain/repository/i_unit_repository.dart';
import '../../data/repository/unit_repository.dart';
import '../../domain/repository/i_product_repository.dart';
import '../../data/repository/product_repository.dart';

/// å•ä½æ“ä½œçŠ¶æ€?
enum UnitOperationStatus { initial, loading, success, error }

/// å•ä½æ§åˆ¶å™¨çŠ¶æ€?
class UnitControllerState {
  final UnitOperationStatus status;
  final String? errorMessage;
  final Unit? lastOperatedUnit;

  const UnitControllerState({
    this.status = UnitOperationStatus.initial,
    this.errorMessage,
    this.lastOperatedUnit,
  });

  UnitControllerState copyWith({
    UnitOperationStatus? status,
    String? errorMessage,
    Unit? lastOperatedUnit,
  }) {
    return UnitControllerState(
      status: status ?? this.status,
      errorMessage: errorMessage,
      lastOperatedUnit: lastOperatedUnit ?? this.lastOperatedUnit,
    );
  }

  bool get isLoading => status == UnitOperationStatus.loading;
  bool get isError => status == UnitOperationStatus.error;
  bool get isSuccess => status == UnitOperationStatus.success;
}

/// å•ä½æ§åˆ¶å™?- ç®¡ç†å•ä½çš„å¢åˆ æ”¹æ“ä½œ
class UnitController extends StateNotifier<UnitControllerState> {
  final IUnitRepository _repository;
  final IProductRepository _productRepository;
  final Ref _ref;

  UnitController(this._repository, this._productRepository, this._ref)
      : super(const UnitControllerState());

  /// æ·»åŠ å•ä½
  Future<Unit> addUnit(Unit unit) async {
    print('ğŸ¯ UnitController.addUnit - å¼€å§‹æ·»åŠ å•ä½? ID=${unit.id}, åç§°="${unit.name}"');
    state = state.copyWith(status: UnitOperationStatus.loading);

    try {
      // æ£€æŸ¥å•ä½åç§°æ˜¯å¦ä¸ºç©?
      if (unit.name.trim().isEmpty) {
        print('â?å•ä½åç§°ä¸ºç©º');
        throw Exception('å•ä½åç§°ä¸èƒ½ä¸ºç©º');
      }

      // æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨
      print('ğŸ” æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨: "${unit.name.trim()}"');
      final existingUnit = await _repository.getUnitByName(unit.name.trim());
      if (existingUnit != null) {
        print('â?å•ä½åç§°å·²å­˜åœ? ${existingUnit.id}');
        throw Exception('å•ä½åç§°å·²å­˜åœ?);
      }
      print('âœ?å•ä½åç§°æ£€æŸ¥é€šè¿‡');

      print('ğŸ’¾ è°ƒç”¨ä»“å‚¨å±‚æ·»åŠ å•ä½?..');
      final newUnit = await _repository.addUnit(unit);
      print('âœ?ä»“å‚¨å±‚æ·»åŠ å•ä½æˆåŠ? æ–°ID: ${newUnit.id}');
      
      state = state.copyWith(
        status: UnitOperationStatus.success,
        lastOperatedUnit: newUnit,
        errorMessage: null,
      );

      // åˆ·æ–°å•ä½åˆ—è¡¨ - Streamä¼šè‡ªåŠ¨æ›´æ–°ï¼Œæ‰€ä»¥invalidateä¸æ˜¯å¿…é¡»çš„ï¼Œ
      // ä½†ä¸ºäº†ç¡®ä¿ä¾èµ–æ­¤providerçš„æ—§ä»£ç èƒ½ç«‹å³ååº”ï¼Œå¯ä»¥ä¿ç•™ã€?
      // ä¸è¿‡ï¼Œç”±äºæˆ‘ä»¬è¿”å›äº†æ–°å¯¹è±¡ï¼Œè°ƒç”¨æ–¹åº”ä¼˜å…ˆä½¿ç”¨è¿”å›å€¼ã€?
      print('ğŸ”„ åˆ·æ–°å•ä½åˆ—è¡¨...');
      _ref.invalidate(allUnitsProvider);
      print('âœ?UnitController.addUnit - æ·»åŠ å•ä½å®Œæˆ');
      return newUnit;
    } catch (e) {
      print('â?UnitController.addUnit - æ·»åŠ å•ä½å¤±è´¥: $e');
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: 'æ·»åŠ å•ä½å¤±è´¥: ${e.toString()}',
      );
      rethrow; // é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œè®©è°ƒç”¨æ–¹å¯ä»¥å¤„ç?
    }
  }

  // updateUnit æ–¹æ³•å·²ä¸å†éœ€è¦ï¼Œå› ä¸ºç¼–è¾‘åŠŸèƒ½è¢«ç§»é™¤äº†ã€?

  /// åˆ é™¤å•ä½
  Future<void> deleteUnit(int unitId) async {
    state = state.copyWith(status: UnitOperationStatus.loading);
    try {
      // ä¾èµ–æ£€æŸ?
      final isUsed = await _productRepository.isUnitUsed(unitId);
      if (isUsed) {
        throw Exception('æ— æ³•åˆ é™¤ï¼šè¯¥å•ä½å·²è¢«ä¸€ä¸ªæˆ–å¤šä¸ªå•†å“ä½¿ç”¨');
      }

      final deletedCount = await _repository.deleteUnit(unitId);

      if (deletedCount > 0) {
        state = state.copyWith(
          status: UnitOperationStatus.success,
          errorMessage: null,
        );
        _ref.invalidate(allUnitsProvider);
      } else {
        throw Exception('åˆ é™¤å•ä½å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„å•ä½è®°å½?);
      }
    } catch (e) {
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: e.toString(),
      );
      // è®©UIå±‚èƒ½æ•è·åˆ°è¯¦ç»†é”™è¯?
      rethrow;
    }
  }

  /// æ ¹æ®IDè·å–å•ä½
  Future<Unit?> getUnitById(int unitId) async {
    try {
      return await _repository.getUnitById(unitId);
    } catch (e) {
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: 'è·å–å•ä½å¤±è´¥: ${e.toString()}',
      );
      return null;
    }
  }

  /// æ ¹æ®åç§°è·å–å•ä½
  Future<Unit?> getUnitByName(String name) async {
    try {
      return await _repository.getUnitByName(name);
    } catch (e) {
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: 'æ ¹æ®åç§°è·å–å•ä½å¤±è´¥: ${e.toString()}',
      );
      return null;
    }
  }

  /// æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨
  Future<bool> isUnitNameExists(String name, [int? excludeId]) async {
    try {
      return await _repository.isUnitNameExists(name, excludeId);
    } catch (e) {
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: 'æ£€æŸ¥å•ä½åç§°å¤±è´? ${e.toString()}',
      );
      return false;
    }
  }

  /// æ’å…¥é»˜è®¤å•ä½
  Future<void> insertDefaultUnits() async {
    state = state.copyWith(status: UnitOperationStatus.loading);

    try {
      await _repository.insertDefaultUnits();
      state = state.copyWith(
        status: UnitOperationStatus.success,
        errorMessage: null,
      );

      // åˆ·æ–°å•ä½åˆ—è¡¨
      _ref.invalidate(allUnitsProvider);
    } catch (e) {
      state = state.copyWith(
        status: UnitOperationStatus.error,
        errorMessage: 'æ’å…¥é»˜è®¤å•ä½å¤±è´¥: ${e.toString()}',
      );
    }
  }

  /// é‡ç½®çŠ¶æ€?
  void resetState() {
    state = const UnitControllerState();
  }

  /// æ¸…é™¤é”™è¯¯çŠ¶æ€?
  void clearError() {
    if (state.isError) {
      state = state.copyWith(
        status: UnitOperationStatus.initial,
        errorMessage: null,
      );
    }
  }
}

/// æ‰€æœ‰å•ä½åˆ—è¡¨çš„StreamProvider
/// ç›‘å¬å•ä½æ•°æ®çš„å®æ—¶å˜åŒ–ï¼Œå½“æ•°æ®åº“ä¸­çš„å•ä½å‘ç”Ÿå˜åŒ–æ—¶ä¼šè‡ªåŠ¨æ›´æ–°UI
final allUnitsProvider = StreamProvider<List<Unit>>((ref) {
  final repository = ref.watch(unitRepositoryProvider);
  return repository.watchAllUnits().asBroadcastStream();
});

/// å•ä½æ§åˆ¶å™¨Provider
/// ç®¡ç†å•ä½çš„å¢åˆ æ”¹æ“ä½œçŠ¶æ€?
final unitControllerProvider =
    StateNotifierProvider<UnitController, UnitControllerState>((ref) {
      final repository = ref.watch(unitRepositoryProvider);
      final productRepository = ref.watch(productRepositoryProvider);
      return UnitController(repository, productRepository, ref);
    });
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/barcodes_table.dart';

part 'barcode_dao.g.dart';

/// æ¡ç æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
/// ä¸“é—¨è´Ÿè´£æ¡ç ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [Barcode])
class BarcodeDao extends DatabaseAccessor<AppDatabase> with _$BarcodeDaoMixin {
  BarcodeDao(super.db);

  /// æ·»åŠ æ¡ç 
  Future<int> insertBarcode(BarcodeCompanion companion) async {
    return await into(db.barcode).insert(companion);
  }

  /// æ‰¹é‡æ·»åŠ æ¡ç 
  Future<void> insertMultipleBarcodes(
    List<BarcodeCompanion> companions,
  ) async {
    await batch((batch) {
      batch.insertAll(db.barcode, companions);
    });
  }

  /// æ ¹æ®IDè·å–æ¡ç 
  Future<BarcodeData?> getBarcodeById(int id) async {
    return await (select(
      db.barcode,
    )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®æ¡ç å€¼è·å–æ¡ç ä¿¡æ?
  Future<BarcodeData?> getBarcodeByValue(String barcode) async {
    return await (select(
      db.barcode,
    )..where((tbl) => tbl.barcodeValue.equals(barcode))).getSingleOrNull();
  }

  /// æ ¹æ®äº§å“å•ä½IDè·å–æ‰€æœ‰æ¡ç ?
  Future<List<BarcodeData>> getBarcodesByProductUnitId(
    int id,
  ) async {
    return await (select(
      db.barcode,
    )..where((tbl) => tbl.unitProductId.equals(id))).get();
  }

  /// è·å–æ‰€æœ‰æ¡ç ?
  Future<List<BarcodeData>> getAllBarcodes() async {
    return await select(db.barcode).get();
  }

  /// ç›‘å¬äº§å“å•ä½çš„æ¡ç å˜åŒ?
  Stream<List<BarcodeData>> watchBarcodesByProductUnitId(
    int id,
  ) {
    return (select(
      db.barcode,
    )..where((tbl) => tbl.unitProductId.equals(id))).watch();
  }

  /// æ›´æ–°æ¡ç 
  Future<bool> updateBarcode(BarcodeCompanion companion) async {
    final rowsAffected = await (update(
      db.barcode,
    )..where((tbl) => tbl.id.equals(companion.id.value))).write(companion);
    return rowsAffected > 0;
  }

  /// åˆ é™¤æ¡ç 
  Future<int> deleteBarcode(int id) async {
    return await (delete(
      db.barcode,
    )..where((tbl) => tbl.id.equals(id))).go();
  }

  /// åˆ é™¤äº§å“å•ä½çš„æ‰€æœ‰æ¡ç ?
  Future<int> deleteBarcodesByProductUnitId(int id) async {
    return await (delete(
      db.barcode,
    )..where((tbl) => tbl.unitProductId.equals(id))).go();
  }

  /// æ£€æŸ¥æ¡ç æ˜¯å¦å·²å­˜åœ¨
  Future<bool> barcodeExists(String barcode) async {
    final result =
        await (select(db.barcode)
              ..where((tbl) => tbl.barcodeValue.equals(barcode))
              ..limit(1))
            .get();
    return result.isNotEmpty;
  }

  /// æ£€æŸ¥äº§å“å•ä½æ˜¯å¦å·²æœ‰è¯¥æ¡ç 
  Future<bool> productUnitHasBarcode(
    int id,
    String barcode,
  ) async {
    final result =
        await (select(db.barcode)
              ..where(
                (tbl) =>
                    tbl.unitProductId.equals(id) &
                    tbl.barcodeValue.equals(barcode),
              )
              ..limit(1))
            .get();
    return result.isNotEmpty;
  }

  /// æ›´æ–°æˆ–æ’å…¥æ¡ç ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ›´æ–°ï¼Œå¦åˆ™æ’å…¥ï¼?
  Future<void> upsertBarcode(BarcodeCompanion companion) async {
    await into(db.barcode).insertOnConflictUpdate(companion);
  }

  /// æ‰¹é‡æ›´æ–°æˆ–æ’å…¥æ¡ç ?
  Future<void> upsertMultipleBarcodes(
    List<BarcodeCompanion> companions,
  ) async {
    await batch((batch) {
      for (final companion in companions) {
        batch.insert(
          db.barcode,
          companion,
          onConflict: DoUpdate((_) => companion),
        );
      }
    });
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'barcode_dao.dart';

// ignore_for_file: type=lint
mixin _$BarcodeDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $UnitProductTable get unitProduct => attachedDatabase.unitProduct;
  $BarcodeTable get barcode => attachedDatabase.barcode;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/batches_table.dart';

part 'batch_dao.g.dart';

/// æ‰¹æ¬¡æ•°æ®è®¿é—®å¯¹è±¡
/// è´Ÿè´£å¤„ç†æ‰¹æ¬¡è¡¨çš„æ•°æ®åº“æ“ä½?
@DriftAccessor(tables: [ProductBatch])
class BatchDao extends DatabaseAccessor<AppDatabase> with _$BatchDaoMixin {
  BatchDao(super.db);

  /// åˆ›å»ºæ–°æ‰¹æ¬?
  Future<void> createBatch({
    required int productId,
    required DateTime productionDate,
    required int totalInboundQuantity,
    required int shopId,
  }) async {
    await into(db.productBatch).insert(
      ProductBatchCompanion.insert(
        productId: productId,
        productionDate: productionDate,
        totalInboundQuantity: totalInboundQuantity,
        shopId: shopId,
      ),
    );
  }

  /// ä½¿ç”¨ ON CONFLICT DO UPDATE åœ¨å”¯ä¸€é”®å†²çªæ—¶ç´¯åŠ æ•°é‡
  /// è‹?(productId, productionDate, shopId) å·²å­˜åœ¨ï¼Œåˆ?total_inbound_quantity += increment å¹¶åˆ·æ–?updated_at
  Future<void> upsertBatchIncrement({
    required int productId,
    required DateTime productionDate,
    required int shopId,
    required int increment,
  }) async {
    // å¯é€‰ï¼šå°†æ—¶é—´æ ‡å‡†åŒ–ä¸ºæ—¥æœŸç²’åº¦ï¼ˆä¸å”¯ä¸€é”®è¯­ä¹‰ä¸€è‡´ï¼‰ã€?
    final d = productionDate.toUtc();
    final dateOnly = DateTime.utc(d.year, d.month, d.day);
    final now = DateTime.now();

    await db.customInsert(
      'INSERT INTO product_batch (product_id, production_date, total_inbound_quantity, shop_id, created_at, updated_at) '
      'VALUES (?1, ?2, ?3, ?4, ?5, ?6) '
      'ON CONFLICT(product_id, production_date, shop_id) DO UPDATE SET '
      'total_inbound_quantity = product_batch.total_inbound_quantity + excluded.total_inbound_quantity, '
      // å…³é”®ä¿®å¤ï¼šé¿å…ä½¿ç”?CURRENT_TIMESTAMPï¼ˆTEXTï¼‰ï¼Œç»‘å®š DateTimeï¼ŒåŒ¹é…?Drift çš„æ•´æ•°å­˜å‚¨ã€?
      'updated_at = ?6',
      variables: [
        Variable(productId),
        Variable(dateOnly),
        Variable(increment),
        Variable(shopId),
        Variable(now), // created_at
        Variable(now), // updated_at
      ],
      updates: {db.productBatch},
    );
  }

  /// é€šè¿‡ (productId, productionDate, shopId) æŸ¥è¯¢æ‰¹æ¬¡
  Future<ProductBatchData?> getBatchByBusinessKey({
    required int productId,
    required DateTime productionDate,
    required int shopId,
  }) {
    final d = productionDate.toUtc();
    final dateOnly = DateTime.utc(d.year, d.month, d.day);
    final q = select(db.productBatch)
      ..where((t) => t.productId.equals(productId) &
          t.productionDate.equals(dateOnly) &
          t.shopId.equals(shopId));
    return q.getSingleOrNull();
  }

  /// ä»…è¿”å›æ‰¹æ¬?idï¼Œé¿å…æ˜ å°?DateTime åˆ—ï¼ˆå…¼å®¹æ—§æ•°æ?TEXT æ—¶é—´å­˜å‚¨ï¼?
  Future<int?> getBatchIdByBusinessKey({
    required int productId,
    required DateTime productionDate,
    required int shopId,
  }) async {
    final d = productionDate.toUtc();
    final dateOnly = DateTime.utc(d.year, d.month, d.day);
    final query = selectOnly(db.productBatch)
      ..addColumns([db.productBatch.id])
      ..where(db.productBatch.productId.equals(productId) &
          db.productBatch.productionDate.equals(dateOnly) &
          db.productBatch.shopId.equals(shopId));
    final row = await query.getSingleOrNull();
    return row?.read(db.productBatch.id);
  }

  /// è·å–æ‰€æœ‰æ‰¹æ¬?
  Future<List<ProductBatchData>> getAllBatches() {
    return select(db.productBatch).get();
  }

  /// æ ¹æ®åº—é“ºIDè·å–æ‰¹æ¬¡
  Future<List<ProductBatchData>> getBatchesByShop(int shopId) {
    return (select(db.productBatch)..where((t) => t.shopId.equals(shopId))).get();
  }

  /// æ ¹æ®æ‰¹æ¬¡å·è·å–æ‰¹æ¬?
  Future<ProductBatchData?> getBatchByNumber(int id) async {
    try {
      return await (select(
        db.productBatch,
      )..where((t) => t.id.equals(id))).getSingleOrNull();
    } catch (e) {
      print('è·å–æ‰¹æ¬¡æ•°æ®å¤±è´¥ (ID: $id): $e');
      return null;
    }
  }

  /// æ›´æ–°æ‰¹æ¬¡åˆå§‹æ•°é‡
  /// ç”¨äºåŒä¸€æ‰¹æ¬¡å¤šæ¬¡å…¥åº“æ—¶çš„æ•°é‡ç´¯åŠ 
  Future<void> updateBatchQuantity(
    int id,
    int newInitialQuantity,
  ) {
    return (update(
      db.productBatch,
    )..where((t) => t.id.equals(id))).write(
      ProductBatchCompanion(totalInboundQuantity: Value(newInitialQuantity)),
    );
  }

  /// åˆ é™¤æ‰¹æ¬¡
  Future<void> deleteBatch(int id) {
    return (delete(
      db.productBatch,
    )..where((t) => t.id.equals(id))).go();
  }

  /// æ ¹æ®è´§å“IDè·å–æ‰¹æ¬¡
  Future<List<ProductBatchData>> getBatchesByProduct(int productId) {
    return (select(
      db.productBatch,
    )..where((t) => t.productId.equals(productId))).get();
  }
/// æ ¹æ®è´§å“IDå’Œåº—é“ºIDè·å–æ‰¹æ¬¡
  Future<List<ProductBatchData>> getBatchesByProductAndShop(int productId, int shopId) {
    return (select(db.productBatch)
          ..where((t) => t.productId.equals(productId) & t.shopId.equals(shopId)))
        .get();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'batch_dao.dart';

// ignore_for_file: type=lint
mixin _$BatchDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ShopTable get shop => attachedDatabase.shop;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/categories_table.dart';

part 'category_dao.g.dart';

/// ç±»åˆ«æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
/// ä¸“é—¨è´Ÿè´£ç±»åˆ«ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [Category])
class CategoryDao extends DatabaseAccessor<AppDatabase>
    with _$CategoryDaoMixin {
  CategoryDao(super.db);

  /// æ·»åŠ ç±»åˆ«
  Future<int> insertCategory(CategoryCompanion companion) async {
    return await into(db.category).insert(companion);
  }

  /// æ ¹æ®IDè·å–ç±»åˆ«
  Future<CategoryData?> getCategoryById(int id) async {
    return await (select(
      db.category,
    )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰ç±»åˆ?
  Future<List<CategoryData>> getAllCategories() async {
    return await select(db.category).get();
  }

  /// ç›‘å¬æ‰€æœ‰ç±»åˆ«å˜åŒ?
  Stream<List<CategoryData>> watchAllCategories() {
    return select(db.category).watch();
  }

  /// æ ¹æ®çˆ¶ç±»åˆ«IDè·å–å­ç±»åˆ?
  Future<List<CategoryData>> getCategoriesByParentId(
    int? parentId,
  ) async {
    if (parentId == null) {
      // è·å–æ ¹ç±»åˆ«ï¼ˆæ²¡æœ‰çˆ¶ç±»åˆ«çš„ç±»åˆ«ï¼?
      return await (select(
        db.category,
      )..where((tbl) => tbl.parentId.isNull())).get();
    } else {
      // è·å–æŒ‡å®šçˆ¶ç±»åˆ«çš„å­ç±»åˆ?
      return await (select(
        db.category,
      )..where((tbl) => tbl.parentId.equals(parentId))).get();
    }
  }

  /// ç›‘å¬æ ¹ç±»åˆ«å˜åŒ–ï¼ˆæ²¡æœ‰çˆ¶ç±»åˆ«çš„ç±»åˆ«ï¼?
  Stream<List<CategoryData>> watchRootCategories() {
    return (select(
      db.category,
    )..where((tbl) => tbl.parentId.isNull())).watch();
  }

  /// ç›‘å¬æŒ‡å®šçˆ¶ç±»åˆ«çš„å­ç±»åˆ«å˜åŒ?
  Stream<List<CategoryData>> watchCategoriesByParentId(int parentId) {
    return (select(
      db.category,
    )..where((tbl) => tbl.parentId.equals(parentId))).watch();
  }

  /// æ›´æ–°ç±»åˆ«
  Future<bool> updateCategory(CategoryCompanion companion) async {
    final result = await update(db.category).replace(companion);
    return result;
  }

  /// åˆ é™¤ç±»åˆ«
  Future<int> deleteCategory(int id) async {
    return await (delete(
      db.category,
    )..where((tbl) => tbl.id.equals(id))).go();
  }

  /// æ£€æŸ¥ç±»åˆ«æ˜¯å¦æœ‰å­ç±»åˆ?
  Future<bool> hasSubCategories(int categoryId) async {
    final count = await (select(
      db.category,
    )..where((tbl) => tbl.parentId.equals(categoryId))).get();
    return count.isNotEmpty;
  }

  /// æ£€æŸ¥ç±»åˆ«åç§°æ˜¯å¦å·²å­˜åœ¨ï¼ˆåœ¨åŒä¸€çˆ¶ç±»åˆ«ä¸‹ï¼?
  Future<bool> isCategoryNameExists(
    String name,
    int? parentId, {
    int? excludeId,
  }) async {
    var query = select(db.category)
      ..where((tbl) => tbl.name.equals(name));

    if (parentId == null) {
      query = query..where((tbl) => tbl.parentId.isNull());
    } else {
      query = query..where((tbl) => tbl.parentId.equals(parentId));
    }

    if (excludeId != null) {
      query = query..where((tbl) => tbl.id.isNotValue(excludeId));
    }

    final result = await query.get();
    return result.isNotEmpty;
  }

  /// è·å–ç±»åˆ«å±‚çº§è·¯å¾„ï¼ˆä»æ ¹åˆ°æŒ‡å®šç±»åˆ«ï¼?
  Future<List<CategoryData>> getCategoryPath(int categoryId) async {
    final path = <CategoryData>[];
    int? currentId = categoryId;

    while (currentId != null) {
      final category = await getCategoryById(currentId);
      if (category == null) break;

      path.insert(0, category);
      currentId = category.parentId;
    }

    return path;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'category_dao.dart';

// ignore_for_file: type=lint
mixin _$CategoryDaoMixin on DatabaseAccessor<AppDatabase> {
  $CategoryTable get category => attachedDatabase.category;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/products_table.dart';
import '../../../../core/database/barcodes_table.dart';
import '../../../../core/database/product_units_table.dart';
import '../../../../core/database/units_table.dart';
import '../../../../core/database/inventory_table.dart';

part 'product_dao.g.dart';

/// äº§å“æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
/// ä¸“é—¨è´Ÿè´£äº§å“ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(
  tables: [Product, Barcode, UnitProduct, Unit, Stock],
)
class ProductDao extends DatabaseAccessor<AppDatabase> with _$ProductDaoMixin {
  ProductDao(super.db);

  /// æ·»åŠ äº§å“
  Future<int> insertProduct( ProductCompanion companion) async {
    return await into(db.product).insert(companion);
  }

  /// æ ¹æ®IDè·å–äº§å“
  Future<ProductData?> getProductById(int id) async {
    return await (select(
      db.product,
    )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰äº§å“?
  Future<List<ProductData>> getAllProducts() async {
    return await select(db.product).get();
  }

  /// ç›‘å¬æ‰€æœ‰äº§å“å˜åŒ?
  Stream<List<ProductData>> watchAllProducts() {
    return select(db.product).watch();
  }

  /// ç›‘å¬æ‰€æœ‰äº§å“åŠå…¶ä¸»å•ä½çš„åç§?
  Stream<
    List<
      ({
        ProductData product,
        int unitId,
        String unitName,
        int conversionRate,
        int? sellingPriceInCents,
        int? wholesalePriceInCents
      })
    >
  >
  watchAllProductsWithUnit() {
    final query = select(db.product).join([
      leftOuterJoin(
        db.unitProduct,
        db.unitProduct.productId.equalsExp(db.product.id) &
            db.unitProduct.conversionRate.equals(1),
      ),
      leftOuterJoin(
        db.unit,
        db.unit.id.equalsExp(db.product.baseUnitId),
      ),
    ]);

    return query.watch().map((rows) {
      return rows.map((row) {
        try {
          final product = row.readTable(db.product);
          final unit = row.readTableOrNull(db.unit);
          final unitProduct = row.readTableOrNull(db.unitProduct);
          
          // å®‰å…¨åœ°è·å–å•ä½IDï¼Œç¡®ä¿ä¸ä¼šå‡ºç°æ•°å­—è§£æé”™è¯?
          int unitId;
          String unitName;
          
          if (unit != null) {
            unitId = unit.id;
            unitName = unit.name;
          } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å•ä½ï¼Œä½¿ç”¨äº§å“çš„åŸºç¡€å•ä½ID
            unitId = product.baseUnitId;
            unitName = 'æœªçŸ¥å•ä½';
          }
          
          return (
            product: product,
            unitId: unitId,
            unitName: unitName,
            conversionRate: unitProduct?.conversionRate ?? 1,
            sellingPriceInCents: unitProduct?.sellingPriceInCents,
            wholesalePriceInCents: unitProduct?.wholesalePriceInCents,
          );
        } catch (e) {
          print('å¤„ç†äº§å“å•ä½æ•°æ®æ—¶å‡ºé”? $e');
          // è¿”å›ä¸€ä¸ªå®‰å…¨çš„é»˜è®¤å€?
          final product = row.readTable(db.product);
          return (
            product: product,
            unitId: product.baseUnitId,
            unitName: 'æœªçŸ¥å•ä½',
            conversionRate: 1,
            sellingPriceInCents: null,
            wholesalePriceInCents: null,
          );
        }
      }).toList();
    }).handleError((error) {
      print('ç›‘å¬äº§å“åŠå•ä½æ•°æ®æ—¶å‡ºé”™: $error');
      return <({
        ProductData product,
        int unitId,
        String unitName,
        int conversionRate,
        int? sellingPriceInCents,
        int? wholesalePriceInCents
      })>[];
    });
  }

  /// æ›´æ–°äº§å“
  Future<bool> updateProduct( ProductCompanion companion) async {
    final rowsAffected = await (update(
      db.product,
    )..where((tbl) => tbl.id.equals(companion.id.value))).write(companion);
    return rowsAffected > 0;
  }

  /// åˆ é™¤äº§å“
  Future<int> deleteProduct(int id) async {
    print('ğŸ’¾ æ•°æ®åº“å±‚ï¼šåˆ é™¤äº§å“ï¼ŒID: $id');
    final result = await (delete(
      db.product,
    )..where((tbl) => tbl.id.equals(id))).go();
    print('ğŸ’¾ æ•°æ®åº“å±‚ï¼šåˆ é™¤å®Œæˆï¼Œå½±å“è¡Œæ•°: $result');
    return result;
  }

  /// æ ¹æ®æ¡ä»¶æŸ¥è¯¢äº§å“
  Future<List<ProductData>> getProductsByCondition({
    int? categoryId,
    String? status,
    String? keyword,
  }) async {
    final query = select(db.product);

    if (categoryId != null) {
      query.where((tbl) => tbl.categoryId.equals(categoryId));
    }

    if (status != null) {
      query.where((tbl) => tbl.status.equals(status));
    }
    if (keyword != null && keyword.isNotEmpty) {
      query.where(
        (tbl) =>
            tbl.name.contains(keyword) |
            // æ¡ç æœç´¢å·²ç§»é™¤ï¼Œç°åœ¨æ¡ç å­˜å‚¨åœ¨ç‹¬ç«‹çš„æ¡ç è¡¨ä¸­
            tbl.sku.contains(keyword),
      );
    }

    return await query.get();
  }

  /// ç›‘å¬æŒ‡å®šç±»åˆ«çš„äº§å“?
  Stream<List<ProductData>> watchProductsByCategory(int categoryId) {
    return (select(
      db.product,
    )..where((tbl) => tbl.categoryId.equals(categoryId))).watch();
  }

  /// è·å–åº“å­˜é¢„è­¦äº§å“ (å‡è®¾å½“å‰åº“å­˜é€šè¿‡å…¶ä»–æ–¹å¼è·å–)
  Future<List<ProductData>> getStockWarningProducts() async {
    return await (select(
      db.product,
    )..where((tbl) => tbl.stockWarningValue.isNotNull())).get();
  }

  /// æ‰¹é‡æ’å…¥äº§å“
  Future<void> insertMultipleProducts(
    List< ProductCompanion> companions,
  ) async {
    await batch((batch) {
      batch.insertAll(db.product, companions);
    });
  }

  /// æ‰¹é‡æ›´æ–°äº§å“
  Future<void> updateMultipleProducts(
    List< ProductCompanion> companions,
  ) async {
    await batch((batch) {
      for (final companion in companions) {
        batch.update(
          db.product,
          companion,
          where: (tbl) => tbl.id.equals(companion.id.value),
        );
      }
    });
  }

  /// æ£€æŸ¥äº§å“æ˜¯å¦å­˜åœ?
  Future<bool> productExists(int id) async {
    final result =
        await (selectOnly(db.product)
              ..addColumns([db.product.id])
              ..where(db.product.id.equals(id)))
            .getSingleOrNull();
    return result != null;
  }

  /// è·å–äº§å“æ•°é‡
  Future<int> getProductCount() async {
    final countExp = countAll();
    final query = selectOnly(db.product)..addColumns([countExp]);
    final result = await query.getSingle();
    return result.read(countExp)!;
  }

  /// æ ¹æ®æ¡ç è·å–äº§å“
  /// é€šè¿‡æ¡ç è¡¨å’Œäº§å“å•ä½è¡¨è”æŸ¥è·å–äº§å“?
  Future<ProductData?> getProductByBarcode(String barcode) async {
    // é¦–å…ˆåœ¨æ¡ç è¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„äº§å“å•ä½ID
    final barcodeResult = await (select(
      db.barcode,
    )..where((tbl) => tbl.barcodeValue.equals(barcode))).getSingleOrNull();

    if (barcodeResult == null) {
      return null; // æ¡ç ä¸å­˜åœ?
    }

    // ç„¶ååœ¨äº§å“å•ä½è¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„äº§å“ID
    final productUnitResult =
        await (select(db.unitProduct)..where(
              (tbl) => tbl.id.equals(barcodeResult.unitProductId),
            ))
            .getSingleOrNull();

    if (productUnitResult == null) {
      return null; // äº§å“å•ä½ä¸å­˜åœ?
    }

    // æœ€åè·å–äº§å“ä¿¡æ?
    return await (select(db.product)
          ..where((tbl) => tbl.id.equals(productUnitResult.productId)))
        .getSingleOrNull();
  }

  /// æ ¹æ®æ¡ç è·å–äº§å“åŠå…¶å•ä½ä¿¡æ¯
  /// è¿”å›åŒ…å«äº§å“ä¿¡æ¯å’Œå•ä½åç§°çš„ç»“æœ
  Future<
    ({
      ProductData product,
      int unitId,
      String unitName,
      int conversionRate,
      int? sellingPriceInCents,
      int? wholesalePriceInCents,
      int? averageUnitPriceInCents
    })?
  >
  getProductWithUnitByBarcode(String barcode) async {
    // é¦–å…ˆåœ¨æ¡ç è¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„äº§å“å•ä½ID
    final barcodeResult = await (select(
      db.barcode,
    )..where((tbl) => tbl.barcodeValue.equals(barcode))).getSingleOrNull();

    if (barcodeResult == null) {
      return null; // æ¡ç ä¸å­˜åœ?
    }

    // è”åˆæŸ¥è¯¢äº§å“å•ä½è¡¨ã€äº§å“è¡¨å’Œå•ä½è¡¨
    final query =
        select(db.unitProduct).join([
          innerJoin(
            db.product,
            db.product.id.equalsExp(db.unitProduct.productId),
          ),
          innerJoin(
            db.unit,
            db.unit.id.equalsExp(db.unitProduct.unitId),
          ),
        ])..where(
          db.unitProduct.id.equals(
            barcodeResult.unitProductId,
          ),
        );

    final result = await query.getSingleOrNull();
    if (result == null) {
      return null;
    }

    final product = result.readTable(db.product);
    final unit = result.readTable(db.unit);
    final unitProduct = result.readTable(db.unitProduct);

    // æŸ¥è¯¢åº“å­˜è·å–é‡‡è´­ä»·ï¼ˆç§»åŠ¨åŠ æƒå¹³å‡ä»·ï¼‰
    // è¿™é‡Œè·å–æ‰€æœ‰åº—é“ºçš„åº“å­˜ï¼Œå–ç¬¬ä¸€ä¸ªæœ‰åº“å­˜çš„åº—é“ºçš„é‡‡è´­ä»?
    final stockQuery = select(db.stock)
      ..where((tbl) => tbl.productId.equals(product.id))
      ..orderBy([(tbl) => OrderingTerm.desc(tbl.quantity)])
      ..limit(1);
    
    final stock = await stockQuery.getSingleOrNull();
    final averageUnitPriceInCents = stock?.averageUnitPriceInCents;

    // å¦‚æœ UnitProduct è¡¨ä¸­çš„å”®ä»·ä¸º nullï¼Œåˆ™å›é€€ä½¿ç”¨ Product è¡¨ä¸­çš„ä»·æ ?
    // ä¼˜å…ˆçº§ï¼šUnitProduct.sellingPriceInCents > Product.retailPrice > Product.suggestedRetailPrice
    final int? effectiveSellingPrice = unitProduct.sellingPriceInCents 
        ?? product.retailPrice?.cents 
        ?? product.suggestedRetailPrice?.cents;

    return (
      product: product,
      unitId: unit.id,
      unitName: unit.name,
      conversionRate: unitProduct.conversionRate,
      sellingPriceInCents: effectiveSellingPrice,
      wholesalePriceInCents: unitProduct.wholesalePriceInCents,
      averageUnitPriceInCents: averageUnitPriceInCents,
    );
  }

  /// æ£€æŸ¥å•ä½æ˜¯å¦è¢«ä»»ä½•äº§å“ä½¿ç”¨
  Future<bool> isUnitUsed(int unitId) async {
    final query = select(db.product)
      ..where((tbl) => tbl.baseUnitId.equals(unitId))
      ..limit(1);
    final result = await query.getSingleOrNull();
    return result != null;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'product_dao.dart';

// ignore_for_file: type=lint
mixin _$ProductDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $UnitProductTable get unitProduct => attachedDatabase.unitProduct;
  $BarcodeTable get barcode => attachedDatabase.barcode;
  $ShopTable get shop => attachedDatabase.shop;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $StockTable get stock => attachedDatabase.stock;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/product_units_table.dart';

part 'product_unit_dao.g.dart';

/// äº§å“å•ä½æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
/// ä¸“é—¨è´Ÿè´£äº§å“å•ä½å…³è”ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [UnitProduct])
class ProductUnitDao extends DatabaseAccessor<AppDatabase>
    with _$ProductUnitDaoMixin {
  ProductUnitDao(super.db);

  /// æ·»åŠ äº§å“å•ä½
  Future<int> insertProductUnit(UnitProductCompanion companion) async {
    return await into(db.unitProduct).insert(companion);
  }

  /// æ‰¹é‡æ·»åŠ äº§å“å•ä½
  Future<void> insertMultipleProductUnits(
    List<UnitProductCompanion> companions,
  ) async {
    await batch((batch) {
      batch.insertAll(db.unitProduct, companions);
    });
  }

  /// æ ¹æ®äº§å“å•ä½IDè·å–äº§å“å•ä½
  Future<UnitProductData?> getProductUnitById(
    int id,
  ) async {
    return await (select(db.unitProduct)
          ..where((tbl) => tbl.id.equals(id)))
        .getSingleOrNull();
  }

  /// æ ¹æ®äº§å“IDè·å–æ‰€æœ‰äº§å“å•ä½?
  Future<List<UnitProductData>> getProductUnitsByProductId(
    int productId,
  ) async {
    return await (select(
      db.unitProduct,
    )..where((tbl) => tbl.productId.equals(productId))).get();
  }

  /// è·å–æ‰€æœ‰äº§å“å•ä½?
  Future<List<UnitProductData>> getAllProductUnits() async {
    return await select(db.unitProduct).get();
  }

  /// ç›‘å¬äº§å“çš„æ‰€æœ‰å•ä½å˜åŒ?
  Stream<List<UnitProductData>> watchProductUnitsByProductId(
    int productId,
  ) {
    return (select(
      db.unitProduct,
    )..where((tbl) => tbl.productId.equals(productId))).watch();
  }

  /// æ›´æ–°äº§å“å•ä½
  Future<bool> updateProductUnit(UnitProductCompanion companion) async {
    final rowsAffected =
        await (update(db.unitProduct)..where(
              (tbl) => tbl.id.equals(companion.id.value),
            ))
            .write(companion);
    return rowsAffected > 0;
  }

  /// åˆ é™¤äº§å“å•ä½
  Future<int> deleteProductUnit(int id) async {
    return await (delete(
      db.unitProduct,
    )..where((tbl) => tbl.id.equals(id))).go();
  }

  /// åˆ é™¤äº§å“çš„æ‰€æœ‰å•ä½?
  Future<int> deleteProductUnitsByProductId(int productId) async {
    return await (delete(
      db.unitProduct,
    )..where((tbl) => tbl.productId.equals(productId))).go();
  }

  /// æ£€æŸ¥äº§å“æ˜¯å¦å·²é…ç½®æŸä¸ªå•ä½
  Future<bool> isUnitConfiguredForProduct(
    int productId,
    int unitId,
  ) async {
    final result =
        await (select(db.unitProduct)..where(
              (tbl) =>
                  tbl.productId.equals(productId) & tbl.unitId.equals(unitId),
            ))
            .getSingleOrNull();
    return result != null;
  }

  /// è·å–äº§å“çš„åŸºç¡€å•ä½ï¼ˆæ¢ç®—ç‡ä¸?.0çš„å•ä½ï¼‰
  Future<UnitProductData?> getBaseUnitForProduct(int productId) async {
    return await (select(db.unitProduct)..where(
          (tbl) =>
              tbl.productId.equals(productId) & tbl.conversionRate.equals(1),
        ))
        .getSingleOrNull();
  }

  /// æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ›´æ–°ï¼Œå¦åˆ™æ’å…¥ï¼?
  Future<void> upsertProductUnit(UnitProductCompanion companion) async {
    await into(db.unitProduct).insertOnConflictUpdate(companion);
  }

  /// æ‰¹é‡æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½?
  Future<void> upsertMultipleProductUnits(
    List<UnitProductCompanion> companions,
  ) async {
    await batch((batch) {
      for (final companion in companions) {
        batch.insert(
          db.unitProduct,
          companion,
          onConflict: DoUpdate((_) => companion),
        );
      }
    });
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'product_unit_dao.dart';

// ignore_for_file: type=lint
mixin _$ProductUnitDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $UnitProductTable get unitProduct => attachedDatabase.unitProduct;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/units_table.dart';

part 'unit_dao.g.dart';

/// å•ä½æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
/// ä¸“é—¨è´Ÿè´£å•ä½ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
@DriftAccessor(tables: [Unit])
class UnitDao extends DatabaseAccessor<AppDatabase> with _$UnitDaoMixin {
  UnitDao(super.db);

  /// æ·»åŠ å•ä½
  Future<int> insertUnit(UnitCompanion companion) async {
    return await into(db.unit).insert(companion);
  }

  /// æ ¹æ®IDè·å–å•ä½
  Future<UnitData?> getUnitById(int id) async {
    return await (select(
      db.unit,
    )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®åç§°è·å–å•ä½
  Future<UnitData?> getUnitByName(String name) async {
    return await (select(
      db.unit,
    )..where((tbl) => tbl.name.equals(name))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰å•ä½?
  Future<List<UnitData>> getAllUnits() async {
    return await select(db.unit).get();
  }

  /// ç›‘å¬æ‰€æœ‰å•ä½å˜åŒ?
  Stream<List<UnitData>> watchAllUnits() {
    return select(db.unit).watch();
  }

  /// æ›´æ–°å•ä½
  Future<bool> updateUnit(UnitCompanion companion) async {
    final rowsAffected = await (update(
      db.unit,
    )..where((tbl) => tbl.id.equals(companion.id.value))).write(companion);
    return rowsAffected > 0;
  }

  /// åˆ é™¤å•ä½
  Future<int> deleteUnit(int id) async {
    print('ğŸ’¾ æ•°æ®åº“å±‚ï¼šåˆ é™¤å•ä½ï¼ŒID: $id');
    final result = await (delete(
      db.unit,
    )..where((tbl) => tbl.id.equals(id))).go();
    print('ğŸ’¾ æ•°æ®åº“å±‚ï¼šåˆ é™¤å®Œæˆï¼Œå½±å“è¡Œæ•°: $result');
    return result;
  }

  /// æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨
  Future<bool> isUnitNameExists(String name, [int? excludeId]) async {
    final query = select(db.unit)..where((tbl) => tbl.name.equals(name));

    if (excludeId != null) {
      query.where((tbl) => tbl.id.isNotValue(excludeId));
    }

    final result = await query.getSingleOrNull();
    return result != null;
  }

  /// æ‰¹é‡æ’å…¥é»˜è®¤å•ä½
  Future<void> insertDefaultUnits() async {
    final defaultUnitNames = [
      'ä¸?,
      'ç®?,
      'åŒ?,
      'å…¬æ–¤',
      'å…?,
      'å?,
      'æ¯«å‡',
    ];

    for (final name in defaultUnitNames) {
      final existing = await getUnitByName(name);
      if (existing == null) {
        await insertUnit(UnitCompanion.insert(name: name));
      }
    }
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'unit_dao.dart';

// ignore_for_file: type=lint
mixin _$UnitDaoMixin on DatabaseAccessor<AppDatabase> {
  $UnitTable get unit => attachedDatabase.unit;
}
import '../../domain/repository/i_barcode_repository.dart';
import '../../domain/model/barcode.dart';
import '../../../../core/database/database.dart';
import '../dao/barcode_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// æ¡ç ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„æ¡ç æ•°æ®è®¿é—®å±‚å®ç?
class BarcodeRepository implements IBarcodeRepository {
  final BarcodeDao _barcodeDao;

  BarcodeRepository(AppDatabase database) : _barcodeDao = database.barcodeDao;

  @override
  Future<int> addBarcode(BarcodeModel barcode) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ æ¡ç ï¼ŒID: ${barcode.id}');
      return await _barcodeDao.insertBarcode(_barcodeToCompanion(barcode));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<void> addMultipleBarcodes(List<BarcodeModel> barcodes) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ·»åŠ æ¡ç ï¼Œæ•°é‡? ${barcodes.length}');
      final companions = barcodes.map(_barcodeToCompanion).toList();
      await _barcodeDao.insertMultipleBarcodes(companions);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ·»åŠ æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<BarcodeModel?> getBarcodeById(int id) async {
    try {
      final data = await _barcodeDao.getBarcodeById(id);
      return data != null ? _dataToBarcode(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<BarcodeModel?> getBarcodeByValue(String barcode) async {
    try {
      final data = await _barcodeDao.getBarcodeByValue(barcode);
      return data != null ? _dataToBarcode(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®æ¡ç å€¼è·å–æ¡ç å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<BarcodeModel>> getBarcodesByProductUnitId(int? id) async {
    if (id == null) {
      return [];
    }
    try {
      final dataList = await _barcodeDao.getBarcodesByProductUnitId(
        id,
      );
      return dataList.map(_dataToBarcode).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“å•ä½IDè·å–æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<BarcodeModel>> getAllBarcodes() async {
    try {
      final dataList = await _barcodeDao.getAllBarcodes();
      return dataList.map(_dataToBarcode).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰æ¡ç å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<BarcodeModel>> watchBarcodesByProductUnitId(int id) {
    try {
      return _barcodeDao
          .watchBarcodesByProductUnitId(id)
          .map((dataList) => dataList.map(_dataToBarcode).toList());
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šç›‘å¬äº§å“å•ä½æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateBarcode(BarcodeModel barcode) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æ¡ç ï¼ŒID: ${barcode.id}');
      return await _barcodeDao.updateBarcode(_barcodeToCompanion(barcode));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteBarcode(int id) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤æ¡ç ï¼ŒID: $id');
      return await _barcodeDao.deleteBarcode(id);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteBarcodesByProductUnitId(int id) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½çš„æ‰€æœ‰æ¡ç ï¼Œäº§å“å•ä½ID: $id');
      return await _barcodeDao.deleteBarcodesByProductUnitId(id);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> barcodeExists(String barcode) async {
    try {
      return await _barcodeDao.barcodeExists(barcode);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ£€æŸ¥æ¡ç æ˜¯å¦å­˜åœ¨å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> productUnitHasBarcode(
    int id,
    String barcode,
  ) async {
    try {
      return await _barcodeDao.productUnitHasBarcode(id, barcode);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ£€æŸ¥äº§å“å•ä½æ˜¯å¦æœ‰æ¡ç å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<void> upsertBarcode(BarcodeModel barcode) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æˆ–æ’å…¥æ¡ç ï¼ŒID: ${barcode.id}');
      await _barcodeDao.upsertBarcode(_barcodeToCompanion(barcode));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æˆ–æ’å…¥æ¡ç å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<void> upsertMultipleBarcodes(List<BarcodeModel> barcodes) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ›´æ–°æˆ–æ’å…¥æ¡ç ï¼Œæ•°é‡: ${barcodes.length}');
      final companions = barcodes.map(_barcodeToCompanion).toList();
      await _barcodeDao.upsertMultipleBarcodes(companions);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ›´æ–°æˆ–æ’å…¥æ¡ç å¤±è´? $e');
      rethrow;
    }
  }

  /// å°†Barcodeæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companion
  BarcodeCompanion _barcodeToCompanion(BarcodeModel barcode) {
    return BarcodeCompanion(
      id: barcode.id == null ? const Value.absent() : Value(barcode.id!),
      unitProductId: Value(barcode.unitProductId),
      barcodeValue: Value(barcode.barcodeValue),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºBarcodeæ¨¡å‹
  BarcodeModel _dataToBarcode(BarcodeData data) {
    return BarcodeModel(
      id: data.id,
      unitProductId: data.unitProductId,
      barcodeValue: data.barcodeValue,
    );
  }
}

/// BarcodeModel Repository Provider
final barcodeRepositoryProvider = Provider<IBarcodeRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return BarcodeRepository(database);
});
import '../../domain/repository/i_category_repository.dart';
import '../../domain/model/category.dart';
import '../../../../core/database/database.dart';
import '../dao/category_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// ç±»åˆ«ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„ç±»åˆ«æ•°æ®è®¿é—®å±‚å®ç?
class CategoryRepository implements ICategoryRepository {
  final CategoryDao _categoryDao;

  CategoryRepository(AppDatabase database)
    : _categoryDao = database.categoryDao;

  @override
  Future<int> addCategory(CategoryModel category) async {
    try {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ ç±»åˆ«ï¼ŒID: ${category.id}, åç§°: ${category.name}');
      final newId = await _categoryDao.insertCategory(_categoryToCompanion(category));
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šç±»åˆ«æ·»åŠ æˆåŠŸï¼Œæ–°ID: $newId');
      return newId; // è¿”å›æ–°åˆ›å»ºçš„ç±»åˆ«ID
    } catch (e) {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ ç±»åˆ«å¤±è´¥: $e');
      throw Exception('æ·»åŠ ç±»åˆ«å¤±è´¥: $e');
    }
  }

  @override
  Future<CategoryModel?> getCategoryById(int id) async {
    print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–ç±»åˆ«ï¼ŒID: $id');
    try {
      final categoryData = await _categoryDao.getCategoryById(id);
      if (categoryData != null) {
        final category = _categoryDataToModel(categoryData);
        print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šè·å–ç±»åˆ«æˆåŠŸï¼Œåç§? ${category.name}');
        return category;
      }
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæœªæ‰¾åˆ°æŒ‡å®šIDçš„ç±»åˆ?);
      return null;
    } catch (e) {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šè·å–ç±»åˆ«å¤±è´¥: $e');
      throw Exception('è·å–ç±»åˆ«å¤±è´¥: $e');
    }
  }

  @override
  Future<List<CategoryModel>> getAllCategories() async {
    print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰ç±»åˆ?);
    try {
      final categoriesData = await _categoryDao.getAllCategories();
      final categories = categoriesData.map(_categoryDataToModel).toList();
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šè·å–åˆ?${categories.length} ä¸ªç±»åˆ?);
      return categories;
    } catch (e) {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰ç±»åˆ«å¤±è´? $e');
      throw Exception('è·å–æ‰€æœ‰ç±»åˆ«å¤±è´? $e');
    }
  }

  @override
  Future<List<CategoryModel>> getRootCategories() async {
    try {
      final categoriesData = await _categoryDao.getCategoriesByParentId(null);
      return categoriesData.map(_categoryDataToModel).toList();
    } catch (e) {
      throw Exception('è·å–æ ¹ç±»åˆ«å¤±è´? $e');
    }
  }

  @override
  Future<List<CategoryModel>> getCategoriesByParentId(int parentId) async {
    try {
      final categoriesData = await _categoryDao.getCategoriesByParentId(
        parentId,
      );
      return categoriesData.map(_categoryDataToModel).toList();
    } catch (e) {
      throw Exception('è·å–å­ç±»åˆ«å¤±è´? $e');
    }
  }

  @override
  Stream<List<CategoryModel>> watchAllCategories() {
    return _categoryDao.watchAllCategories().map(
      (categoriesData) => categoriesData.map(_categoryDataToModel).toList(),
    );
  }

  @override
  Stream<List<CategoryModel>> watchRootCategories() {
    return _categoryDao.watchRootCategories().map(
      (categoriesData) => categoriesData.map(_categoryDataToModel).toList(),
    );
  }

  @override
  Stream<List<CategoryModel>> watchCategoriesByParentId(int parentId) {
    return _categoryDao
        .watchCategoriesByParentId(parentId)
        .map(
          (categoriesData) => categoriesData.map(_categoryDataToModel).toList(),
        );
  }

  @override
  Future<bool> updateCategory(CategoryModel category) async {
    if ((category.id ?? 0)>0) {
      throw Exception('ç±»åˆ«IDä¸èƒ½ä¸ºç©º');
    }

    try {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°ç±»åˆ«ï¼ŒID: ${category.id}, åç§°: ${category.name}');
      return await _categoryDao.updateCategory(_categoryToCompanion(category));
    } catch (e) {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°ç±»åˆ«å¤±è´¥: $e');
      throw Exception('æ›´æ–°ç±»åˆ«å¤±è´¥: $e');
    }
  }

  @override
  Future<int> deleteCategory(int id) async {
    print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤ç±»åˆ«ï¼ŒID: $id');
    try {
      final result = await _categoryDao.deleteCategory(id);
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤ç»“æœï¼Œå½±å“è¡Œæ•? $result');
      return result;
    } catch (e) {
      print('ğŸ·ï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤ç±»åˆ«å¤±è´¥: $e');
      throw Exception('åˆ é™¤ç±»åˆ«å¤±è´¥: $e');
    }
  }

  @override
  Future<bool> hasSubCategories(int categoryId) async {
    try {
      return await _categoryDao.hasSubCategories(categoryId);
    } catch (e) {
      throw Exception('æ£€æŸ¥å­ç±»åˆ«å¤±è´¥: $e');
    }
  }

  @override
  Future<bool> isCategoryNameExists(
    String name,
    int? parentId, {
    int? excludeId,
  }) async {
    try {
      return await _categoryDao.isCategoryNameExists(
        name,
        parentId,
        excludeId: excludeId,
      );
    } catch (e) {
      throw Exception('æ£€æŸ¥ç±»åˆ«åç§°å¤±è´? $e');
    }
  }

  @override
  Future<List<CategoryModel>> getCategoryPath(int categoryId) async {
    try {
      final categoriesData = await _categoryDao.getCategoryPath(categoryId);
      return categoriesData.map(_categoryDataToModel).toList();
    } catch (e) {
      throw Exception('è·å–ç±»åˆ«è·¯å¾„å¤±è´¥: $e');
    }
  }

  /// å°?CategoryModel æ¨¡å‹è½¬æ¢ä¸?CategoryCompanion
  CategoryCompanion _categoryToCompanion(CategoryModel category) {
    return CategoryCompanion(
      name: Value(category.name),
      parentId: category.parentId != null
          ? Value(category.parentId!)
          : const Value.absent(),
    );
  }

  /// å°?CategoryData è½¬æ¢ä¸?CategoryModel æ¨¡å‹
  CategoryModel _categoryDataToModel(CategoryData data) {
    return CategoryModel(id: data.id, name: data.name, parentId: data.parentId);
  }
}

/// CategoryModel Repository Provider
final categoryRepositoryProvider = Provider<CategoryRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return CategoryRepository(database);
});
import 'package:stocko_app/features/inventory/domain/model/batch.dart';

import '../../domain/repository/i_product_repository.dart';
import '../../domain/model/product.dart';
import '../../../../core/database/database.dart';
import '../dao/product_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// äº§å“ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„äº§å“æ•°æ®è®¿é—®å±‚å®ç?
class ProductRepository implements IProductRepository {
  final ProductDao _productDao;

  ProductRepository(AppDatabase database) : _productDao = database.productDao;
  @override
  Future<int> addProduct(ProductModel product) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ äº§å“ï¼ŒID: ${product.id}, åç§°: ${product.name}');
      await _productDao.insertProduct(
        _productToCompanion(product.updateTimestamp()),
      );
      // ç”±äºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯String IDï¼Œè¿”å›ä¸€ä¸ªè¡¨ç¤ºæˆåŠŸçš„å€?
      return 1;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ äº§å“å¤±è´¥: $e');
      throw Exception('æ·»åŠ äº§å“å¤±è´¥: $e');
    }
  }

  @override
  Future<bool> updateProduct(ProductModel product) async {
    // æ£€æŸ¥äº§å“IDæ˜¯å¦ä¸ºç©º
    if (product.id == null || product.id! <= 0) {
      throw Exception('äº§å“IDä¸èƒ½ä¸ºç©º');
    }

    try {
      return await _productDao.updateProduct(_productToCompanion(product));
    } catch (e) {
      throw Exception('æ›´æ–°äº§å“å¤±è´¥: $e');
    }
  }

  @override
  Future<int> deleteProduct(int id) async {
    print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“ï¼ŒID: $id');
    try {
      final productUnitDao = (_productDao.db).productUnitDao;
      final barcodeDao = (_productDao.db).barcodeDao;

      // 1. å…ˆè·å–è¯¥äº§å“å…³è”çš„æ‰€æœ‰äº§å“å•ä½?
      final productUnits = await productUnitDao.getProductUnitsByProductId(id);

      // 2. åˆ é™¤æ‰€æœ‰å…³è”çš„æ¡ç 
      int barcodeTotal = 0;
      for (final unit in productUnits) {
        final barcodeResult = await barcodeDao.deleteBarcodesByProductUnitId(
          unit.id,
        );
        barcodeTotal += barcodeResult;
      }
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤æ¡ç ï¼Œå½±å“è¡Œæ•? $barcodeTotal');

      // 3. åˆ é™¤äº§å“å•ä½å…³è”è¡?
      final unitResult = await productUnitDao.deleteProductUnitsByProductId(id);
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½ï¼Œå½±å“è¡Œæ•? $unitResult');

      // 4. æœ€ååˆ é™¤äº§å“æœ¬èº?
      final result = await _productDao.deleteProduct(id);
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“ï¼Œå½±å“è¡Œæ•? $result');
      return result;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤æ—¶å‘ç”Ÿå¼‚å¸? $e');
      throw Exception('åˆ é™¤äº§å“å¤±è´¥: $e');
    }
  }

  @override
  Future<ProductModel?> getProductById(int id) async {
    try {
      final result = await _productDao.getProductById(id);
      return result != null ? _dataToProduct(result) : null;
    } catch (e) {
      throw Exception('è·å–äº§å“å¤±è´¥: $e');
    }
  }

  @override
  Stream<List<ProductModel>> watchAllProducts() {
    return _productDao
        .watchAllProducts()
        .map((data) => data.map(_dataToProduct).toList())
        .handleError((error) {
          throw Exception('ç›‘å¬äº§å“åˆ—è¡¨å¤±è´¥: $error');
        });
  }

  @override
  Stream<
    List<
      ({
        ProductModel product,
        int unitId,
        String unitName,
        int conversionRate,
        int? sellingPriceInCents,
        int? wholesalePriceInCents
      })
    >
  >
  watchAllProductsWithUnit() {
    return _productDao
        .watchAllProductsWithUnit()
        .map(
          (data) => data
              .map(
                (e) {
                  try {
                    return (
                      product: _dataToProduct(e.product),
                      unitId: e.unitId,
                      unitName: e.unitName,
                      conversionRate: e.conversionRate,
                      sellingPriceInCents: e.sellingPriceInCents,
                      wholesalePriceInCents: e.wholesalePriceInCents,
                    );
                  } catch (error) {
                    print('è½¬æ¢äº§å“æ•°æ®æ—¶å‡ºé”? $error');
                    print('é—®é¢˜äº§å“ID: ${e.product.id}');
                    // è¿”å›ä¸€ä¸ªå®‰å…¨çš„é»˜è®¤å€¼ï¼Œä½†è·³è¿‡è¿™ä¸ªæœ‰é—®é¢˜çš„é¡¹
                    rethrow;
                  }
                },
              )
              .toList(),
        )
        .handleError((error) {
          print('ç›‘å¬äº§å“åŠå…¶å•ä½å¤±è´¥: $error');
          // è¿”å›ç©ºåˆ—è¡¨è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸?
          return <({
            ProductModel product,
            int unitId,
            String unitName,
            int conversionRate,
            int? sellingPriceInCents,
            int? wholesalePriceInCents
          })>[];
        });
  }

  @override
  Future<List<ProductModel>> getAllProducts() async {
    try {
      final data = await _productDao.getAllProducts();
      return data.map(_dataToProduct).toList();
    } catch (e) {
      throw Exception('è·å–äº§å“åˆ—è¡¨å¤±è´¥: $e');
    }
  }

  /// æ ¹æ®æ¡ä»¶æŸ¥è¯¢äº§å“
  @override
  Future<List<ProductModel>> getProductsByCondition({
    int? categoryId,
    String? status,
    String? keyword,
  }) async {
    try {
      final data = await _productDao.getProductsByCondition(
        categoryId: categoryId,
        status: status,
        keyword: keyword,
      );
      return data.map(_dataToProduct).toList();
    } catch (e) {
      throw Exception('æ ¹æ®æ¡ä»¶æŸ¥è¯¢äº§å“å¤±è´¥: $e');
    }
  }

  /// ç›‘å¬æŒ‡å®šç±»åˆ«çš„äº§å“?
  @override
  Stream<List<ProductModel>> watchProductsByCategory(int categoryId) {
    return _productDao
        .watchProductsByCategory(categoryId)
        .map((data) => data.map(_dataToProduct).toList())
        .handleError((error) {
          throw Exception('ç›‘å¬ç±»åˆ«äº§å“å¤±è´¥: $error');
        });
  }

  /// æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“
  @override
  Future<ProductModel?> getProductByBarcode(String barcode) async {
    try {
      final result = await _productDao.getProductByBarcode(barcode);
      return result != null ? _dataToProduct(result) : null;
    } catch (e) {
      throw Exception('æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“å¤±è´¥: $e');
    }
  }

  /// æ ¹æ®æ¡ç è·å–äº§å“åŠå…¶å•ä½ä¿¡æ¯
  @override
  Future<
    ({
      ProductModel product,
      int unitId,
      String unitName,
      int conversionRate,
      int? sellingPriceInCents,
      int? wholesalePriceInCents,
      int? averageUnitPriceInCents
    })?
  >
  getProductWithUnitByBarcode(String barcode) async {
    try {
      final result = await _productDao.getProductWithUnitByBarcode(barcode);
      if (result == null) return null;

      return (
        product: _dataToProduct(result.product),
        unitId: result.unitId,
        unitName: result.unitName,
        conversionRate: result.conversionRate,
        sellingPriceInCents: result.sellingPriceInCents,
        wholesalePriceInCents: result.wholesalePriceInCents,
        averageUnitPriceInCents: result.averageUnitPriceInCents,
      );
    } catch (e) {
      throw Exception('æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“åŠå•ä½å¤±è´? $e');
    }
  }

  /// è·å–åº“å­˜é¢„è­¦äº§å“
  Future<List<ProductModel>> getStockWarningProducts() async {
    try {
      final data = await _productDao.getStockWarningProducts();
      return data.map(_dataToProduct).toList();
    } catch (e) {
      throw Exception('è·å–åº“å­˜é¢„è­¦äº§å“å¤±è´¥: $e');
    }
  }

  /// æ‰¹é‡æ·»åŠ äº§å“
  Future<void> addMultipleProducts(List<ProductModel> products) async {
    try {
      final companions = products.map(_productToCompanion).toList();
      await _productDao.insertMultipleProducts(companions);
    } catch (e) {
      throw Exception('æ‰¹é‡æ·»åŠ äº§å“å¤±è´¥: $e');
    }
  }

  /// æ‰¹é‡æ›´æ–°äº§å“
  Future<void> updateMultipleProducts(List<ProductModel> products) async {
    try {
      final companions = products.map(_productToCompanion).toList();
      await _productDao.updateMultipleProducts(companions);
    } catch (e) {
      throw Exception('æ‰¹é‡æ›´æ–°äº§å“å¤±è´¥: $e');
    }
  }

  /// æ£€æŸ¥äº§å“æ˜¯å¦å­˜åœ?
  Future<bool> productExists(int id) async {
    try {
      return await _productDao.productExists(id);
    } catch (e) {
      throw Exception('æ£€æŸ¥äº§å“æ˜¯å¦å­˜åœ¨å¤±è´? $e');
    }
  }

  /// è·å–äº§å“æ•°é‡
  Future<int> getProductCount() async {
    try {
      return await _productDao.getProductCount();
    } catch (e) {
      throw Exception('è·å–äº§å“æ•°é‡å¤±è´¥: $e');
    }
  }

  /// å°†Productæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companion
  ProductCompanion _productToCompanion(ProductModel product) {
    return ProductCompanion(
      // è‡ªå¢IDï¼šæ’å…¥æ—¶åº”å½“ç¼ºçœï¼Œæ›´æ–°æ—¶éœ€è¦æä¾?
      id: product.id == null ? const Value.absent() : Value(product.id!),
      name: Value(product.name),
      sku: Value(product.sku),
      image: Value(product.image),
      categoryId: Value(product.categoryId),
      baseUnitId: Value(product.baseUnitId),
      specification: Value(product.specification),
      brand: Value(product.brand),
      // Money å­—æ®µï¼Œç›´æ¥æ˜ å°„å¯¹åº”åˆ—å?
      suggestedRetailPrice: Value(product.suggestedRetailPrice),
      retailPrice: Value(product.retailPrice),
      promotionalPrice: Value(product.promotionalPrice),
      stockWarningValue: Value(product.stockWarningValue),
      shelfLife: Value(product.shelfLife),
      shelfLifeUnit: Value(product.shelfLifeUnit),
      enableBatchManagement: Value(product.enableBatchManagement),
      status: Value(product.status),
      remarks: Value(product.remarks),
      lastUpdated: Value(product.lastUpdated),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºProductæ¨¡å‹
  ProductModel _dataToProduct(ProductData data) {
    try {
      return ProductModel(
        id: data.id, // ç›´æ¥ä½¿ç”¨intç±»å‹çš„id
        name: data.name,
        sku: data.sku,
        image: data.image,
        categoryId: data.categoryId,
        baseUnitId: data.baseUnitId,
        specification: data.specification,
        brand: data.brand,
        suggestedRetailPrice: data.suggestedRetailPrice,
        retailPrice: data.retailPrice,
        promotionalPrice: data.promotionalPrice,
        stockWarningValue: data.stockWarningValue,
        shelfLife: data.shelfLife,
        shelfLifeUnit: data.shelfLifeUnit,
        enableBatchManagement: data.enableBatchManagement,
        status: data.status,
        remarks: data.remarks,
        lastUpdated: data.lastUpdated,
      );
    } catch (e) {
      print('è½¬æ¢äº§å“æ•°æ®æ—¶å‡ºé”? $e');
      print('é—®é¢˜æ•°æ®: id=${data.id}, name=${data.name}, baseUnitId=${data.baseUnitId}');
      rethrow;
    }
  }

  @override
  Future<bool> isUnitUsed(int unitId) async {
    try {
      return await _productDao.isUnitUsed(unitId);
    } catch (e) {
      throw Exception('æ£€æŸ¥å•ä½æ˜¯å¦è¢«ä½¿ç”¨å¤±è´¥: $e');
    }
  }
  @override
  Future<List<BatchModel>> getBatchesByProductAndShop(
      int productId, int shopId) async {
    try {
      final batchDao = (_productDao.db).batchDao;
      final data = await batchDao.getBatchesByProductAndShop(productId, shopId);
      return data.map(_dataToBatch).toList();
    } catch (e) {
      throw Exception('æ ¹æ®äº§å“å’Œåº—é“ºè·å–æ‰¹æ¬¡å¤±è´? $e');
    }
  }

  BatchModel _dataToBatch(ProductBatchData data) {
    return BatchModel(
      id: data.id,
      productId: data.productId,
      productionDate: data.productionDate,
      totalInboundQuantity: data.totalInboundQuantity,
      shopId: data.shopId,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
    );
  }
}

/// äº§å“ä»“å‚¨ Provider
/// æä¾› IProductRepository çš„å®ç°å®ä¾?
final productRepositoryProvider = Provider<IProductRepository>((ref) {
  return ProductRepository(ref.watch(appDatabaseProvider));
});

/// Provider to get a single product by its ID.
final productByIdProvider = FutureProvider.family<ProductModel?, int>((
  ref,
  id,
) async {
  final repository = ref.watch(productRepositoryProvider);
  return repository.getProductById(id);
});
import '../../domain/repository/i_product_unit_repository.dart';
import '../../domain/model/product_unit.dart';
import '../../../../core/database/database.dart';
import '../dao/product_unit_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// äº§å“å•ä½ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„äº§å“å•ä½æ•°æ®è®¿é—®å±‚å®ç?
class ProductUnitRepository implements IProductUnitRepository {
  final ProductUnitDao _productUnitDao;

  ProductUnitRepository(AppDatabase database)
    : _productUnitDao = database.productUnitDao;

  @override
  Future<int> addProductUnit(UnitProduct unitProduct) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ äº§å“å•ä½ï¼ŒID: ${unitProduct.id}');
      return await _productUnitDao.insertProductUnit(
        _productUnitToCompanion(unitProduct),
      );
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<void> addMultipleProductUnits(List<UnitProduct> productUnits) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ·»åŠ äº§å“å•ä½ï¼Œæ•°é‡? ${productUnits.length}');
      final companions = productUnits.map(_productUnitToCompanion).toList();
      await _productUnitDao.insertMultipleProductUnits(companions);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ·»åŠ äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<UnitProduct?> getProductUnitById(int id) async {
    try {
      final data = await _productUnitDao.getProductUnitById(id);
      return data != null ? _dataToProductUnit(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<UnitProduct>> getProductUnitsByProductId(int productId) async {
    try {
      final dataList = await _productUnitDao.getProductUnitsByProductId(
        productId,
      );
      return dataList.map(_dataToProductUnit).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®äº§å“IDè·å–äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<UnitProduct>> getAllProductUnits() async {
    try {
      final dataList = await _productUnitDao.getAllProductUnits();
      return dataList.map(_dataToProductUnit).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰äº§å“å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<UnitProduct>> watchProductUnitsByProductId(int productId) {
    try {
      return _productUnitDao.watchProductUnitsByProductId(productId).map((
        dataList,
      ) {
        return dataList.map(_dataToProductUnit).toList();
      });
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šç›‘å¬äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateProductUnit(UnitProduct unitProduct) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°äº§å“å•ä½ï¼ŒID: ${unitProduct.id}');
      return await _productUnitDao.updateProductUnit(
        _productUnitToCompanion(unitProduct),
      );
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteProductUnit(int id) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½ï¼ŒID: $id');
      return await _productUnitDao.deleteProductUnit(id);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteProductUnitsByProductId(int productId) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“çš„æ‰€æœ‰å•ä½ï¼Œäº§å“ID: $productId');
      return await _productUnitDao.deleteProductUnitsByProductId(productId);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤äº§å“å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> isUnitConfiguredForProduct(
    int productId,
    int unitId,
  ) async {
    try {
      return await _productUnitDao.isUnitConfiguredForProduct(
        productId,
        unitId,
      );
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ£€æŸ¥äº§å“å•ä½é…ç½®å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<UnitProduct?> getBaseUnitForProduct(int productId) async {
    try {
      final data = await _productUnitDao.getBaseUnitForProduct(productId);
      return data != null ? _dataToProductUnit(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–äº§å“åŸºç¡€å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<void> upsertProductUnit(UnitProduct unitProduct) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æˆ–æ’å…¥äº§å“å•ä½ï¼ŒID: ${unitProduct.id}');
      await _productUnitDao.upsertProductUnit(
        _productUnitToCompanion(unitProduct),
      );
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°æˆ–æ’å…¥äº§å“å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<void> upsertMultipleProductUnits(
    List<UnitProduct> productUnits,
  ) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½ï¼Œæ•°é‡: ${productUnits.length}');
      final companions = productUnits.map(_productUnitToCompanion).toList();
      await _productUnitDao.upsertMultipleProductUnits(companions);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰¹é‡æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<void> replaceProductUnits(
    int productId,
    List<UnitProduct> productUnits,
  ) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šå·®å¼‚æ›´æ–°äº§å“å•ä½é…ç½®ï¼Œäº§å“ID: $productIdï¼Œæ–°å•ä½æ•°é‡: ${productUnits.length}');

      // å¼€å¯äº‹åŠ?
      await _productUnitDao.db.transaction(() async {
        // 1. è·å–ç°æœ‰çš„äº§å“å•ä½é…ç½?
        final existingUnits = await _productUnitDao.getProductUnitsByProductId(productId);
        print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šç°æœ‰å•ä½æ•°é‡: ${existingUnits.length}');

        // 2. æ„å»ºç°æœ‰å•ä½çš„æ˜ å°„è¡¨ï¼ˆä½¿ç”?unitId ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œç¬¦åˆæ•°æ®åº“å”¯ä¸€é”®çº¦æŸï¼‰
        final existingMap = <int, UnitProductData>{};
        for (final unit in existingUnits) {
          existingMap[unit.unitId] = unit;
        }

        // 3. æ„å»ºæ–°å•ä½çš„æ˜ å°„è¡?
        final newMap = <int, UnitProduct>{};
        for (final unit in productUnits) {
          newMap[unit.unitId] = unit;
        }

        // 4. æ‰¾å‡ºéœ€è¦åˆ é™¤çš„å•ä½ï¼ˆå­˜åœ¨äºæ—§åˆ—è¡¨ä½†ä¸åœ¨æ–°åˆ—è¡¨ä¸­ï¼?
        final toDelete = <int>[];
        for (final entry in existingMap.entries) {
          if (!newMap.containsKey(entry.key)) {
            toDelete.add(entry.value.id);
            print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ‡è®°åˆ é™¤ - ID: ${entry.value.id}, unitId: ${entry.value.unitId}');
          }
        }

        // 5. æ‰¾å‡ºéœ€è¦æ–°å¢å’Œæ›´æ–°çš„å•ä½?
        final toInsert = <UnitProductCompanion>[];
        final toUpdate = <UnitProductCompanion>[];
        
        for (final entry in newMap.entries) {
          if (existingMap.containsKey(entry.key)) {
            // å­˜åœ¨äºæ—§åˆ—è¡¨ä¸­ï¼Œéœ€è¦æ›´æ–?
            final existingUnit = existingMap[entry.key]!;
            final newUnit = entry.value;
            
            // æ£€æŸ¥æ˜¯å¦çœŸçš„éœ€è¦æ›´æ–°ï¼ˆæ¢ç®—ç‡ã€ä»·æ ¼æˆ–å…¶ä»–å­—æ®µæ˜¯å¦å˜åŒ–ï¼?
            if (existingUnit.conversionRate != newUnit.conversionRate ||
                existingUnit.sellingPriceInCents != newUnit.sellingPriceInCents ||
                existingUnit.wholesalePriceInCents != newUnit.wholesalePriceInCents) {
              toUpdate.add(_productUnitToCompanion(newUnit.copyWith(id: existingUnit.id)));
              print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ‡è®°æ›´æ–° - ID: ${existingUnit.id}, unitId: ${newUnit.unitId}');
            } else {
              print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ— éœ€æ›´æ–° - ID: ${existingUnit.id}, unitId: ${newUnit.unitId}');
            }
          } else {
            // ä¸å­˜åœ¨äºæ—§åˆ—è¡¨ä¸­ï¼Œéœ€è¦æ–°å¢?
            toInsert.add(_productUnitToCompanion(entry.value));
            print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ‡è®°æ–°å¢ - unitId: ${entry.value.unitId}');
          }
        }

        // 6. æ‰§è¡Œåˆ é™¤æ“ä½œ
        if (toDelete.isNotEmpty) {
          print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰§è¡Œåˆ é™¤æ“ä½œï¼Œæ•°é‡? ${toDelete.length}');
          for (final id in toDelete) {
            await _productUnitDao.deleteProductUnit(id);
          }
        }

        // 7. æ‰§è¡Œæ›´æ–°æ“ä½œ
        if (toUpdate.isNotEmpty) {
          print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰§è¡Œæ›´æ–°æ“ä½œï¼Œæ•°é‡? ${toUpdate.length}');
          for (final companion in toUpdate) {
            await _productUnitDao.updateProductUnit(companion);
          }
        }

        // 8. æ‰§è¡Œæ–°å¢æ“ä½œ
        if (toInsert.isNotEmpty) {
          print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ‰§è¡Œæ–°å¢æ“ä½œï¼Œæ•°é‡? ${toInsert.length}');
          await _productUnitDao.insertMultipleProductUnits(toInsert);
        }
      });

      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šå·®å¼‚æ›´æ–°äº§å“å•ä½é…ç½®å®Œæˆ');
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šå·®å¼‚æ›´æ–°äº§å“å•ä½é…ç½®å¤±è´¥: $e');
      rethrow;
    }
  }

  /// å°†ProductUnitæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companion
  UnitProductCompanion _productUnitToCompanion(UnitProduct unitProduct) {
    print('==================ã€æ‰¹å‘ä»·è°ƒè¯•ã€?=================');
    print('UnitProduct ID: ${unitProduct.id}');
    print('SELLING PRICE: ${unitProduct.sellingPriceInCents}');
    print('WHOLESALE PRICE: ${unitProduct.wholesalePriceInCents}');
    print(
      'productId: ${unitProduct.productId}, unitId: ${unitProduct.unitId}, conversionRate: ${unitProduct.conversionRate}',
    );
    print('=================================================');
    return UnitProductCompanion(
      id: unitProduct.id == null
          ? const Value.absent()
          : Value(unitProduct.id!),
      productId: Value(unitProduct.productId),
      unitId: Value(unitProduct.unitId),
      conversionRate: Value(unitProduct.conversionRate),
      sellingPriceInCents: unitProduct.sellingPriceInCents != null
          ? Value(unitProduct.sellingPriceInCents!)
          : const Value.absent(),
      wholesalePriceInCents: unitProduct.wholesalePriceInCents != null
          ? Value(unitProduct.wholesalePriceInCents!)
          : const Value.absent(),
      lastUpdated: Value(unitProduct.lastUpdated ?? DateTime.now()),
    );
  }

  /// å°†æ•°æ®åº“æ•°æ®è½¬æ¢ä¸ºProductUnitæ¨¡å‹
  UnitProduct _dataToProductUnit(UnitProductData data) {
    print('==================ã€æ‰¹å‘ä»·å›æ˜¾è°ƒè¯•ã€?=================');
    print('UnitProduct ID: ${data.id}');
    print('SELLING PRICE: ${data.sellingPriceInCents}');
    print('WHOLESALE PRICE: ${data.wholesalePriceInCents}');
    print(
      'productId: ${data.productId}, unitId: ${data.unitId}, conversionRate: ${data.conversionRate}',
    );
    print('=====================================================');
    return UnitProduct(
      id: data.id,
      productId: data.productId,
      unitId: data.unitId,
      conversionRate: data.conversionRate,
      sellingPriceInCents: data.sellingPriceInCents,
      wholesalePriceInCents: data.wholesalePriceInCents,
      lastUpdated: data.lastUpdated,
    );
  }
}

/// UnitProduct Repository Provider
final productUnitRepositoryProvider = Provider<IProductUnitRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return ProductUnitRepository(database);
});
import '../../domain/repository/i_unit_repository.dart';
import '../../domain/model/unit.dart';
import '../../../../core/database/database.dart';
import '../dao/unit_dao.dart';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// å•ä½ä»“å‚¨å®ç°ç±?
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„å•ä½æ•°æ®è®¿é—®å±‚å®ç?
class UnitRepository implements IUnitRepository {
  final UnitDao _unitDao;
  UnitRepository(AppDatabase database) : _unitDao = database.unitDao;

  @override
  Future<Unit> addUnit(Unit unit) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ å•ä½ï¼ŒID: ${unit.id}, åç§°: ${unit.name}');
      final newId = await _unitDao.insertUnit(_unitToCompanion(unit));
      // è¿”å›ä¸€ä¸ªåŒ…å«æ–°IDçš„æ–°Unitå®ä¾‹
      return unit.copyWith(id: newId);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<Unit?> getUnitById(int id) async {
    try {
      final data = await _unitDao.getUnitById(id);
      return data != null ? _unitDataToModel(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<Unit?> getUnitByName(String name) async {
    try {
      final data = await _unitDao.getUnitByName(name);
      return data != null ? _unitDataToModel(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®åç§°è·å–å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<Unit>> getAllUnits() async {
    try {
      final dataList = await _unitDao.getAllUnits();
      return dataList.map(_unitDataToModel).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Stream<List<Unit>> watchAllUnits() {
    try {
      return _unitDao.watchAllUnits().map((dataList) {
        return dataList.map(_unitDataToModel).toList();
      });
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šç›‘å¬æ‰€æœ‰å•ä½å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateUnit(Unit unit) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°å•ä½ï¼ŒID: ${unit.id}, åç§°: ${unit.name}');
      return await _unitDao.updateUnit(_unitToCompanion(unit));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteUnit(int id) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤å•ä½ï¼ŒID: $id');
      final result = await _unitDao.deleteUnit(id);
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤å®Œæˆï¼Œå½±å“è¡Œæ•? $result');
      return result;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> isUnitNameExists(String name, [int? excludeId]) async {
    try {
      return await _unitDao.isUnitNameExists(name, excludeId);
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ£€æŸ¥å•ä½åç§°æ˜¯å¦å­˜åœ¨å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<void> insertDefaultUnits() async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ’å…¥é»˜è®¤å•ä½');
      await _unitDao.insertDefaultUnits();
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šé»˜è®¤å•ä½æ’å…¥å®Œæˆ');
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ’å…¥é»˜è®¤å•ä½å¤±è´¥: $e');
      rethrow;
    }
  }

  /// å°?Unit æ¨¡å‹è½¬æ¢ä¸?UnitCompanion
  UnitCompanion _unitToCompanion(Unit unit) {
    return UnitCompanion(
      id: unit.id == null ? const Value.absent() : Value(unit.id!),
      name: Value(unit.name),
    );
  }

  /// å°?UnitData è½¬æ¢ä¸?Unit æ¨¡å‹
  Unit _unitDataToModel(UnitData data) {
    return Unit(id: data.id, name: data.name);
  }
}

/// Unit Repository Provider
final unitRepositoryProvider = Provider<IUnitRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return UnitRepository(database);
});
import 'package:flutter/foundation.dart';

/// è¾…å•ä½æ•°æ®æ¨¡å?
/// ç”¨äºè¡¨å•æ•°æ®çš„è·¨é¡µé¢æŒä¹…åŒ?
@immutable
class AuxiliaryUnitData {
  /// å”¯ä¸€æ ‡è¯†ç¬?
  final int id;

  /// å•ä½ID
  final int? unitId;

  /// å•ä½åç§°
  final String unitName;

  /// æ¢ç®—ç?
  final int conversionRate;

  /// æ¡ç 
  final String barcode;

  /// å»ºè®®é›¶å”®ä»?
  final String retailPriceInCents;

  /// æ‰¹å‘ä»?
  final String wholesalePriceInCents;

  const AuxiliaryUnitData({
    required this.id,
    this.unitId,
    this.unitName = '',
    this.conversionRate = 0,
    this.barcode = '',
    this.retailPriceInCents = '',
    this.wholesalePriceInCents = '',
  });

  /// åˆ›å»ºç©ºçš„è¾…å•ä½æ•°æ?
  const AuxiliaryUnitData.empty(this.id)
    : unitId = null,
      unitName = '',
      conversionRate = 0,
      barcode = '',
      retailPriceInCents = '',
      wholesalePriceInCents = '';

  /// å¤åˆ¶å¹¶æ›´æ–°æŒ‡å®šå­—æ®?
  AuxiliaryUnitData copyWith({
    int? id,
    int? unitId,
    String? unitName,
    int? conversionRate,
    String? barcode,
    String? retailPriceInCents,
    String? wholesalePriceInCents,
  }) {
    return AuxiliaryUnitData(
      id: id ?? this.id,
      unitId: unitId ?? this.unitId,
      unitName: unitName ?? this.unitName,
      conversionRate: conversionRate ?? this.conversionRate,
      barcode: barcode ?? this.barcode,
      retailPriceInCents: retailPriceInCents ?? this.retailPriceInCents,
      wholesalePriceInCents: wholesalePriceInCents ?? this.wholesalePriceInCents,
    );
  }

  /// è½¬æ¢ä¸ºJSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'unitId': unitId,
      'unitName': unitName,
      'conversionRate': conversionRate,
      'barcode': barcode,
      'retailPriceInCents': retailPriceInCents,
      'wholesalePriceInCents': wholesalePriceInCents,
    };
  }

  /// ä»JSONåˆ›å»ºå®ä¾‹
  factory AuxiliaryUnitData.fromJson(Map<String, dynamic> json) {
    return AuxiliaryUnitData(
      id: json['id'] as int,
      unitId: json['unitId'] as int?,
      unitName: json['unitName'] as String? ?? '',
      conversionRate: (json['conversionRate'] as int?) ?? 0,
      barcode: json['barcode'] as String? ?? '',
      retailPriceInCents: json['retailPriceInCents'] as String? ?? '',
      wholesalePriceInCents: json['wholesalePriceInCents'] as String? ?? '',
    );
  }

  /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„è¾…å•ä½æ•°æ®
  bool get isValid {
    return unitName.trim().isNotEmpty &&
        conversionRate > 0 &&
        conversionRate != 1.0;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AuxiliaryUnitData &&
        other.id == id &&
        other.unitId == unitId &&
        other.unitName == unitName &&
        other.conversionRate == conversionRate &&
        other.barcode == barcode &&
        other.retailPriceInCents == retailPriceInCents &&
        other.wholesalePriceInCents == wholesalePriceInCents;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      unitId,
      unitName,
      conversionRate,
      barcode,
      retailPriceInCents,
      wholesalePriceInCents,
    );
  }

  @override
  String toString() {
    return 'AuxiliaryUnitData(id: $id, unitId: $unitId, unitName: $unitName, '
        'conversionRate: $conversionRate, barcode: $barcode, retailPriceInCents: $retailPriceInCents, '
        'wholesalePriceInCents: $wholesalePriceInCents)';
  }
}
import 'package:freezed_annotation/freezed_annotation.dart';

part 'barcode.freezed.dart';
part 'barcode.g.dart';

@freezed
abstract class BarcodeModel with _$BarcodeModel {
  const factory BarcodeModel({
    int? id, // ä¸»é”®
    required int unitProductId, // å¤–é”®ï¼ŒæŒ‡å?UnitProduct
    required String barcodeValue, // æ¡ç å€?
  }) = _BarcodeModel;

  const BarcodeModel._();

  factory BarcodeModel.fromJson(Map<String, dynamic> json) =>
      _$BarcodeModelFromJson(json);

  /// æ£€æŸ¥æ¡ç æ˜¯å¦æœ‰æ•ˆï¼ˆéç©ºä¸”éçº¯ç©ºæ ¼ï¼‰
  bool get isValid => barcodeValue.trim().isNotEmpty;
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'barcode.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BarcodeModel {

 int? get id;// ä¸»é”®
 int get unitProductId;// å¤–é”®ï¼ŒæŒ‡å?UnitProduct
 String get barcodeValue;
/// Create a copy of BarcodeModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BarcodeModelCopyWith<BarcodeModel> get copyWith => _$BarcodeModelCopyWithImpl<BarcodeModel>(this as BarcodeModel, _$identity);

  /// Serializes this BarcodeModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BarcodeModel&&(identical(other.id, id) || other.id == id)&&(identical(other.unitProductId, unitProductId) || other.unitProductId == unitProductId)&&(identical(other.barcodeValue, barcodeValue) || other.barcodeValue == barcodeValue));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,unitProductId,barcodeValue);

@override
String toString() {
  return 'BarcodeModel(id: $id, unitProductId: $unitProductId, barcodeValue: $barcodeValue)';
}


}

/// @nodoc
abstract mixin class $BarcodeModelCopyWith<$Res>  {
  factory $BarcodeModelCopyWith(BarcodeModel value, $Res Function(BarcodeModel) _then) = _$BarcodeModelCopyWithImpl;
@useResult
$Res call({
 int? id, int unitProductId, String barcodeValue
});




}
/// @nodoc
class _$BarcodeModelCopyWithImpl<$Res>
    implements $BarcodeModelCopyWith<$Res> {
  _$BarcodeModelCopyWithImpl(this._self, this._then);

  final BarcodeModel _self;
  final $Res Function(BarcodeModel) _then;

/// Create a copy of BarcodeModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? unitProductId = null,Object? barcodeValue = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,unitProductId: null == unitProductId ? _self.unitProductId : unitProductId // ignore: cast_nullable_to_non_nullable
as int,barcodeValue: null == barcodeValue ? _self.barcodeValue : barcodeValue // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _BarcodeModel extends BarcodeModel {
  const _BarcodeModel({this.id, required this.unitProductId, required this.barcodeValue}): super._();
  factory _BarcodeModel.fromJson(Map<String, dynamic> json) => _$BarcodeModelFromJson(json);

@override final  int? id;
// ä¸»é”®
@override final  int unitProductId;
// å¤–é”®ï¼ŒæŒ‡å?UnitProduct
@override final  String barcodeValue;

/// Create a copy of BarcodeModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BarcodeModelCopyWith<_BarcodeModel> get copyWith => __$BarcodeModelCopyWithImpl<_BarcodeModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BarcodeModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BarcodeModel&&(identical(other.id, id) || other.id == id)&&(identical(other.unitProductId, unitProductId) || other.unitProductId == unitProductId)&&(identical(other.barcodeValue, barcodeValue) || other.barcodeValue == barcodeValue));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,unitProductId,barcodeValue);

@override
String toString() {
  return 'BarcodeModel(id: $id, unitProductId: $unitProductId, barcodeValue: $barcodeValue)';
}


}

/// @nodoc
abstract mixin class _$BarcodeModelCopyWith<$Res> implements $BarcodeModelCopyWith<$Res> {
  factory _$BarcodeModelCopyWith(_BarcodeModel value, $Res Function(_BarcodeModel) _then) = __$BarcodeModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int unitProductId, String barcodeValue
});




}
/// @nodoc
class __$BarcodeModelCopyWithImpl<$Res>
    implements _$BarcodeModelCopyWith<$Res> {
  __$BarcodeModelCopyWithImpl(this._self, this._then);

  final _BarcodeModel _self;
  final $Res Function(_BarcodeModel) _then;

/// Create a copy of BarcodeModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? unitProductId = null,Object? barcodeValue = null,}) {
  return _then(_BarcodeModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,unitProductId: null == unitProductId ? _self.unitProductId : unitProductId // ignore: cast_nullable_to_non_nullable
as int,barcodeValue: null == barcodeValue ? _self.barcodeValue : barcodeValue // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'barcode.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BarcodeModel _$BarcodeModelFromJson(Map<String, dynamic> json) =>
    _BarcodeModel(
      id: (json['id'] as num?)?.toInt(),
      unitProductId: (json['unitProductId'] as num).toInt(),
      barcodeValue: json['barcodeValue'] as String,
    );

Map<String, dynamic> _$BarcodeModelToJson(_BarcodeModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'unitProductId': instance.unitProductId,
      'barcodeValue': instance.barcodeValue,
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'category.freezed.dart';
part 'category.g.dart';

@freezed
abstract class CategoryModel with _$CategoryModel {
  const factory CategoryModel({
    int? id,
    required String name,
    int? parentId,
  }) = _CategoryModel;

  factory CategoryModel.fromJson(Map<String, dynamic> json) =>
      _$CategoryModelFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'category.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CategoryModel {

 int? get id; String get name; int? get parentId;
/// Create a copy of CategoryModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CategoryModelCopyWith<CategoryModel> get copyWith => _$CategoryModelCopyWithImpl<CategoryModel>(this as CategoryModel, _$identity);

  /// Serializes this CategoryModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CategoryModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.parentId, parentId) || other.parentId == parentId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,parentId);

@override
String toString() {
  return 'CategoryModel(id: $id, name: $name, parentId: $parentId)';
}


}

/// @nodoc
abstract mixin class $CategoryModelCopyWith<$Res>  {
  factory $CategoryModelCopyWith(CategoryModel value, $Res Function(CategoryModel) _then) = _$CategoryModelCopyWithImpl;
@useResult
$Res call({
 int? id, String name, int? parentId
});




}
/// @nodoc
class _$CategoryModelCopyWithImpl<$Res>
    implements $CategoryModelCopyWith<$Res> {
  _$CategoryModelCopyWithImpl(this._self, this._then);

  final CategoryModel _self;
  final $Res Function(CategoryModel) _then;

/// Create a copy of CategoryModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,Object? parentId = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,parentId: freezed == parentId ? _self.parentId : parentId // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _CategoryModel implements CategoryModel {
  const _CategoryModel({this.id, required this.name, this.parentId});
  factory _CategoryModel.fromJson(Map<String, dynamic> json) => _$CategoryModelFromJson(json);

@override final  int? id;
@override final  String name;
@override final  int? parentId;

/// Create a copy of CategoryModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CategoryModelCopyWith<_CategoryModel> get copyWith => __$CategoryModelCopyWithImpl<_CategoryModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CategoryModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CategoryModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.parentId, parentId) || other.parentId == parentId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,parentId);

@override
String toString() {
  return 'CategoryModel(id: $id, name: $name, parentId: $parentId)';
}


}

/// @nodoc
abstract mixin class _$CategoryModelCopyWith<$Res> implements $CategoryModelCopyWith<$Res> {
  factory _$CategoryModelCopyWith(_CategoryModel value, $Res Function(_CategoryModel) _then) = __$CategoryModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, String name, int? parentId
});




}
/// @nodoc
class __$CategoryModelCopyWithImpl<$Res>
    implements _$CategoryModelCopyWith<$Res> {
  __$CategoryModelCopyWithImpl(this._self, this._then);

  final _CategoryModel _self;
  final $Res Function(_CategoryModel) _then;

/// Create a copy of CategoryModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,Object? parentId = freezed,}) {
  return _then(_CategoryModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,parentId: freezed == parentId ? _self.parentId : parentId // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'category.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CategoryModel _$CategoryModelFromJson(Map<String, dynamic> json) =>
    _CategoryModel(
      id: (json['id'] as num?)?.toInt(),
      name: json['name'] as String,
      parentId: (json['parentId'] as num?)?.toInt(),
    );

Map<String, dynamic> _$CategoryModelToJson(_CategoryModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'parentId': instance.parentId,
    };
// ignore_for_file: invalid_annotation_target
import 'package:equatable/equatable.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:intl/intl.dart';

part 'product.freezed.dart';
part 'product.g.dart';

// å¸®åŠ©å‡½æ•°ï¼Œç”¨äº?JSON è½¬æ¢
int? _intFromJson(dynamic value) {
  if (value == null) return null;
  if (value is int) return value;
  if (value is String) return int.tryParse(value);
  return null;
}

Money? _moneyFromJson(int? cents) => cents == null ? null : Money(cents);
int? _moneyToJson(Money? money) => money?.cents;

/// ä»·æ ¼å°è£…ç±»ï¼ˆå•ä½ä¸ºåˆ†ï¼?
class Money extends Equatable {
  final int cents;
  const Money(this.cents);

  double get yuan => cents / 100;

  String format({String symbol = 'Â¥', String locale = 'zh_CN'}) {
    final cacheKey = '$locale|$symbol';
    final formatter = _formatterCache.putIfAbsent(
      cacheKey,
      () => NumberFormat.currency(locale: locale, symbol: symbol, decimalDigits: 2),
    );
    return formatter.format(yuan);
  }

  static final _formatterCache = <String, NumberFormat>{};

  factory Money.fromJson(int cents) => Money(cents);
  int toJson() => cents;

  @override
  List<Object?> get props => [cents];
}


/// ä¿è´¨æœŸå•ä½?
@JsonEnum(alwaysCreate: true)
enum ShelfLifeUnit { days, months, years }

/// äº§å“çŠ¶æ€?
@JsonEnum(alwaysCreate: true)
enum ProductStatus { active, inactive }

@freezed
abstract class ProductModel with _$ProductModel {
  const factory ProductModel({
    @JsonKey(fromJson: _intFromJson) int? id,
    required String name,
    String? sku,
    String? image,
    required int baseUnitId,
    @JsonKey(fromJson: _intFromJson) int? categoryId,
    String? specification,
    String? brand,
    @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson)
    Money? suggestedRetailPrice,
    @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson)
    Money? retailPrice,
    @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson)
    Money? promotionalPrice,
    int? stockWarningValue,
    int? shelfLife,
    @Default(ShelfLifeUnit.months) ShelfLifeUnit shelfLifeUnit,
    @Default(false) bool enableBatchManagement,
    @Default(ProductStatus.active) ProductStatus status,
    String? remarks,
    DateTime? lastUpdated,
  }) = _ProductModel;

  factory ProductModel.fromJson(Map<String, dynamic> json) =>
      _$ProductModelFromJson(json);

  const ProductModel._();

  /// è·å–æœ‰æ•ˆä»·æ ¼ï¼ˆä¿ƒé”€ä»?> é›¶å”®ä»?> å»ºè®®é›¶å”®ä»·ï¼‰
  Money? get effectivePrice =>
      promotionalPrice ?? retailPrice ?? suggestedRetailPrice;

  /// æ˜¯å¦æœ‰ä¿ƒé”€ä»?
  bool get hasPromotionalPrice => promotionalPrice != null;

  /// æ˜¯å¦éœ€è¦åº“å­˜é¢„è­?(ä¼˜åŒ–å?
  bool isStockWarning(int currentStock) {
    final limit = stockWarningValue;
    if (limit == null || limit <= 0) {
      return false;
    }
    return currentStock <= limit;
  }

  /// æ˜¯å¦æœ‰æ•ˆï¼ˆçŠ¶æ€ä¸ºæ´»è·ƒï¼?
  bool get isActive => status == ProductStatus.active;

  /// è·å–æ ¼å¼åŒ–çš„ä»·æ ¼æ˜¾ç¤º
  String get formattedPrice => effectivePrice?.format() ?? 'ä»·æ ¼å¾…å®š';

  /// å¤åˆ¶å¹¶æ›´æ–°æœ€åæ›´æ–°æ—¶é—´ï¼ˆç»Ÿä¸€ç”?UTCï¼?
  ProductModel updateTimestamp() {
    return copyWith(lastUpdated: DateTime.now().toUtc());
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'product.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ProductModel {

@JsonKey(fromJson: _intFromJson) int? get id; String get name; String? get sku; String? get image; int get baseUnitId;@JsonKey(fromJson: _intFromJson) int? get categoryId; String? get specification; String? get brand;@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? get suggestedRetailPrice;@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? get retailPrice;@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? get promotionalPrice; int? get stockWarningValue; int? get shelfLife; ShelfLifeUnit get shelfLifeUnit; bool get enableBatchManagement; ProductStatus get status; String? get remarks; DateTime? get lastUpdated;
/// Create a copy of ProductModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ProductModelCopyWith<ProductModel> get copyWith => _$ProductModelCopyWithImpl<ProductModel>(this as ProductModel, _$identity);

  /// Serializes this ProductModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ProductModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.sku, sku) || other.sku == sku)&&(identical(other.image, image) || other.image == image)&&(identical(other.baseUnitId, baseUnitId) || other.baseUnitId == baseUnitId)&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.specification, specification) || other.specification == specification)&&(identical(other.brand, brand) || other.brand == brand)&&(identical(other.suggestedRetailPrice, suggestedRetailPrice) || other.suggestedRetailPrice == suggestedRetailPrice)&&(identical(other.retailPrice, retailPrice) || other.retailPrice == retailPrice)&&(identical(other.promotionalPrice, promotionalPrice) || other.promotionalPrice == promotionalPrice)&&(identical(other.stockWarningValue, stockWarningValue) || other.stockWarningValue == stockWarningValue)&&(identical(other.shelfLife, shelfLife) || other.shelfLife == shelfLife)&&(identical(other.shelfLifeUnit, shelfLifeUnit) || other.shelfLifeUnit == shelfLifeUnit)&&(identical(other.enableBatchManagement, enableBatchManagement) || other.enableBatchManagement == enableBatchManagement)&&(identical(other.status, status) || other.status == status)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.lastUpdated, lastUpdated) || other.lastUpdated == lastUpdated));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,sku,image,baseUnitId,categoryId,specification,brand,suggestedRetailPrice,retailPrice,promotionalPrice,stockWarningValue,shelfLife,shelfLifeUnit,enableBatchManagement,status,remarks,lastUpdated);

@override
String toString() {
  return 'ProductModel(id: $id, name: $name, sku: $sku, image: $image, baseUnitId: $baseUnitId, categoryId: $categoryId, specification: $specification, brand: $brand, suggestedRetailPrice: $suggestedRetailPrice, retailPrice: $retailPrice, promotionalPrice: $promotionalPrice, stockWarningValue: $stockWarningValue, shelfLife: $shelfLife, shelfLifeUnit: $shelfLifeUnit, enableBatchManagement: $enableBatchManagement, status: $status, remarks: $remarks, lastUpdated: $lastUpdated)';
}


}

/// @nodoc
abstract mixin class $ProductModelCopyWith<$Res>  {
  factory $ProductModelCopyWith(ProductModel value, $Res Function(ProductModel) _then) = _$ProductModelCopyWithImpl;
@useResult
$Res call({
@JsonKey(fromJson: _intFromJson) int? id, String name, String? sku, String? image, int baseUnitId,@JsonKey(fromJson: _intFromJson) int? categoryId, String? specification, String? brand,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? suggestedRetailPrice,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? retailPrice,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? promotionalPrice, int? stockWarningValue, int? shelfLife, ShelfLifeUnit shelfLifeUnit, bool enableBatchManagement, ProductStatus status, String? remarks, DateTime? lastUpdated
});




}
/// @nodoc
class _$ProductModelCopyWithImpl<$Res>
    implements $ProductModelCopyWith<$Res> {
  _$ProductModelCopyWithImpl(this._self, this._then);

  final ProductModel _self;
  final $Res Function(ProductModel) _then;

/// Create a copy of ProductModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,Object? sku = freezed,Object? image = freezed,Object? baseUnitId = null,Object? categoryId = freezed,Object? specification = freezed,Object? brand = freezed,Object? suggestedRetailPrice = freezed,Object? retailPrice = freezed,Object? promotionalPrice = freezed,Object? stockWarningValue = freezed,Object? shelfLife = freezed,Object? shelfLifeUnit = null,Object? enableBatchManagement = null,Object? status = null,Object? remarks = freezed,Object? lastUpdated = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,sku: freezed == sku ? _self.sku : sku // ignore: cast_nullable_to_non_nullable
as String?,image: freezed == image ? _self.image : image // ignore: cast_nullable_to_non_nullable
as String?,baseUnitId: null == baseUnitId ? _self.baseUnitId : baseUnitId // ignore: cast_nullable_to_non_nullable
as int,categoryId: freezed == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int?,specification: freezed == specification ? _self.specification : specification // ignore: cast_nullable_to_non_nullable
as String?,brand: freezed == brand ? _self.brand : brand // ignore: cast_nullable_to_non_nullable
as String?,suggestedRetailPrice: freezed == suggestedRetailPrice ? _self.suggestedRetailPrice : suggestedRetailPrice // ignore: cast_nullable_to_non_nullable
as Money?,retailPrice: freezed == retailPrice ? _self.retailPrice : retailPrice // ignore: cast_nullable_to_non_nullable
as Money?,promotionalPrice: freezed == promotionalPrice ? _self.promotionalPrice : promotionalPrice // ignore: cast_nullable_to_non_nullable
as Money?,stockWarningValue: freezed == stockWarningValue ? _self.stockWarningValue : stockWarningValue // ignore: cast_nullable_to_non_nullable
as int?,shelfLife: freezed == shelfLife ? _self.shelfLife : shelfLife // ignore: cast_nullable_to_non_nullable
as int?,shelfLifeUnit: null == shelfLifeUnit ? _self.shelfLifeUnit : shelfLifeUnit // ignore: cast_nullable_to_non_nullable
as ShelfLifeUnit,enableBatchManagement: null == enableBatchManagement ? _self.enableBatchManagement : enableBatchManagement // ignore: cast_nullable_to_non_nullable
as bool,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as ProductStatus,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,lastUpdated: freezed == lastUpdated ? _self.lastUpdated : lastUpdated // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _ProductModel extends ProductModel {
  const _ProductModel({@JsonKey(fromJson: _intFromJson) this.id, required this.name, this.sku, this.image, required this.baseUnitId, @JsonKey(fromJson: _intFromJson) this.categoryId, this.specification, this.brand, @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) this.suggestedRetailPrice, @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) this.retailPrice, @JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) this.promotionalPrice, this.stockWarningValue, this.shelfLife, this.shelfLifeUnit = ShelfLifeUnit.months, this.enableBatchManagement = false, this.status = ProductStatus.active, this.remarks, this.lastUpdated}): super._();
  factory _ProductModel.fromJson(Map<String, dynamic> json) => _$ProductModelFromJson(json);

@override@JsonKey(fromJson: _intFromJson) final  int? id;
@override final  String name;
@override final  String? sku;
@override final  String? image;
@override final  int baseUnitId;
@override@JsonKey(fromJson: _intFromJson) final  int? categoryId;
@override final  String? specification;
@override final  String? brand;
@override@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) final  Money? suggestedRetailPrice;
@override@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) final  Money? retailPrice;
@override@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) final  Money? promotionalPrice;
@override final  int? stockWarningValue;
@override final  int? shelfLife;
@override@JsonKey() final  ShelfLifeUnit shelfLifeUnit;
@override@JsonKey() final  bool enableBatchManagement;
@override@JsonKey() final  ProductStatus status;
@override final  String? remarks;
@override final  DateTime? lastUpdated;

/// Create a copy of ProductModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ProductModelCopyWith<_ProductModel> get copyWith => __$ProductModelCopyWithImpl<_ProductModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ProductModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ProductModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name)&&(identical(other.sku, sku) || other.sku == sku)&&(identical(other.image, image) || other.image == image)&&(identical(other.baseUnitId, baseUnitId) || other.baseUnitId == baseUnitId)&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.specification, specification) || other.specification == specification)&&(identical(other.brand, brand) || other.brand == brand)&&(identical(other.suggestedRetailPrice, suggestedRetailPrice) || other.suggestedRetailPrice == suggestedRetailPrice)&&(identical(other.retailPrice, retailPrice) || other.retailPrice == retailPrice)&&(identical(other.promotionalPrice, promotionalPrice) || other.promotionalPrice == promotionalPrice)&&(identical(other.stockWarningValue, stockWarningValue) || other.stockWarningValue == stockWarningValue)&&(identical(other.shelfLife, shelfLife) || other.shelfLife == shelfLife)&&(identical(other.shelfLifeUnit, shelfLifeUnit) || other.shelfLifeUnit == shelfLifeUnit)&&(identical(other.enableBatchManagement, enableBatchManagement) || other.enableBatchManagement == enableBatchManagement)&&(identical(other.status, status) || other.status == status)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.lastUpdated, lastUpdated) || other.lastUpdated == lastUpdated));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name,sku,image,baseUnitId,categoryId,specification,brand,suggestedRetailPrice,retailPrice,promotionalPrice,stockWarningValue,shelfLife,shelfLifeUnit,enableBatchManagement,status,remarks,lastUpdated);

@override
String toString() {
  return 'ProductModel(id: $id, name: $name, sku: $sku, image: $image, baseUnitId: $baseUnitId, categoryId: $categoryId, specification: $specification, brand: $brand, suggestedRetailPrice: $suggestedRetailPrice, retailPrice: $retailPrice, promotionalPrice: $promotionalPrice, stockWarningValue: $stockWarningValue, shelfLife: $shelfLife, shelfLifeUnit: $shelfLifeUnit, enableBatchManagement: $enableBatchManagement, status: $status, remarks: $remarks, lastUpdated: $lastUpdated)';
}


}

/// @nodoc
abstract mixin class _$ProductModelCopyWith<$Res> implements $ProductModelCopyWith<$Res> {
  factory _$ProductModelCopyWith(_ProductModel value, $Res Function(_ProductModel) _then) = __$ProductModelCopyWithImpl;
@override @useResult
$Res call({
@JsonKey(fromJson: _intFromJson) int? id, String name, String? sku, String? image, int baseUnitId,@JsonKey(fromJson: _intFromJson) int? categoryId, String? specification, String? brand,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? suggestedRetailPrice,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? retailPrice,@JsonKey(fromJson: _moneyFromJson, toJson: _moneyToJson) Money? promotionalPrice, int? stockWarningValue, int? shelfLife, ShelfLifeUnit shelfLifeUnit, bool enableBatchManagement, ProductStatus status, String? remarks, DateTime? lastUpdated
});




}
/// @nodoc
class __$ProductModelCopyWithImpl<$Res>
    implements _$ProductModelCopyWith<$Res> {
  __$ProductModelCopyWithImpl(this._self, this._then);

  final _ProductModel _self;
  final $Res Function(_ProductModel) _then;

/// Create a copy of ProductModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,Object? sku = freezed,Object? image = freezed,Object? baseUnitId = null,Object? categoryId = freezed,Object? specification = freezed,Object? brand = freezed,Object? suggestedRetailPrice = freezed,Object? retailPrice = freezed,Object? promotionalPrice = freezed,Object? stockWarningValue = freezed,Object? shelfLife = freezed,Object? shelfLifeUnit = null,Object? enableBatchManagement = null,Object? status = null,Object? remarks = freezed,Object? lastUpdated = freezed,}) {
  return _then(_ProductModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,sku: freezed == sku ? _self.sku : sku // ignore: cast_nullable_to_non_nullable
as String?,image: freezed == image ? _self.image : image // ignore: cast_nullable_to_non_nullable
as String?,baseUnitId: null == baseUnitId ? _self.baseUnitId : baseUnitId // ignore: cast_nullable_to_non_nullable
as int,categoryId: freezed == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int?,specification: freezed == specification ? _self.specification : specification // ignore: cast_nullable_to_non_nullable
as String?,brand: freezed == brand ? _self.brand : brand // ignore: cast_nullable_to_non_nullable
as String?,suggestedRetailPrice: freezed == suggestedRetailPrice ? _self.suggestedRetailPrice : suggestedRetailPrice // ignore: cast_nullable_to_non_nullable
as Money?,retailPrice: freezed == retailPrice ? _self.retailPrice : retailPrice // ignore: cast_nullable_to_non_nullable
as Money?,promotionalPrice: freezed == promotionalPrice ? _self.promotionalPrice : promotionalPrice // ignore: cast_nullable_to_non_nullable
as Money?,stockWarningValue: freezed == stockWarningValue ? _self.stockWarningValue : stockWarningValue // ignore: cast_nullable_to_non_nullable
as int?,shelfLife: freezed == shelfLife ? _self.shelfLife : shelfLife // ignore: cast_nullable_to_non_nullable
as int?,shelfLifeUnit: null == shelfLifeUnit ? _self.shelfLifeUnit : shelfLifeUnit // ignore: cast_nullable_to_non_nullable
as ShelfLifeUnit,enableBatchManagement: null == enableBatchManagement ? _self.enableBatchManagement : enableBatchManagement // ignore: cast_nullable_to_non_nullable
as bool,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as ProductStatus,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,lastUpdated: freezed == lastUpdated ? _self.lastUpdated : lastUpdated // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'product.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ProductModel _$ProductModelFromJson(Map<String, dynamic> json) =>
    _ProductModel(
      id: _intFromJson(json['id']),
      name: json['name'] as String,
      sku: json['sku'] as String?,
      image: json['image'] as String?,
      baseUnitId: (json['baseUnitId'] as num).toInt(),
      categoryId: _intFromJson(json['categoryId']),
      specification: json['specification'] as String?,
      brand: json['brand'] as String?,
      suggestedRetailPrice: _moneyFromJson(
        (json['suggestedRetailPrice'] as num?)?.toInt(),
      ),
      retailPrice: _moneyFromJson((json['retailPrice'] as num?)?.toInt()),
      promotionalPrice: _moneyFromJson(
        (json['promotionalPrice'] as num?)?.toInt(),
      ),
      stockWarningValue: (json['stockWarningValue'] as num?)?.toInt(),
      shelfLife: (json['shelfLife'] as num?)?.toInt(),
      shelfLifeUnit:
          $enumDecodeNullable(_$ShelfLifeUnitEnumMap, json['shelfLifeUnit']) ??
          ShelfLifeUnit.months,
      enableBatchManagement: json['enableBatchManagement'] as bool? ?? false,
      status:
          $enumDecodeNullable(_$ProductStatusEnumMap, json['status']) ??
          ProductStatus.active,
      remarks: json['remarks'] as String?,
      lastUpdated: json['lastUpdated'] == null
          ? null
          : DateTime.parse(json['lastUpdated'] as String),
    );

Map<String, dynamic> _$ProductModelToJson(_ProductModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'sku': instance.sku,
      'image': instance.image,
      'baseUnitId': instance.baseUnitId,
      'categoryId': instance.categoryId,
      'specification': instance.specification,
      'brand': instance.brand,
      'suggestedRetailPrice': _moneyToJson(instance.suggestedRetailPrice),
      'retailPrice': _moneyToJson(instance.retailPrice),
      'promotionalPrice': _moneyToJson(instance.promotionalPrice),
      'stockWarningValue': instance.stockWarningValue,
      'shelfLife': instance.shelfLife,
      'shelfLifeUnit': _$ShelfLifeUnitEnumMap[instance.shelfLifeUnit]!,
      'enableBatchManagement': instance.enableBatchManagement,
      'status': _$ProductStatusEnumMap[instance.status]!,
      'remarks': instance.remarks,
      'lastUpdated': instance.lastUpdated?.toIso8601String(),
    };

const _$ShelfLifeUnitEnumMap = {
  ShelfLifeUnit.days: 'days',
  ShelfLifeUnit.months: 'months',
  ShelfLifeUnit.years: 'years',
};

const _$ProductStatusEnumMap = {
  ProductStatus.active: 'active',
  ProductStatus.inactive: 'inactive',
};
import 'package:freezed_annotation/freezed_annotation.dart';
part 'product_unit.freezed.dart';
part 'product_unit.g.dart';

@freezed
abstract class UnitProduct with _$UnitProduct {
  const factory UnitProduct({
    int? id, // ä¸»é”®
    required int productId, // å¤–é”®, æŒ‡å‘ Products è¡?
    required int unitId, // å¤–é”®, æŒ‡å‘ Units è¡?
    required int conversionRate, // æ¢ç®—ç?
    int? sellingPriceInCents, // å”®ä»·
    int? wholesalePriceInCents, // æ‰¹å‘ä»?
    DateTime? lastUpdated, // æœ€åæ›´æ–°æ—¥æœ?
  }) = _UnitProduct;

  const UnitProduct._();

  factory UnitProduct.fromJson(Map<String, dynamic> json) =>
      _$UnitProductFromJson(json);

  // å°†ä»¥â€œåˆ†â€ä¸ºå•ä½çš„ä»·æ ¼è½¬æ¢ä¸ºâ€œå…ƒâ€ä»¥ä¾›æ˜¾ç¤?
  double get displaySellingPrice => (sellingPriceInCents ?? 0) / 100.0;
  double get displayWholesalePrice => (wholesalePriceInCents ?? 0) / 100.0;

  // æ ¹æ®æ•°é‡å’Œæ¢ç®—ç‡è®¡ç®—åŸºç¡€å•ä½æ•°é‡
  int calculateBaseQuantity(int quantity) {
    return quantity * conversionRate;
  }

  // æ ¹æ®åŸºç¡€å•ä½æ•°é‡è®¡ç®—å½“å‰å•ä½æ•°é‡
  int calculateUnitQuantity(int baseQuantity) {
    return baseQuantity ~/ conversionRate;
  }

  // å¤åˆ¶å¹¶æ›´æ–°æœ€åæ›´æ–°æ—¶é—?
  UnitProduct updateTimestamp() {
    return copyWith(lastUpdated: DateTime.now());
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'product_unit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UnitProduct {

 int? get id;// ä¸»é”®
 int get productId;// å¤–é”®, æŒ‡å‘ Products è¡? int get unitId;// å¤–é”®, æŒ‡å‘ Units è¡? int get conversionRate;// æ¢ç®—ç? int? get sellingPriceInCents;// å”®ä»·
 int? get wholesalePriceInCents;// æ‰¹å‘ä»? DateTime? get lastUpdated;
/// Create a copy of UnitProduct
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnitProductCopyWith<UnitProduct> get copyWith => _$UnitProductCopyWithImpl<UnitProduct>(this as UnitProduct, _$identity);

  /// Serializes this UnitProduct to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnitProduct&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.unitId, unitId) || other.unitId == unitId)&&(identical(other.conversionRate, conversionRate) || other.conversionRate == conversionRate)&&(identical(other.sellingPriceInCents, sellingPriceInCents) || other.sellingPriceInCents == sellingPriceInCents)&&(identical(other.wholesalePriceInCents, wholesalePriceInCents) || other.wholesalePriceInCents == wholesalePriceInCents)&&(identical(other.lastUpdated, lastUpdated) || other.lastUpdated == lastUpdated));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,unitId,conversionRate,sellingPriceInCents,wholesalePriceInCents,lastUpdated);

@override
String toString() {
  return 'UnitProduct(id: $id, productId: $productId, unitId: $unitId, conversionRate: $conversionRate, sellingPriceInCents: $sellingPriceInCents, wholesalePriceInCents: $wholesalePriceInCents, lastUpdated: $lastUpdated)';
}


}

/// @nodoc
abstract mixin class $UnitProductCopyWith<$Res>  {
  factory $UnitProductCopyWith(UnitProduct value, $Res Function(UnitProduct) _then) = _$UnitProductCopyWithImpl;
@useResult
$Res call({
 int? id, int productId, int unitId, int conversionRate, int? sellingPriceInCents, int? wholesalePriceInCents, DateTime? lastUpdated
});




}
/// @nodoc
class _$UnitProductCopyWithImpl<$Res>
    implements $UnitProductCopyWith<$Res> {
  _$UnitProductCopyWithImpl(this._self, this._then);

  final UnitProduct _self;
  final $Res Function(UnitProduct) _then;

/// Create a copy of UnitProduct
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? productId = null,Object? unitId = null,Object? conversionRate = null,Object? sellingPriceInCents = freezed,Object? wholesalePriceInCents = freezed,Object? lastUpdated = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,unitId: null == unitId ? _self.unitId : unitId // ignore: cast_nullable_to_non_nullable
as int,conversionRate: null == conversionRate ? _self.conversionRate : conversionRate // ignore: cast_nullable_to_non_nullable
as int,sellingPriceInCents: freezed == sellingPriceInCents ? _self.sellingPriceInCents : sellingPriceInCents // ignore: cast_nullable_to_non_nullable
as int?,wholesalePriceInCents: freezed == wholesalePriceInCents ? _self.wholesalePriceInCents : wholesalePriceInCents // ignore: cast_nullable_to_non_nullable
as int?,lastUpdated: freezed == lastUpdated ? _self.lastUpdated : lastUpdated // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _UnitProduct extends UnitProduct {
  const _UnitProduct({this.id, required this.productId, required this.unitId, required this.conversionRate, this.sellingPriceInCents, this.wholesalePriceInCents, this.lastUpdated}): super._();
  factory _UnitProduct.fromJson(Map<String, dynamic> json) => _$UnitProductFromJson(json);

@override final  int? id;
// ä¸»é”®
@override final  int productId;
// å¤–é”®, æŒ‡å‘ Products è¡?@override final  int unitId;
// å¤–é”®, æŒ‡å‘ Units è¡?@override final  int conversionRate;
// æ¢ç®—ç?@override final  int? sellingPriceInCents;
// å”®ä»·
@override final  int? wholesalePriceInCents;
// æ‰¹å‘ä»?@override final  DateTime? lastUpdated;

/// Create a copy of UnitProduct
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnitProductCopyWith<_UnitProduct> get copyWith => __$UnitProductCopyWithImpl<_UnitProduct>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnitProductToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UnitProduct&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.unitId, unitId) || other.unitId == unitId)&&(identical(other.conversionRate, conversionRate) || other.conversionRate == conversionRate)&&(identical(other.sellingPriceInCents, sellingPriceInCents) || other.sellingPriceInCents == sellingPriceInCents)&&(identical(other.wholesalePriceInCents, wholesalePriceInCents) || other.wholesalePriceInCents == wholesalePriceInCents)&&(identical(other.lastUpdated, lastUpdated) || other.lastUpdated == lastUpdated));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,unitId,conversionRate,sellingPriceInCents,wholesalePriceInCents,lastUpdated);

@override
String toString() {
  return 'UnitProduct(id: $id, productId: $productId, unitId: $unitId, conversionRate: $conversionRate, sellingPriceInCents: $sellingPriceInCents, wholesalePriceInCents: $wholesalePriceInCents, lastUpdated: $lastUpdated)';
}


}

/// @nodoc
abstract mixin class _$UnitProductCopyWith<$Res> implements $UnitProductCopyWith<$Res> {
  factory _$UnitProductCopyWith(_UnitProduct value, $Res Function(_UnitProduct) _then) = __$UnitProductCopyWithImpl;
@override @useResult
$Res call({
 int? id, int productId, int unitId, int conversionRate, int? sellingPriceInCents, int? wholesalePriceInCents, DateTime? lastUpdated
});




}
/// @nodoc
class __$UnitProductCopyWithImpl<$Res>
    implements _$UnitProductCopyWith<$Res> {
  __$UnitProductCopyWithImpl(this._self, this._then);

  final _UnitProduct _self;
  final $Res Function(_UnitProduct) _then;

/// Create a copy of UnitProduct
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? productId = null,Object? unitId = null,Object? conversionRate = null,Object? sellingPriceInCents = freezed,Object? wholesalePriceInCents = freezed,Object? lastUpdated = freezed,}) {
  return _then(_UnitProduct(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,unitId: null == unitId ? _self.unitId : unitId // ignore: cast_nullable_to_non_nullable
as int,conversionRate: null == conversionRate ? _self.conversionRate : conversionRate // ignore: cast_nullable_to_non_nullable
as int,sellingPriceInCents: freezed == sellingPriceInCents ? _self.sellingPriceInCents : sellingPriceInCents // ignore: cast_nullable_to_non_nullable
as int?,wholesalePriceInCents: freezed == wholesalePriceInCents ? _self.wholesalePriceInCents : wholesalePriceInCents // ignore: cast_nullable_to_non_nullable
as int?,lastUpdated: freezed == lastUpdated ? _self.lastUpdated : lastUpdated // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'product_unit.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UnitProduct _$UnitProductFromJson(Map<String, dynamic> json) => _UnitProduct(
  id: (json['id'] as num?)?.toInt(),
  productId: (json['productId'] as num).toInt(),
  unitId: (json['unitId'] as num).toInt(),
  conversionRate: (json['conversionRate'] as num).toInt(),
  sellingPriceInCents: (json['sellingPriceInCents'] as num?)?.toInt(),
  wholesalePriceInCents: (json['wholesalePriceInCents'] as num?)?.toInt(),
  lastUpdated: json['lastUpdated'] == null
      ? null
      : DateTime.parse(json['lastUpdated'] as String),
);

Map<String, dynamic> _$UnitProductToJson(_UnitProduct instance) =>
    <String, dynamic>{
      'id': instance.id,
      'productId': instance.productId,
      'unitId': instance.unitId,
      'conversionRate': instance.conversionRate,
      'sellingPriceInCents': instance.sellingPriceInCents,
      'wholesalePriceInCents': instance.wholesalePriceInCents,
      'lastUpdated': instance.lastUpdated?.toIso8601String(),
    };
import 'package:freezed_annotation/freezed_annotation.dart';

part 'unit.freezed.dart';
part 'unit.g.dart';

@freezed
abstract class Unit with _$Unit {
  const Unit._();

  const factory Unit({int? id, required String name}) = _Unit;

  factory Unit.fromJson(Map<String, dynamic> json) => _$UnitFromJson(json);

  factory Unit.empty() => const Unit(id: null, name: '');

  bool get isNew => id == null;
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'unit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Unit {

 int? get id; String get name;
/// Create a copy of Unit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnitCopyWith<Unit> get copyWith => _$UnitCopyWithImpl<Unit>(this as Unit, _$identity);

  /// Serializes this Unit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Unit&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Unit(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $UnitCopyWith<$Res>  {
  factory $UnitCopyWith(Unit value, $Res Function(Unit) _then) = _$UnitCopyWithImpl;
@useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class _$UnitCopyWithImpl<$Res>
    implements $UnitCopyWith<$Res> {
  _$UnitCopyWithImpl(this._self, this._then);

  final Unit _self;
  final $Res Function(Unit) _then;

/// Create a copy of Unit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _Unit extends Unit {
  const _Unit({this.id, required this.name}): super._();
  factory _Unit.fromJson(Map<String, dynamic> json) => _$UnitFromJson(json);

@override final  int? id;
@override final  String name;

/// Create a copy of Unit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnitCopyWith<_Unit> get copyWith => __$UnitCopyWithImpl<_Unit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnitToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Unit&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Unit(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$UnitCopyWith<$Res> implements $UnitCopyWith<$Res> {
  factory _$UnitCopyWith(_Unit value, $Res Function(_Unit) _then) = __$UnitCopyWithImpl;
@override @useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class __$UnitCopyWithImpl<$Res>
    implements _$UnitCopyWith<$Res> {
  __$UnitCopyWithImpl(this._self, this._then);

  final _Unit _self;
  final $Res Function(_Unit) _then;

/// Create a copy of Unit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_Unit(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'unit.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Unit _$UnitFromJson(Map<String, dynamic> json) =>
    _Unit(id: (json['id'] as num?)?.toInt(), name: json['name'] as String);

Map<String, dynamic> _$UnitToJson(_Unit instance) => <String, dynamic>{
  'id': instance.id,
  'name': instance.name,
};
import '../model/barcode.dart';

/// æ¡ç ä»“å‚¨æ¥å£
/// å®šä¹‰æ¡ç ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IBarcodeRepository {
  /// æ·»åŠ æ¡ç 
  Future<int> addBarcode(BarcodeModel barcode);

  /// æ‰¹é‡æ·»åŠ æ¡ç 
  Future<void> addMultipleBarcodes(List<BarcodeModel> barcodes);

  /// æ ¹æ®IDè·å–æ¡ç 
  Future<BarcodeModel?> getBarcodeById(int id);

  /// æ ¹æ®æ¡ç å€¼è·å–æ¡ç ä¿¡æ?
  Future<BarcodeModel?> getBarcodeByValue(String barcode);

  /// æ ¹æ®äº§å“å•ä½IDè·å–æ‰€æœ‰æ¡ç ?
  Future<List<BarcodeModel>> getBarcodesByProductUnitId(int? id);

  /// è·å–æ‰€æœ‰æ¡ç ?
  Future<List<BarcodeModel>> getAllBarcodes();

  /// ç›‘å¬äº§å“å•ä½çš„æ¡ç å˜åŒ?
  Stream<List<BarcodeModel>> watchBarcodesByProductUnitId(int id);

  /// æ›´æ–°æ¡ç 
  Future<bool> updateBarcode(BarcodeModel barcode);

  /// åˆ é™¤æ¡ç 
  Future<int> deleteBarcode(int id);

  /// åˆ é™¤äº§å“å•ä½çš„æ‰€æœ‰æ¡ç ?
  Future<int> deleteBarcodesByProductUnitId(int id);

  /// æ£€æŸ¥æ¡ç æ˜¯å¦å·²å­˜åœ¨
  Future<bool> barcodeExists(String barcode);

  /// æ£€æŸ¥äº§å“å•ä½æ˜¯å¦å·²æœ‰è¯¥æ¡ç 
  Future<bool> productUnitHasBarcode(int id, String barcode);

  /// æ›´æ–°æˆ–æ’å…¥æ¡ç ?
  Future<void> upsertBarcode(BarcodeModel barcode);

  /// æ‰¹é‡æ›´æ–°æˆ–æ’å…¥æ¡ç ?
  Future<void> upsertMultipleBarcodes(List<BarcodeModel> barcodes);
}
import '../model/category.dart';

/// ç±»åˆ«ä»“å‚¨æ¥å£
/// å®šä¹‰ç±»åˆ«ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class ICategoryRepository {
  /// æ·»åŠ ç±»åˆ«
  Future<int> addCategory(CategoryModel category);

  /// æ ¹æ®IDè·å–ç±»åˆ«
  Future<CategoryModel?> getCategoryById(int id);

  /// è·å–æ‰€æœ‰ç±»åˆ?
  Future<List<CategoryModel>> getAllCategories();

  /// è·å–æ ¹ç±»åˆ«ï¼ˆæ²¡æœ‰çˆ¶ç±»åˆ«çš„ç±»åˆ«ï¼?
  Future<List<CategoryModel>> getRootCategories();

  /// æ ¹æ®çˆ¶ç±»åˆ«IDè·å–å­ç±»åˆ?
  Future<List<CategoryModel>> getCategoriesByParentId(int parentId);

  /// ç›‘å¬æ‰€æœ‰ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchAllCategories();

  /// ç›‘å¬æ ¹ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchRootCategories();

  /// ç›‘å¬æŒ‡å®šçˆ¶ç±»åˆ«çš„å­ç±»åˆ«å˜åŒ?
  Stream<List<CategoryModel>> watchCategoriesByParentId(int parentId);

  /// æ›´æ–°ç±»åˆ«
  Future<bool> updateCategory(CategoryModel category);

  /// åˆ é™¤ç±»åˆ«
  Future<int> deleteCategory(int id);

  /// æ£€æŸ¥ç±»åˆ«æ˜¯å¦æœ‰å­ç±»åˆ?
  Future<bool> hasSubCategories(int categoryId);

  /// æ£€æŸ¥ç±»åˆ«åç§°æ˜¯å¦å·²å­˜åœ¨ï¼ˆåœ¨åŒä¸€çˆ¶ç±»åˆ«ä¸‹ï¼?
  Future<bool> isCategoryNameExists(
    String name,
    int? parentId, {
    int? excludeId,
  });

  /// è·å–ç±»åˆ«å±‚çº§è·¯å¾„ï¼ˆä»æ ¹åˆ°æŒ‡å®šç±»åˆ«ï¼?
  Future<List<CategoryModel>> getCategoryPath(int categoryId);
}
import 'package:stocko_app/features/inventory/domain/model/batch.dart';

import '../model/product.dart';

/// äº§å“ä»“å‚¨æŠ½è±¡æ¥å£
/// å®šä¹‰äº§å“æ•°æ®è®¿é—®çš„æ ¸å¿ƒæ–¹æ³?
abstract class IProductRepository {
  /// æ·»åŠ äº§å“
  /// [product] è¦æ·»åŠ çš„äº§å“
  /// è¿”å›æ·»åŠ æˆåŠŸçš„äº§å“ID
  Future<int> addProduct(ProductModel product);

  /// æ›´æ–°äº§å“
  /// [product] è¦æ›´æ–°çš„äº§å“
  /// è¿”å›æ˜¯å¦æ›´æ–°æˆåŠŸ
  Future<bool> updateProduct(ProductModel product);

  /// åˆ é™¤äº§å“
  /// [id] äº§å“ID
  /// è¿”å›åˆ é™¤çš„è®°å½•æ•°
  Future<int> deleteProduct(int id);

  /// æ ¹æ®IDè·å–äº§å“
  /// [id] äº§å“ID
  /// è¿”å›äº§å“å¯¹è±¡ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
  Future<ProductModel?> getProductById(int id);

  /// ç›‘å¬æ‰€æœ‰äº§å“å˜åŒ?
  /// ä½¿ç”¨Streamå®æ—¶ç›‘å¬äº§å“åˆ—è¡¨çš„å˜åŒ?
  /// è¿”å›äº§å“åˆ—è¡¨çš„æ•°æ®æµ
  Stream<List<ProductModel>> watchAllProducts();

  /// ç›‘å¬æ‰€æœ‰äº§å“åŠå…¶å•ä½åç§?
  Stream<
    List<
      ({
        ProductModel product,
        int unitId,
        String unitName,
        int conversionRate,
        int? sellingPriceInCents,
        int? wholesalePriceInCents
      })
    >
  >
  watchAllProductsWithUnit();

  /// è·å–æ‰€æœ‰äº§å“?
  /// è¿”å›å½“å‰æ‰€æœ‰äº§å“çš„åˆ—è¡¨
  Future<List<ProductModel>> getAllProducts();

  /// æ ¹æ®æ¡ä»¶æŸ¥è¯¢äº§å“
  /// [categoryId] ç±»åˆ«ID
  /// [status] äº§å“çŠ¶æ€?
  /// [keyword] å…³é”®å­?
  /// è¿”å›ç¬¦åˆæ¡ä»¶çš„äº§å“åˆ—è¡?
  Future<List<ProductModel>> getProductsByCondition({
    int? categoryId,
    String? status,
    String? keyword,
  });

  /// ç›‘å¬æŒ‡å®šç±»åˆ«çš„äº§å“?
  /// [categoryId] ç±»åˆ«ID
  /// è¿”å›æŒ‡å®šç±»åˆ«äº§å“çš„æ•°æ®æµ
  Stream<List<ProductModel>> watchProductsByCategory(int categoryId);

  /// æ ¹æ®æ¡ç æŸ¥è¯¢äº§å“
  /// [barcode] æ¡ç 
  /// è¿”å›åŒ¹é…çš„äº§å“ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
  Future<ProductModel?> getProductByBarcode(String barcode);

  /// æ ¹æ®æ¡ç è·å–äº§å“åŠå…¶å•ä½ä¿¡æ¯
  /// [barcode] æ¡ç 
  /// è¿”å›åŒ…å«äº§å“å’Œå•ä½åç§°çš„ç»“æœï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
  Future<
    ({
      ProductModel product,
      int unitId,
      String unitName,
      int conversionRate,
      int? sellingPriceInCents,
      int? wholesalePriceInCents,
      int? averageUnitPriceInCents
    })?
  >
  getProductWithUnitByBarcode(String barcode);

  /// æ£€æŸ¥å•ä½æ˜¯å¦è¢«ä»»ä½•äº§å“ä½¿ç”¨
  /// [unitId] å•ä½ID
  /// è¿”å›å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºæ˜¯å¦è¢«ä½¿ç”?
  Future<bool> isUnitUsed(int unitId);
  /// æ ¹æ®è´§å“IDå’Œåº—é“ºIDè·å–æ‰¹æ¬¡
  Future<List<BatchModel>> getBatchesByProductAndShop(int productId, int shopId);
}
import '../model/product_unit.dart';

/// äº§å“å•ä½ä»“å‚¨æ¥å£
/// å®šä¹‰äº§å“å•ä½å…³è”ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IProductUnitRepository {
  /// æ·»åŠ äº§å“å•ä½
  Future<int> addProductUnit(UnitProduct unitProduct);

  /// æ‰¹é‡æ·»åŠ äº§å“å•ä½
  Future<void> addMultipleProductUnits(List<UnitProduct> productUnits);

  /// æ ¹æ®äº§å“å•ä½IDè·å–äº§å“å•ä½
  Future<UnitProduct?> getProductUnitById(int id);
  /// æ ¹æ®äº§å“IDè·å–æ‰€æœ‰äº§å“å•ä½?
  Future<List<UnitProduct>> getProductUnitsByProductId(int productId);

  /// è·å–æ‰€æœ‰äº§å“å•ä½?
  Future<List<UnitProduct>> getAllProductUnits();

  /// ç›‘å¬äº§å“çš„æ‰€æœ‰å•ä½å˜åŒ?
  Stream<List<UnitProduct>> watchProductUnitsByProductId(int productId);

  /// æ›´æ–°äº§å“å•ä½
  Future<bool> updateProductUnit(UnitProduct unitProduct);

  /// åˆ é™¤äº§å“å•ä½
  Future<int> deleteProductUnit(int id);

  /// åˆ é™¤äº§å“çš„æ‰€æœ‰å•ä½?
  Future<int> deleteProductUnitsByProductId(int productId);

  /// æ£€æŸ¥äº§å“æ˜¯å¦å·²é…ç½®æŸä¸ªå•ä½
  Future<bool> isUnitConfiguredForProduct(int productId, int unitId);

  /// è·å–äº§å“çš„åŸºç¡€å•ä½
  Future<UnitProduct?> getBaseUnitForProduct(int productId);

  /// æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½?
  Future<void> upsertProductUnit(UnitProduct unitProduct);

  /// æ‰¹é‡æ›´æ–°æˆ–æ’å…¥äº§å“å•ä½?
  Future<void> upsertMultipleProductUnits(List<UnitProduct> productUnits);

  /// æ›¿æ¢äº§å“çš„æ‰€æœ‰å•ä½é…ç½?
  /// è¿™ä¼šåˆ é™¤äº§å“çš„ç°æœ‰å•ä½é…ç½®ï¼Œç„¶åæ·»åŠ æ–°çš„é…ç½®
  Future<void> replaceProductUnits(
    int productId,
    List<UnitProduct> productUnits,
  );
}
import '../model/unit.dart';

/// å•ä½ä»“å‚¨æ¥å£
/// å®šä¹‰å•ä½ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒ?
abstract class IUnitRepository {
  /// æ·»åŠ å•ä½
  Future<Unit> addUnit(Unit unit);

  /// æ ¹æ®IDè·å–å•ä½
  Future<Unit?> getUnitById(int id);

  /// æ ¹æ®åç§°è·å–å•ä½
  Future<Unit?> getUnitByName(String name);

  /// è·å–æ‰€æœ‰å•ä½?
  Future<List<Unit>> getAllUnits();

  /// ç›‘å¬æ‰€æœ‰å•ä½å˜åŒ?
  Stream<List<Unit>> watchAllUnits();

  /// æ›´æ–°å•ä½
  Future<bool> updateUnit(Unit unit);

  /// åˆ é™¤å•ä½
  Future<int> deleteUnit(int id);

  /// æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨
  Future<bool> isUnitNameExists(String name, [int? excludeId]);

  /// æ‰¹é‡æ’å…¥é»˜è®¤å•ä½
  Future<void> insertDefaultUnits();
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/services/barcode_scanner_service.dart';
import '../../../../core/shared_widgets/shared_widgets.dart';
import '../../domain/model/category.dart';
import '../../domain/model/unit.dart';
import '../../domain/model/product_unit.dart';
import '../../application/provider/unit_providers.dart';
import '../../application/provider/unit_edit_form_providers.dart';
import '../navigation/product_form_coordinator.dart';
import '../state/product_form_ui_provider.dart';
import 'product_add_edit_controller.dart';

class ProductAddEditActions {
  final WidgetRef ref;
  final BuildContext context;
  final int? productId;

  ProductAddEditActions({
    required this.ref,
    required this.context,
    required this.productId,
  });

  /// æ‰«ææ¡ç å¹¶æ›´æ–°ä¼ å…¥çš„ TextEditingController
  Future<void> scanBarcode(TextEditingController barcodeController, {
    FocusNode? nextFocus,
  }) async {
    try {
      final String? barcode = await BarcodeScannerService.scanForProduct(context);
      if (barcode != null && barcode.isNotEmpty) {
        barcodeController.text = barcode;
        ToastService.success('âœ?æ¡ç æ‰«ææˆåŠŸ: $barcode');
        nextFocus?.requestFocus();
      }
    } catch (e) {
      ToastService.error('â?æ‰«ç å¤±è´¥: $e');
    }
  }

  /// é€‰æ‹©ç±»åˆ«
  Future<void> chooseCategory({
    required int? selectedCategoryId,
    required void Function(CategoryModel c) onPicked,
  }) async {
    final CategoryModel? selectedCategory = await ProductFormCoordinator.chooseCategory(
      context,
      ref,
      selectedCategoryId: selectedCategoryId,
    );
    if (selectedCategory != null) {
      onPicked(selectedCategory);
    }
  }

  /// é€‰æ‹©å•ä½ï¼ˆä»åˆ—è¡¨ï¼?
  Future<void> chooseUnit({
    required int? selectedUnitId,
    required void Function(Unit u) onPicked,
  }) async {
    final allUnits = ref.read(allUnitsProvider).value ?? [];
    final Unit? selectedUnit = await ProductFormCoordinator.chooseUnit(
      context,
      allUnits,
      selectedUnitId: selectedUnitId,
    );
    if (selectedUnit != null) {
      onPicked(selectedUnit);
    }
  }

  /// ç¼–è¾‘è¾…å•ä½?
  Future<void> editAuxUnits({
    required int? currentUnitId,
    required String currentUnitName,
  }) async {
    // âœ?æ ‡è®°ç”¨æˆ·å·²è¿›å…¥è¾…å•ä½ç¼–è¾‘é¡µé¢
    ref.read(productFormUiProvider.notifier).setHasEnteredAuxUnitPage(true);
    
    final dynamic result = await ProductFormCoordinator.editAuxiliaryUnits(
      context,
      ref,
      productId: productId,
      currentUnitId: currentUnitId,
      currentUnitName: currentUnitName,
    );

    if (result == null) return;

    List<UnitProduct>? productUnits;
    List<Map<String, String>>? auxiliaryBarcodes;

    if (result is Map<String, dynamic>) {
      productUnits = result['productUnits'] as List<UnitProduct>?;
      auxiliaryBarcodes = result['auxiliaryBarcodes'] as List<Map<String, String>>?;
    } else if (result is List<UnitProduct>) {
      productUnits = result;
    }

    if (productUnits != null && productUnits.isNotEmpty) {
      // ä¿å­˜åˆ?UI çŠ¶æ€?
      ref.read(productFormUiProvider.notifier).setProductUnitsAndBarcodes(
            productUnits: productUnits,
            auxiliaryUnitBarcodes: auxiliaryBarcodes,
          );

      // æ‰¾åˆ°åŸºç¡€å•ä½
      final List<UnitProduct> units = productUnits; // éç©ºæ–­è¨€åèµ‹å€?
      final baseProductUnit = units.firstWhere(
        (unit) => unit.conversionRate == 1.0,
        orElse: () => units.first,
      );
      ref.read(productFormUiProvider.notifier).setUnitId(baseProductUnit.unitId);
    }
  }

  /// æäº¤è¡¨å•
  Future<void> submitForm({
    required GlobalKey<FormState> formKey,
    required TextEditingController nameController,
    required TextEditingController categoryController,
    required TextEditingController unitController,
    required TextEditingController barcodeController,
    required TextEditingController retailPriceController,
    required TextEditingController promotionalPriceController,
    required TextEditingController suggestedRetailPriceController,
    required TextEditingController stockWarningValueController,
    required TextEditingController shelfLifeController,
    required void Function() onSuccess,
    required void Function(String message) onError,
  }) async {
    if (!formKey.currentState!.validate()) return;

    // åŸºæœ¬å•ä½æ ¡éªŒ
    if (unitController.text.trim().isEmpty) {
      onError('â?åŸºæœ¬å•ä½ä¸èƒ½ä¸ºç©º');
      return;
    }

    // è¾…å•ä½æ¢ç®—ç‡æ ¡éªŒ
    final formState = ref.read(unitEditFormProvider);
    if (formState.auxiliaryUnits.isNotEmpty) {
      for (final auxUnit in formState.auxiliaryUnits) {
        if (auxUnit.unitName.trim().isNotEmpty && auxUnit.conversionRate <= 0) {
          onError('â?è¾…å•ä½æ¢ç®—ç‡ä¸èƒ½ä¸ºç©º');
          return;
        }
      }
    }

    // æ‰¹æ¬¡å¼€å…³æ¨å¯?
    final shelfLife = int.tryParse(shelfLifeController.text.trim());
    final enableBatch = shelfLife != null && shelfLife > 0;
    ref.read(productFormUiProvider.notifier).setEnableBatchManagement(enableBatch);

    // æ¡ç æ•°æ®
    final ui = ref.read(productFormUiProvider);
    List<AuxiliaryUnitBarcodeData>? auxiliaryBarcodeData;
    if (ui.auxiliaryUnitBarcodes != null && ui.auxiliaryUnitBarcodes!.isNotEmpty) {
      auxiliaryBarcodeData = ui.auxiliaryUnitBarcodes!
          .map((item) => AuxiliaryUnitBarcodeData(
                // æŸäº›ä¸´æ—¶IDå¯èƒ½åŒ…å«ä¸‹åˆ’çº¿ç­‰éæ•°å­—å­—ç¬¦ï¼Œä¾‹å¦‚ "1757666934778_8"ï¼?
                // ä¸ºé¿å…?int.parse æŠ›å‡ºå¼‚å¸¸ï¼Œè¿™é‡Œå…ˆç§»é™¤éæ•°å­—å­—ç¬¦å†å°è¯•è§£æï¼Œå¤±è´¥åˆ™ç½®ä¸º 0ã€?
                id: int.tryParse(
                      (item['id'] ?? '')
                          .replaceAll(RegExp(r'[^0-9]'), ''),
                    ) ??
                    0,
                barcode: item['barcode'] ?? '',
              ))
          .toList();
    }

    final formData = ProductFormData(
      productId: productId,
      name: nameController.text.trim(),
      selectedCategoryId: ui.selectedCategoryId,
      newCategoryName: categoryController.text.trim(),
      selectedUnitId: ui.selectedUnitId,
      newUnitName: unitController.text.trim(),
      imagePath: ui.selectedImagePath,
      barcode: barcodeController.text.trim(),
      retailPriceInCents: double.tryParse(retailPriceController.text.trim()),
      promotionalPriceInCents: double.tryParse(promotionalPriceController.text.trim()),
      suggestedRetailPriceInCents: double.tryParse(suggestedRetailPriceController.text.trim()),
      stockWarningValue: int.tryParse(stockWarningValueController.text.trim()) ?? 5,
      shelfLife: int.tryParse(shelfLifeController.text.trim()),
      shelfLifeUnit: ui.shelfLifeUnit,
      enableBatchManagement: ui.enableBatchManagement,
      productUnits: ui.productUnits,
      auxiliaryUnitBarcodes: auxiliaryBarcodeData,
    );

    try {
      final controller = ref.read(productAddEditControllerProvider);
      final result = await controller.submitForm(formData);
      if (result.success) {
        ToastService.success('âœ?${result.message ?? 'æ“ä½œæˆåŠŸ'}');
        // æäº¤æˆåŠŸï¼Œæ¸…ç©ºè¾…å•ä½ä¸´æ—¶è¡¨å•çŠ¶æ€ï¼Œé¿å…ä¸‹æ¬¡è¿›å…¥ä¸²æ•°æ?
        ref.read(unitEditFormProvider.notifier).resetUnitEditForm();
        onSuccess();
      } else {
        onError('â?${result.message ?? 'æ“ä½œå¤±è´¥'}');
      }
    } catch (e) {
      onError('â?æ“ä½œå¤±è´¥: $e');
    }
  }
}
// lib/features/product/presentation/controllers/product_add_edit_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/model/product.dart';
import '../../domain/model/category.dart';
import '../../domain/model/unit.dart';
import '../../domain/model/product_unit.dart';
import '../../domain/model/barcode.dart';
import '../../domain/model/auxiliary_unit_data.dart';

import '../../application/category_notifier.dart';
import '../../application/provider/product_providers.dart';
import '../../application/provider/unit_providers.dart';
import '../../application/provider/product_unit_providers.dart';
import '../../application/provider/barcode_providers.dart';
import '../../application/category_service.dart';
import '../../application/provider/unit_edit_form_providers.dart';
import '../../data/repository/product_unit_repository.dart';
import '../state/product_form_ui_provider.dart';

/// è¾…å•ä½æ¡ç æ•°æ?
class AuxiliaryUnitBarcodeData {
  final int id;
  final String barcode;

  const AuxiliaryUnitBarcodeData({required this.id, required this.barcode});
}

/// è¡¨å•æ•°æ®å°è£…
class ProductFormData {
  final int? productId;
  final String name;
  final int? selectedCategoryId;
  final String newCategoryName;
  final int? selectedUnitId;
  final String newUnitName;
  final String? imagePath;
  final String barcode;
  // ä»·æ ¼ï¼ˆå…ƒï¼?
  final double? retailPriceInCents;
  final double? promotionalPriceInCents;
  final double? suggestedRetailPriceInCents;
  final int? stockWarningValue;
  final int? shelfLife;
  final String shelfLifeUnit;
  final bool enableBatchManagement;
  final String? remarks;
  final List<UnitProduct>? productUnits;
  final List<AuxiliaryUnitBarcodeData>? auxiliaryUnitBarcodes;

  const ProductFormData({
    this.productId,
    required this.name,
    this.selectedCategoryId,
    this.newCategoryName = '',
    this.selectedUnitId,
    this.newUnitName = '',
    this.imagePath,
    this.barcode = '',
    this.retailPriceInCents,
    this.promotionalPriceInCents,
    this.suggestedRetailPriceInCents,
    this.stockWarningValue,
    this.shelfLife,
    this.shelfLifeUnit = 'months',
    this.enableBatchManagement = false,
    this.remarks,
    this.productUnits,
    this.auxiliaryUnitBarcodes,
  });
}

/// æ“ä½œç»“æœ
class ProductOperationResult {
  final bool success;
  final String? message;
  final ProductModel? product;

  const ProductOperationResult._(this.success, {this.message, this.product});

  factory ProductOperationResult.success({
    String? message,
    ProductModel? product,
  }) => ProductOperationResult._(true, message: message, product: product);

  factory ProductOperationResult.failure(String message) =>
      ProductOperationResult._(false, message: message);
}

/// Controller æä¾›è€?
final productAddEditControllerProvider = Provider<ProductAddEditController>(
  (ref) => ProductAddEditController(ref),
);

/// äº§å“æ·»åŠ /ç¼–è¾‘æ§åˆ¶å™?
class ProductAddEditController {
  final Ref ref;
  ProductAddEditController(this.ref);

  /// æäº¤è¡¨å•å¹¶è¿”å›æ“ä½œç»“æ?
  Future<ProductOperationResult> submitForm(ProductFormData data) async {
    try {
      // 1. å¤„ç†ç±»åˆ«
      int? categoryId = data.selectedCategoryId;
      if ((categoryId == null) && data.newCategoryName.trim().isNotEmpty) {
        final categoryNotifier = ref.read(categoryListProvider.notifier);
        await categoryNotifier.loadCategories();
        final categories = ref.read(categoryListProvider).categories;
        CategoryModel? existingCat;
        try {
          existingCat = categories.firstWhere(
            (c) =>
                c.name.toLowerCase() ==
                data.newCategoryName.trim().toLowerCase(),
          );
        } catch (e) {
          existingCat = null;
        }
        if (existingCat != null) {
          categoryId = existingCat.id;
        } else {
          // è°ƒè¯•ä¿¡æ¯
          print('ğŸ” [DEBUG] åˆ›å»ºæ–°ç±»åˆ? "${data.newCategoryName.trim()}"');

          final service = ref.read(categoryServiceProvider);
          categoryId = await service.addCategory(
            name: data.newCategoryName.trim(),
          );

          // è°ƒè¯•ä¿¡æ¯
          print('ğŸ” [DEBUG] æ–°ç±»åˆ«åˆ›å»ºæˆåŠŸï¼ŒID: $categoryId');

          // ç«‹å³åˆ·æ–°ç±»åˆ«ç¼“å­˜ï¼Œç¡®ä¿æ–°ç±»åˆ«åœ¨ç¼–è¾‘æ—¶å¯è§
          ref.invalidate(categoryListProvider);
        }
      }

      // 2. å¤„ç†å•ä½
      int? unitId = data.selectedUnitId;
      if (unitId == null && data.newUnitName.trim().isNotEmpty) {
        final units = ref
            .read(allUnitsProvider)
            .maybeWhen(data: (u) => u, orElse: () => <Unit>[]);
        Unit? existingUnit;
        existingUnit = units
            .where(
              (u) =>
                  u.name.toLowerCase() == data.newUnitName.trim().toLowerCase(),
            )
            .firstOrNull;

        if (existingUnit != null) {
          unitId = existingUnit.id;
        } else {
          final unitCtrl = ref.read(unitControllerProvider.notifier);
          final newUnit = await unitCtrl.addUnit(
            Unit(name: data.newUnitName.trim()),
          );
          unitId = newUnit.id;
        }
      }
      if (unitId == null) {
        return ProductOperationResult.failure('è¯·é€‰æ‹©è®¡é‡å•ä½');
      }

      // 2.1 å¤„ç†è¾…å•ä½?- æ£€æŸ¥å¹¶æ’å…¥æ–°çš„è¾…å•ä½åˆ°å•ä½è¡?
      await _processAuxiliaryUnits(data.productUnits);

      // 3. æ„å»ºäº§å“å¯¹è±¡
      Money? toMoney(double? yuan) =>
          yuan == null ? null : Money((yuan * 100).round());

      // è°ƒè¯•ä¿¡æ¯
      print('ğŸ” [DEBUG] ==================== åˆ›å»ºäº§å“ ====================');
      print('ğŸ” [DEBUG] äº§å“åç§°: "${data.name.trim()}"');
      print('ğŸ” [DEBUG] é€‰ä¸­çš„ç±»åˆ«ID: ${data.selectedCategoryId}');
      print('ğŸ” [DEBUG] æ–°ç±»åˆ«åç§? "${data.newCategoryName.trim()}"');
      print('ğŸ” [DEBUG] æœ€ç»ˆç±»åˆ«ID: $categoryId');
      print('ğŸ” [DEBUG] å•ä½ID: $unitId');

      final product = ProductModel(
        id: data.productId ?? DateTime.now().millisecondsSinceEpoch,
        // ç¡®ä¿idä¸ºæ•´æ•°ç±»å?
        name: data.name.trim(),
        image: data.imagePath,
        categoryId: categoryId,
        baseUnitId: unitId,
        // å¯é€‰å­—æ®µæŒ‰éœ€ä¼ å…¥
        suggestedRetailPrice: toMoney(data.suggestedRetailPriceInCents),
        retailPrice: toMoney(data.retailPriceInCents),
        promotionalPrice: toMoney(data.promotionalPriceInCents),
        stockWarningValue: data.stockWarningValue,
        shelfLife: data.shelfLife,
        shelfLifeUnit: ShelfLifeUnit.values.byName(data.shelfLifeUnit),
        enableBatchManagement: data.enableBatchManagement,
        remarks: data.remarks?.trim(),
        lastUpdated: DateTime.now(),
      );

      // 4. ä¿å­˜äº§å“
      final ops = ref.read(productOperationsProvider.notifier);
      if (data.productId == null) {
        await ops.addProduct(product);
      } else {
        await ops.updateProduct(product);
      }

      // 5. ä¿å­˜å•ä½é…ç½®
      await _saveProductUnits(product, data.productUnits);

      // 6. ä¿å­˜ä¸»æ¡ç ?
      await _saveMainBarcode(product, data.barcode);

      // 7. ä¿å­˜è¾…å•ä½æ¡ç ?
      await _saveAuxiliaryUnitBarcodes(product, data.auxiliaryUnitBarcodes);

      // ä¿®å¤ï¼šåœ¨æ‰€æœ‰æ•°æ®åº“æ“ä½œï¼ˆåŒ…æ‹¬å•ä½å’Œæ¡ç ï¼‰å®Œæˆåï¼Œå†æ¬¡å¼ºåˆ¶åˆ·æ–°äº§å“åˆ—è¡¨ï¼Œ
      // ç¡®ä¿UIè·å–åˆ°åŒ…å«æœ€æ–°å•ä½ä¿¡æ¯çš„è´§å“æ•°æ®ã€?
      ref.invalidate(allProductsProvider);
      // å…³é”®ä¿®å¤ï¼šåŒæ—¶ä½¿ä¸»æ¡ç çš„Providerå¤±æ•ˆï¼Œä»¥ä¾¿ä¸‹æ¬¡è¿›å…¥é¡µé¢æ—¶èƒ½é‡æ–°è·å?
      ref.invalidate(mainBarcodeProvider(product.id!));
      // ç¡®ä¿ç±»åˆ«åˆ—è¡¨ä¹Ÿè¢«åˆ·æ–°ï¼Œä»¥ä¾¿ç¼–è¾‘é¡µé¢èƒ½æ­£ç¡®æ˜¾ç¤ºæ–°åˆ›å»ºçš„ç±»åˆ«
      ref.invalidate(categoryListProvider);

      return ProductOperationResult.success(
        message: data.productId == null ? 'åˆ›å»ºæˆåŠŸ' : 'æ›´æ–°æˆåŠŸ',
        product: product,
      );
    } catch (e) {
      return ProductOperationResult.failure('ä¿å­˜å¤±è´¥: ${e.toString()}');
    }
  }

  /// ä¿å­˜æˆ–æ›¿æ¢äº§å“å•ä½é…ç½?
  Future<void> _saveProductUnits(
    ProductModel product,
    List<UnitProduct>? units,
  ) async {
    print('ğŸ” [DEBUG] ==================== å¼€å§‹ä¿å­˜äº§å“å•ä½?====================');
    print('ğŸ” [DEBUG] äº§å“ID: ${product.id}');
    print('ğŸ” [DEBUG] ä¼ å…¥å•ä½æ•°é‡: ${units?.length ?? 0}');

    if (units != null && units.isNotEmpty) {
      print('ğŸ” [DEBUG] --- ä¼ å…¥çš„å•ä½åˆ—è¡?---');
      for (int i = 0; i < units.length; i++) {
        final unit = units[i];
        print(
          'ğŸ” [DEBUG] å•ä½ ${i + 1}: ${unit.id} (æ¢ç®—ç? ${unit.conversionRate})',
        );
      }
    }

    // è·å– UI çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦è¿›å…¥è¿‡è¾…å•ä½ç¼–è¾‘é¡µé?
    final uiState = ref.read(productFormUiProvider);
    final hasEnteredAuxUnitPage = uiState.hasEnteredAuxUnitPage;
    print('ğŸ” [DEBUG] æ˜¯å¦è¿›å…¥è¿‡è¾…å•ä½é¡µé¢: $hasEnteredAuxUnitPage');

    List<AuxiliaryUnitData> auxiliaryUnits;

    if (hasEnteredAuxUnitPage) {
      // âœ?ç”¨æˆ·è¿›å…¥è¿‡è¾…å•ä½ç¼–è¾‘é¡µé¢ï¼Œä»è¡¨å•çŠ¶æ€è·å–æ•°æ?
      print('ğŸ” [DEBUG] ä»è¡¨å•çŠ¶æ€è·å–è¾…å•ä½æ•°æ®');
      final formState = ref.read(unitEditFormProvider);
      auxiliaryUnits = formState.auxiliaryUnits;
      print('ğŸ” [DEBUG] è¡¨å•ä¸­è¾…å•ä½æ•°é‡: ${auxiliaryUnits.length}');
    } else if (product.id != null) {
      // âœ?ç”¨æˆ·æœªè¿›å…¥è¾…å•ä½ç¼–è¾‘é¡µé¢ä¸”æ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œä»æ•°æ®åº“åŠ è½½ç°æœ‰è¾…å•ä½
      print('ğŸ” [DEBUG] ä»æ•°æ®åº“åŠ è½½ç°æœ‰è¾…å•ä½æ•°æ?);
      auxiliaryUnits = await _loadExistingAuxiliaryUnits(product.id!);
      print('ğŸ” [DEBUG] ä»æ•°æ®åº“åŠ è½½äº?${auxiliaryUnits.length} ä¸ªè¾…å•ä½');
    } else {
      // æ–°å¢æ¨¡å¼ä¸”æœªè¿›å…¥è¾…å•ä½é¡µé?
      print('ğŸ” [DEBUG] æ–°å¢æ¨¡å¼ï¼Œæ— è¾…å•ä½æ•°æ?);
      auxiliaryUnits = [];
    }

    final ctrl = ref.read(productUnitControllerProvider.notifier);
    final list = <UnitProduct>[];

    // æ·»åŠ åŸºç¡€å•ä½
    list.add(
      UnitProduct(
        productId: product.id!,
        unitId: product.baseUnitId,
        conversionRate: 1,
      ),
    );

    // ç›´æ¥ä»providerè·å–æœ€æ–°çš„å•ä½åˆ—è¡¨ï¼?futureä¼šè‡ªåŠ¨å¤„ç†åŠ è½½çŠ¶æ€?
    final allUnits = await ref.read(allUnitsProvider.future);
    print('ğŸ” [DEBUG] åˆ·æ–°åå•ä½æ€»æ•°: ${allUnits.length}');

    for (final auxUnit in auxiliaryUnits) {
      final unitName = auxUnit.unitName.trim();
      print('ğŸ” [DEBUG] å¤„ç†è¾…å•ä½? "$unitName", æ¢ç®—ç? ${auxUnit.conversionRate}');

      if (unitName.isEmpty) {
        print('ğŸ” [DEBUG] å•ä½åç§°ä¸ºç©ºï¼Œè·³è¿?);
        continue;
      }

      Unit? unit;
      try {
        unit = allUnits
            .where((u) => u.name.toLowerCase() == unitName.toLowerCase())
            .firstOrNull;
      } catch (e) {
        unit = null;
      }

      // å¦‚æœåœ¨è¿™é‡Œæ‰¾ä¸åˆ°å•ä½ï¼Œè¯´æ˜æœ‰ä¸€ä¸ªè¾…å•ä½çš„åç§°åœ¨å•ä½è¡¨ä¸­ä¸å­˜åœ¨ï¼Œ
      // è¿™åœ¨æ­£å¸¸æµç¨‹ä¸‹ä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºæ‰€æœ‰æ–°å•ä½éƒ½åº”åœ¨_processAuxiliaryUnitsä¸­è¢«æ·»åŠ ã€?
      // å› æ­¤ï¼Œè¿™æ˜¯ä¸€ä¸ªå…³é”®é”™è¯¯ï¼Œéœ€è¦æŠ›å‡ºå¼‚å¸¸è€Œä¸æ˜¯é™é»˜å¤±è´¥ã€?
      if (unit != null && unit.id != null) {
        list.add(
          UnitProduct(
            productId: product.id!,
            unitId: unit.id!,
            conversionRate: auxUnit.conversionRate,
            sellingPriceInCents: auxUnit.retailPriceInCents.trim().isNotEmpty
                ? int.tryParse(auxUnit.retailPriceInCents.trim())
                : null,
            wholesalePriceInCents:
                auxUnit.wholesalePriceInCents.trim().isNotEmpty
                ? int.tryParse(auxUnit.wholesalePriceInCents.trim())
                : null,
          ),
        );
        print(
          'ğŸ” [DEBUG] âœ?æ·»åŠ è¾…å•ä½? ${unit.name} (ID: ${unit.id}, æ¢ç®—ç? ${auxUnit.conversionRate})',
        );
      } else {
        print('ğŸ” [DEBUG] â?åœ¨_saveProductUnitsä¸­æœªæ‰¾åˆ°å•ä½: "$unitName"');
        // è¿™æ˜¯ä¸€ä¸ªå…³é”®é”™è¯¯ï¼Œæ„å‘³ç€åœ¨è¡¨å•æäº¤æ—¶ï¼Œä¸€ä¸ªé¢„æœŸçš„å•ä½æ²¡æœ‰è¢«æ­£ç¡®åˆ›å»ºæˆ–æ‰¾åˆ°ã€?
        // æŠ›å‡ºå¼‚å¸¸ä»¥é˜»æ­¢ä¸å®Œæ•´çš„æ•°æ®è¢«ä¿å­˜ã€?
        throw Exception('ä¿å­˜äº§å“å•ä½å¤±è´¥ï¼šæ— æ³•æ‰¾åˆ°å•ä½?"$unitName"ã€‚è¯·æ£€æŸ¥å•ä½æ˜¯å¦å·²æ­£ç¡®æ·»åŠ ã€?);
      }
    }

    print('ğŸ” [DEBUG] --- æœ€ç»ˆä¿å­˜çš„å•ä½åˆ—è¡¨ ---');
    for (int i = 0; i < list.length; i++) {
      final unit = list[i];
      print(
        'ğŸ” [DEBUG] ä¿å­˜å•ä½ ${i + 1}: ${unit.id} (æ¢ç®—ç? ${unit.conversionRate})',
      );
    }

    try {
      await ctrl.replaceProductUnits(product.id!, list);
      print('ğŸ” [DEBUG] âœ?äº§å“å•ä½ä¿å­˜æˆåŠŸ');
    } catch (e) {
      print('ğŸ” [DEBUG] â?äº§å“å•ä½ä¿å­˜å¤±è´¥: $e');
      rethrow;
    }

    print('ğŸ” [DEBUG] ==================== äº§å“å•ä½ä¿å­˜å®Œæˆ ====================');
  }

  /// ä¿å­˜ä¸»æ¡ç ?
  Future<void> _saveMainBarcode(ProductModel product, String barcode) async {
    final code = barcode.trim();
    final barcodeCtrl = ref.read(barcodeControllerProvider.notifier);
    final productUnitRepository = ref.read(productUnitRepositoryProvider);

    // 1. æ‰¾åˆ°æ–°çš„åŸºç¡€äº§å“å•ä½ID (åœ?_saveProductUnits æ‰§è¡Œå?
    final productUnitController = ref.read(
      productUnitControllerProvider.notifier,
    );
    final productUnits = await productUnitController.getProductUnitsByProductId(
      product.id!,
    );
    final baseProductUnit = productUnits
        .where((pu) => pu.conversionRate == 1.0)
        .firstOrNull;
    if (baseProductUnit == null) {
      throw Exception('ä¿å­˜ä¸»æ¡ç å¤±è´¥ï¼šæœªæ‰¾åˆ°åŸºç¡€äº§å“å•ä½ã€?);
    }
    final baseUnitProductId = baseProductUnit.id!;

    // 2. æŸ¥æ‰¾ä¸è¾“å…¥æ¡ç åŒ¹é…çš„ç°æœ‰æ¡ç 
    final existingBarcode = code.isEmpty
        ? null
        : await barcodeCtrl.getBarcodeByValue(code);

    // 3. éªŒè¯æ¡ç æ˜¯å¦è¢«å…¶ä»–è´§å“å ç”?
    if (existingBarcode != null) {
      // é€šè¿‡ unitProductId æ‰¾åˆ°å¯¹åº”çš?product_unit è®°å½•
      final productUnit = await productUnitRepository.getProductUnitById(
        existingBarcode.unitProductId,
      );
      // å¦‚æœèƒ½æ‰¾åˆ?product_unit è®°å½•ï¼Œå¹¶ä¸”å…¶ productId ä¸æ˜¯å½“å‰äº§å“çš?IDï¼Œåˆ™è¯´æ˜æ¡ç è¢«å ç”?
      if (productUnit != null && productUnit.productId != product.id) {
        throw Exception('æ¡ç  "$code" å·²è¢«å…¶ä»–è´§å“ä½¿ç”¨ï¼Œæ— æ³•é‡å¤æ·»åŠ ã€?);
      }
    }

    // 4. æŸ¥æ‰¾ä¸å½“å‰äº§å“å…³è”çš„æ‰€æœ‰æ¡ç ï¼Œå¹¶æ‰¾åˆ°ä¸»æ¡ç 
    // ç”±äº unit_id å·²å˜ï¼Œç›´æ¥æŸ¥æ‰¾ä¼šå¾ˆå›°éš¾ã€‚æˆ‘ä»¬è½¬è€Œå¤„ç†ä¸å½“å‰äº§å“å…³è”çš„æ‰€æœ‰æ¡ç ã€?
    // æ­¤å¤„ç®€åŒ–é€»è¾‘ï¼šæˆ‘ä»¬ä¿¡ä»»éªŒè¯æ­¥éª¤ï¼Œå¹¶ç›´æ¥è¿›è¡?upsert æ“ä½œã€?
    // æˆ‘ä»¬éœ€è¦å…ˆåˆ é™¤æ‰€æœ‰ä¸è¯¥äº§å“åŸºç¡€å•ä½æ— å…³çš„æ¡ç ï¼ˆå³æ—§çš„æ¡ç ï¼‰ã€?
    // è¿™éƒ¨åˆ†é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œæš‚æ—¶çš„ä¿®å¤æ–¹æ¡ˆæ˜¯åªå¤„ç†å½“å‰æ¡ç çš„æ›´æ–°ã€?

    // 5. åŒæ­¥ä¸»æ¡ç ?
    if (code.isEmpty) {
      // å¦‚æœè¾“å…¥ä¸ºç©ºï¼Œåˆ™åˆ é™¤ç°æœ‰çš„ä¸»æ¡ç ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      if (existingBarcode != null &&
          existingBarcode.unitProductId == baseUnitProductId) {
        await barcodeCtrl.deleteBarcode(existingBarcode.id!);
      }
    } else {
      // è¾“å…¥ä¸ä¸ºç©?
      if (existingBarcode != null) {
        // æ¡ç å·²å­˜åœ¨ï¼ˆéªŒè¯å·²ç¡®è®¤å®ƒå±äºå½“å‰äº§å“ï¼‰ï¼Œæ›´æ–°å…?unitProductId æŒ‡å‘æ–°çš„åŸºç¡€å•ä½
        if (existingBarcode.unitProductId != baseUnitProductId) {
          await barcodeCtrl.updateBarcode(
            existingBarcode.copyWith(unitProductId: baseUnitProductId),
          );
        }
      } else {
        // æ¡ç ä¸å­˜åœ¨ï¼Œæ·»åŠ æ–°æ¡ç ?
        await barcodeCtrl.addBarcode(
          BarcodeModel(unitProductId: baseUnitProductId, barcodeValue: code),
        );
      }
    }
  }

  /// ä¿å­˜è¾…å•ä½æ¡ç ?
  Future<void> _saveAuxiliaryUnitBarcodes(
    ProductModel product,
    List<AuxiliaryUnitBarcodeData>? auxiliaryBarcodes,
  ) async {
    print('ğŸ” [DEBUG] ==================== å¼€å§‹ä¿å­˜è¾…å•ä½æ¡ç  ====================');

    // è·å– UI çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦è¿›å…¥è¿‡è¾…å•ä½ç¼–è¾‘é¡µé?
    final uiState = ref.read(productFormUiProvider);
    final hasEnteredAuxUnitPage = uiState.hasEnteredAuxUnitPage;
    print('ğŸ” [DEBUG] æ˜¯å¦è¿›å…¥è¿‡è¾…å•ä½é¡µé¢: $hasEnteredAuxUnitPage');

    List<AuxiliaryUnitData> auxiliaryUnits;

    if (hasEnteredAuxUnitPage) {
      // âœ?ç”¨æˆ·è¿›å…¥è¿‡è¾…å•ä½ç¼–è¾‘é¡µé¢ï¼Œä»è¡¨å•çŠ¶æ€è·å–æ•°æ?
      print('ğŸ” [DEBUG] ä»è¡¨å•çŠ¶æ€è·å–è¾…å•ä½æ¡ç æ•°æ®');
      final formState = ref.read(unitEditFormProvider);
      auxiliaryUnits = formState.auxiliaryUnits;
      print('ğŸ” [DEBUG] è¡¨å•ä¸­è¾…å•ä½æ•°é‡: ${auxiliaryUnits.length}');
    } else if (product.id != null) {
      // âœ?ç”¨æˆ·æœªè¿›å…¥è¾…å•ä½ç¼–è¾‘é¡µé¢ä¸”æ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œä»æ•°æ®åº“åŠ è½½ç°æœ‰è¾…å•ä½
      print('ğŸ” [DEBUG] ä»æ•°æ®åº“åŠ è½½ç°æœ‰è¾…å•ä½æ¡ç æ•°æ?);
      auxiliaryUnits = await _loadExistingAuxiliaryUnits(product.id!);
      print('ğŸ” [DEBUG] ä»æ•°æ®åº“åŠ è½½äº?${auxiliaryUnits.length} ä¸ªè¾…å•ä½');
    } else {
      // æ–°å¢æ¨¡å¼ä¸”æœªè¿›å…¥è¾…å•ä½é¡µé?
      print('ğŸ” [DEBUG] æ–°å¢æ¨¡å¼ï¼Œæ— è¾…å•ä½æ¡ç æ•°æ?);
      auxiliaryUnits = [];
    }

    if (auxiliaryUnits.isEmpty) {
      print('ğŸ” [DEBUG] æ²¡æœ‰è¾…å•ä½æ•°æ®ï¼Œè·³è¿‡æ¡ç ä¿å­˜');
      return;
    }

    // è·å–å·²ä¿å­˜çš„äº§å“å•ä½ä¿¡æ¯
    final productUnitController = ref.read(
      productUnitControllerProvider.notifier,
    );
    final productUnits = await productUnitController.getProductUnitsByProductId(
      product.id!,
    );

    final ctrl = ref.read(barcodeControllerProvider.notifier);
    final barcodes = <BarcodeModel>[];

    for (final auxUnit in auxiliaryUnits) {
      final code = auxUnit.barcode.trim();
      if (code.isEmpty) {
        print('ğŸ” [DEBUG] è¾…å•ä½?"${auxUnit.unitName}" æ¡ç ä¸ºç©ºï¼Œè·³è¿?);
        continue;
      }

      // é€šè¿‡å•ä½åç§°å’Œæ¢ç®—ç‡æŸ¥æ‰¾å¯¹åº”çš„äº§å“å•ä½ID
      final allUnits = ref
          .read(allUnitsProvider)
          .maybeWhen(data: (u) => u, orElse: () => <Unit>[]);
      Unit? targetUnit;
      try {
        targetUnit = allUnits
            .where(
              (u) =>
                  u.name.toLowerCase() == auxUnit.unitName.trim().toLowerCase(),
            )
            .firstOrNull;
      } catch (e) {
        targetUnit = null;
      }

      if (targetUnit != null) {
        final finalTargetUnit = targetUnit;
        UnitProduct? matchingProductUnit;
        matchingProductUnit = productUnits
            .where(
              (pu) =>
                  pu.unitId == finalTargetUnit.id &&
                  pu.conversionRate == auxUnit.conversionRate,
            )
            .firstOrNull;

        if (matchingProductUnit == null) {
          throw Exception(
            'æ•°æ®ä¸ä¸€è‡´ï¼šåœ¨äº§å“å•ä½åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°å•ä½?${finalTargetUnit.name} (æ¢ç®—ç? ${auxUnit.conversionRate})',
          );
        }

        if ((matchingProductUnit.id ?? 0) > 0) {
          barcodes.add(
            BarcodeModel(
              unitProductId: matchingProductUnit.id!,
              barcodeValue: code,
            ),
          );
          print(
            'ğŸ” [DEBUG] âœ?æ·»åŠ è¾…å•ä½æ¡ç ? ${auxUnit.unitName} -> $code (ProductUnitId: ${matchingProductUnit.id})',
          );
        } else {
          print(
            'ğŸ” [DEBUG] â?æœªæ‰¾åˆ°åŒ¹é…çš„äº§å“å•ä½: ${auxUnit.unitName} (æ¢ç®—ç? ${auxUnit.conversionRate})',
          );
        }
      } else {
        print('ğŸ” [DEBUG] â?æœªæ‰¾åˆ°å•ä½? ${auxUnit.unitName}');
      }
    }

    if (barcodes.isNotEmpty) {
      await ctrl.addMultipleBarcodes(barcodes);
      print('ğŸ” [DEBUG] âœ?æˆåŠŸä¿å­˜ ${barcodes.length} ä¸ªè¾…å•ä½æ¡ç ');
    } else {
      print('ğŸ” [DEBUG] æ²¡æœ‰æœ‰æ•ˆçš„è¾…å•ä½æ¡ç éœ€è¦ä¿å­?);
    }

    print('ğŸ” [DEBUG] ==================== è¾…å•ä½æ¡ç ä¿å­˜å®Œæˆ?====================');
  }

  /// ä»æ•°æ®åº“åŠ è½½ç°æœ‰è¾…å•ä½æ•°æ®å¹¶è½¬æ¢ä¸ºè¡¨å•æ ¼å¼?
  Future<List<AuxiliaryUnitData>> _loadExistingAuxiliaryUnits(
    int productId,
  ) async {
    try {
      final productUnitController = ref.read(
        productUnitControllerProvider.notifier,
      );
      final barcodeController = ref.read(barcodeControllerProvider.notifier);

      // è·å–æ‰€æœ‰äº§å“å•ä½?
      final allProductUnits = await productUnitController
          .getProductUnitsByProductId(productId);

      // è¿‡æ»¤å‡ºè¾…å•ä½ï¼ˆæ¢ç®—ç‡ä¸ä¸º1ï¼?
      final auxiliaryProductUnits = allProductUnits
          .where((pu) => pu.conversionRate != 1.0)
          .toList();

      if (auxiliaryProductUnits.isEmpty) {
        return [];
      }

      // è·å–æ‰€æœ‰å•ä½ä¿¡æ?
      final allUnits = await ref.read(allUnitsProvider.future);

      // è½¬æ¢ä¸?AuxiliaryUnitData æ ¼å¼
      final List<AuxiliaryUnitData> auxiliaryUnitsData = [];

      for (final productUnit in auxiliaryProductUnits) {
        // æŸ¥æ‰¾å•ä½åç§°
        final unit = allUnits.firstWhere(
          (u) => u.id == productUnit.unitId,
          orElse: () => Unit(name: 'Unknown'),
        );

        // æŸ¥æ‰¾æ¡ç 
        final barcodes = await barcodeController.getBarcodesByProductUnitId(
          productUnit.id,
        );
        final barcodeValue = barcodes.isNotEmpty
            ? barcodes.first.barcodeValue
            : '';

        // è½¬æ¢ä»·æ ¼ï¼ˆåˆ† -> å…ƒçš„å­—ç¬¦ä¸²ï¼‰
        final retailPrice = productUnit.sellingPriceInCents != null
            ? productUnit.sellingPriceInCents.toString()
            : '';
        final wholesalePrice = productUnit.wholesalePriceInCents != null
            ? productUnit.wholesalePriceInCents.toString()
            : '';

        auxiliaryUnitsData.add(
          AuxiliaryUnitData(
            id: productUnit.id ?? 0,
            unitId: unit.id,
            unitName: unit.name,
            conversionRate: productUnit.conversionRate,
            barcode: barcodeValue,
            retailPriceInCents: retailPrice,
            wholesalePriceInCents: wholesalePrice,
          ),
        );

        print(
          'ğŸ” [DEBUG] åŠ è½½è¾…å•ä½? ${unit.name}, æ¢ç®—ç? ${productUnit.conversionRate}, '
          'é›¶å”®ä»? $retailPrice, æ‰¹å‘ä»? $wholesalePrice',
        );
      }

      return auxiliaryUnitsData;
    } catch (e) {
      print('ğŸ” [DEBUG] â?åŠ è½½ç°æœ‰è¾…å•ä½å¤±è´? $e');
      return [];
    }
  }

  /// å¤„ç†è¾…å•ä½?- æ£€æŸ¥å¹¶æ’å…¥æ–°çš„è¾…å•ä½åˆ°å•ä½è¡?
  Future<void> _processAuxiliaryUnits(List<UnitProduct>? productUnits) async {
    print('ğŸ” [DEBUG] ==================== å¼€å§‹å¤„ç†è¾…å•ä½ ====================');

    // è·å–è¾…å•ä½è¡¨å•æ•°æ?
    final formState = ref.read(unitEditFormProvider);
    print('ğŸ” [DEBUG] è¡¨å•ä¸­çš„è¾…å•ä½æ•°é‡? ${formState.auxiliaryUnits.length}');

    if (formState.auxiliaryUnits.isEmpty) {
      print('ğŸ” [DEBUG] è¡¨å•ä¸­æ²¡æœ‰è¾…å•ä½æ•°æ®ï¼Œè·³è¿‡å¤„ç?);
      return;
    }

    final unitCtrl = ref.read(unitControllerProvider.notifier);
    final units = ref
        .read(allUnitsProvider)
        .maybeWhen(data: (u) => u, orElse: () => <Unit>[]);

    print('ğŸ” [DEBUG] å½“å‰æ•°æ®åº“ä¸­çš„å•ä½æ•°é‡? ${units.length}');

    for (int i = 0; i < formState.auxiliaryUnits.length; i++) {
      final auxUnit = formState.auxiliaryUnits[i];
      final unitName = auxUnit.unitName.trim();

      print('ğŸ” [DEBUG] --- å¤„ç†è¾…å•ä½?${i + 1}: "$unitName" ---');

      if (unitName.isEmpty) {
        print('ğŸ” [DEBUG] å•ä½åç§°ä¸ºç©ºï¼Œè·³è¿?);
        continue;
      }

      // æ£€æŸ¥å•ä½æ˜¯å¦å·²å­˜åœ¨
      Unit? existingUnit;
      existingUnit = units
          .where((u) => u.name.toLowerCase() == unitName.toLowerCase())
          .firstOrNull;

      if (existingUnit != null) {
        print(
          'ğŸ” [DEBUG] å•ä½å·²å­˜åœ? ID=${existingUnit.id}, åç§°="${existingUnit.name}"',
        );
      } else {
        // å¦‚æœå•ä½ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°å•ä½?
        print('ğŸ” [DEBUG] åˆ›å»ºæ–°å•ä½? åç§°="$unitName"');

        try {
          // è°ƒç”¨æ–°çš„addUnitæ–¹æ³•ï¼Œå®ƒä¼šå¤„ç†ä¸€åˆ?
          final newUnit = await unitCtrl.addUnit(Unit(name: unitName));
          print('ğŸ” [DEBUG] âœ?æ–°å•ä½åˆ›å»ºæˆåŠ? ID: ${newUnit.id}');

          // å°†æ–°åˆ›å»ºçš„å•ä½æ·»åŠ åˆ°å½“å‰å¾ªç¯çš„å•ä½åˆ—è¡¨ä¸­ï¼?
          // ä»¥ä¾¿åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­å¤„ç†ä¾èµ–äºè¿™ä¸ªæ–°å•ä½çš„å…¶ä»–é€»è¾‘ã€?
          units.add(newUnit);
          ref.invalidate(allUnitsProvider);
        } catch (e) {
          print('ğŸ” [DEBUG] â?æ–°å•ä½åˆ›å»ºå¤±è´? $e');
          throw Exception('åˆ›å»ºå•ä½å¤±è´¥: $unitName - $e');
        }
      }
    }

    // æœ€ç»ˆåˆ·æ–°ä¸€æ¬¡å•ä½æ•°æ®ä»¥ç¡®ä¿æ‰€æœ‰æ–°å•ä½éƒ½å¯ç”?
    ref.invalidate(allUnitsProvider);
    print('ğŸ” [DEBUG] ==================== è¾…å•ä½å¤„ç†å®Œæˆ?====================');
  }
}
import 'package:flutter/material.dart';

import '../../domain/model/product.dart';

/// è´Ÿè´£ç®¡ç† Product è¡¨å•çš?TextEditingController ä¸?FocusNodeã€?
/// å°†åˆå§‹åŒ–/å›å¡«ä¸èµ„æºé‡Šæ”¾ä»é¡µé¢ä¸­æŠ½ç¦»ï¼Œé¡µé¢åªåš UI ç»„è£…ä¸äº‹ä»¶è½¬å‘ã€?
class ProductFormControllers {
  // æ–‡æœ¬æ§åˆ¶å™?
  final TextEditingController categoryController = TextEditingController();
  final TextEditingController unitController = TextEditingController();
  late final TextEditingController nameController;
  late final TextEditingController barcodeController;
  late final TextEditingController retailPriceController;
  late final TextEditingController promotionalPriceController;
  late final TextEditingController suggestedRetailPriceController;
  late final TextEditingController stockWarningValueController;
  late final TextEditingController shelfLifeController;
  late final TextEditingController remarksController;

  // ç„¦ç‚¹èŠ‚ç‚¹
  final FocusNode nameFocusNode = FocusNode();
  final FocusNode unitFocusNode = FocusNode();
  final FocusNode categoryFocusNode = FocusNode();
  final FocusNode retailPriceFocusNode = FocusNode();
  final FocusNode shelfLifeFocusNode = FocusNode();
  final FocusNode stockWarningValueFocusNode = FocusNode();

  /// æ ¹æ®ä¼ å…¥çš?[product] åˆå§‹åŒ–å„è¾“å…¥æ¡†ï¼Œç©ºå€¼ä½¿ç”¨é¡µé¢é»˜è®¤å€¼ä¿æŒä¸€è‡´ã€?
  void init(ProductModel? product) {
    nameController = TextEditingController(text: product?.name ?? '');
    barcodeController = TextEditingController(text: ''); // æ¡ç å¼‚æ­¥åŠ è½½

    retailPriceController = TextEditingController(
      text: product?.retailPrice != null
          ? product!.retailPrice!.yuan.toStringAsFixed(2)
          : '',
    );

    promotionalPriceController = TextEditingController(
      text: product?.promotionalPrice != null
          ? product!.promotionalPrice!.yuan.toStringAsFixed(2)
          : '',
    );

    suggestedRetailPriceController = TextEditingController(
      text: product?.suggestedRetailPrice != null
          ? product!.suggestedRetailPrice!.yuan.toStringAsFixed(2)
          : '',
    );

    stockWarningValueController = TextEditingController(
      text: product?.stockWarningValue?.toString() ?? '',
    );

    shelfLifeController = TextEditingController(
      text: product?.shelfLife?.toString() ?? '',
    );

    remarksController = TextEditingController(text: product?.remarks ?? '');

    // categoryController ä¸?unitController åˆå§‹æ–‡æœ¬ç”±é¡µé¢é€‰æ‹©é€»è¾‘/å›å¡«å†³å®š
  }

  void dispose() {
    // æ–‡æœ¬æ§åˆ¶å™?
    nameController.dispose();
    barcodeController.dispose();
    retailPriceController.dispose();
    promotionalPriceController.dispose();
    suggestedRetailPriceController.dispose();
    stockWarningValueController.dispose();
    shelfLifeController.dispose();
    remarksController.dispose();
    categoryController.dispose();
    unitController.dispose();

    // ç„¦ç‚¹èŠ‚ç‚¹
    nameFocusNode.dispose();
    unitFocusNode.dispose();
    categoryFocusNode.dispose();
    retailPriceFocusNode.dispose();
    shelfLifeFocusNode.dispose();
    stockWarningValueFocusNode.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/model/category.dart';
import '../../domain/model/unit.dart';
import '../../application/provider/unit_providers.dart';
import '../../application/category_notifier.dart';
import '../screens/category_selection_screen.dart';
import '../screens/unit_selection_screen.dart';
import '../screens/auxiliaryunit_edit_screen.dart';

/// è´Ÿè´£ä¸è·¯ç”±ç›¸å…³çš„è¡¨å•åè°ƒé€»è¾‘ï¼Œé¿å…åœ¨ Widget ä¸­å †ç§¯å¯¼èˆªä¸æ•°æ®å‡†å¤‡ä»£ç 
class ProductFormCoordinator {
  const ProductFormCoordinator._();

  /// é€‰æ‹©ç±»åˆ«
  static Future<CategoryModel?> chooseCategory(
    BuildContext context,
    WidgetRef ref, {
    int? selectedCategoryId,
  }) async {
    await ref.read(categoryListProvider.notifier).loadCategories();
    return Navigator.of(context).push<CategoryModel>(
      MaterialPageRoute(
        builder: (context) => CategorySelectionScreen(
          selectedCategoryId: selectedCategoryId,
          isSelectionMode: true,
        ),
      ),
    );
  }

  /// é€‰æ‹©å•ä½
  static Future<Unit?> chooseUnit(
    BuildContext context,
    List<Unit> allUnits, {
    int? selectedUnitId,
  }) async {
    final initialUnit = selectedUnitId != null
        ? allUnits.firstWhere(
            (u) => u.id == selectedUnitId,
            orElse: () => Unit.empty(),
          )
        : Unit.empty();

    return Navigator.of(context).push<Unit>(
      MaterialPageRoute(
        builder: (context) => UnitSelectionScreen(initialUnit: initialUnit),
      ),
    );
  }

  /// ç¼–è¾‘è¾…å•ä½ä¸æ¡ç é…ç½®ï¼Œè¿”å›é¡µé¢å›ä¼ çš„æ•°æ®ï¼ˆå…¼å®?Map æˆ?List<UnitProduct>ï¼?
  static Future<dynamic> editAuxiliaryUnits(
    BuildContext context,
    WidgetRef ref, {
    int? productId,
    int? currentUnitId,
    required String currentUnitName,
  }) async {
    int? baseUnitId = currentUnitId;
    String baseUnitName = currentUnitName.trim();

    // è‹¥æœªé€‰å•ä½ä½†å¡«äº†åç§°ï¼Œå°è¯•åŒ¹é…å·²å­˜åœ¨å•ä½
    if (baseUnitId == null && baseUnitName.isNotEmpty) {
      try {
        final allUnits = await ref.read(allUnitsProvider.future);
        final existing = allUnits.where((u) =>
            u.name.toLowerCase() == baseUnitName.toLowerCase());
        if (existing.isNotEmpty) {
          baseUnitId = existing.first.id;
        }
      } catch (_) {
        // å¿½ç•¥è¯»å–å¤±è´¥ï¼Œç»§ç»­ä»¥è¾“å…¥åç§°è¿›å…¥ç¼–è¾‘é¡?
      }
    }

    // è‹¥åç§°ä¸ºç©ºï¼Œå…è®¸è¿›å…¥é¡µé¢åˆ›å»º
    if (baseUnitName.isEmpty) {
      baseUnitName = '';
      baseUnitId = null;
    }

    return Navigator.of(context).push<dynamic>(
      MaterialPageRoute(
        builder: (context) => AuxiliaryUnitEditScreen(
          productId: productId,
          baseUnitId: baseUnitId?.toString() ?? '0',
          baseUnitName: baseUnitName,
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/services/barcode_scanner_service.dart';
import '../../domain/model/unit.dart';
import '../../domain/model/product_unit.dart';
import '../../domain/model/auxiliary_unit_data.dart';
import '../../application/provider/unit_providers.dart';
import '../../application/provider/unit_edit_form_providers.dart';
import '../../application/provider/barcode_providers.dart';
import '../../application/provider/product_unit_providers.dart';
import '../../../../core/utils/snackbar_helper.dart';
import 'unit_selection_screen.dart';

class AuxiliaryUnitEditScreen extends ConsumerStatefulWidget {
  final int? productId;
  final String baseUnitId;
  final String? baseUnitName;

  const AuxiliaryUnitEditScreen({
    super.key,
    this.productId,
    required this.baseUnitId,
    this.baseUnitName,
  });

  @override
  ConsumerState<AuxiliaryUnitEditScreen> createState() =>
      _AuxiliaryUnitEditScreenState();
}

class _AuxiliaryUnitEditScreenState
    extends ConsumerState<AuxiliaryUnitEditScreen> {
  final _formKey = GlobalKey<FormState>();

  final List<_AuxiliaryUnit> _auxiliaryUnits = [];

  int _auxiliaryCounter = 1;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeUnits();
    });
  }

  @override
  void dispose() {
    for (final aux in _auxiliaryUnits) {
      aux.dispose();
    }
    super.dispose();
  }

  void _initializeUnits() async {
    print('ğŸ” _initializeUnits: productId=${widget.productId}');
    // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼ˆæœ‰productIdï¼‰ï¼Œä¼˜å…ˆä»æ•°æ®åº“åŠ è½½ç°æœ‰æ•°æ®
    if (widget.productId != null) {
      print('ğŸ” ç¼–è¾‘æ¨¡å¼ï¼Œè°ƒç”¨_initializeAuxiliaryUnits');
      await _initializeAuxiliaryUnits();
      return;
    }

    // å¦‚æœæ˜¯æ–°å¢æ¨¡å¼ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æŒä¹…åŒ–æ•°æ?
    final formState = ref.read(unitEditFormProvider);
    final hasPersistedData = formState.auxiliaryUnits.isNotEmpty;
    print('ğŸ” æ–°å¢æ¨¡å¼ï¼ŒhasPersistedData=$hasPersistedData');

    if (hasPersistedData) {
      print('ğŸ” åŠ è½½æŒä¹…åŒ–æ•°æ?);
      _loadFromFormProvider();
      return;
    }

    print('ğŸ” æ— æŒä¹…åŒ–æ•°æ®ï¼Œè°ƒç”¨_initializeAuxiliaryUnits');
    await _initializeAuxiliaryUnits();
  }

  Future<void> _initializeAuxiliaryUnits() async {
    print('ğŸ” _initializeAuxiliaryUnits å¼€å§?);
    try {
      final formState = ref.read(unitEditFormProvider);
      print(
        'ğŸ” formState.auxiliaryUnits.length=${formState.auxiliaryUnits.length}',
      );
      if (formState.auxiliaryUnits.isNotEmpty) {
        print('ğŸ” ä»è¡¨å•æ•°æ®åŠ è½?);
        await _loadAuxiliaryUnitsFromFormData(formState.auxiliaryUnits);
        _auxiliaryCounter = formState.auxiliaryCounter;
        return;
      }
      if (widget.productId != null) {
        print('ğŸ” ä»æ•°æ®åº“åŠ è½½è¾…å•ä½?);
        final productUnitController = ref.read(
          productUnitControllerProvider.notifier,
        );
        final allProductUnits = await productUnitController
            .getProductUnitsByProductId(widget.productId!);
        final auxiliaryUnits = allProductUnits
            .where((pu) => pu.conversionRate != 1.0)
            .toList();

        if (auxiliaryUnits.isNotEmpty) {
          await _loadAuxiliaryUnits(auxiliaryUnits);
        } else {
          _addAuxiliaryUnit();
        }
      } else {
        _addAuxiliaryUnit();
      }
    } catch (e, s) {
      debugPrint('Error initializing auxiliary units: $e\n$s');
    }
  }

  Future<void> _loadAuxiliaryUnits(List<UnitProduct> auxiliaryUnits) async {
    final List<_AuxiliaryUnit> tempAuxiliaryUnits = [];

    for (final unitProduct in auxiliaryUnits) {
      try {
        print('=================ã€ä»“å‚¨å±‚è°ƒè¯•ã€?================');
        print('UnitProduct ID: ${unitProduct.id}');
        print('SELLING PRICE: ${unitProduct.sellingPriceInCents}');
        print('WHOLESALE PRICE: ${unitProduct.wholesalePriceInCents}');
        print(
          'productId: ${unitProduct.productId}, unitId: ${unitProduct.unitId}, conversionRate: ${unitProduct.conversionRate}',
        );
        print('==============================================');
        final allUnits = await ref.read(allUnitsProvider.future);
        final unit = allUnits.firstWhere(
          (u) => u.id == unitProduct.unitId,
          orElse: () =>
              throw Exception('Unit not found: ${unitProduct.unitId}'),
        );
        final auxiliaryUnit = _AuxiliaryUnit(
          id: _auxiliaryCounter,
          unit: unit,
          conversionRate: unitProduct.conversionRate,
          initialSellingPrice: (unitProduct.sellingPriceInCents ?? 0) / 100,
          initialWholesalePrice: (unitProduct.wholesalePriceInCents ?? 0) / 100,
        );
        print('ğŸ” æ§åˆ¶å™¨åˆå§‹åŒ–åå”®ä»? ${auxiliaryUnit.retailPriceController.text}');
        print('ğŸ” æ§åˆ¶å™¨åˆå§‹åŒ–åæ‰¹å‘ä»·: ${auxiliaryUnit.wholesalePriceController.text}');

        auxiliaryUnit.unitController.text = unit.name;

        final barcodeController = ref.read(barcodeControllerProvider.notifier);
        final barcodes = await barcodeController.getBarcodesByProductUnitId(
          unitProduct.id,
        );
        if (barcodes.isNotEmpty) {
          auxiliaryUnit.barcodeController.text = barcodes.first.barcodeValue;
        }

        tempAuxiliaryUnits.add(auxiliaryUnit);
        _auxiliaryCounter++;
      } catch (e) {}
    }

    if (mounted && tempAuxiliaryUnits.isNotEmpty) {
      setState(() {
        _auxiliaryUnits.clear();
        _auxiliaryUnits.addAll(tempAuxiliaryUnits);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) {
        if (!didPop) {
          _handleReturn();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('ç¼–è¾‘è¾…å•ä½?),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: _handleReturn,
          ),
        ),
        body: Form(
          key: _formKey,
          child: Column(
            children: [
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (widget.baseUnitName != null)
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16.0),
                          child: Text(
                            'åŸºæœ¬å•ä½: ${widget.baseUnitName}',
                            style: const TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      const SizedBox(height: 8),
                      _buildAuxiliaryUnitsSection(),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAuxiliaryUnitsSection() {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.only(bottom: 80),
              itemCount: _auxiliaryUnits.length,
              itemBuilder: (context, index) {
                return Column(
                  children: [
                    _buildAuxiliaryUnitItem(index),
                    if (index == _auxiliaryUnits.length - 1) ...[
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          FloatingActionButton.small(
                            onPressed: _addAuxiliaryUnit,
                            child: const Icon(Icons.add),
                          ),
                          const SizedBox(width: 12),
                          const Text(
                            'æ·»åŠ è¾…å•ä½?,
                            style: TextStyle(fontSize: 14, color: Colors.grey),
                          ),
                        ],
                      ),
                    ],
                  ],
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAuxiliaryUnitItem(int index) {
    final auxiliaryUnit = _auxiliaryUnits[index];

    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  'è¾…å•ä½?{index + 1}',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Spacer(),
                IconButton(
                  onPressed: () => _removeAuxiliaryUnit(index),
                  icon: const Icon(
                    Icons.delete,
                    color: Color.fromARGB(255, 78, 4, 138),
                  ),
                  iconSize: 20,
                ),
              ],
            ),
            const SizedBox(height: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'è¾…å•ä½åç§?,
                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        decoration: const InputDecoration(
                          hintText: 'è¯·è¾“å…¥æˆ–é€‰æ‹©å•ä½åç§°',
                          border: OutlineInputBorder(),
                        ),
                        controller: auxiliaryUnit.unitController,
                        focusNode: auxiliaryUnit.unitFocusNode,
                        onFieldSubmitted: (_) => auxiliaryUnit
                            .conversionRateFocusNode
                            .requestFocus(),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'è¯·è¾“å…¥å•ä½åç§?;
                          }
                          return null;
                        },
                        onChanged: (value) {
                          _onAuxiliaryUnitNameChanged(index, value);
                        },
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      onPressed: () => _selectAuxiliaryUnit(index),
                      icon: const Icon(Icons.list),
                      style: IconButton.styleFrom(
                        backgroundColor: Theme.of(
                          context,
                        ).primaryColor.withValues(alpha: 0.1),
                        foregroundColor: Theme.of(context).primaryColor,
                      ),
                      tooltip: 'é€‰æ‹©å•ä½',
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'æ¢ç®—ç?(ç›¸å¯¹äº?{widget.baseUnitName ?? 'åŸºæœ¬å•ä½'})',
                  style: const TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  decoration: const InputDecoration(
                    hintText: 'è¯·è¾“å…¥æ¢ç®—ç‡',
                    border: OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.number,
                  focusNode: auxiliaryUnit.conversionRateFocusNode,
                  onFieldSubmitted: (_) =>
                      auxiliaryUnit.retailPriceFocusNode.requestFocus(),
                  initialValue: auxiliaryUnit.conversionRate > 0
                      ? auxiliaryUnit.conversionRate.toString()
                      : '',
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'è¯·è¾“å…¥æ¢ç®—ç‡';
                    }
                    final rate = double.tryParse(value.trim());
                    if (rate == null || rate <= 0) {
                      return 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ¢ç®—ç?;
                    }
                    if (rate == 1.0) {
                      return 'è¾…å•ä½æ¢ç®—ç‡ä¸èƒ½ä¸?';
                    }
                    return null;
                  },
                  onChanged: (value) {
                    final rate = int.tryParse(value.trim());
                    if (rate != null) {
                      auxiliaryUnit.conversionRate = rate;
                      ref
                          .read(unitEditFormProvider.notifier)
                          .updateAuxiliaryUnitConversionRate(
                            auxiliaryUnit.id,
                            rate,
                          );
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'æ¡ç ',
                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        controller: auxiliaryUnit.barcodeController,
                        decoration: const InputDecoration(
                          hintText: 'è¯·è¾“å…¥æˆ–æ‰«ææ¡ç ',
                          border: OutlineInputBorder(),
                        ),
                        keyboardType: TextInputType.text,
                        onChanged: (value) {
                          ref
                              .read(unitEditFormProvider.notifier)
                              .updateAuxiliaryUnitBarcode(
                                auxiliaryUnit.id,
                                value,
                              );
                        },
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      onPressed: () => _scanBarcode(index),
                      icon: const Icon(Icons.qr_code_scanner),
                      style: IconButton.styleFrom(
                        backgroundColor: Theme.of(
                          context,
                        ).primaryColor.withOpacity(0.1),
                        foregroundColor: Theme.of(context).primaryColor,
                      ),
                      tooltip: 'æ‰«ææ¡ç ',
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'å»ºè®®é›¶å”®ä»?,
                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: auxiliaryUnit.retailPriceController,
                  focusNode: auxiliaryUnit.retailPriceFocusNode,
                  decoration: const InputDecoration(
                    hintText: 'è¯·è¾“å…¥é›¶å”®ä»·',
                    border: OutlineInputBorder(),
                    prefixText: 'Â¥ ',
                  ),
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final price = double.tryParse(value.trim());
                      if (price == null || price < 0) {
                        return 'è¯·è¾“å…¥æœ‰æ•ˆçš„ä»·æ ¼';
                      }
                    }
                    return null;
                  },
                  onChanged: (value) {
                    ref
                        .read(unitEditFormProvider.notifier)
                        .updateAuxiliaryUnitRetailPrice(
                          auxiliaryUnit.id,
                          value,
                        );
                  },
                  onFieldSubmitted: (_) =>
                      auxiliaryUnit.wholesalePriceFocusNode.requestFocus(),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'æ‰¹å‘ä»?,
                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: auxiliaryUnit.wholesalePriceController,
                  focusNode: auxiliaryUnit.wholesalePriceFocusNode,
                  decoration: const InputDecoration(
                    hintText: 'è¯·è¾“å…¥æ‰¹å‘ä»·',
                    border: OutlineInputBorder(),
                    prefixText: 'Â¥ ',
                  ),
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final price = double.tryParse(value.trim());
                      if (price == null || price < 0) {
                        return 'è¯·è¾“å…¥æœ‰æ•ˆçš„ä»·æ ¼';
                      }
                    }
                    return null;
                  },
                  onChanged: (value) {
                    ref
                        .read(unitEditFormProvider.notifier)
                        .updateAuxiliaryUnitWholesalePrice(
                          auxiliaryUnit.id,
                          value,
                        );
                  },
                  onFieldSubmitted: (_) => _handleReturn(),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  void _onAuxiliaryUnitNameChanged(int index, String unitName) async {
    print('ğŸ” è¾…å•ä½åç§°å˜æ›?- ç´¢å¼•: $index, è¾“å…¥: "$unitName"');
    final trimmedName = unitName.trim();
    if (trimmedName.isEmpty) {
      print('ğŸ” å•ä½åç§°ä¸ºç©ºï¼Œæ¸…é™¤å•ä½?);
      setState(() {
        _auxiliaryUnits[index].unit = null;
      });
      ref
          .read(unitEditFormProvider.notifier)
          .updateAuxiliaryUnitName(_auxiliaryUnits[index].id, '');
      return;
    }

    try {
      print('ğŸ” æŸ¥æ‰¾ç°æœ‰å•ä½: "$trimmedName"');
      final allUnits = await ref.read(allUnitsProvider.future);
      print('ğŸ” æ•°æ®åº“ä¸­å…±æœ‰ ${allUnits.length} ä¸ªå•ä½?);

      Unit? existingUnit = allUnits.firstWhere(
        (unit) => unit.name == trimmedName,
        orElse: () => Unit.empty(),
      );

      if (existingUnit.isNew) {
        print('ğŸ” å•ä½ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°å•ä½å¯¹è±? "$trimmedName"');
        existingUnit = Unit(name: trimmedName);
        print('ğŸ” æ–°å•ä½å¯¹è±¡å·²åˆ›å»º: ID=${existingUnit.id}, åç§°="${existingUnit.name}"');
      } else {
        print('ğŸ” æ‰¾åˆ°ç°æœ‰å•ä½: ID=${existingUnit.id}, åç§°="${existingUnit.name}"');
      }

      if (widget.baseUnitName != null &&
          existingUnit.name == widget.baseUnitName!) {
        if (mounted) {
          showAppSnackBar(context, message: 'è¾…å•ä½ä¸èƒ½ä¸åŸºæœ¬å•ä½ç›¸åŒ', isError: true);
        }
        return;
      }

      final existingIndex = _auxiliaryUnits.indexWhere(
        (aux) => aux.unit?.name == existingUnit!.name,
      );
      if (existingIndex != -1 && existingIndex != index) {
        if (mounted) {
          showAppSnackBar(context, message: 'è¯¥å•ä½å·²è¢«å…¶ä»–è¾…å•ä½ä½¿ç”¨', isError: true);
        }
        return;
      }
      print('ğŸ” è®¾ç½®è¾…å•ä½?$index çš„å•ä½ä¸º: ${existingUnit.name}');
      setState(() {
        _auxiliaryUnits[index].unit = existingUnit;
      });

      print(
        'ğŸ” æ›´æ–°è¡¨å•çŠ¶æ€? è¾…å•ä½ID=${_auxiliaryUnits[index].id}, å•ä½ID=${existingUnit.id}',
      );
      ref
          .read(unitEditFormProvider.notifier)
          .updateAuxiliaryUnitName(
            _auxiliaryUnits[index].id,
            trimmedName,
            unitId: existingUnit.id,
          );
      print('âœ?è¾…å•ä½åç§°å˜æ›´å®Œæˆ?);
    } catch (e) {
      print('â?è¾…å•ä½åç§°å˜æ›´å¼‚å¸? $e');
    }
  }

  void _addAuxiliaryUnit() {
    setState(() {
      _auxiliaryUnits.add(
        _AuxiliaryUnit(id: _auxiliaryCounter, unit: null, conversionRate: 0),
      );
      _auxiliaryCounter++;
    });

    ref.read(unitEditFormProvider.notifier).addAuxiliaryUnit();
  }

  void _removeAuxiliaryUnit(int index) {
    final auxiliaryUnitId = _auxiliaryUnits[index].id;

    setState(() {
      _auxiliaryUnits[index].dispose();
      _auxiliaryUnits.removeAt(index);
    });

    ref
        .read(unitEditFormProvider.notifier)
        .removeAuxiliaryUnit(auxiliaryUnitId);
  }

  void _selectAuxiliaryUnit(int index) async {
    try {
      final Unit? selectedUnit = await Navigator.of(context).push<Unit>(
        MaterialPageRoute(
          builder: (context) =>
              UnitSelectionScreen(initialUnit: _auxiliaryUnits[index].unit),
        ),
      );

      if (selectedUnit != null) {
        if (widget.baseUnitName != null &&
            selectedUnit.name == widget.baseUnitName!) {
          if (mounted) {
            showAppSnackBar(context, message: 'è¾…å•ä½ä¸èƒ½ä¸åŸºæœ¬å•ä½ç›¸åŒ', isError: true);
          }
          return;
        }

        final existingIndex = _auxiliaryUnits.indexWhere(
          (aux) => aux.unit?.name == selectedUnit.name,
        );
        if (existingIndex != -1 && existingIndex != index) {
          if (mounted) {
            showAppSnackBar(context, message: 'è¯¥å•ä½å·²è¢«å…¶ä»–è¾…å•ä½ä½¿ç”¨', isError: true);
          }
          return;
        }
        setState(() {
          _auxiliaryUnits[index].unit = selectedUnit;
          _auxiliaryUnits[index].unitController.text = selectedUnit.name;
        });

        ref
            .read(unitEditFormProvider.notifier)
            .updateAuxiliaryUnitName(
              _auxiliaryUnits[index].id,
              selectedUnit.name,
              unitId: selectedUnit.id,
            );
      }
    } catch (e) {
      if (mounted) {
        showAppSnackBar(context, message: 'é€‰æ‹©å•ä½å¤±è´¥: $e', isError: true);
      }
    }
  }

  void _scanBarcode(int index) async {
    try {
      final String? barcode = await BarcodeScannerService.scanForProduct(
        context,
      );
      if (barcode != null && barcode.isNotEmpty) {
        setState(() {
          _auxiliaryUnits[index].barcodeController.text = barcode;
        });

        ref
            .read(unitEditFormProvider.notifier)
            .updateAuxiliaryUnitBarcode(_auxiliaryUnits[index].id, barcode);

        // æ‰«ç æˆåŠŸåè½¬ç§»ç„¦ç‚¹åˆ°è¾…å•ä½åç§°è¾“å…¥æ¡†
        _auxiliaryUnits[index].unitFocusNode.requestFocus();

        if (mounted) {
          showAppSnackBar(context, message: 'æ‰«ææˆåŠŸ: $barcode');
        }
      }
    } catch (e) {
      if (mounted) {
        showAppSnackBar(context, message: 'æ‰«æå¤±è´¥: $e', isError: true);
      }
    }
  }

  List<UnitProduct> _buildProductUnits() {
    print('ğŸ” [DEBUG] ==================== å¼€å§‹æ„å»ºäº§å“å•ä½?====================');
    print('ğŸ” [DEBUG] äº§å“ID: ${widget.productId}');
    print('ğŸ” [DEBUG] åŸºæœ¬å•ä½ID: ${widget.baseUnitId}');
    print('ğŸ” [DEBUG] åŸºæœ¬å•ä½åç§°: ${widget.baseUnitName}');
    print('ğŸ” [DEBUG] è¾…å•ä½æ•°é‡? ${_auxiliaryUnits.length}');

    final List<UnitProduct> productUnits = [];

    // æ·»åŠ åŸºæœ¬å•ä½
    final int? parsedBaseUnitId = int.tryParse(widget.baseUnitId);
    if (parsedBaseUnitId == null) {
      print('â?åŸºæœ¬å•ä½IDæ— æ•ˆ: ${widget.baseUnitId}');
      // å¦‚æœåŸºæœ¬å•ä½IDæ— æ•ˆï¼Œç›´æ¥è¿”å›?
      Navigator.of(context).pop();
      return [];
    }

    final baseUnit = UnitProduct(
      // id: '${widget.productId ?? 'new'}_${widget.baseUnitId!}',
      productId: widget.productId ?? 0,
      unitId: parsedBaseUnitId,
      conversionRate: 1,
    );
    productUnits.add(baseUnit);
    print('ğŸ” [DEBUG] âœ?æ·»åŠ åŸºæœ¬å•ä½: ${baseUnit.id}');

    // å¤„ç†è¾…å•ä½?
    for (int i = 0; i < _auxiliaryUnits.length; i++) {
      final aux = _auxiliaryUnits[i];
      print('ğŸ” [DEBUG] --- å¤„ç†è¾…å•ä½?${i + 1} ---');
      print('ğŸ” [DEBUG]   å•ä½å¯¹è±¡: ${aux.unit}');
      print('ğŸ” [DEBUG]   å•ä½ID: ${aux.unit?.id}');
      print('ğŸ” [DEBUG]   å•ä½åç§°: "${aux.unit?.name}"');
      print('ğŸ” [DEBUG]   æ¢ç®—ç? ${aux.conversionRate}');
      print('ğŸ” [DEBUG]   è¾“å…¥æ¡†æ–‡æœ? "${aux.unitController.text}"');
      print('ğŸ” [DEBUG]   æ¡ç : "${aux.barcodeController.text}"');
      print('ğŸ” [DEBUG]   é›¶å”®ä»? "${aux.retailPriceController.text}"');
      print('ğŸ” [DEBUG]   æ‰¹å‘ä»·è¾“å…¥æ¡†: "${aux.wholesalePriceController.text}"');

      if (aux.unit != null && aux.conversionRate > 0) {
        print('=== æ„å»ºè¾…å•ä½ProductUnit ===');
        print(
          'retailPriceController.text: "${aux.retailPriceController.text}"',
        );
        print(
          'wholesalePriceController.text: "${aux.wholesalePriceController.text}"',
        );
        final sellingPriceInCents =
            aux.retailPriceController.text.trim().isNotEmpty
            ? (double.tryParse(aux.retailPriceController.text.trim()) != null
                  ? (double.parse(aux.retailPriceController.text.trim()) * 100)
                        .round()
                  : null)
            : null;
        final wholesalePriceInCents =
            aux.wholesalePriceController.text.trim().isNotEmpty
            ? (double.tryParse(aux.wholesalePriceController.text.trim()) != null
                  ? (double.parse(aux.wholesalePriceController.text.trim()) *
                            100)
                        .round()
                  : null)
            : null;
        print('è§£æåçš„sellingPrice: $sellingPriceInCents');
        print('è§£æåçš„wholesalePrice: $wholesalePriceInCents');
        print('========================');

        final auxUnit = UnitProduct(
          productId: widget.productId ?? 0,
          unitId: aux.unit!.id!,
          conversionRate: aux.conversionRate,
          sellingPriceInCents: sellingPriceInCents,
          wholesalePriceInCents: wholesalePriceInCents,
          lastUpdated: DateTime.now(),
        );
        productUnits.add(auxUnit);
        print(
          'ğŸ” [DEBUG]   âœ?æ·»åŠ è¾…å•ä½? ${auxUnit.id} æ‰¹å‘ä»? ${auxUnit.wholesalePriceInCents}',
        );
      } else {
        print('ğŸ” [DEBUG]   â?è·³è¿‡æ— æ•ˆè¾…å•ä½?');
        if (aux.unit == null) {
          print('ğŸ” [DEBUG]     - å•ä½å¯¹è±¡ä¸ºnull');
        }
        if (aux.conversionRate <= 0) {
          print('ğŸ” [DEBUG]     - æ¢ç®—ç‡æ— æ•? ${aux.conversionRate}');
        }
      }
    }

    print('ğŸ” [DEBUG] ==================== æ„å»ºç»“æœ ====================');
    print('ğŸ” [DEBUG] æ€»è®¡äº§å“å•ä½æ•°é‡: ${productUnits.length}');
    for (int i = 0; i < productUnits.length; i++) {
      final pu = productUnits[i];
      print('ğŸ” [DEBUG] äº§å“å•ä½ ${i + 1}: ${pu.id} (æ¢ç®—ç? ${pu.conversionRate})');
    }
    print('ğŸ” [DEBUG] ==================== æ„å»ºå®Œæˆ ====================');

    return productUnits;
  }

  /// æ„å»ºè¾…å•ä½æ¡ç æ•°æ?
  List<Map<String, String>> _buildAuxiliaryUnitBarcodes() {
    final List<Map<String, String>> barcodes = [];

    for (final aux in _auxiliaryUnits) {
      if (aux.unit != null && aux.barcodeController.text.trim().isNotEmpty) {
        barcodes.add({
          'id': '${widget.productId ?? 'new'}_${aux.unit!.id}',
          'barcode': aux.barcodeController.text.trim(),
        });
      }
    }

    return barcodes;
  }

  void _handleReturn() {
    print('ğŸ” å¤„ç†è¿”å›ï¼Œå¼€å§‹æ„å»ºæ•°æ?..');
    try {
      final productUnits = _buildProductUnits();
      final auxiliaryBarcodes = _buildAuxiliaryUnitBarcodes();

      if (productUnits.isNotEmpty) {
        print('ğŸ” æ•°æ®æœ‰æ•ˆï¼Œè¿”å›äº§å“å•ä½æ•°æ?);

        // âœ?å…ˆä¿å­˜åˆ° unitEditFormProviderï¼Œç¡®ä¿ä¸‹æ¬¡è¿›å…¥æ—¶èƒ½æ¢å¤æ•°æ?
        _saveCurrentDataToFormProvider();

        // è¿”å›åŒ…å«äº§å“å•ä½å’Œæ¡ç ä¿¡æ¯çš„æ•°æ®
        Navigator.of(context).pop({
          'productUnits': productUnits,
          'auxiliaryBarcodes': auxiliaryBarcodes,
        });
      } else {
        print('ğŸ” æ•°æ®æ— æ•ˆæˆ–ç¼ºå°‘åŸºæœ¬å•ä½ï¼Œç›´æ¥è¿”å›');
        Navigator.of(context).pop();
      }
    } catch (e, s) {
      print('â?è¿”å›å¤„ç†å¼‚å¸¸: $e\n$s');
      // å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œç®€å•è¿”å›?
      Navigator.of(context).pop();
    }
  }

  /// å°†å½“å‰ç¼–è¾‘çš„è¾…å•ä½æ•°æ®ä¿å­˜åˆ° FormProviderï¼Œç¡®ä¿æ•°æ®æŒä¹…åŒ–
  void _saveCurrentDataToFormProvider() {
    print('ğŸ” ä¿å­˜å½“å‰æ•°æ®åˆ?unitEditFormProvider');
    try {
      final auxiliaryUnitsData = _auxiliaryUnits.map((aux) {
        // å°†å…ƒè½¬æ¢ä¸ºåˆ†å­˜å‚¨
        String retailPriceInCents = '';
        if (aux.retailPriceController.text.trim().isNotEmpty) {
          final priceInYuan = double.tryParse(
            aux.retailPriceController.text.trim(),
          );
          if (priceInYuan != null) {
            retailPriceInCents = (priceInYuan * 100).round().toString();
          }
        }

        String wholesalePriceInCents = '';
        if (aux.wholesalePriceController.text.trim().isNotEmpty) {
          final priceInYuan = double.tryParse(
            aux.wholesalePriceController.text.trim(),
          );
          if (priceInYuan != null) {
            wholesalePriceInCents = (priceInYuan * 100).round().toString();
          }
        }

        return AuxiliaryUnitData(
          id: aux.id,
          unitId: aux.unit?.id,
          unitName: aux.unitController.text.trim(),
          conversionRate: aux.conversionRate,
          barcode: aux.barcodeController.text.trim(),
          retailPriceInCents: retailPriceInCents,
          wholesalePriceInCents: wholesalePriceInCents,
        );
      }).toList();

      ref
          .read(unitEditFormProvider.notifier)
          .setAuxiliaryUnits(auxiliaryUnitsData, counter: _auxiliaryCounter);
      print(
        'âœ?æ•°æ®å·²ä¿å­˜åˆ° unitEditFormProviderï¼Œå…± ${auxiliaryUnitsData.length} ä¸ªè¾…å•ä½',
      );
    } catch (e, s) {
      print('â?ä¿å­˜æ•°æ®åˆ?FormProvider å¤±è´¥: $e\n$s');
    }
  }

  void _loadFromFormProvider() {
    try {
      final formState = ref.read(unitEditFormProvider);

      if (formState.auxiliaryUnits.isNotEmpty) {
        _loadAuxiliaryUnitsFromFormData(formState.auxiliaryUnits);
        _auxiliaryCounter = formState.auxiliaryCounter;
      }
    } catch (e) {}
  }

  Future<void> _loadAuxiliaryUnitsFromFormData(
    List<AuxiliaryUnitData> auxiliaryUnitsData,
  ) async {
    try {
      final List<_AuxiliaryUnit> tempAuxiliaryUnits = [];
      final allUnits = await ref.read(allUnitsProvider.future);

      for (final auxData in auxiliaryUnitsData) {
        print('=================ã€Providerè°ƒè¯•ã€?================');
        print('AuxiliaryUnitData ID: ${auxData.id}');
        print('unitName: ${auxData.unitName}, unitId: ${auxData.unitId}');
        print('conversionRate: ${auxData.conversionRate}');
        print('retailPriceInCents: ${auxData.retailPriceInCents}');
        print('wholesalePriceInCents: ${auxData.wholesalePriceInCents}');
        print('barcode: ${auxData.barcode}');
        print('===============================================');
        Unit? unit;

        if (auxData.unitName.trim().isNotEmpty) {
          unit = allUnits.firstWhere(
            (u) => u.name == auxData.unitName.trim(),
            orElse: () => Unit.empty(),
          );

          if (unit.isNew) {
            unit = Unit(id: auxData.unitId, name: auxData.unitName.trim());
          }
        }

        final auxiliaryUnit = _AuxiliaryUnit(
          id: auxData.id,
          unit: unit,
          conversionRate: auxData.conversionRate,
          initialSellingPrice: auxData.retailPriceInCents.isNotEmpty
              ? (double.tryParse(auxData.retailPriceInCents) ?? 0) / 100
              : null,
          initialWholesalePrice: auxData.wholesalePriceInCents.isNotEmpty
              ? (double.tryParse(auxData.wholesalePriceInCents) ?? 0) / 100
              : null,
        );

        auxiliaryUnit.unitController.text = auxData.unitName;
        auxiliaryUnit.barcodeController.text = auxData.barcode;
        // retailPriceController å’?wholesalePriceController å·²åœ¨æ„é€ å‡½æ•°åˆå§‹åŒ–ï¼Œæ— éœ€é‡å¤èµ‹å€?
        print('=== Provideræ§ä»¶åˆå§‹åŒ?===');
        print(
          'retailPriceController.text: "${auxiliaryUnit.retailPriceController.text}"',
        );
        print(
          'wholesalePriceController.text: "${auxiliaryUnit.wholesalePriceController.text}"',
        );
        print('=======================');

        tempAuxiliaryUnits.add(auxiliaryUnit);
      }

      if (mounted && tempAuxiliaryUnits.isNotEmpty) {
        setState(() {
          _auxiliaryUnits.clear();
          _auxiliaryUnits.addAll(tempAuxiliaryUnits);
        });
      }
    } catch (e) {}
  }
}

class _AuxiliaryUnit {
  final int id;
  Unit? unit;
  int conversionRate;
  late TextEditingController unitController;
  late TextEditingController barcodeController;
  late TextEditingController retailPriceController;
  late TextEditingController wholesalePriceController;

  // ç„¦ç‚¹èŠ‚ç‚¹
  final FocusNode unitFocusNode = FocusNode();
  final FocusNode conversionRateFocusNode = FocusNode();
  final FocusNode retailPriceFocusNode = FocusNode();
  final FocusNode wholesalePriceFocusNode = FocusNode();

  _AuxiliaryUnit({
    required this.id,
    this.unit,
    required this.conversionRate,
    double? initialSellingPrice,
    double? initialWholesalePrice,
  }) {
    print('ğŸ” æ„é€ _AuxiliaryUnit: initialSellingPrice=$initialSellingPrice');
    unitController = TextEditingController(text: unit?.name ?? '');
    barcodeController = TextEditingController();
    retailPriceController = TextEditingController(
      text: initialSellingPrice?.toString() ?? '',
    );
    wholesalePriceController = TextEditingController(
      text: initialWholesalePrice?.toString() ?? '',
    );
    print('ğŸ” retailPriceController.text=${retailPriceController.text}');
  }

  void dispose() {
    unitController.dispose();
    barcodeController.dispose();
    retailPriceController.dispose();
    wholesalePriceController.dispose();
    unitFocusNode.dispose();
    conversionRateFocusNode.dispose();
    retailPriceFocusNode.dispose();
    wholesalePriceFocusNode.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../application/category_notifier.dart';
import '../../domain/model/category.dart';
import '../../../../core/utils/snackbar_helper.dart';
import '../../data/repository/product_repository.dart';

/// ç±»åˆ«é€‰æ‹©å±å¹•
/// æ”¯æŒé€‰æ‹©ã€æ–°å¢ã€é‡å‘½åã€åˆ é™¤ç±»åˆ«çš„åŠŸèƒ½
class CategorySelectionScreen extends ConsumerStatefulWidget {
  final int? selectedCategoryId;
  final bool isSelectionMode;

  const CategorySelectionScreen({
    super.key,
    this.selectedCategoryId,
    this.isSelectionMode = true,
  });

  @override
  ConsumerState<CategorySelectionScreen> createState() =>
      _CategorySelectionScreenState();
}

class _CategorySelectionScreenState
    extends ConsumerState<CategorySelectionScreen> {
  // ç”¨äºç®¡ç†æ¯ä¸ªç±»åˆ«çš„å±•å¼€/æ”¶èµ·çŠ¶æ€?
  final Map<int, bool> _expandedCategories = {};
  // æœç´¢å…³é”®å­?
  String _searchQuery = '';
  // ç¼“å­˜æ¯ä¸ªç±»åˆ«çš„äº§å“æ•°é‡?
  final Map<int, int> _categoryProductCounts = {};

  @override
  void initState() {
    super.initState();
    _loadProductCounts();
  }

  /// åŠ è½½æ‰€æœ‰ç±»åˆ«çš„äº§å“æ•°é‡ï¼ˆåŒ…å«å­ç±»åˆ«ï¼?
  Future<void> _loadProductCounts() async {
    final categoryState = ref.read(categoryListProvider);
    final productRepository = ref.read(productRepositoryProvider);
    final allCategories = categoryState.categories;

    for (final category in allCategories) {
      if (category.id != null) {
        try {
          // è·å–å½“å‰ç±»åˆ«çš„äº§å“æ•°é‡?
          final products = await productRepository.getProductsByCondition(
            categoryId: category.id,
          );
          int totalCount = products.length;

          // é€’å½’è®¡ç®—æ‰€æœ‰å­ç±»åˆ«çš„äº§å“æ•°é‡?
          totalCount += await _getSubCategoriesProductCount(
            category.id!,
            allCategories,
            productRepository,
          );

          _categoryProductCounts[category.id!] = totalCount;
        } catch (e) {
          _categoryProductCounts[category.id!] = 0;
        }
      }
    }

    if (mounted) {
      setState(() {});
    }
  }

  /// é€’å½’è®¡ç®—å­ç±»åˆ«çš„äº§å“æ€»æ•°
  Future<int> _getSubCategoriesProductCount(
    int parentId,
    List<CategoryModel> allCategories,
    dynamic productRepository,
  ) async {
    int count = 0;

    // è·å–ç›´æ¥å­ç±»åˆ?
    final subCategories = allCategories
        .where((cat) => cat.parentId == parentId)
        .toList();

    for (final subCategory in subCategories) {
      if (subCategory.id != null) {
        try {
          // è·å–å­ç±»åˆ«çš„äº§å“æ•°é‡
          final products = await productRepository.getProductsByCondition(
            categoryId: subCategory.id,
          );
          count += products.length as int;

          // é€’å½’è®¡ç®—å­ç±»åˆ«çš„å­ç±»åˆ?
          final subCount = await _getSubCategoriesProductCount(
            subCategory.id!,
            allCategories,
            productRepository,
          );
          count += subCount;
        } catch (e) {
          // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­è®¡ç®—å…¶ä»–å­ç±»åˆ«
        }
      }
    }

    return count;
  }

  Future<void> _showSearchDialog(BuildContext context) async {
    final searchController = TextEditingController();
    searchController.text = _searchQuery;

    final newQuery = await showDialog<String>(
      context: context,
      builder: (context) => Transform.translate(
        offset: const Offset(0, 150),
        child: Dialog(
          backgroundColor: Colors.transparent,
          elevation: 0,
          insetPadding: const EdgeInsets.symmetric(horizontal: 9.0),
          child: TextField(
            controller: searchController,
            autofocus: true,
            onSubmitted: (value) => Navigator.of(context).pop(value),
            decoration: InputDecoration(
              filled: true,
              fillColor: Theme.of(context).scaffoldBackgroundColor,
              border: const OutlineInputBorder(borderSide: BorderSide.none),
              contentPadding: const EdgeInsets.symmetric(
                vertical: 15.0,
                horizontal: 10.0,
              ),
              suffixIcon: Padding(
                padding: const EdgeInsets.only(right: 4.0),
                child: TextButton(
                  onPressed: () =>
                      Navigator.of(context).pop(searchController.text),
                  child: const Text('æœç´¢'),
                ),
              ),
            ),
          ),
        ),
      ),
    );

    if (newQuery != null) {
      setState(() {
        _searchQuery = newQuery;
      });
    }
  }

  List<CategoryModel> _getFilteredCategories(List<CategoryModel> categories) {
    if (_searchQuery.isEmpty) {
      return categories;
    }

    final lowerCaseQuery = _searchQuery.toLowerCase();
    return categories
        .where(
          (category) => category.name.toLowerCase().contains(lowerCaseQuery),
        )
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    final categoryState = ref.watch(categoryListProvider);
    final allCategories = categoryState.categories;
    final filteredCategories = _getFilteredCategories(allCategories);

    // å½“ç±»åˆ«åˆ—è¡¨å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé‡æ–°åŠ è½½äº§å“æ•°é‡?
    ref.listen(categoryListProvider, (previous, next) {
      if (previous?.categories != next.categories) {
        _loadProductCounts();
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: _searchQuery.isNotEmpty
            ? Row(
                children: [
                  const Icon(Icons.search, size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(_searchQuery, overflow: TextOverflow.ellipsis),
                  ),
                  Text('(${filteredCategories.length})'),
                ],
              )
            : Text(widget.isSelectionMode ? 'é€‰æ‹©ç±»åˆ«' : 'ç±»åˆ«ç®¡ç†'),
        leading: IconButton(
          onPressed: () => Navigator.of(context).pop(),
          icon: const Icon(Icons.arrow_back),
          tooltip: 'è¿”å›',
        ),
        actions: [
          if (_searchQuery.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.clear),
              tooltip: 'æ¸…é™¤æœç´¢',
              onPressed: () {
                setState(() {
                  _searchQuery = '';
                });
              },
            ),
          IconButton(
            icon: const Icon(Icons.search),
            tooltip: 'æœç´¢',
            onPressed: () => _showSearchDialog(context),
          ),
          IconButton(
            onPressed: () => _showAddCategoryDialog(context),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å¢ç±»åˆ«',
          ),
        ],
      ),
      body: filteredCategories.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const SizedBox(height: 16),
                  Text(
                    _searchQuery.isNotEmpty ? 'æœªæ‰¾åˆ°åŒ¹é…çš„ç±»åˆ«' : 'æš‚æ— ç±»åˆ«',
                    style: const TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  Text(_searchQuery.isNotEmpty ? 'å°è¯•å…¶ä»–å…³é”®è¯? : 'ç‚¹å‡»å³ä¸Šè§?+ å·æ·»åŠ æ–°ç±»åˆ«'),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: _searchQuery.isNotEmpty
                  ? filteredCategories.length
                  : _buildHierarchicalList(filteredCategories).length,
              itemBuilder: (context, index) {
                if (_searchQuery.isNotEmpty) {
                  // æœç´¢æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰å¹³åˆ—è¡?
                  final category = filteredCategories[index];
                  return _buildCategoryTile(
                    context,
                    category,
                    0,
                    allCategories,
                  );
                } else {
                  // æ­£å¸¸æ¨¡å¼ï¼šæ˜¾ç¤ºå±‚çº§ç»“æ?
                  final item = _buildHierarchicalList(
                    filteredCategories,
                  )[index];
                  return item;
                }
              },
            ),
    );
  }

  List<Widget> _buildHierarchicalList(List<CategoryModel> categories) {
    final widgets = <Widget>[];

    // è·å–é¡¶çº§ç±»åˆ«ï¼ˆæ— çˆ¶çº§çš„ç±»åˆ«ï¼‰
    final topLevelCategories = categories
        .where((category) => category.parentId == null)
        .toList();

    for (final category in topLevelCategories) {
      _buildCategoryWithChildren(widgets, categories, category, 0);
    }

    return widgets;
  }

  void _buildCategoryWithChildren(
    List<Widget> widgets,
    List<CategoryModel> allCategories,
    CategoryModel category,
    int level,
  ) {
    widgets.add(_buildCategoryTile(context, category, level, allCategories));

    // è·å–å½“å‰ç±»åˆ«çš„å­ç±»åˆ«
    if (category.id != null) {
      final subCategories = allCategories
          .where((subCat) => subCat.parentId == category.id)
          .toList(); // åªæœ‰åœ¨å±•å¼€çŠ¶æ€ä¸‹æ‰é€’å½’æ·»åŠ å­ç±»åˆ?
      final isExpanded = _expandedCategories[category.id!] ?? false; // æ‰€æœ‰ç±»åˆ«é»˜è®¤æ”¶èµ?
      if (isExpanded && subCategories.isNotEmpty) {
        for (final subCategory in subCategories) {
          _buildCategoryWithChildren(
            widgets,
            allCategories,
            subCategory,
            level + 1,
          );
        }
      }
    }
  }

  Widget _buildCategoryTile(
    BuildContext context,
    CategoryModel category, [
    int level = 0,
    List<CategoryModel>? allCategories,
  ]) {
    final isSelected = widget.selectedCategoryId == category.id;
    final isSubCategory = level > 0;

    // æ£€æŸ¥æ˜¯å¦æœ‰å­ç±»åˆ?
    final hasSubCategories =
        allCategories?.any((cat) => cat.parentId == category.id) ?? false;
    final isExpanded = _expandedCategories[category.id!] ?? false; // æ‰€æœ‰ç±»åˆ«é»˜è®¤æ”¶èµ?

    // è®¡ç®—å·¦ä¾§è¾¹è·
    final leftMargin = level * 24.0;

    // è·å–äº§å“æ•°é‡
    final productCount = _categoryProductCounts[category.id] ?? 0;

    return Container(
      margin: EdgeInsets.only(bottom: 8, left: leftMargin),
      child: Card(
        elevation: isSelected ? 4 : 1,
        color: isSelected
            ? Theme.of(context).primaryColor.withOpacity(0.1)
            : null,
        child: ListTile(
          title: Row(
            children: [
              // å±•å¼€/æ”¶èµ·å›¾æ ‡ï¼ˆåªå¯¹æœ‰å­ç±»åˆ«çš„ç±»åˆ«æ˜¾ç¤ºï¼?
              if (hasSubCategories) ...[
                GestureDetector(
                  onTap: () {
                    setState(() {
                      if (category.id != null) {
                        _expandedCategories[category.id!] = !isExpanded;
                      }
                    });
                  },
                  child: Icon(
                    isExpanded ? Icons.expand_less : Icons.expand_more,
                    size: 20,
                    color: Colors.grey.shade600,
                  ),
                ),
                const SizedBox(width: 8),
              ],
              Expanded(
                child: Row(
                  children: [
                    Text(
                      category.name,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        fontSize: isSubCategory ? 14 : 16,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 6,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.blue.shade100,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Text(
                        '$productCount',
                        style: TextStyle(
                          fontSize: 11,
                          color: Colors.blue.shade700,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          subtitle: hasSubCategories
              ? Text(
                  '${allCategories?.where((cat) => cat.parentId == category.id).length ?? 0} ä¸ªå­ç±»åˆ«',
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                )
              : null,
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              PopupMenuButton<String>(
                onSelected: (action) =>
                    _handleCategoryAction(context, category, action),
                itemBuilder: (context) => [
                  // å¯ä»¥ä¸ºä»»ä½•ç±»åˆ«æ·»åŠ çˆ¶ç±?
                  const PopupMenuItem(
                    value: 'add_parent_category',
                    child: Row(
                      children: [
                        Icon(Icons.add, size: 20),
                        SizedBox(width: 8),
                        Text('æ–°å¢çˆ¶ç±»'),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'edit',
                    child: Row(
                      children: [
                        Icon(Icons.edit, size: 20),
                        SizedBox(width: 8),
                        Text('é‡å‘½å?),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(
                          Icons.delete,
                          size: 20,
                          color: Color.fromARGB(255, 78, 6, 138),
                        ),
                        SizedBox(width: 8),
                        Text(
                          'åˆ é™¤',
                          style: TextStyle(
                            color: Color.fromARGB(255, 85, 0, 141),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
          onTap: () {
            if (widget.isSelectionMode) {
              // æ£€æŸ¥æ˜¯å¦ä¸º"çƒ?ç±»åˆ«ä¸”æ˜¯ä¸€çº§ç±»åˆ?
              if (category.name == 'çƒ? && level == 0 && hasSubCategories) {
                // "çƒ?ç±»åˆ«ä¸”æœ‰å­ç±»åˆ«ï¼šåˆ‡æ¢å±•å¼€/æ”¶èµ·çŠ¶æ€?
                setState(() {
                  if (category.id != null) {
                    _expandedCategories[category.id!] = !isExpanded;
                  }
                });
              } else {
                // é€‰æ‹©æ¨¡å¼ï¼šç›´æ¥è¿”å›é€‰ä¸­çš„ç±»åˆ?
                Navigator.of(context).pop(category);
              }
            } else if (hasSubCategories) {
              // éé€‰æ‹©æ¨¡å¼ä¸”æœ‰å­ç±»åˆ«ï¼šåˆ‡æ¢å±•å¼€/æ”¶èµ·çŠ¶æ€?
              setState(() {
                if (category.id != null) {
                  _expandedCategories[category.id!] = !isExpanded;
                }
              });
            }
          },
        ),
      ),
    );
  }

  void _handleCategoryAction(
    BuildContext context,
    CategoryModel category,
    String action,
  ) {
    switch (action) {
      case 'add_parent_category':
        _showAddParentCategoryDialog(context, category);
        break;
      case 'edit':
        _showEditCategoryDialog(context, category);
        break;
      case 'delete':
        _showDeleteCategoryDialog(context, category);
        break;
    }
  }

  void _showAddCategoryDialog(BuildContext context) {
    final nameController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('æ–°å¢ç±»åˆ«'),
        content: Form(
          key: formKey,
          child: TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'ç±»åˆ«åç§°',
              hintText: 'è¯·è¾“å…¥ç±»åˆ«åç§?,
              border: OutlineInputBorder(),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'è¯·è¾“å…¥ç±»åˆ«åç§?;
              }
              final categories = ref.read(categoryListProvider).categories;
              if (categories.any((cat) => cat.name == value.trim())) {
                return 'ç±»åˆ«åç§°å·²å­˜åœ?;
              }
              return null;
            },
            autofocus: true,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                try {
                  await ref
                      .read(categoryListProvider.notifier)
                      .addCategory(name: nameController.text.trim());
                  Navigator.of(context).pop();
                  showAppSnackBar(context, message: 'ç±»åˆ«æ·»åŠ æˆåŠŸ');
                  _loadProductCounts(); // é‡æ–°åŠ è½½äº§å“æ•°é‡
                } catch (e) {
                  showAppSnackBar(context, message: 'æ·»åŠ å¤±è´¥: $e', isError: true);
                }
              }
            },
            child: const Text('æ·»åŠ '),
          ),
        ],
      ),
    );
  }

  void _showAddParentCategoryDialog(
    BuildContext context,
    CategoryModel childCategory,
  ) {
    final nameController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('ä¸?${childCategory.name}"æ–°å¢çˆ¶ç±»'),
        content: Form(
          key: formKey,
          child: TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'çˆ¶ç±»åç§°',
              hintText: 'è¯·è¾“å…¥çˆ¶ç±»åç§?,
              border: OutlineInputBorder(),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'è¯·è¾“å…¥çˆ¶ç±»åç§?;
              }
              final categories = ref.read(categoryListProvider).categories;
              if (categories.any((cat) => cat.name == value.trim())) {
                return 'ç±»åˆ«åç§°å·²å­˜åœ?;
              }
              return null;
            },
            autofocus: true,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                try {
                  // 1. å…ˆåˆ›å»ºæ–°çš„çˆ¶ç±»åˆ«
                  await ref
                      .read(categoryListProvider.notifier)
                      .addCategory(
                        name: nameController.text.trim(),
                        parentId: childCategory.parentId, // æ–°çˆ¶ç±»ç»§æ‰¿å½“å‰ç±»åˆ«çš„çˆ¶çº§
                      );

                  // 2. è·å–æ–°åˆ›å»ºçš„çˆ¶ç±»åˆ«IDï¼ˆæ ¹æ®åç§°æŸ¥æ‰¾ï¼‰
                  await ref
                      .read(categoryListProvider.notifier)
                      .loadCategories();
                  final updatedCategories = ref
                      .read(categoryListProvider)
                      .categories;
                  final newParent = updatedCategories.firstWhere(
                    (cat) => cat.name == nameController.text.trim(),
                  );

                  // 3. æ›´æ–°å½“å‰ç±»åˆ«ï¼Œè®©å®ƒæˆä¸ºæ–°çˆ¶ç±»çš„å­ç±?
                  await ref
                      .read(categoryListProvider.notifier)
                      .updateCategory(
                        id: childCategory.id!,
                        name: childCategory.name,
                        parentId: newParent.id, // è®¾ç½®æ–°åˆ›å»ºçš„çˆ¶ç±»ä¸ºçˆ¶çº?
                      );

                  Navigator.of(context).pop();
                  showAppSnackBar(
                    context,
                    message: 'çˆ¶ç±»"${nameController.text.trim()}"åˆ›å»ºæˆåŠŸ',
                  );
                  _loadProductCounts(); // é‡æ–°åŠ è½½äº§å“æ•°é‡
                } catch (e) {
                  showAppSnackBar(context, message: 'æ·»åŠ å¤±è´¥: $e', isError: true);
                }
              }
            },
            child: const Text('æ·»åŠ '),
          ),
        ],
      ),
    );
  }

  void _showEditCategoryDialog(BuildContext context, CategoryModel category) {
    final nameController = TextEditingController(text: category.name);
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('é‡å‘½åç±»åˆ?),
        content: Form(
          key: formKey,
          child: TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'ç±»åˆ«åç§°',
              border: OutlineInputBorder(),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'è¯·è¾“å…¥ç±»åˆ«åç§?;
              }
              final categories = ref.read(categoryListProvider).categories;
              if (categories.any(
                (cat) => cat.name == value.trim() && cat.id != category.id,
              )) {
                return 'ç±»åˆ«åç§°å·²å­˜åœ?;
              }
              return null;
            },
            autofocus: true,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                try {
                  await ref
                      .read(categoryListProvider.notifier)
                      .updateCategory(
                        id: category.id!,
                        name: nameController.text.trim(),
                      );
                  Navigator.of(context).pop();
                  showAppSnackBar(context, message: 'ç±»åˆ«é‡å‘½åæˆåŠ?);
                  _loadProductCounts(); // é‡æ–°åŠ è½½äº§å“æ•°é‡
                } catch (e) {
                  showAppSnackBar(context, message: 'é‡å‘½åå¤±è´? $e', isError: true);
                }
              }
            },
            child: const Text('ä¿å­˜'),
          ),
        ],
      ),
    );
  }

  void _showDeleteCategoryDialog(
    BuildContext context,
    CategoryModel category,
  ) async {
    final categories = ref.read(categoryListProvider).categories;
    final allSubCategories = _getAllSubCategories(categories, category.id!);
    final hasSubCategories = allSubCategories.isNotEmpty;

    // è·å–å…³è”äº§å“æ•°é‡
    int relatedProductsCount = 0;
    try {
      final productRepository = ref.read(productRepositoryProvider);
      final products = await productRepository.getProductsByCondition(
        categoryId: category.id,
      );
      relatedProductsCount = products.length;
    } catch (e) {
      print('è·å–äº§å“æ•°é‡å¤±è´¥: $e');
      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”?ä½œä¸ºé»˜è®¤å€?
    }

    showDialog(
      context: context,
      builder: (context) => _DeleteCategoryDialog(
        category: category,
        hasSubCategories: hasSubCategories,
        subCategoriesCount: allSubCategories.length,
        relatedProductsCount: relatedProductsCount,
        onDeleteOnly: () async {
          try {
            await ref
                .read(categoryListProvider.notifier)
                .deleteCategoryOnly(category.id!);
            Navigator.of(context).pop();
            showAppSnackBar(context, message: 'ç±»åˆ«åˆ é™¤æˆåŠŸï¼Œå­ç±»åˆ«å’Œäº§å“å·²ä¿ç•™');
            _loadProductCounts(); // é‡æ–°åŠ è½½äº§å“æ•°é‡
          } catch (e) {
            Navigator.of(context).pop();
            showAppSnackBar(context, message: 'åˆ é™¤å¤±è´¥: $e', isError: true);
          }
        },
        onDeleteCascade: () async {
          try {
            await ref
                .read(categoryListProvider.notifier)
                .deleteCategoryCascade(category.id!);
            Navigator.of(context).pop();
            showAppSnackBar(context, message: 'ç±»åˆ«åŠæ‰€æœ‰å…³è”å†…å®¹åˆ é™¤æˆåŠ?, isError: true);
            _loadProductCounts(); // é‡æ–°åŠ è½½äº§å“æ•°é‡
          } catch (e) {
            Navigator.of(context).pop();
            showAppSnackBar(context, message: 'åˆ é™¤å¤±è´¥: $e', isError: true);
          }
        },
      ),
    );
  }

  // é€’å½’è·å–æ‰€æœ‰å­ç±»åˆ«
  List<CategoryModel> _getAllSubCategories(
    List<CategoryModel> allCategories,
    int parentId,
  ) {
    final result = <CategoryModel>[];

    // è·å–ç›´æ¥å­ç±»åˆ?
    final directSubCategories = allCategories
        .where((cat) => cat.parentId == parentId)
        .toList();

    for (final subCategory in directSubCategories) {
      result.add(subCategory);
      // é€’å½’è·å–å­ç±»åˆ«çš„å­ç±»åˆ?
      if (subCategory.id != null) {
        result.addAll(_getAllSubCategories(allCategories, subCategory.id!));
      }
    }
    return result;
  }
}

/// åˆ é™¤ç±»åˆ«å¯¹è¯æ¡†ç»„ä»?
class _DeleteCategoryDialog extends StatefulWidget {
  final CategoryModel category;
  final bool hasSubCategories;
  final int subCategoriesCount;
  final int relatedProductsCount;
  final VoidCallback onDeleteOnly;
  final VoidCallback onDeleteCascade;

  const _DeleteCategoryDialog({
    required this.category,
    required this.hasSubCategories,
    required this.subCategoriesCount,
    required this.relatedProductsCount,
    required this.onDeleteOnly,
    required this.onDeleteCascade,
  });

  @override
  State<_DeleteCategoryDialog> createState() => _DeleteCategoryDialogState();
}

class _DeleteCategoryDialogState extends State<_DeleteCategoryDialog> {
  int _selectedOption = 0; // 0: ä»…åˆ é™¤å½“å‰ç±»åˆ? 1: çº§è”åˆ é™¤

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.warning, color: Colors.orange, size: 24),
          const SizedBox(width: 8),
          const Text('åˆ é™¤ç±»åˆ«'),
        ],
      ),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'å³å°†åˆ é™¤ç±»åˆ« "${widget.category.name}"',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),

            // æ˜¾ç¤ºå½±å“èŒƒå›´ä¿¡æ¯
            if (widget.hasSubCategories || widget.relatedProductsCount > 0) ...[
              const Text(
                'å½±å“èŒƒå›´ï¼?,
                style: TextStyle(fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),

              if (widget.hasSubCategories)
                Row(
                  children: [
                    Icon(Icons.folder, size: 16, color: Colors.blue),
                    const SizedBox(width: 4),
                    Text('å­ç±»åˆ«ï¼š${widget.subCategoriesCount} ä¸?),
                  ],
                ),

              if (widget.relatedProductsCount > 0) ...[
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(Icons.inventory, size: 16, color: Colors.green),
                    const SizedBox(width: 4),
                    Text('å…³è”äº§å“ï¼?{widget.relatedProductsCount} ä¸?),
                  ],
                ),
              ],

              const SizedBox(height: 16),
            ],

            const Text(
              'è¯·é€‰æ‹©åˆ é™¤æ¨¡å¼ï¼?,
              style: TextStyle(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 12),

            // é€‰é¡¹1ï¼šä»…åˆ é™¤å½“å‰ç±»åˆ«
            Container(
              decoration: BoxDecoration(
                border: Border.all(
                  color: _selectedOption == 0
                      ? Theme.of(context).primaryColor
                      : Colors.grey.shade300,
                  width: _selectedOption == 0 ? 2 : 1,
                ),
                borderRadius: BorderRadius.circular(8),
                color: _selectedOption == 0
                    ? Theme.of(context).primaryColor.withOpacity(0.1)
                    : null,
              ),
              child: RadioListTile<int>(
                value: 0,
                groupValue: _selectedOption,
                onChanged: (value) {
                  setState(() {
                    _selectedOption = value!;
                  });
                },
                title: const Text(
                  'ä»…åˆ é™¤å½“å‰ç±»åˆ?,
                  style: TextStyle(fontWeight: FontWeight.w600),
                ),
                subtitle: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const SizedBox(height: 4),
                    const Text('ä¿ç•™å­ç±»åˆ«å’Œå…³è”äº§å“'),
                    const SizedBox(height: 8),

                    if (widget.hasSubCategories) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.arrow_forward,
                            size: 14,
                            color: Colors.blue,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              widget.category.parentId != null
                                  ? 'å­ç±»åˆ«å°†è½¬ç§»åˆ°ä¸Šçº§ç±»åˆ?
                                  : 'å­ç±»åˆ«å°†æˆä¸ºæ ¹ç±»åˆ?,
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.blue.shade700,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                    ],

                    if (widget.relatedProductsCount > 0) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.arrow_forward,
                            size: 14,
                            color: Colors.green,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              widget.category.parentId != null
                                  ? 'äº§å“å°†è½¬ç§»åˆ°ä¸Šçº§ç±»åˆ«'
                                  : 'äº§å“å°†å–æ¶ˆç±»åˆ«å…³è?,
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.green.shade700,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                    ],
                  ],
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 8),
              ),
            ),

            const SizedBox(height: 12),

            // é€‰é¡¹2ï¼šçº§è”åˆ é™?
            Container(
              decoration: BoxDecoration(
                border: Border.all(
                  color: _selectedOption == 1
                      ? Colors.red
                      : Colors.grey.shade300,
                  width: _selectedOption == 1 ? 2 : 1,
                ),
                borderRadius: BorderRadius.circular(8),
                color: _selectedOption == 1
                    ? Colors.red.withOpacity(0.1)
                    : null,
              ),
              child: RadioListTile<int>(
                value: 1,
                groupValue: _selectedOption,
                onChanged: (value) {
                  setState(() {
                    _selectedOption = value!;
                  });
                },
                title: const Text(
                  'çº§è”åˆ é™¤æ‰€æœ‰å†…å®?,
                  style: TextStyle(fontWeight: FontWeight.w600),
                ),
                subtitle: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const SizedBox(height: 4),
                    const Text('åˆ é™¤ç±»åˆ«åŠæ‰€æœ‰å…³è”å†…å®?),
                    const SizedBox(height: 8),

                    if (widget.hasSubCategories) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.delete,
                            size: 14,
                            color: const Color.fromARGB(255, 136, 54, 244),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            'åˆ é™¤æ‰€æœ‰å­ç±»åˆ«ï¼?{widget.subCategoriesCount} ä¸ªï¼‰',
                            style: TextStyle(
                              fontSize: 12,
                              color: const Color.fromARGB(255, 178, 47, 211),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                    ],

                    if (widget.relatedProductsCount > 0) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.delete,
                            size: 14,
                            color: const Color.fromARGB(255, 152, 54, 244),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            'åˆ é™¤æ‰€æœ‰å…³è”äº§å“ï¼ˆ${widget.relatedProductsCount} ä¸ªï¼‰',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.red.shade700,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                    ],

                    const Row(
                      children: [
                        Icon(Icons.warning, size: 14, color: Colors.orange),
                        SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            'æ­¤æ“ä½œä¸å¯æ¢å¤?,
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.orange,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 8),
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: _selectedOption == 0
              ? widget.onDeleteOnly
              : widget.onDeleteCascade,
          style: ElevatedButton.styleFrom(
            backgroundColor: _selectedOption == 0 ? Colors.blue : Colors.red,
            foregroundColor: Colors.white,
          ),
          child: Text(_selectedOption == 0 ? 'ä»…åˆ é™¤ç±»åˆ? : 'çº§è”åˆ é™¤'),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/shared_widgets/shared_widgets.dart';
import '../../domain/model/product.dart';
import '../../domain/model/unit.dart';
import '../../application/provider/product_providers.dart';
import '../../application/category_notifier.dart';
import '../../application/provider/unit_providers.dart';
import '../../application/provider/barcode_providers.dart';
import '../widgets/sections/shelf_life_section.dart';
import '../widgets/sections/pricing_section.dart';
import '../widgets/inputs/app_text_field.dart';
// coordinator é€»è¾‘å·²ç§»åŠ¨åˆ° actions
import '../widgets/sections/basic_info_section.dart';
import '../widgets/sections/unit_category_section.dart';
import '../widgets/product_form_action_bar.dart';
import '../controllers/product_form_controllers.dart';
import '../state/product_form_ui_provider.dart';
import '../controllers/product_add_edit_actions.dart';
import '../../application/provider/unit_edit_form_providers.dart';

/// è´§å“æ·»åŠ /ç¼–è¾‘é¡µé¢
/// è¡¨å•é¡µé¢ï¼Œæäº¤æ—¶è°ƒç”¨ ref.read(productOperationsProvider.notifier).addProduct(...)
class ProductAddEditScreen extends ConsumerStatefulWidget {
  final ProductModel? product; // å¦‚æœä¼ å…¥è´§å“åˆ™ä¸ºç¼–è¾‘æ¨¡å¼ï¼Œå¦åˆ™ä¸ºæ–°å¢æ¨¡å¼
  final String? initialBarcode; // åˆå§‹æ¡ç ï¼ˆä»æ‰«ç è¿›å…¥æ—¶ä¼ å…¥ï¼‰

  const ProductAddEditScreen({super.key, this.product, this.initialBarcode});

  @override
  ConsumerState<ProductAddEditScreen> createState() =>
      _ProductAddEditScreenState();
}

class _ProductAddEditScreenState extends ConsumerState<ProductAddEditScreen> {
  final _formKey = GlobalKey<FormState>(); // è¡¨å•æ§åˆ¶å™?
  // æ§åˆ¶å™¨ä¸ç„¦ç‚¹ç»Ÿä¸€æŠ½ç¦»ç®¡ç†
  late final ProductFormControllers _c;

  // UI å¸¸é‡ï¼ˆå¯æ”¾ç½®äºç»„ä»¶å†…ï¼Œä¸è¿?providerï¼?
  final List<String> _shelfLifeUnitOptions = ['days', 'months', 'years'];

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
  }

  @override
  void initState() {
    super.initState();
    // é¦–å¸§ååšå¿…è¦çš„åˆå§‹åŒ–ï¼ˆä¸è¦åœ¨è¿™é‡Œé‡ç½® unitEditFormProviderï¼Œä»¥ä¾¿çˆ¶é¡µç”Ÿå‘½å‘¨æœŸå†…å¤šæ¬¡è¿›å…¥å­é¡µå¯ä¿ç•™æ•°æ®ï¼‰
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // ç¼–è¾‘æ¨¡å¼ï¼šæ¯æ¬¡æ‰“å¼€çˆ¶é¡µå³æ¸…ç©ºè¾…å•ä½ç¼“å­˜ï¼Œé¿å…æ²¿ç”¨ä¸Šä¸€æ¬¡ç¼–è¾‘çš„ä¸´æ—¶æ•°æ®
      if (widget.product != null) {
        ref.read(unitEditFormProvider.notifier).resetUnitEditForm();
      }
      if (widget.product?.id != null) {
        ref.invalidate(mainBarcodeProvider(widget.product!.id!));
      }
      // åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œå›å¡«å•ä½å’Œç±»åˆ«ä¿¡æ¯
      if (widget.product != null) {
        _populateUnitAndCategoryData();
      }
    });
    // åˆå§‹åŒ–è¡¨å•æ§åˆ¶å™¨
    _c = ProductFormControllers()..init(widget.product);

    // å¦‚æœæœ‰åˆå§‹æ¡ç ï¼Œå¡«å……åˆ°æ¡ç è¾“å…¥æ¡†å¹¶è®©åç§°è¾“å…¥æ¡†è·å¾—ç„¦ç‚?
    if (widget.initialBarcode != null && widget.initialBarcode!.isNotEmpty) {
      _c.barcodeController.text = widget.initialBarcode!;
      // å»¶è¿Ÿè®©åç§°è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½åå†æ‰§è¡?
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _c.nameFocusNode.requestFocus();
      });
    }

    // æ¡ç ç›‘å¬å°†åœ¨ build æ–¹æ³•ä¸­å¤„ç†ï¼Œç¡®ä¿ ref.listen åœ¨æ­£ç¡®çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨
  }

  // æ§åˆ¶å™¨åˆå§‹åŒ–å·²ç§»åŠ¨åˆ° ProductFormControllers

  @override
  void dispose() {
    // åœ¨çˆ¶é¡µç»“æŸæ—¶å¼‚æ­¥æ¸…ç©ºè¾…å•ä½ä¸´æ—¶çŠ¶æ€ï¼Œé¿å…åœ?dispose ç”Ÿå‘½å‘¨æœŸç›´æ¥ä¿®æ”¹ provider
    Future.microtask(() {
      ref.read(unitEditFormProvider.notifier).resetUnitEditForm();
    });
    _c.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final operationsState = ref.watch(productOperationsProvider);

    // æ¡ç ç›‘å¬å¿…é¡»åœ?build æ–¹æ³•ä¸­å¤„ç?
    if (widget.product?.id != null) {
      ref.listen<AsyncValue<String?>>(
        mainBarcodeProvider(widget.product!.id!),
        (previous, next) {
          next.whenData((barcode) {
            if (barcode != null && _c.barcodeController.text != barcode) {
              _c.barcodeController.text = barcode;
            } else if (barcode == null &&
                _c.barcodeController.text.isNotEmpty) {
              _c.barcodeController.clear();
            }
          });
        },
      );
    }
    final categoryState = ref.watch(categoryListProvider);
    final categories = categoryState.categories;
    final unitsAsyncValue = ref.watch(allUnitsProvider); // è·å–å•ä½åˆ—è¡¨
    final ui = ref.watch(productFormUiProvider);
    final isEdit = widget.product != null;
    final actions = ProductAddEditActions(
      ref: ref,
      context: context,
      productId: widget.product?.id,
    );
    return GestureDetector(
      onTap: () => FocusManager.instance.primaryFocus?.unfocus(),
      behavior: HitTestBehavior.opaque,
      child: Scaffold(
        appBar: AppBar(
          title: Text(isEdit ? 'ç¼–è¾‘è´§å“' : 'æ·»åŠ è´§å“'),
          elevation: 0,
          actions: [],
        ),
        body: Form(
          key: _formKey,
          child: Column(
            children: [
              // æ˜¾ç¤ºåŠ è½½çŠ¶æ€?
              if (operationsState.isLoading) const LinearProgressIndicator(),

              // è¡¨å•å†…å®¹
              Expanded(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      BasicInfoSection(
                        initialImagePath: ui.selectedImagePath,
                        onImageChanged: (imagePath) {
                          ref
                              .read(productFormUiProvider.notifier)
                              .setImagePath(imagePath);
                        },
                        nameController: _c.nameController,
                        nameFocusNode: _c.nameFocusNode,
                        onNameSubmitted: () => _c.unitFocusNode.requestFocus(),
                        barcodeController: _c.barcodeController,
                        onScan: () => actions.scanBarcode(
                          _c.barcodeController,
                          nextFocus: _c.nameFocusNode,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // å•ä½ + ç±»åˆ«ç»„åˆ
                      unitsAsyncValue.when(
                        data: (units) {
                          WidgetsBinding.instance.addPostFrameCallback((_) {
                            _ensureValidUnitSelection(units);
                          });
                          return UnitCategorySection(
                            unitController: _c.unitController,
                            unitFocusNode: _c.unitFocusNode,
                            units: units,
                            selectedUnitId: ui.selectedUnitId,
                            onUnitSelected: (u) {
                              ref
                                  .read(productFormUiProvider.notifier)
                                  .setUnitId(u.id);
                              _c.unitController.text = u.name.replaceAll(
                                ' ',
                                '',
                              );
                            },
                            onTapAddAuxiliary: () => actions.editAuxUnits(
                              currentUnitId: ui.selectedUnitId,
                              currentUnitName: _c.unitController.text,
                            ),
                            onTapChooseUnit: _navigateToUnitList,
                            errorTextBuilder: () =>
                                _getUnitValidationError(units),
                            helperText:
                                ui.selectedUnitId == null &&
                                    _c.unitController.text.isNotEmpty
                                ? 'å°†åˆ›å»ºæ–°å•ä½: "${_c.unitController.text}"'
                                : null,
                            onUnitClear: () {
                              ref
                                  .read(productFormUiProvider.notifier)
                                  .setUnitId(null);
                              _c.unitController.clear();
                            },
                            onUnitSubmitted: () =>
                                _c.categoryFocusNode.requestFocus(),
                            categoryController: _c.categoryController,
                            categoryFocusNode: _c.categoryFocusNode,
                            categories: categories,
                            selectedCategoryId: ui.selectedCategoryId,
                            onCategorySelected: (c) {
                              if (c.id == null) {
                                ref
                                    .read(productFormUiProvider.notifier)
                                    .setCategoryId(null);
                                _c.categoryController.text = 'æœªåˆ†ç±?;
                              } else {
                                ref
                                    .read(productFormUiProvider.notifier)
                                    .setCategoryId(c.id);
                                _c.categoryController.text = c.name.replaceAll(
                                  ' ',
                                  '',
                                );
                              }
                            },
                            onTapChooseCategory: () =>
                                _navigateToCategorySelection(context),
                            onCategoryClear: () {
                              ref
                                  .read(productFormUiProvider.notifier)
                                  .setCategoryId(null);
                              _c.categoryController.clear();
                            },
                            onCategorySubmitted: () =>
                                _c.retailPriceFocusNode.requestFocus(),
                          );
                        },
                        loading: () => Row(
                          children: [
                            Expanded(
                              child: Container(
                                height: 58,
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: Colors.grey.shade300,
                                  ),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Center(child: Text('åŠ è½½å•ä½ä¸?..')),
                              ),
                            ),
                            const SizedBox(width: 8),
                            IconButton(
                              onPressed: () => actions.editAuxUnits(
                                currentUnitId: ui.selectedUnitId,
                                currentUnitName: _c.unitController.text,
                              ),
                              icon: const Icon(Icons.add),
                              tooltip: 'æ·»åŠ è¾…å•ä½?,
                            ),
                          ],
                        ),
                        error: (error, stackTrace) => Row(
                          children: [
                            Expanded(
                              child: Container(
                                height: 58,
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: Colors.red.shade300,
                                  ),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Center(
                                  child: Text(
                                    'åŠ è½½å¤±è´¥',
                                    style: TextStyle(color: Colors.red),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 8),
                            IconButton(
                              onPressed: () => actions.editAuxUnits(
                                currentUnitId: ui.selectedUnitId,
                                currentUnitName: _c.unitController.text,
                              ),
                              icon: const Icon(Icons.add),
                              tooltip: 'æ·»åŠ è¾…å•ä½?,
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 16),
                      PricingSection(
                        retailPriceController: _c.retailPriceController,
                        promotionalPriceController:
                            _c.promotionalPriceController,
                        suggestedRetailPriceController:
                            _c.suggestedRetailPriceController,
                        retailPriceFocusNode: _c.retailPriceFocusNode,
                        onRetailPriceSubmitted: () =>
                            _c.shelfLifeFocusNode.requestFocus(),
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _c.stockWarningValueController,
                        label: 'åº“å­˜é¢„è­¦å€?,
                        keyboardType: TextInputType.number,
                        focusNode: _c.stockWarningValueFocusNode,
                      ),
                      const SizedBox(height: 16),
                      // ä¿è´¨æœ?
                      ShelfLifeSection(
                        shelfLifeController: _c.shelfLifeController,
                        shelfLifeFocusNode: _c.shelfLifeFocusNode,
                        shelfLifeUnit: ui.shelfLifeUnit,
                        shelfLifeUnitOptions: _shelfLifeUnitOptions,
                        onShelfLifeUnitChanged: (val) {
                          ref
                              .read(productFormUiProvider.notifier)
                              .setShelfLifeUnit(val);
                        },
                        onSubmitted: _submitForm,
                      ),
                      const SizedBox(height: 16),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
        bottomNavigationBar: ProductFormActionBar(
          isLoading: operationsState.isLoading,
          isEdit: isEdit,
          onSubmit: _submitForm,
        ),
      ),
    );
  }

  // ç§»é™¤æœ¬åœ°è¾“å…¥æ„å»ºæ–¹æ³•ï¼Œæ”¹ä¸ºä½¿ç”?AppTextField ç»„ä»¶

  // å•ä½éªŒè¯å‡½æ•° - åªåœ¨è¡¨å•æäº¤æ—¶éªŒè¯ï¼Œä¸åœ¨è¾“å…¥æ—¶æ˜¾ç¤ºé”™è¯?
  String? _getUnitValidationError(List<Unit> units) {
    return null;
  }

  /// å¯¼èˆªåˆ°ç±»åˆ«é€‰æ‹©å±å¹•
  void _navigateToCategorySelection(BuildContext context) async {
    final ui = ref.read(productFormUiProvider);
    final actions = ProductAddEditActions(
      ref: ref,
      context: context,
      productId: widget.product?.id,
    );
    await actions.chooseCategory(
      selectedCategoryId: ui.selectedCategoryId,
      onPicked: (c) {
        ref.read(productFormUiProvider.notifier).setCategoryId(c.id);
        _c.categoryController.text = c.name.replaceAll(' ', '');
        _c.retailPriceFocusNode.requestFocus();
      },
    );
  }

  /// å¯¼èˆªåˆ°å•ä½åˆ—è¡¨é¡µ
  void _navigateToUnitList() async {
    final ui = ref.read(productFormUiProvider);
    final actions = ProductAddEditActions(
      ref: ref,
      context: context,
      productId: widget.product?.id,
    );
    await actions.chooseUnit(
      selectedUnitId: ui.selectedUnitId,
      onPicked: (u) {
        ref.read(productFormUiProvider.notifier).setUnitId(u.id);
        _c.unitController.text = u.name;
        _c.categoryFocusNode.requestFocus();
      },
    );
  }

  // è¾…å•ä½ç¼–è¾‘å·²ç§»è‡³ actions.editAuxUnitsï¼ŒUI ä¾§ç›´æ¥è°ƒç”?

  // æ‰«ç é€»è¾‘å·²ç§»è‡?actions.scanBarcode

  /// æäº¤è¡¨å•
  void _submitForm() async {
    final actions = ProductAddEditActions(
      ref: ref,
      context: context,
      productId: widget.product?.id,
    );
    await actions.submitForm(
      formKey: _formKey,
      nameController: _c.nameController,
      categoryController: _c.categoryController,
      unitController: _c.unitController,
      barcodeController: _c.barcodeController,
      retailPriceController: _c.retailPriceController,
      promotionalPriceController: _c.promotionalPriceController,
      suggestedRetailPriceController: _c.suggestedRetailPriceController,
      stockWarningValueController: _c.stockWarningValueController,
      shelfLifeController: _c.shelfLifeController,
      // remarksController: _c.remarksController,
      onSuccess: () {
        if (mounted) context.pop();
      },
      onError: (msg) {
        if (mounted) ToastService.error(msg);
      },
    );
  }

  /// éªŒè¯å¹¶ç¡®ä¿å•ä½é€‰æ‹©çš„æœ‰æ•ˆæ€?
  void _ensureValidUnitSelection(List<Unit> units) {
    // å¦‚æœå½“å‰é€‰æ‹©çš„å•ä½IDä¸åœ¨å•ä½åˆ—è¡¨ä¸­ï¼Œæ¸…é™¤é€‰æ‹©
    final ui = ref.read(productFormUiProvider);
    final selectedUnitId = ui.selectedUnitId;
    if (selectedUnitId != null &&
        !units.any((unit) => unit.id == selectedUnitId)) {
      ref.read(productFormUiProvider.notifier).setUnitId(null);
      _c.unitController.clear();
    }
    // å…è®¸ç”¨æˆ·ä¸é€‰æ‹©å•ä½ï¼Œä¸å¼ºåˆ¶è®¾ç½®é»˜è®¤å€?
  }

  /// åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹å›å¡«å•ä½å’Œç±»åˆ«æ•°æ?
  Future<void> _populateUnitAndCategoryData() async {
    if (widget.product == null || !mounted) return;

    // è®¾ç½®å›¾ç‰‡è·¯å¾„
    if (widget.product!.image != null && widget.product!.image!.isNotEmpty) {
      ref
          .read(productFormUiProvider.notifier)
          .setImagePath(widget.product!.image);
    }

    // è®¾ç½®å•ä½IDå’Œåç§?
    ref
        .read(productFormUiProvider.notifier)
        .setUnitId(widget.product!.baseUnitId);

    // è·å–å•ä½ä¿¡æ¯å¹¶è®¾ç½®æ§åˆ¶å™¨æ–‡æœ¬
    final unit = await ref
        .read(unitControllerProvider.notifier)
        .getUnitById(widget.product!.baseUnitId);
    if (unit != null && mounted) {
      setState(() {
        _c.unitController.text = unit.name.replaceAll(' ', '');
      });
    }

    // è®¾ç½®ç±»åˆ«IDå’Œåç§?
    if (widget.product!.categoryId != null && mounted) {
      ref
          .read(productFormUiProvider.notifier)
          .setCategoryId(widget.product!.categoryId);

      // ç¡®ä¿ç±»åˆ«åˆ—è¡¨æ˜¯æœ€æ–°çš„
      await ref.read(categoryListProvider.notifier).loadCategories();

      // ä»ç±»åˆ«åˆ—è¡¨ä¸­è·å–ç±»åˆ«åç§°
      final categories = ref.read(categoryListProvider).categories;
      final category = categories
          .where((c) => c.id == widget.product!.categoryId)
          .firstOrNull;

      if (category != null && mounted) {
        setState(() {
          _c.categoryController.text = category.name.replaceAll(' ', '');
        });
      } else if (mounted) {
        // å¦‚æœåœ¨ç±»åˆ«åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°å¯¹åº”çš„ç±»åˆ«ï¼Œå¯èƒ½æ˜¯æ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜
        print('âš ï¸ [WARNING] äº§å“çš„ç±»åˆ«ID ${widget.product!.categoryId} åœ¨ç±»åˆ«åˆ—è¡¨ä¸­ä¸å­˜åœ?);
        setState(() {
          _c.categoryController.text = 'æœªåˆ†ç±?;
        });
      }
    } else if (mounted) {
      // å¦‚æœæ²¡æœ‰ç±»åˆ«ï¼Œè®¾ç½®ä¸ºæœªåˆ†ç±?
      setState(() {
        _c.categoryController.text = 'æœªåˆ†ç±?;
      });
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../application/provider/product_providers.dart';
import '../../domain/model/product.dart';
import '../../../../core/constants/app_routes.dart';
import '../../../../core/shared_widgets/loading_widget.dart';
import '../../../../core/shared_widgets/error_widget.dart';
import '../../../../core/widgets/cached_image_widget.dart';
import '../../../../core/widgets/full_screen_image_viewer.dart';

/// å•†å“è¯¦æƒ…é¡µé¢
class ProductDetailScreen extends ConsumerWidget {
  final int productId;

  const ProductDetailScreen({super.key, required this.productId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productsAsyncValue = ref.watch(allProductsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('å•†å“è¯¦æƒ…'),
        actions: [
          // ç¼–è¾‘æŒ‰é’®
          IconButton(
            onPressed: () {
              context.go(AppRoutes.productEditPath(productId.toString()));
            },
            icon: const Icon(Icons.edit),
            tooltip: 'ç¼–è¾‘å•†å“',
          ),
        ],
      ),
      body: productsAsyncValue.when(
        data: (products) {
          final product = products.where((p) => p.id == productId).firstOrNull;
          if (product == null) {
            return const Center(child: Text('å•†å“ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤'));
          }
          return _buildProductDetail(context, ref, product);
        },
        loading: () => const LoadingWidget(message: 'åŠ è½½å•†å“è¯¦æƒ…ä¸?..'),
        error: (error, stackTrace) => CustomErrorWidget(
          message: 'åŠ è½½å•†å“è¯¦æƒ…å¤±è´¥',
          onRetry: () => ref.invalidate(allProductsProvider),
        ),
      ),
    );
  }

  Widget _buildProductDetail(
    BuildContext context,
    WidgetRef ref,
    ProductModel product,
  ) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // å•†å“åŸºæœ¬ä¿¡æ¯å¡ç‰‡
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        child: Text(
                          product.name,
                          style: Theme.of(context).textTheme.headlineSmall
                              ?.copyWith(fontWeight: FontWeight.bold),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16), // äº§å“å›¾ç‰‡
                  if (product.image != null && product.image!.isNotEmpty)
                    Center(
                      child: ProductDetailImage(
                        imagePath: product.image!,
                        onTap: () =>
                            _showFullScreenImage(context, product.image!),
                      ),
                    ),
                  // åŸºæœ¬ä¿¡æ¯
                  if (product.sku != null)
                    _buildDetailItem(context, 'SKU', product.sku!),
                  // æ¡ç ä¿¡æ¯ - å·²ç§»é™¤ï¼Œç°åœ¨æ¡ç å­˜å‚¨åœ¨ç‹¬ç«‹çš„æ¡ç è¡¨ä¸­
                  // å¦‚æœéœ€è¦æ˜¾ç¤ºæ¡ç ï¼Œéœ€è¦å•ç‹¬æŸ¥è¯¢æ¡ç è¡¨
                ],
              ),
            ),
          ),

          const SizedBox(height: 16),

          // ä»·æ ¼ä¿¡æ¯å¡ç‰‡
          if (product.effectivePrice != null) ...[
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'ä»·æ ¼ä¿¡æ¯',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),

                    // æœ‰æ•ˆä»·æ ¼
                    Row(
                      children: [
                        Icon(
                          Icons.price_change,
                          color: Theme.of(context).primaryColor,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'å½“å‰ä»·æ ¼',
                          style: Theme.of(context).textTheme.bodyMedium
                              ?.copyWith(fontWeight: FontWeight.w500),
                        ),
                        const Spacer(),
                        Text(
                          product.effectivePrice!.format(),
                          style: Theme.of(context).textTheme.titleLarge
                              ?.copyWith(
                                color: Theme.of(context).primaryColor,
                                fontWeight: FontWeight.bold,
                              ),
                        ),
                      ],
                    ),

                    if (product.retailPrice != null) ...[
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          Icon(Icons.sell, color: Colors.grey.shade600),
                          const SizedBox(width: 8),
                          Text(
                            'é›¶å”®ä»?,
                            style: Theme.of(context).textTheme.bodyMedium
                                ?.copyWith(color: Colors.grey.shade600),
                          ),
                          const Spacer(),
                          Text(
                            product.retailPrice!.format(),
                            style: Theme.of(context).textTheme.bodyLarge
                                ?.copyWith(color: Colors.grey.shade700),
                          ),
                        ],
                      ),
                    ],

                    if (product.promotionalPrice != null) ...[
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          Icon(Icons.local_offer, color: Colors.red.shade600),
                          const SizedBox(width: 8),
                          Text(
                            'ä¿ƒé”€ä»?,
                            style: Theme.of(context).textTheme.bodyMedium
                                ?.copyWith(
                                  color: Colors.red.shade600,
                                  fontWeight: FontWeight.w500,
                                ),
                          ),
                          const Spacer(),
                          Text(
                            product.promotionalPrice!.format(),
                            style: Theme.of(context).textTheme.bodyLarge
                                ?.copyWith(
                                  color: Colors.red.shade600,
                                  fontWeight: FontWeight.bold,
                                ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
          ],

          // å…¶ä»–ä¿¡æ¯å¡ç‰‡
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'å…¶ä»–ä¿¡æ¯',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),

                  if (product.stockWarningValue != null)
                    _buildDetailItem(
                      context,
                      'åº“å­˜é¢„è­¦å€?,
                      '${product.stockWarningValue}',
                    ),
                  if (product.shelfLife != null)
                    _buildDetailItem(
                      context,
                      'ä¿è´¨æœ?,
                      _formatShelfLife(
                        product.shelfLife,
                        _getProductShelfLifeUnit(product),
                      ),
                    ),
                  _buildDetailItem(
                    context,
                    'æ‰¹é‡ç®¡ç†',
                    product.enableBatchManagement ? 'å·²å¯ç”? : 'æœªå¯ç”?,
                  ),
                  if (product.remarks != null)
                    _buildDetailItem(context, 'å¤‡æ³¨', product.remarks!),
                  if (product.lastUpdated != null)
                    _buildDetailItem(
                      context,
                      'æœ€åæ›´æ–?,
                      _formatDateTime(product.lastUpdated!),
                    ),
                ],
              ),
            ),
          ),

          const SizedBox(height: 32),

          // æ“ä½œæŒ‰é’®
          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () {
                    context.go(AppRoutes.productEditPath(productId.toString()));
                  },
                  icon: const Icon(Icons.edit),
                  label: const Text('ç¼–è¾‘å•†å“'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () {
                    context.go(AppRoutes.products);
                  },
                  icon: const Icon(Icons.list),
                  label: const Text('è¿”å›åˆ—è¡¨'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildDetailItem(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: Colors.grey.shade700,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(value, style: Theme.of(context).textTheme.bodyMedium),
          ),
        ],
      ),
    );
  }

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  /// æ ¼å¼åŒ–ä¿è´¨æœŸæ˜¾ç¤º
  String _formatShelfLife(int? shelfLife, String? unit) {
    if (shelfLife == null) return '';

    final unitText = _getShelfLifeUnitDisplayName(unit ?? 'months');
    return '$shelfLife$unitText';
  }

  /// è·å–ä¿è´¨æœŸå•ä½æ˜¾ç¤ºåç§?
  String _getShelfLifeUnitDisplayName(String unit) {
    switch (unit) {
      case 'days':
        return 'å¤?;
      case 'months':
        return 'ä¸ªæœˆ';
      case 'years':
        return 'å¹?;
      default:
        return 'ä¸ªæœˆ';
    }
  }

  /// è·å–äº§å“çš„ä¿è´¨æœŸå•ä½
  String _getProductShelfLifeUnit(ProductModel product) {
    // è¿”å›äº§å“å®é™…çš„ä¿è´¨æœŸå•ä½
    return product.shelfLifeUnit.name;
  }

  /// æ˜¾ç¤ºå…¨å±å›¾ç‰‡æŸ¥çœ‹å™?
  void _showFullScreenImage(BuildContext context, String imagePath) {
    Navigator.of(context).push(
      PageRouteBuilder(
        pageBuilder: (context, animation, secondaryAnimation) =>
            FullScreenImageViewer(
              imagePath: imagePath,
              heroTag: 'product_detail_image_$imagePath',
            ),
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          return FadeTransition(opacity: animation, child: child);
        },
        transitionDuration: const Duration(milliseconds: 300),
        reverseTransitionDuration: const Duration(milliseconds: 200),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/constants/app_routes.dart';
import '../../../../core/widgets/product_list/product_list.dart';
import '../../application/category_notifier.dart';
import '../../../inventory/application/inventory_service.dart';
import '../../../inventory/application/provider/shop_providers.dart';
import '../../../inventory/domain/model/shop.dart';
import '../../application/provider/product_providers.dart';
import '../../domain/model/category.dart';
import '../../domain/model/product.dart';
import 'category_selection_screen.dart';

class ProductListScreen extends ConsumerWidget {
  const ProductListScreen({super.key});

  Future<void> _showDeleteConfirmDialog(
    BuildContext context,
    WidgetRef ref,
    ProductModel product,
  ) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤åˆ é™¤'),
        content: Text('ç¡®å®šè¦åˆ é™¤è´§å“ã€?{product.name}ã€å—ï¼?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('åˆ é™¤', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await ref
          .read(productOperationsProvider.notifier)
          .deleteProduct(product.id!);
    }
  }

  Future<void> _showAdjustInventoryDialog(
    BuildContext context,
    WidgetRef ref,
    ProductModel product,
  ) async {
    final quantityController = TextEditingController();
    final shops = await ref.read(allShopsProvider.future);
    Shop? selectedShop = shops.isNotEmpty ? shops.first : null;

    // ignore: use_build_context_synchronously
    if (shops.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('æ²¡æœ‰å¯ç”¨çš„åº—é“ºï¼Œè¯·å…ˆæ·»åŠ åº—é“º')),
      );
      return;
    }

    final inventory = await ref
        .read(inventoryServiceProvider)
        .getInventory(product.id!, selectedShop!.id!);
    if (inventory != null) {
      quantityController.text = inventory.quantity.toStringAsFixed(0);
    }

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Text('è°ƒæ•´åº“å­˜: ${product.name}'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  DropdownButtonFormField<Shop>(
                    value: selectedShop,
                    decoration: const InputDecoration(labelText: 'åº—é“º'),
                    items: shops.map((shop) {
                      return DropdownMenuItem<Shop>(
                        value: shop,
                        child: Text(shop.name),
                      );
                    }).toList(),
                    onChanged: (shop) {
                      setState(() {
                        selectedShop = shop;
                      });
                    },
                  ),
                  TextField(
                    controller: quantityController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(labelText: 'æ–°åº“å­˜æ•°é‡?),
                    autofocus: true,
                  ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('å–æ¶ˆ'),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop({
                      'quantity': quantityController.text,
                      'shop': selectedShop,
                    });
                  },
                  child: const Text('ç¡®å®š'),
                ),
              ],
            );
          },
        );
      },
    );

    if (result != null) {
      final newQuantityString = result['quantity'] as String;
      final shop = result['shop'] as Shop;

      if (newQuantityString.isNotEmpty) {
        final newQuantity = int.tryParse(newQuantityString);
        if (newQuantity == null) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('æ— æ•ˆçš„æ•°å­—æ ¼å¼?)),
          );
          return;
        }

        try {
          await ref.read(inventoryServiceProvider).adjustInventory(
                productId: product.id!,
                quantity: newQuantity,
                shopId: shop.id!,
              );
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('åº“å­˜è°ƒæ•´æˆåŠŸ')),
          );
          ref.invalidate(filteredProductsProvider); // Refresh the product list
        } catch (e) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('åº“å­˜è°ƒæ•´å¤±è´¥: $e')),
          );
        }
      }
    }
  }

  Future<void> _showSearchDialog(BuildContext context, WidgetRef ref) async {
    final searchController = TextEditingController();
    final searchQuery = ref.read(searchQueryProvider);
    searchController.text = searchQuery;

    final newQuery = await showDialog<String>(
      context: context,
      builder: (context) => Transform.translate(
        offset: const Offset(0, 150),
        child: Dialog(
          backgroundColor: Colors.transparent,
          elevation: 0,
          insetPadding: const EdgeInsets.symmetric(horizontal: 9.0),
          child: TextField(
            controller: searchController,
            autofocus: true,
            onSubmitted: (value) => Navigator.of(context).pop(value),
            decoration: InputDecoration(
              // hintText: 'è¾“å…¥å…³é”®å­?..',
              filled: true,
              fillColor: Theme.of(context).scaffoldBackgroundColor,
              border: OutlineInputBorder(
                // borderRadius: BorderRadius.circular(22.0),
                borderSide: BorderSide.none,
              ),
              contentPadding: const EdgeInsets.symmetric(
                vertical: 15.0,
                horizontal: 10.0,
              ),
              suffixIcon: Padding(
                padding: const EdgeInsets.only(right: 4.0),
                child: TextButton(
                  onPressed: () =>
                      Navigator.of(context).pop(searchController.text),
                  child: const Text('æœç´¢'),
                ),
              ),
            ),
          ),
        ),
      ),
    );

    if (newQuery != null) {
      ref.read(searchQueryProvider.notifier).state = newQuery;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productsAsyncValue = ref.watch(filteredProductsProvider);
    final selectedCategoryId = ref.watch(selectedCategoryIdProvider);
    final searchQuery = ref.watch(searchQueryProvider);
    final allCategories = ref.watch(categoryListProvider).categories;


    String? categoryName;
    if (selectedCategoryId != null) {
      final category = allCategories.firstWhere(
        (c) => c.id == selectedCategoryId,
        orElse: () => const CategoryModel(id: -1, name: 'æœªçŸ¥åˆ†ç±»'),
      );
      categoryName = category.name;
    }

    Widget titleWidget;
    final productCount = productsAsyncValue.asData?.value.length;
    final countSuffix = productCount != null ? ' ($productCount)' : '';

    if (searchQuery.isNotEmpty) {
      titleWidget = Row(
        children: [
          const Icon(Icons.search, size: 20),
          const SizedBox(width: 8),
          Expanded(child: Text(searchQuery, overflow: TextOverflow.ellipsis)),
          if (productCount != null) Text('($productCount)'),
        ],
      );
    } else {
      titleWidget = Text('${categoryName ?? 'è´§å“åˆ—è¡¨'}$countSuffix');
    }

    return Scaffold(
      appBar: AppBar(
        title: titleWidget,
        actions: [
          IconButton(
            icon: const Icon(Icons.leaderboard),
            tooltip: 'å•†å“æ’è¡Œæ¦?,
            onPressed: () => context.push(AppRoutes.productRanking),
          ),
          if (searchQuery.isNotEmpty || selectedCategoryId != null)
            IconButton(
              icon: const Icon(Icons.clear_all),
              tooltip: 'æ¸…é™¤æ‰€æœ‰ç­›é€‰å’Œæœç´¢',
              onPressed: () {
                ref.read(searchQueryProvider.notifier).state = '';
                ref.read(selectedCategoryIdProvider.notifier).state = null;
              },
            ),
          IconButton(
            icon: const Icon(Icons.search),
            tooltip: 'æœç´¢',
            onPressed: () => _showSearchDialog(context, ref),
          ),
          IconButton(
            icon: const Icon(Icons.filter_list),
            tooltip: 'æŒ‰åˆ†ç±»ç­›é€?,
            onPressed: () async {
              final selectedCategory = await Navigator.push<CategoryModel>(
                context,
                MaterialPageRoute(
                  builder: (context) => const CategorySelectionScreen(),
                ),
              );
              if (selectedCategory != null) {
                ref.read(selectedCategoryIdProvider.notifier).state =
                    selectedCategory.id;
              }
            },
          ),
          IconButton(
            onPressed: () => context.push(AppRoutes.productNew),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å¢è´§å“',
          ),
        ],
      ),
      body: productsAsyncValue.when(
        data: (products) {
          final sortedProducts = [...products]
            ..sort(
              (a, b) =>
                  (b.lastUpdated ??
                          DateTime.fromMillisecondsSinceEpoch(
                            b.id ?? 0,
                          ))
                      .compareTo(
                        a.lastUpdated ??
                            DateTime.fromMillisecondsSinceEpoch(
                              a.id ?? 0,
                            ),
                      ),
            );
          return ProductList(
            data: sortedProducts,
            onEdit: (product) =>
                context.push(AppRoutes.productEditPath(product.id.toString())),
            onDelete: (product) =>
                _showDeleteConfirmDialog(context, ref, product),
            onAdjustInventory: (product) =>
                _showAdjustInventoryDialog(context, ref, product),
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('åŠ è½½å¤±è´¥: $error'),
              ElevatedButton(
                onPressed: () => ref.invalidate(allProductsProvider),
                child: const Text('é‡è¯•'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../analytics/application/provider/ranking_providers.dart';
import '../../../analytics/data/repository/sales_analytics_repository.dart';
import '../widgets/time_filter_bottom_sheet.dart';

class ProductRankingScreen extends ConsumerWidget {
  const ProductRankingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final rankingAsync = ref.watch(productSalesRankingProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('å•†å“æ’è¡Œæ¦?),
        actions: [
          Consumer(
            builder: (context, ref, child) {
              final range = ref.watch(rankingRangeProvider);
              final timeFilterText = _getTimeFilterText(range);
              return TextButton.icon(
                onPressed: () => _showTimeFilterBottomSheet(context),
                icon: const Icon(Icons.calendar_today, size: 20),
                label: Text(timeFilterText),
                style: TextButton.styleFrom(
                  foregroundColor: Theme.of(context).colorScheme.primary,
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          const Divider(height: 1),
          _SortToggle(),
          const Divider(height: 1),
          Expanded(
            child: rankingAsync.when(
              data: (list) {
                if (list.isEmpty) {
                  return const Center(child: Text('æš‚æ— é”€é‡?));
                }
                return ListView.separated(
                  itemCount: list.length,
                  separatorBuilder: (_, __) => const Divider(height: 1),
                  itemBuilder: (context, index) {
                    final it = list[index];
                    final hasMissingCost = it.missingCostCount > 0;
                    final profitYuan = it.totalProfitInCents / 100.0;
                    final profitColor = hasMissingCost
                        ? Colors.orange
                        : (profitYuan < 0 ? Colors.red : Colors.green);
                    return ListTile(
                      leading: _RankBadge(rank: index + 1),
                      title: Text(
                        it.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      subtitle: Text(it.sku ?? ''),
                      trailing: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            '${it.totalQty} ä»?,
                            style: const TextStyle(fontWeight: FontWeight.w600),
                          ),
                          Text(
                            'ï¿?{(it.totalAmountInCents / 100).toStringAsFixed(2)}',
                            style: const TextStyle(color: Colors.grey),
                          ),
                          const SizedBox(height: 2),
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              if (hasMissingCost)
                                const Tooltip(
                                  message: 'æ— é‡‡è´­è®°å½•ï¼Œåˆ©æ¶¦æŒ?è®¡ç®—',
                                  child: Icon(
                                    Icons.info_outline,
                                    size: 14,
                                    color: Colors.orange,
                                  ),
                                ),
                              const SizedBox(width: 4),
                              Text(
                                'åˆ©æ¶¦ ï¿?{profitYuan.toStringAsFixed(2)}',
                                style: TextStyle(
                                  color: profitColor,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    );
                  },
                );
              },
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, st) => Center(child: Text('åŠ è½½å¤±è´¥: $e')),
            ),
          ),
        ],
      ),
    );
  }
}

class _SortToggle extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sort = ref.watch(rankingSortProvider);
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        ChoiceChip(
          label: const Text('æŒ‰é”€é‡?),
          selected: sort == ProductRankingSort.byQtyDesc,
          onSelected: (_) => ref.read(rankingSortProvider.notifier).state =
              ProductRankingSort.byQtyDesc,
        ),
        const SizedBox(width: 8),
        ChoiceChip(
          label: const Text('æŒ‰åˆ©æ¶?),
          selected: sort == ProductRankingSort.byProfitDesc,
          onSelected: (_) => ref.read(rankingSortProvider.notifier).state =
              ProductRankingSort.byProfitDesc,
        ),
        const SizedBox(width: 8),
      ],
    );
  }
}

class _RankBadge extends StatelessWidget {
  final int rank;
  const _RankBadge({required this.rank});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    Color bg;
    switch (rank) {
      case 1:
        bg = Colors.amber;
        break;
      case 2:
        bg = Colors.blueGrey;
        break;
      case 3:
        bg = Colors.brown;
        break;
      default:
        bg = colors.primaryContainer;
    }
    return CircleAvatar(
      backgroundColor: bg,
      foregroundColor: Colors.white,
      child: Text('$rank'),
    );
  }
}

// è·å–æ—¶é—´ç­›é€‰æ˜¾ç¤ºæ–‡æœ?
String _getTimeFilterText(RankingRange range) {
  final now = DateTime.now();
  final today = DateTime(now.year, now.month, now.day);
  final yesterday = today.subtract(const Duration(days: 1));
  final start = DateTime(range.start.year, range.start.month, range.start.day);
  final end = DateTime(
    range.endOpen.year,
    range.endOpen.month,
    range.endOpen.day,
  ).subtract(const Duration(days: 1));

  // æ£€æŸ¥æ˜¯å¦æ˜¯æ— é™åˆ¶ï¼ˆå…¨éƒ¨æ—¶é—´ï¼?
  if (start.year <= 2000 &&
      end.isAfter(today.subtract(const Duration(days: 2)))) {
    return 'å…¨éƒ¨';
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯ä»Šå¤©
  if (start == today && end == today) {
    return 'ä»Šå¤©';
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯æ˜¨å¤©
  if (start == yesterday && end == yesterday) {
    return 'æ˜¨å¤©';
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬å‘¨
  final startOfWeek = today.subtract(Duration(days: today.weekday - 1));
  final endOfWeek = startOfWeek.add(const Duration(days: 6));
  if (start == startOfWeek && end == endOfWeek) {
    return now.year == start.year ? 'æœ¬å‘¨' : '${start.year}å¹´æœ¬å‘?;
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸Šå‘¨
  final startOfLastWeek = startOfWeek.subtract(const Duration(days: 7));
  final endOfLastWeek = startOfWeek.subtract(const Duration(days: 1));
  if (start == startOfLastWeek && end == endOfLastWeek) {
    return now.year == start.year ? 'ä¸Šå‘¨' : '${start.year}å¹´ä¸Šå‘?;
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬æœˆ
  final startOfMonth = DateTime(today.year, today.month, 1);
  final endOfMonth = DateTime(
    today.year,
    today.month + 1,
    1,
  ).subtract(const Duration(days: 1));
  if (start == startOfMonth && end == endOfMonth) {
    return now.year == start.year ? 'æœ¬æœˆ' : '${start.year}å¹´æœ¬æœ?;
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸Šæœˆ
  final startOfLastMonth = DateTime(today.year, today.month - 1, 1);
  final endOfLastMonth = DateTime(
    today.year,
    today.month,
    1,
  ).subtract(const Duration(days: 1));
  if (start == startOfLastMonth && end == endOfLastMonth) {
    return now.year == start.year ? 'ä¸Šæœˆ' : '${start.year}å¹´ä¸Šæœ?;
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€è¿?å¤?
  if (end == today && start == today.subtract(const Duration(days: 6))) {
    return now.year == start.year ? 'è¿?å¤? : '${start.year}å¹´è¿‘7å¤?;
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€è¿?0å¤?
  if (end == today && start == today.subtract(const Duration(days: 29))) {
    return now.year == start.year ? 'è¿?0å¤? : '${start.year}å¹´è¿‘30å¤?;
  }

  // å¦‚æœæ˜¯åŒä¸€å¤©ï¼Œæ˜¾ç¤ºæ—¥æœŸ
  if (start == end) {
    return now.year == start.year
        ? '${start.month}æœ?{start.day}æ—?
        : '${start.year}å¹?{start.month}æœ?{start.day}æ—?;
  }

  // å¦‚æœæ˜¯åŒä¸€æœˆï¼Œæ˜¾ç¤ºæœˆæ—¥-æ—?
  if (start.year == end.year && start.month == end.month) {
    return now.year == start.year
        ? '${start.month}æœ?{start.day}-${end.day}æ—?
        : '${start.year}å¹?{start.month}æœ?{start.day}-${end.day}æ—?;
  }

  // å¦‚æœæ˜¯åŒä¸€å¹´ï¼Œæ˜¾ç¤ºæœˆæ—¥-æœˆæ—¥
  if (start.year == end.year) {
    return now.year == start.year
        ? '${start.month}æœ?{start.day}-${end.month}æœ?{end.day}æ—?
        : '${start.year}å¹?{start.month}æœ?{start.day}-${end.month}æœ?{end.day}æ—?;
  }

  // å…¶ä»–æƒ…å†µï¼Œæ˜¾ç¤ºå®Œæ•´æ—¥æœŸèŒƒå›?
  return '${start.year}/${start.month}/${start.day}-${end.year}/${end.month}/${end.day}';
}

// æ˜¾ç¤ºæ—¶é—´ç­›é€‰åº•éƒ¨é¢æ?
void _showTimeFilterBottomSheet(BuildContext context) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
    ),
    builder: (context) => const TimeFilterBottomSheet(),
  );
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/widgets/product_list/index.dart';
import '../../application/category_notifier.dart';
import '../../application/provider/product_providers.dart';
import '../../domain/model/category.dart';
import 'category_selection_screen.dart';

class ProductSelectionScreen extends ConsumerStatefulWidget {
  const ProductSelectionScreen({super.key});

  @override
  ConsumerState<ProductSelectionScreen> createState() =>
      _ProductSelectionScreenState();
}

class _ProductSelectionScreenState
    extends ConsumerState<ProductSelectionScreen> {
  List<dynamic> selectedIds = [];

  @override
  void initState() {
    super.initState();
    // Entering the page, clearing the category selection and search
    Future.microtask(() {
      ref.read(selectedCategoryIdProvider.notifier).state = null;
      ref.read(searchQueryProvider.notifier).state = '';
    });
  }

  Future<void> _showSearchDialog(BuildContext context, WidgetRef ref) async {
    final searchController = TextEditingController();
    final searchQuery = ref.read(searchQueryProvider);
    searchController.text = searchQuery;

    final newQuery = await showDialog<String>(
      context: context,
      builder: (context) => Transform.translate(
        offset: const Offset(0, 150),
        child: Dialog(
          backgroundColor: Colors.transparent,
          elevation: 0,
          insetPadding: const EdgeInsets.symmetric(horizontal: 9.0),
          child: TextField(
            controller: searchController,
            autofocus: true,
            onSubmitted: (value) => Navigator.of(context).pop(value),
            decoration: InputDecoration(
              // hintText: 'è¾“å…¥å…³é”®å­?..',
              filled: true,
              fillColor: Theme.of(context).scaffoldBackgroundColor,
              border: OutlineInputBorder(
                // borderRadius: BorderRadius.circular(22.0),
                borderSide: BorderSide.none,
              ),
              contentPadding: const EdgeInsets.symmetric(
                vertical: 15.0,
                horizontal: 10.0,
              ),
              suffixIcon: Padding(
                padding: const EdgeInsets.only(right: 4.0),
                child: TextButton(
                  onPressed: () =>
                      Navigator.of(context).pop(searchController.text),
                  child: const Text('æœç´¢'),
                ),
              ),
            ),
          ),
        ),
      ),
    );

    if (newQuery != null) {
      ref.read(searchQueryProvider.notifier).state = newQuery;
    }
  }

  @override
  Widget build(BuildContext context) {
    final productsAsync = ref.watch(filteredProductsProvider);
    final selectedCategoryId = ref.watch(selectedCategoryIdProvider);
    final searchQuery = ref.watch(searchQueryProvider);
    final allCategories = ref.watch(categoryListProvider).categories;

    String? categoryName;
    if (selectedCategoryId != null) {
      final category = allCategories.firstWhere(
        (c) => c.id == selectedCategoryId,
        orElse: () => const CategoryModel(id: -1, name: 'æœªçŸ¥åˆ†ç±»'),
      );
      categoryName = category.name;
    }

    Widget titleWidget;
    final countSuffix = ' (å·²é€?{selectedIds.length}ç§?';

    // ä½¿ç”¨ trim() æ¥ç¡®ä¿?searchQuery åŒ…å«å¯è§å­—ç¬¦ï¼Œè€Œä¸ä»…ä»…æ˜¯ç©ºæ ¼ã€?
    if (searchQuery.trim().isNotEmpty) {
      titleWidget = Row(
        children: [
          Flexible(
            flex: 2,
            child: Text(
              searchQuery,
              overflow: TextOverflow.ellipsis,
              softWrap: false,
              style: const TextStyle(fontSize: 14), // ç¼©å°å­—ä½“ä»¥å‡å°‘ç©ºé—´å ç”?
            ),
          ),
          const SizedBox(width: 8),
          Flexible(
            flex: 5,
            child: Text(
              '(å·²é€?{selectedIds.length}ç§?',
              // overflow: TextOverflow.ellipsis,
              // softWrap: false,
              style: const TextStyle(fontSize: 14), // ç»Ÿä¸€ç¼©å°å­—ä½“
            ),
          ),
        ],
      );
    } else {
      titleWidget = Text(
        '${categoryName ?? 'é€‰æ‹©è´§å“'}$countSuffix',
        style: const TextStyle(fontSize: 15),
      );
    }

    return Scaffold(
      appBar: AppBar(
        toolbarHeight: 33,
        title: titleWidget,
        actions: [
          Transform.translate(
            offset: const Offset(0, -8.0), // å‘ä¸Šç§»åŠ¨æŒ‰é’®
            child: Wrap(
              spacing: -8.0, // ä½¿ç”¨è´Ÿé—´è·æ¥å‡å°‘æŒ‰é’®é—´çš„ç©ºéš™
              crossAxisAlignment: WrapCrossAlignment.center,
              children: [
                if (searchQuery.isNotEmpty || selectedCategoryId != null)
                  IconButton(
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                    icon: const Icon(Icons.clear_all, size: 22),
                    tooltip: 'æ¸…é™¤æ‰€æœ‰ç­›é€‰å’Œæœç´¢',
                    onPressed: () {
                      ref.read(searchQueryProvider.notifier).state = '';
                      ref.read(selectedCategoryIdProvider.notifier).state =
                          null;
                    },
                  ),
                IconButton(
                  padding: const EdgeInsets.symmetric(horizontal: 0),
                  constraints: const BoxConstraints(),
                  icon: const Icon(Icons.search, size: 22),
                  tooltip: 'æœç´¢',
                  onPressed: () => _showSearchDialog(context, ref),
                ),
                IconButton(
                  padding: const EdgeInsets.symmetric(horizontal: 0),
                  constraints: const BoxConstraints(),
                  icon: const Icon(Icons.filter_list, size: 22),
                  tooltip: 'æŒ‰åˆ†ç±»ç­›é€?,
                  onPressed: () async {
                    final selectedCategory = await Navigator.push<CategoryModel>(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const CategorySelectionScreen(),
                      ),
                    );
                    if (selectedCategory != null) {
                      ref.read(selectedCategoryIdProvider.notifier).state =
                          selectedCategory.id;
                    }
                  },
                ),
                Padding(
                  padding: const EdgeInsets.only(right: 8.0),
                  child: TextButton(
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(horizontal: 0),
                      minimumSize: Size.zero,
                    ),
                    onPressed: () {
                      Navigator.of(context).pop(selectedIds);
                    },
                    child: const Text('ç¡®å®š'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      body: productsAsync.when(
        data: (products) {
          final sortedProducts = [...products]
            ..sort(
              (a, b) =>
                  (b.lastUpdated ??
                          DateTime.fromMillisecondsSinceEpoch(
                            b.id ?? 0,
                          ))
                      .compareTo(
                        a.lastUpdated ??
                            DateTime.fromMillisecondsSinceEpoch(
                              a.id ?? 0,
                            ),
                      ),
            );
          return ProductList(
            data: sortedProducts,
            mode: 'select',
            selectedIds: selectedIds,
            onSelectionChange: (newSelectedIds) {
              setState(() {
                selectedIds = newSelectedIds;
              });
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('åŠ è½½å¤±è´¥: $error'),
              ElevatedButton(
                onPressed: () => ref.invalidate(allProductsProvider),
                child: const Text('é‡è¯•'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
// Product Screens Barrel File
// ç»Ÿä¸€å¯¼å‡ºäº§å“ç›¸å…³çš„é¡µé¢ç»„ä»?

export 'product_add_edit_screen.dart';
export 'product_detail_screen.dart';
export 'product_list_screen.dart';
export 'product_selection_screen.dart';
export 'category_selection_screen.dart';
export 'unit_selection_screen.dart';
export 'auxiliaryunit_edit_screen.dart';
export 'product_ranking_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import '../../application/provider/unit_providers.dart';
import '../../domain/model/unit.dart';
import '../../../../core/shared_widgets/loading_widget.dart';
import '../../../../core/shared_widgets/error_widget.dart';
import '../../../../core/utils/snackbar_helper.dart';

/// å•ä½é€‰æ‹©å±å¹•
/// æ”¯æŒé€‰æ‹©å•ä½ã€æ–°å¢å•ä½åŠåˆ é™¤å•ä½æ“ä½œ
class UnitSelectionScreen extends ConsumerStatefulWidget {
  final Unit? initialUnit;

  const UnitSelectionScreen({
    super.key,
    this.initialUnit,
  });

  @override
  ConsumerState<UnitSelectionScreen> createState() =>
      _UnitSelectionScreenState();
}

class _UnitSelectionScreenState extends ConsumerState<UnitSelectionScreen> {
  int? _selectedUnitId;

  @override
  void initState() {
    super.initState();
    _selectedUnitId = widget.initialUnit?.id;
  }

  @override
  Widget build(BuildContext context) {
    final unitsAsyncValue = ref.watch(allUnitsProvider);
    final controllerState = ref.watch(unitControllerProvider);

    // ç›‘å¬æ“ä½œç»“æœ
    ref.listen<UnitControllerState>(unitControllerProvider, (previous, next) {
      if (next.isSuccess) {
        showAppSnackBar(context, message: 'æ“ä½œæˆåŠŸ');
      } else if (next.isError) {
        showAppSnackBar(context,
            message: next.errorMessage ?? 'æ“ä½œå¤±è´¥', isError: true);
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('é€‰æ‹©å•ä½'),
        actions: [
          IconButton(
            onPressed: () => _showAddUnitDialog(context),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å¢å•ä½',
          ),
        ],
      ),
      body: Column(
        children: [
          // æ“ä½œçŠ¶æ€æŒ‡ç¤ºå™¨
          if (controllerState.isLoading) const LinearProgressIndicator(),

          // å•ä½åˆ—è¡¨
          Expanded(
            child: unitsAsyncValue.when(
              data: (units) => _buildUnitList(context, units),
              loading: () => const LoadingWidget(message: 'åŠ è½½å•ä½åˆ—è¡¨ä¸?..'),
              error: (error, stackTrace) => CustomErrorWidget(
                message: 'åŠ è½½å•ä½åˆ—è¡¨å¤±è´¥',
                onRetry: () => ref.invalidate(allUnitsProvider),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// æ„å»ºå•ä½åˆ—è¡¨
  Widget _buildUnitList(BuildContext context, List<Unit> units) {
    if (units.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.straighten, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text('æš‚æ— å•ä½', style: TextStyle(fontSize: 18, color: Colors.grey)),
            SizedBox(height: 8),
            Text(
              'ç‚¹å‡»å³ä¸Šè§’çš„ + å·æ·»åŠ æ–°å•ä½',
              style: TextStyle(fontSize: 14, color: Colors.grey),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () async {
        ref.invalidate(allUnitsProvider);
      },
      child: ListView.builder(
        padding: const EdgeInsets.symmetric(vertical: 8),
        itemCount: units.length,
        itemBuilder: (context, index) {
          final unit = units[index];
          return _buildUnitTile(context, unit);
        },
      ),
    );
  }

  /// æ„å»ºå•ä½åˆ—è¡¨é¡?
  Widget _buildUnitTile(BuildContext context, Unit unit) {
    final isSelected = _selectedUnitId == unit.id;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Slidable(
        key: ValueKey(unit.id),
        endActionPane: ActionPane(
          motion: const DrawerMotion(),
          children: [
            Expanded(
              child: CustomSlidableAction(
                onPressed: (context) {
                  // åªè°ƒç”¨æ–¹æ³•ï¼Œä¸åœ¨æ­¤å¤„å¤„ç†UIåé¦ˆ
                  if (unit.id != null) {
                    ref.read(unitControllerProvider.notifier).deleteUnit(unit.id!);
                  } else {
                    showAppSnackBar(context, message: 'æ— æ³•åˆ é™¤æ²¡æœ‰IDçš„å•ä½?, isError: true);
                  }
                },
                backgroundColor: Colors.red,
                child: const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.delete, color: Colors.white),
                    SizedBox(width: 4),
                    Text('åˆ é™¤', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
            ),
          ],
        ),
        child: Card(
          margin: const EdgeInsets.symmetric(horizontal: 16),
          elevation: isSelected ? 4 : 1,
          color: isSelected
              ? Theme.of(context).primaryColor.withOpacity(0.1)
              : null,
          child: ListTile(
            dense: true,
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0.0),
            title: Text(
              unit.name,
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                fontSize: 16,
              ),
            ),
            onTap: () {
              setState(() {
                _selectedUnitId = unit.id;
              });
              _confirmSelection();
            },
          ),
        ),
      ),
    );
  }

  /// æ˜¾ç¤ºæ–°å¢å•ä½å¯¹è¯æ¡?
  void _showAddUnitDialog(BuildContext context) {
    final nameController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('æ–°å¢å•ä½'),
        content: Form(
          key: formKey,
          child: TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'å•ä½åç§°',
              hintText: 'è¯·è¾“å…¥å•ä½åç§?,
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.straighten),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'è¯·è¾“å…¥å•ä½åç§?;
              }
              return null;
            },
            autofocus: true,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                final unitName = nameController.text.trim();

                // æ£€æŸ¥å•ä½åç§°æ˜¯å¦å·²å­˜åœ¨
                final controller = ref.read(unitControllerProvider.notifier);
                final exists = await controller.isUnitNameExists(unitName);

                if (exists) {
                  showAppSnackBar(context,
                      message: 'å•ä½åç§°å·²å­˜åœ?, isError: true);
                  return;
                }

                final unit = Unit(
                  name: unitName,
                );

                await controller.addUnit(unit);

                if (mounted) {
                  Navigator.of(context).pop();
                }
              }
            },
            child: const Text('æ·»åŠ '),
          ),
        ],
      ),
    );
  }

  // ç¼–è¾‘å’Œåˆ é™¤å¯¹è¯æ¡†éƒ½ä¸å†éœ€è¦?

  /// ç¡®è®¤é€‰æ‹©å•ä½
  void _confirmSelection() {
    if (_selectedUnitId != null) {
      final units = ref.read(allUnitsProvider).value ?? [];
      final selectedUnit = units.firstWhere(
        (unit) => unit.id == _selectedUnitId,
        orElse: () => throw Exception('é€‰ä¸­çš„å•ä½ä¸å­˜åœ¨'),
      );

      Navigator.of(context).pop(selectedUnit);
    }
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/model/product_unit.dart';

/// æè¿°è´§å“è¡¨å•åœ?UI å±‚éœ€è¦ç»´æŠ¤çš„å¯åºåˆ—åŒ–çŠ¶æ€?
class ProductFormUiState {
  final int? selectedCategoryId;
  final int? selectedUnitId;
  final String? selectedImagePath;
  final List<UnitProduct>? productUnits;
  final List<Map<String, String>>? auxiliaryUnitBarcodes;
  final String shelfLifeUnit; // days | months | years
  final bool enableBatchManagement;
  final bool hasEnteredAuxUnitPage; // æ˜¯å¦è¿›å…¥è¿‡è¾…å•ä½ç¼–è¾‘é¡µé¢

  const ProductFormUiState({
    this.selectedCategoryId,
    this.selectedUnitId,
    this.selectedImagePath,
    this.productUnits,
    this.auxiliaryUnitBarcodes,
    this.shelfLifeUnit = 'months',
    this.enableBatchManagement = false,
    this.hasEnteredAuxUnitPage = false,
  });

  ProductFormUiState copyWith({
    int? selectedCategoryId,
    bool selectedCategoryIdToNull = false,
    int? selectedUnitId,
    bool selectedUnitIdToNull = false,
    String? selectedImagePath,
    bool selectedImagePathToNull = false,
    List<UnitProduct>? productUnits,
    bool productUnitsToNull = false,
    List<Map<String, String>>? auxiliaryUnitBarcodes,
    bool auxiliaryUnitBarcodesToNull = false,
    String? shelfLifeUnit,
    bool? enableBatchManagement,
    bool? hasEnteredAuxUnitPage,
  }) {
    return ProductFormUiState(
      selectedCategoryId: selectedCategoryIdToNull
          ? null
          : (selectedCategoryId ?? this.selectedCategoryId),
      selectedUnitId: selectedUnitIdToNull
          ? null
          : (selectedUnitId ?? this.selectedUnitId),
      selectedImagePath: selectedImagePathToNull
          ? null
          : (selectedImagePath ?? this.selectedImagePath),
      productUnits: productUnitsToNull
          ? null
          : (productUnits ?? this.productUnits),
      auxiliaryUnitBarcodes: auxiliaryUnitBarcodesToNull
          ? null
          : (auxiliaryUnitBarcodes ?? this.auxiliaryUnitBarcodes),
      shelfLifeUnit: shelfLifeUnit ?? this.shelfLifeUnit,
      enableBatchManagement:
          enableBatchManagement ?? this.enableBatchManagement,
      hasEnteredAuxUnitPage:
          hasEnteredAuxUnitPage ?? this.hasEnteredAuxUnitPage,
    );
  }
}

class ProductFormUiNotifier extends StateNotifier<ProductFormUiState> {
  ProductFormUiNotifier() : super(const ProductFormUiState());

  void setCategoryId(int? id) {
    state = state.copyWith(
      selectedCategoryId: id,
      selectedCategoryIdToNull: id == null,
    );
  }

  void setUnitId(int? id) {
    state = state.copyWith(
      selectedUnitId: id,
      selectedUnitIdToNull: id == null,
    );
  }

  void setImagePath(String? path) {
    state = state.copyWith(
      selectedImagePath: path,
      selectedImagePathToNull: path == null,
    );
  }

  void setProductUnitsAndBarcodes({
    List<UnitProduct>? productUnits,
    List<Map<String, String>>? auxiliaryUnitBarcodes,
  }) {
    state = state.copyWith(
      productUnits: productUnits,
      productUnitsToNull: productUnits == null,
      auxiliaryUnitBarcodes: auxiliaryUnitBarcodes,
      auxiliaryUnitBarcodesToNull: auxiliaryUnitBarcodes == null,
    );
  }

  void setShelfLifeUnit(String unit) {
    state = state.copyWith(shelfLifeUnit: unit);
  }

  void setEnableBatchManagement(bool enable) {
    state = state.copyWith(enableBatchManagement: enable);
  }

  void setHasEnteredAuxUnitPage(bool hasEntered) {
    state = state.copyWith(hasEnteredAuxUnitPage: hasEntered);
  }

  void reset() {
    state = const ProductFormUiState();
  }
}

final productFormUiProvider =
    StateNotifierProvider.autoDispose<
      ProductFormUiNotifier,
      ProductFormUiState
    >((ref) => ProductFormUiNotifier());
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// åˆ›å»ºä¸€ä¸ªå¯å¤ç”¨çš?Widget
class AsyncValueWidget<T> extends StatelessWidget {
  const AsyncValueWidget({
    super.key,
    required this.value,
    required this.data,
    this.loading,
    this.error,
  });

  final AsyncValue<T> value;
  final Widget Function(T data) data;
  final Widget? loading;
  final Widget Function(Object error, StackTrace stackTrace)? error;

  @override
  Widget build(BuildContext context) {
    return value.when(
      data: data,
      loading: () =>
          loading ?? const Center(child: CircularProgressIndicator()),
      error: (e, s) => error?.call(e, s) ?? Center(child: Text('Error: $e')),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:stocko_app/core/widgets/cached_image_widget.dart';
import 'package:stocko_app/core/widgets/full_screen_image_viewer.dart';
import 'package:stocko_app/features/product/domain/model/product.dart';

class ProductDetailsDialog extends StatelessWidget {
  final ProductModel product;

  const ProductDetailsDialog({super.key, required this.product});

  @override
  Widget build(BuildContext context) {
    print('ProductDetailsDialog: Building for product: ${product.name}');
    print('Product ID: ${product.id}');
    print('Product Image: ${product.image}');
    print('Product SKU: ${product.sku}');
    print('Product Effective Price: ${product.effectivePrice}');
    print('Product Stock Warning Value: ${product.stockWarningValue}');
    print('Product Shelf Life: ${product.shelfLife}');
    print('Product Shelf Life Unit: ${product.shelfLifeUnit}');
    print('Product Remarks: ${product.remarks}');
    print('Product Last Updated: ${product.lastUpdated}');

    return Dialog(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // æ ‡é¢˜
            Row(
              children: [
                Expanded(
                  child: Text(
                    product.name,
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
            const SizedBox(height: 16), // äº§å“å›¾ç‰‡
            if (product.image != null && product.image!.isNotEmpty)
              GestureDetector(
                onTap: () {
                  Navigator.of(context).push(
                    PageRouteBuilder(
                      pageBuilder: (context, animation, secondaryAnimation) =>
                          FullScreenImageViewer(
                            imagePath: product.image!,
                            heroTag:
                                'product_dialog_image_${product.id}_${product.image!}',
                          ),
                      transitionsBuilder:
                          (context, animation, secondaryAnimation, child) {
                            return FadeTransition(
                              opacity: animation,
                              child: child,
                            );
                          },
                      transitionDuration: const Duration(milliseconds: 300),
                      reverseTransitionDuration: const Duration(
                        milliseconds: 200,
                      ),
                    ),
                  );
                },
                child: Hero(
                  tag: 'product_dialog_image_${product.id}_${product.image!}',
                  child: ProductDialogImage(imagePath: product.image!),
                ),
              ),

            // äº§å“è¯¦æƒ…
            if (product.sku != null)
            _buildDetailItem(context, 'SKU', product.sku!),

            // æ¡ç ä¿¡æ¯ - å·²ç§»é™¤ï¼Œç°åœ¨æ¡ç å­˜å‚¨åœ¨ç‹¬ç«‹çš„æ¡ç è¡¨ä¸­
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ¡ç ï¼Œéœ€è¦å•ç‹¬æŸ¥è¯¢æ¡ç è¡¨
            if (product.effectivePrice != null)
              _buildDetailItem(
                context,
                'ä»·æ ¼',
                product.effectivePrice!.format(),
              ),

            if (product.stockWarningValue != null)
              _buildDetailItem(
                context,
                'åº“å­˜é¢„è­¦å€?,
                '${product.stockWarningValue}',
              ),
            if (product.shelfLife != null)
              _buildDetailItem(
                context,
                'ä¿è´¨æœ?,
                _formatShelfLife(
                  product.shelfLife,
                  _getProductShelfLifeUnit(product),
                ),
              ),

            _buildDetailItem(
              context,
              'æ‰¹æ¬¡ç®¡ç†',
              product.enableBatchManagement ? 'å·²å¯ç”? : 'æœªå¯ç”?,
            ),

            if (product.remarks != null)
              _buildDetailItem(context, 'å¤‡æ³¨', product.remarks!),

            if (product.lastUpdated != null)
              _buildDetailItem(
                context,
                'æœ€åæ›´æ–?,
                _formatDateTime(product.lastUpdated!),
              ),

            const SizedBox(height: 24),

            // å…³é—­æŒ‰é’®
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('å…³é—­'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailItem(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: Colors.grey.shade700,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(value, style: Theme.of(context).textTheme.bodyMedium),
          ),
        ],
      ),
    );
  }

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  /// æ ¼å¼åŒ–ä¿è´¨æœŸæ˜¾ç¤º
  String _formatShelfLife(int? shelfLife, String? unit) {
    if (shelfLife == null) return '';

    final unitText = _getShelfLifeUnitDisplayName(unit ?? 'months');
    return '$shelfLife$unitText';
  }

  /// è·å–ä¿è´¨æœŸå•ä½æ˜¾ç¤ºåç§?
  String _getShelfLifeUnitDisplayName(String unit) {
    switch (unit) {
      case 'days':
        return 'å¤?;
      case 'months':
        return 'ä¸ªæœˆ';
      case 'years':
        return 'å¹?;
      default:
        return 'ä¸ªæœˆ';
    }
  }

  /// è·å–äº§å“çš„ä¿è´¨æœŸå•ä½
  String _getProductShelfLifeUnit(ProductModel product) {
    // å°†æšä¸¾è½¬æ¢ä¸ºå­—ç¬¦ä¸²é”®
    return product.shelfLifeUnit.name;
  }
}
import 'package:flutter/material.dart';

/// è¡¨å•åº•éƒ¨æ“ä½œæ ï¼ˆæäº¤æŒ‰é’®ï¼?
class ProductFormActionBar extends StatelessWidget {
  final bool isLoading;
  final bool isEdit;
  final VoidCallback onSubmit;

  const ProductFormActionBar({
    super.key,
    required this.isLoading,
    required this.isEdit,
    required this.onSubmit,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
      ),
      child: SafeArea(
        child: SizedBox(
          width: double.infinity,
          height: 48,
          child: ElevatedButton(
            onPressed: isLoading ? null : onSubmit,
            style: ElevatedButton.styleFrom(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text(
                    isEdit ? 'æ›´æ–°è´§å“' : 'æ·»åŠ è´§å“',
                    style: const TextStyle(fontSize: 16),
                  ),
          ),
        ),
      ),
    );
  }
}
import 'dart:io';
import 'package:flutter/material.dart';
import '../../../../core/services/image_service.dart';
import '../../../../core/utils/snackbar_helper.dart';

/// äº§å“å›¾ç‰‡é€‰æ‹©å™¨ç»„ä»?
class ProductImagePicker extends StatefulWidget {
  final String? initialImagePath;
  final ValueChanged<String?> onImageChanged;
  final double size;
  final bool enabled;

  const ProductImagePicker({
    super.key,
    this.initialImagePath,
    required this.onImageChanged,
    this.size = 120,
    this.enabled = true,
  });

  @override
  State<ProductImagePicker> createState() => _ProductImagePickerState();
}

class _ProductImagePickerState extends State<ProductImagePicker> {
  String? _currentImagePath;
  final ImageService _imageService = ImageService();

  @override
  void initState() {
    super.initState();
    _currentImagePath = widget.initialImagePath;
  }

  @override
  void didUpdateWidget(ProductImagePicker oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialImagePath != oldWidget.initialImagePath) {
      setState(() {
        _currentImagePath = widget.initialImagePath;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸ
        GestureDetector(
          onTap: widget.enabled ? _showImagePickerOptions : null,
          child: Container(
            width: widget.size,
            height: widget.size,
            decoration: BoxDecoration(
              color: Colors.grey.shade100,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: Colors.grey.shade300,
                width: 2,
                style: BorderStyle.solid,
              ),
            ),
            child: _buildImageContent(),
          ),
        ),
        const SizedBox(height: 8),
        // æ“ä½œæŒ‰é’®
        // if (widget.enabled) _buildActionButtons(),
      ],
    );
  }

  Widget _buildImageContent() {
    if (_currentImagePath != null && _currentImagePath!.isNotEmpty) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(10),
        child: Image.file(
          File(_currentImagePath!),
          width: widget.size,
          height: widget.size,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return _buildPlaceholder();
          },
        ),
      );
    } else {
      return _buildPlaceholder();
    }
  }

  Widget _buildPlaceholder() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          Icons.add_a_photo,
          size: widget.size * 0.3,
          color: Colors.grey.shade400,
        ),
        const SizedBox(height: 4),
        Text(
          'æ·»åŠ å›¾ç‰‡',
          style: TextStyle(color: Colors.grey.shade600, fontSize: 12),
        ),
      ],
    );
  }

  void _showImagePickerOptions() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (BuildContext context) {
        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                const SizedBox(height: 16),
                Text('é€‰æ‹©å›¾ç‰‡', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildOptionButton(
                      icon: Icons.camera_alt,
                      label: 'æ‹ç…§',
                      onTap: () {
                        Navigator.of(context).pop();
                        _pickImageFromCamera();
                      },
                    ),
                    _buildOptionButton(
                      icon: Icons.photo_library,
                      label: 'ç›¸å†Œ',
                      onTap: () {
                        Navigator.of(context).pop();
                        _pickImageFromGallery();
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 16),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildOptionButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey.shade300),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          children: [
            Icon(icon, size: 48, color: Theme.of(context).primaryColor),
            const SizedBox(height: 8),
            Text(
              label,
              style: TextStyle(
                color: Theme.of(context).primaryColor,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _pickImageFromCamera() async {
    try {
      final String? imagePath = await _imageService.pickImageFromCamera();
      if (imagePath != null) {
        _updateImage(imagePath);
      }
    } catch (e) {
      showAppSnackBar(context, message: 'æ‹ç…§å¤±è´¥: $e', isError: true);
    }
  }

  Future<void> _pickImageFromGallery() async {
    try {
      final String? imagePath = await _imageService.pickImageFromGallery();
      if (imagePath != null) {
        _updateImage(imagePath);
      }
    } catch (e) {
      showAppSnackBar(context, message: 'é€‰æ‹©å›¾ç‰‡å¤±è´¥: $e', isError: true);
    }
  }

  void _updateImage(String imagePath) {
    setState(() {
      _currentImagePath = imagePath;
    });
    widget.onImageChanged(imagePath);
  }
  // void _removeImage() {
  //   setState(() {
  //     _currentImagePath = null;
  //   });
  //   widget.onImageChanged(null);
  // }

}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../analytics/application/provider/ranking_providers.dart';

class TimeFilterBottomSheet extends ConsumerStatefulWidget {
  const TimeFilterBottomSheet({super.key});

  @override
  ConsumerState<TimeFilterBottomSheet> createState() => _TimeFilterBottomSheetState();
}

class _TimeFilterBottomSheetState extends ConsumerState<TimeFilterBottomSheet> {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Container(
      height: MediaQuery.of(context).size.height * 0.7,
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Column(
        children: [
          // é¡¶éƒ¨æŒ‡ç¤ºæ?
          Container(
            margin: const EdgeInsets.only(top: 8, bottom: 16),
            height: 4,
            width: 40,
            decoration: BoxDecoration(
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.4),
              borderRadius: BorderRadius.circular(2),
            ),
          ),

          // æ ‡é¢˜ä¸å…³é—­åŒº
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: [
                Text(
                  'é€‰æ‹©æ—¶é—´èŒƒå›´',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Spacer(),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: Icon(Icons.close, color: colorScheme.onSurface),
                ),
              ],
            ),
          ),

          const Divider(),

          // æ¨¡å¼åˆ‡æ¢åŒ?
          _ModeSelector(),

          const Divider(),

          // æ—¥æœŸé€‰æ‹©åŒ?
          Expanded(
            child: _DateSelector(),
          ),

          const Divider(),

          // æ“ä½œæŒ‰é’®åŒ?
          _ActionButtons(),
        ],
      ),
    );
  }
}

// æ¨¡å¼åˆ‡æ¢æ§ä»¶
class _ModeSelector extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentMode = ref.watch(timeFilterModeProvider);
    final colorScheme = Theme.of(context).colorScheme;

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Row(
        children: TimeFilterMode.values.map((mode) {
          final isSelected = currentMode == mode;
          return Expanded(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 4),
              child: GestureDetector(
                onTap: () => ref.read(timeFilterModeProvider.notifier).state = mode,
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  decoration: BoxDecoration(
                    color: isSelected ? colorScheme.primary : colorScheme.surfaceContainerHighest,
                    borderRadius: BorderRadius.circular(8),
                    boxShadow: isSelected
                        ? [
                            BoxShadow(
                              color: colorScheme.primary.withValues(alpha: 0.3),
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            )
                          ]
                        : null,
                  ),
                  child: Text(
                    mode.label,
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: isSelected ? colorScheme.onPrimary : colorScheme.onSurface,
                      fontWeight: isSelected ? FontWeight.bold : FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}

// æ—¥æœŸé€‰æ‹©åŒ?
class _DateSelector extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final mode = ref.watch(timeFilterModeProvider);

    switch (mode) {
      case TimeFilterMode.daily:
        return _DailySelector();
      case TimeFilterMode.weekly:
        return _WeeklySelector();
      case TimeFilterMode.monthly:
        return _MonthlySelector();
    }
  }
}

// æ¯æ—¥é€‰æ‹©å™?
class _DailySelector extends ConsumerStatefulWidget {
  @override
  ConsumerState<_DailySelector> createState() => _DailySelectorState();
}

class _DailySelectorState extends ConsumerState<_DailySelector> {
  late DateTime _displayedMonth;

  @override
  void initState() {
    super.initState();
    final selectedDate = ref.read(selectedDateProvider);
    _displayedMonth = DateTime(selectedDate.year, selectedDate.month);
  }

  @override
  Widget build(BuildContext context) {
    final selectedDate = ref.watch(selectedDateProvider);
    final colorScheme = Theme.of(context).colorScheme;

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // æœˆä»½å¯¼èˆª
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  onPressed: () {
                    setState(() {
                      _displayedMonth = DateTime(_displayedMonth.year, _displayedMonth.month - 1);
                    });
                  },
                  icon: const Icon(Icons.chevron_left),
                ),
                Text(
                  '${_displayedMonth.year}å¹?{_displayedMonth.month}æœ?,
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () {
                    setState(() {
                      _displayedMonth = DateTime(_displayedMonth.year, _displayedMonth.month + 1);
                    });
                  },
                  icon: const Icon(Icons.chevron_right),
                ),
              ],
            ),
          ),
          // æ—¥å†ç½‘æ ¼
          _buildCalendarGrid(selectedDate, colorScheme),
        ],
      ),
    );
  }

  Widget _buildCalendarGrid(DateTime selectedDate, ColorScheme colorScheme) {
    final firstDayOfMonth = DateTime(_displayedMonth.year, _displayedMonth.month, 1);
    final lastDayOfMonth = DateTime(_displayedMonth.year, _displayedMonth.month + 1, 0);
    final firstWeekday = firstDayOfMonth.weekday;
    final daysInMonth = lastDayOfMonth.day;
    final totalCells = ((daysInMonth + firstWeekday - 1) / 7).ceil() * 7;

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      child: GridView.builder(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 7,
          childAspectRatio: 1.2,
          crossAxisSpacing: 4,
          mainAxisSpacing: 4,
        ),
        itemCount: totalCells,
        itemBuilder: (context, index) {
          final dayNumber = index - firstWeekday + 2;
          
          if (dayNumber <= 0 || dayNumber > daysInMonth) {
            return const SizedBox();
          }

          final date = DateTime(_displayedMonth.year, _displayedMonth.month, dayNumber);
          final isSelected = date.year == selectedDate.year && 
                            date.month == selectedDate.month && 
                            date.day == selectedDate.day;
          final isToday = date.year == DateTime.now().year && 
                         date.month == DateTime.now().month && 
                         date.day == DateTime.now().day;

          return GestureDetector(
            onTap: () {
              ref.read(selectedDateProvider.notifier).state = date;
            },
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 200),
              decoration: BoxDecoration(
                color: isSelected
                    ? colorScheme.primary
                    : isToday
                        ? colorScheme.primaryContainer.withValues(alpha: 0.6)
                        : null,
                borderRadius: BorderRadius.circular(8),
                border: isToday && !isSelected
                    ? Border.all(color: colorScheme.primary, width: 2)
                    : null,
                boxShadow: isSelected
                    ? [
                        BoxShadow(
                          color: colorScheme.primary.withValues(alpha: 0.4),
                          blurRadius: 6,
                          offset: const Offset(0, 2),
                        )
                      ]
                    : null,
              ),
              child: Center(
                child: Text(
                  '$dayNumber',
                  style: TextStyle(
                    color: isSelected 
                        ? colorScheme.onPrimary 
                        : isToday 
                            ? colorScheme.onPrimaryContainer 
                            : colorScheme.onSurface,
                    fontWeight: isSelected || isToday ? FontWeight.bold : FontWeight.normal,
                    fontSize: 14,
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

// æ¯å‘¨é€‰æ‹©å™?
class _WeeklySelector extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedDate = ref.watch(selectedDateProvider);

    return Column(
      children: [
        // å¹´ä»½æ˜¾ç¤º
        Padding(
          padding: const EdgeInsets.all(0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              IconButton(
                onPressed: () {
                  final newDate = DateTime(selectedDate.year - 1, selectedDate.month, selectedDate.day);
                  ref.read(selectedDateProvider.notifier).state = newDate;
                },
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                '${selectedDate.year}å¹?,
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                onPressed: () {
                  final newDate = DateTime(selectedDate.year + 1, selectedDate.month, selectedDate.day);
                  ref.read(selectedDateProvider.notifier).state = newDate;
                },
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),
        ),
        Expanded(
          child: _WeeklyWheelPicker(
            selectedDate: selectedDate,
            onDateChanged: (date) {
              ref.read(selectedDateProvider.notifier).state = date;
            },
          ),
        ),
      ],
    );
  }

}

// è‡ªå®šä¹‰æ¯å‘¨æ»šè½®é€‰æ‹©å™?
class _WeeklyWheelPicker extends StatefulWidget {
  final DateTime? selectedDate;
  final ValueChanged<DateTime> onDateChanged;

  const _WeeklyWheelPicker({
    required this.selectedDate,
    required this.onDateChanged,
  });

  @override
  State<_WeeklyWheelPicker> createState() => _WeeklyWheelPickerState();
}

class _WeeklyWheelPickerState extends State<_WeeklyWheelPicker> {
  late FixedExtentScrollController _yearController;
  late FixedExtentScrollController _weekController;
  late int _selectedYear;
  late int _selectedWeek;

  @override
  void initState() {
    super.initState();
    final now = widget.selectedDate ?? DateTime.now();
    _selectedYear = now.year;
    _selectedWeek = _getWeekOfYear(now);

    _yearController = FixedExtentScrollController(initialItem: _selectedYear - 2020);
    _weekController = FixedExtentScrollController(initialItem: _selectedWeek - 1);
  }

  @override
  void didUpdateWidget(_WeeklyWheelPicker oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.selectedDate != oldWidget.selectedDate) {
      final now = widget.selectedDate ?? DateTime.now();
      final newYear = now.year;
      final newWeek = _getWeekOfYear(now);
      
      if (newYear != _selectedYear) {
        setState(() {
          _selectedYear = newYear;
          _selectedWeek = newWeek;
        });
        _weekController.animateToItem(
          _selectedWeek - 1,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
      }
    }
  }

  @override
  void dispose() {
    _yearController.dispose();
    _weekController.dispose();
    super.dispose();
  }

  int _getWeekOfYear(DateTime date) {
    final firstDayOfYear = DateTime(date.year, 1, 1);
    final daysSinceFirstDay = date.difference(firstDayOfYear).inDays;
    return ((daysSinceFirstDay + firstDayOfYear.weekday - 1) ~/ 7) + 1;
  }

  int _getTotalWeeksInYear(int year) {
    final lastDayOfYear = DateTime(year, 12, 31);
    return _getWeekOfYear(lastDayOfYear);
  }

  DateTime _getDateFromWeek(int year, int week) {
    final firstDayOfYear = DateTime(year, 1, 1);
    final daysToAdd = (week - 1) * 7 - (firstDayOfYear.weekday - 1);
    return firstDayOfYear.add(Duration(days: daysToAdd));
  }

  void _updateSelectedDate() {
    final selectedDate = _getDateFromWeek(_selectedYear, _selectedWeek);
    widget.onDateChanged(selectedDate);
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Container(
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(12),
        ),
        child: ListWheelScrollView.useDelegate(
          controller: _weekController,
          itemExtent: 60,
          physics: const FixedExtentScrollPhysics(),
          onSelectedItemChanged: (index) {
            final totalWeeks = _getTotalWeeksInYear(_selectedYear);
            final weekInYear = index + 1;
            
            if (weekInYear <= totalWeeks) {
              setState(() {
                _selectedWeek = weekInYear;
                _updateSelectedDate();
              });
            }
          },
          childDelegate: ListWheelChildBuilderDelegate(
            builder: (context, index) {
              final weekInYear = index + 1;
              final totalWeeks = _getTotalWeeksInYear(_selectedYear);
              
              if (weekInYear > totalWeeks) {
                return const SizedBox();
              }
              
              final isSelected = weekInYear == _selectedWeek;
              final weekDate = _getDateFromWeek(_selectedYear, weekInYear);
              final endDate = weekDate.add(const Duration(days: 6));

              return Container(
                height: 60,
                alignment: Alignment.center,
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? colorScheme.primary
                        : null,
                    borderRadius: BorderRadius.circular(10),
                    boxShadow: isSelected
                        ? [
                            BoxShadow(
                              color: colorScheme.primary.withValues(alpha: 0.3),
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            )
                          ]
                        : null,
                  ),
                  child: Text(
                    '${weekDate.month}æœ?{weekDate.day}æ—?- ${endDate.month}æœ?{endDate.day}æ—?,
                    style: TextStyle(
                      color: isSelected ? colorScheme.onPrimary : colorScheme.onSurface,
                      fontSize: 14,
                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                    ),
                  ),
                ),
              );
            },
            childCount: 53,
          ),
        ),
      ),
    );
  }
}

// æ¯æœˆé€‰æ‹©å™?
class _MonthlySelector extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedMonth = ref.watch(selectedMonthProvider);
    final colorScheme = Theme.of(context).colorScheme;



    return Column(
      children: [
        // å¹´ä»½é€‰æ‹©å™?
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              IconButton(
                onPressed: () {
                  final newMonth = DateTime(selectedMonth.year - 1, selectedMonth.month);
                  ref.read(selectedMonthProvider.notifier).state = newMonth;
                },
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                '${selectedMonth.year}å¹?,
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                onPressed: () {
                  final newMonth = DateTime(selectedMonth.year + 1, selectedMonth.month);
                  ref.read(selectedMonthProvider.notifier).state = newMonth;
                },
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),
        ),

        // æœˆä»½ç½‘æ ¼
        Expanded(
          child: Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: GridView.builder(
              padding: const EdgeInsets.all(16),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                crossAxisSpacing: 12,
                mainAxisSpacing: 8,
                childAspectRatio: 1.5,
              ),
              itemCount: 12,
              itemBuilder: (context, index) {
                final month = index + 1;
                final isSelected = selectedMonth.month == month && selectedMonth.year == selectedMonth.year;
                final isCurrentMonth = DateTime.now().month == month && DateTime.now().year == selectedMonth.year;

                return GestureDetector(
                  onTap: () {
                    final newMonth = DateTime(selectedMonth.year, month);
                    ref.read(selectedMonthProvider.notifier).state = newMonth;
                  },
                  child: AnimatedContainer(
                    duration: const Duration(milliseconds: 200),
                    decoration: BoxDecoration(
                      color: isSelected
                          ? colorScheme.primary
                          : isCurrentMonth
                              ? colorScheme.primaryContainer.withValues(alpha: 0.4)
                              : colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(12),
                      border: isSelected
                          ? Border.all(color: colorScheme.primary.withValues(alpha: 0.5), width: 3)
                          : isCurrentMonth && !isSelected
                              ? Border.all(color: colorScheme.primary, width: 2)
                              : null,
                      boxShadow: isSelected
                          ? [
                              BoxShadow(
                                color: colorScheme.primary.withValues(alpha: 0.5),
                                blurRadius: 12,
                                offset: const Offset(0, 4),
                              )
                            ]
                          : null,
                    ),
                    child: Center(
                      child: AnimatedDefaultTextStyle(
                        duration: const Duration(milliseconds: 200),
                        style: TextStyle(
                          color: isSelected
                              ? Theme.of(context).colorScheme.onPrimary
                              : isCurrentMonth
                                  ? Theme.of(context).colorScheme.onPrimaryContainer
                                  : Theme.of(context).colorScheme.onSurface,
                          fontWeight: isSelected || isCurrentMonth ? FontWeight.bold : FontWeight.w600,
                          fontSize: isSelected || isCurrentMonth ? 15 : 14,
                        ),
                        child: Text('$monthæœ?),
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        ),
      ],
    );
  }
}

// æ“ä½œæŒ‰é’®åŒ?
class _ActionButtons extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // å…¨éƒ¨æŒ‰é’®
          SizedBox(
            width: double.infinity,
            child: OutlinedButton.icon(
              onPressed: () {
                // è®¾ç½®ä¸ºå…¨éƒ¨æ—¶é—?
                final now = DateTime.now();
                final endOpen = DateTime(now.year, now.month, now.day).add(const Duration(days: 1));
                final start = DateTime(2000, 1, 1);
                ref.read(rankingRangeProvider.notifier).state = RankingRange(start, endOpen);
                Navigator.of(context).pop();
              },
              icon: const Icon(Icons.all_inclusive),
              label: const Text('å…¨éƒ¨'),
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
            ),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              // é‡ç½®æŒ‰é’®
              Expanded(
                child: OutlinedButton(
                  onPressed: () {
                    // é‡ç½®åˆ°é»˜è®¤çŠ¶æ€?
                    ref.read(timeFilterModeProvider.notifier).state = TimeFilterMode.daily;
                    ref.read(selectedDateProvider.notifier).state = DateTime.now();
                    ref.read(selectedMonthProvider.notifier).state = DateTime.now();
                  },
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text('é‡ç½®'),
                ),
              ),

              const SizedBox(width: 16),

              // ç¡®å®šæŒ‰é’®
              Expanded(
                child: FilledButton(
                  onPressed: () {
                    _applyTimeFilter(ref);
                    Navigator.of(context).pop();
                  },
                  style: FilledButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: const Text('ç¡®å®š'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _applyTimeFilter(WidgetRef ref) {
    final mode = ref.read(timeFilterModeProvider);
    late RankingRange range;

    switch (mode) {
      case TimeFilterMode.daily:
        final date = ref.read(selectedDateProvider);
        final start = DateTime(date.year, date.month, date.day);
        final endOpen = start.add(const Duration(days: 1));
        range = RankingRange(start, endOpen);
        break;

      case TimeFilterMode.weekly:
        final date = ref.read(selectedDateProvider);
        // è®¡ç®—æœ¬å‘¨çš„å¼€å§‹å’Œç»“æŸ
        final startOfWeek = date.subtract(Duration(days: date.weekday - 1));
        final endOfWeek = startOfWeek.add(const Duration(days: 7));
        range = RankingRange(startOfWeek, endOfWeek);
        break;

      case TimeFilterMode.monthly:
        final date = ref.read(selectedMonthProvider);
        final start = DateTime(date.year, date.month, 1);
        final end = DateTime(date.year, date.month + 1, 1);
        range = RankingRange(start, end);
        break;
    }

    ref.read(rankingRangeProvider.notifier).state = range;
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/unit.dart';
import '../../application/provider/unit_providers.dart';

/// å•ä½åˆ—è¡¨é¡¹ç»„ä»?
/// ç”¨äºåœ¨å•ä½åˆ—è¡¨ä¸­æ˜¾ç¤ºå•ä¸ªå•ä½çš„ä¿¡æ?
class UnitListTile extends ConsumerWidget {
  final Unit unit;
  final VoidCallback? onTap;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;
  final bool showActions;
  final bool isSelected;

  const UnitListTile({
    super.key,
    required this.unit,
    this.onTap,
    this.onEdit,
    this.onDelete,
    this.showActions = true,
    this.isSelected = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controllerState = ref.watch(unitControllerProvider);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      elevation: isSelected ? 4 : 2,
      color: isSelected
          ? Theme.of(context).primaryColor.withOpacity(0.1)
          : null,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // å¤´éƒ¨ä¿¡æ¯ï¼šåç§?
              Row(
                children: [
                  Expanded(
                    child: Text(
                      unit.name,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.w600,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  if (isSelected)
                    Icon(
                      Icons.check_circle,
                      color: Theme.of(context).primaryColor,
                      size: 24,
                    ),
                ],
              ),

              const SizedBox(height: 8),

              // å•ä½è¯¦ç»†ä¿¡æ¯
              _buildUnitInfo(context),

              // æ“ä½œæŒ‰é’®
              if (showActions) ...[
                const SizedBox(height: 12),
                _buildActionButtons(context, ref, controllerState),
              ],
            ],
          ),
        ),
      ),
    );
  }

  /// æ„å»ºå•ä½ä¿¡æ¯
  Widget _buildUnitInfo(BuildContext context) {
    return const SizedBox.shrink();
  }

  /// æ„å»ºæ“ä½œæŒ‰é’®
  Widget _buildActionButtons(
    BuildContext context,
    WidgetRef ref,
    UnitControllerState controllerState,
  ) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        // ç¼–è¾‘æŒ‰é’®
        TextButton.icon(
          onPressed: controllerState.isLoading ? null : onEdit,
          icon: const Icon(Icons.edit, size: 16),
          label: const Text('ç¼–è¾‘'),
          style: TextButton.styleFrom(
            foregroundColor: Theme.of(context).primaryColor,
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          ),
        ),
        const SizedBox(width: 8),
        // åˆ é™¤æŒ‰é’®
        TextButton.icon(
          onPressed: controllerState.isLoading
              ? null
              : () => _showDeleteConfirmation(context, ref),
          icon: const Icon(Icons.delete, size: 16),
          label: const Text('åˆ é™¤'),
          style: TextButton.styleFrom(
            foregroundColor: Colors.red.shade600,
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          ),
        ),
      ],
    );
  }

  /// æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡?
  void _showDeleteConfirmation(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ç¡®è®¤åˆ é™¤'),
        content: Text('ç¡®å®šè¦åˆ é™¤å•ä½?"${unit.name}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              if (onDelete != null) {
                onDelete!();
              } else {
                // é»˜è®¤åˆ é™¤æ“ä½œ
                final controller = ref.read(unitControllerProvider.notifier);
                if (unit.id != null) {
                  controller.deleteUnit(unit.id!);
                }
              }
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red.shade600),
            child: const Text('åˆ é™¤'),
          ),
        ],
      ),
    );
  }
}

/// å•ä½åˆ—è¡¨é¡¹çš„ç®€åŒ–ç‰ˆæœ?
/// é€‚ç”¨äºåªéœ€è¦æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯çš„åœºæ™¯
class SimpleUnitListTile extends StatelessWidget {
  final Unit unit;
  final VoidCallback? onTap;
  final bool isSelected;

  const SimpleUnitListTile({
    super.key,
    required this.unit,
    this.onTap,
    this.isSelected = false,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      onTap: onTap,
      title: Text(
        unit.name,
        style: TextStyle(
          fontWeight: isSelected ? FontWeight.bold : FontWeight.w600,
        ),
      ),
      trailing: isSelected
          ? Icon(Icons.check_circle, color: Theme.of(context).primaryColor)
          : null,
      selected: isSelected,
      selectedTileColor: Theme.of(context).primaryColor.withOpacity(0.1),
    );
  }
}
// Product Widgets Barrel File
// ç»Ÿä¸€å¯¼å‡ºäº§å“ç›¸å…³çš?Widget ç»„ä»¶

export 'product_image_picker.dart';
export 'unit_list_tile.dart';

// å¯¼å‡ºé¡µé¢ç»„ä»¶
export '../screens/screens.dart';
import 'package:flutter/material.dart';

/// å¯æµ‹é‡é«˜åº¦çš„å®¹å™¨ç»„ä»¶ï¼ˆç”¨äºè°ƒè¯•ï¼‰
/// åœ¨çº¢è‰²è¾¹æ¡†çš„å³ä¸Šè§’æ˜¾ç¤ºå®¹å™¨å†…å®¹çš„é«˜åº¦
class MeasuredContainer extends StatefulWidget {
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final String? label; // å¯é€‰æ ‡ç­¾ï¼Œç”¨äºåŒºåˆ†ä¸åŒçš„å®¹å™?

  const MeasuredContainer({
    super.key,
    required this.child,
    this.padding,
    this.label,
  });

  @override
  State<MeasuredContainer> createState() => _MeasuredContainerState();
}

class _MeasuredContainerState extends State<MeasuredContainer> {
  final GlobalKey _containerKey = GlobalKey();
  double? _height;

  @override
  void initState() {
    super.initState();
    // åœ¨é¦–å¸§æ¸²æŸ“åæµ‹é‡é«˜åº¦
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _measureHeight();
    });
  }

  void _measureHeight() {
    final RenderBox? renderBox =
        _containerKey.currentContext?.findRenderObject() as RenderBox?;
    if (renderBox != null && mounted) {
      setState(() {
        _height = renderBox.size.height;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          key: _containerKey,
          padding:
              widget.padding ??
              const EdgeInsets.symmetric(horizontal: 0, vertical: 0),
          child: widget.child,
        ),
        // æ˜¾ç¤ºé«˜åº¦æ ‡ç­¾
        if (_height != null)
          Positioned(
            top: -10,
            right: 8,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 0),
              decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                widget.label != null
                    ? '${widget.label}: ${_height!.toStringAsFixed(1)}px'
                    : '${_height!.toStringAsFixed(1)}px',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
      ],
    );
  }
}
import 'package:flutter/material.dart';

/// é€šç”¨è¡¨å•æ–‡æœ¬è¾“å…¥æ¡?
class AppTextField extends StatefulWidget {
  final TextEditingController controller;
  final String label;
  final bool isRequired;
  final IconData? icon;
  final TextInputType? keyboardType;
  final String? prefixText;
  final int maxLines;
  final FocusNode? focusNode;
  final void Function(String)? onFieldSubmitted;

  const AppTextField({
    super.key,
    required this.controller,
    required this.label,
    this.isRequired = false,
    this.icon,
    this.keyboardType,
    this.prefixText,
    this.maxLines = 1,
    this.focusNode,
    this.onFieldSubmitted,
  });

  @override
  State<AppTextField> createState() => _AppTextFieldState();
}

class _AppTextFieldState extends State<AppTextField> {
  late FocusNode _focusNode;

  @override
  void initState() {
    super.initState();
    // ä½¿ç”¨ä¼ å…¥çš?focusNode æˆ–åˆ›å»ºä¸€ä¸ªæ–°çš?
    _focusNode = widget.focusNode ?? FocusNode();
  }

  @override
  void dispose() {
    // å¦‚æœæˆ‘ä»¬åˆ›å»ºäº†æ–°çš?FocusNodeï¼Œåˆ™éœ€è¦é‡Šæ”¾å®ƒ
    if (widget.focusNode == null) {
      _focusNode.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // æ ‡ç­¾æ˜¾ç¤ºåœ¨å·¦è¾?
          SizedBox(
            width: 100,
            child: Padding(
              padding: const EdgeInsets.only(right: 12),
              child: Text(
                widget.isRequired ? '${widget.label} *' : widget.label,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
          // è¾“å…¥æ¡?
          Expanded(
            child: SizedBox(
              height: 48,
              child: TextFormField(
                controller: widget.controller,
                focusNode: _focusNode,
                keyboardType: widget.keyboardType,
                maxLines: widget.maxLines,
                onFieldSubmitted: widget.onFieldSubmitted,
                decoration: InputDecoration(
                  prefixIcon: widget.icon != null ? Icon(widget.icon) : null,
                  prefixText: widget.prefixText,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
                validator: widget.isRequired
                    ? (value) {
                        if (value == null || value.trim().isEmpty) {
                          return '${widget.label}ä¸èƒ½ä¸ºç©º';
                        }
                        return null;
                      }
                    : null,
              ),
            ),
          ),
        ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import '../../../domain/model/category.dart';

/// ç±»åˆ«é€‰æ‹© TypeAhead è¾“å…¥ç»„ä»¶
class CategoryTypeAheadField extends StatefulWidget {
  final TextEditingController controller;
  final FocusNode focusNode;
  final List<CategoryModel> categories;
  final int? selectedCategoryId;
  final void Function(CategoryModel) onSelected;
  final VoidCallback onTapChooseCategory;
  final String hintText;
  final VoidCallback? onClear;
  final VoidCallback? onSubmitted;

  const CategoryTypeAheadField({
    super.key,
    required this.controller,
    required this.focusNode,
    required this.categories,
    required this.selectedCategoryId,
    required this.onSelected,
    required this.onTapChooseCategory,
    this.hintText = 'ç±»åˆ«',
    this.onClear,
    this.onSubmitted,
  });

  @override
  State<CategoryTypeAheadField> createState() => _CategoryTypeAheadFieldState();
}

class _CategoryTypeAheadFieldState extends State<CategoryTypeAheadField> {
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    // æ·»åŠ ç›‘å¬å™?
    widget.focusNode.addListener(_onFocusChange);
  }

  @override
  void dispose() {
    // ç§»é™¤ç›‘å¬å™?
    widget.focusNode.removeListener(_onFocusChange);
    super.dispose();
  }

  void _onFocusChange() {
    setState(() {
      _isFocused = widget.focusNode.hasFocus;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // æ ‡ç­¾æ˜¾ç¤ºåœ¨å·¦è¾?
          SizedBox(
            width: 100,
            child: Padding(
              padding: const EdgeInsets.only(right: 0),
              child: Text(
                'ç±»åˆ«',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
          Expanded(
            child: SizedBox(
              height: 48,
              child: TypeAheadField<CategoryModel>(
                controller: widget.controller,
                suggestionsCallback: (pattern) {
                  if (pattern.isEmpty) {
                    return Future.value([
                      const CategoryModel(name: 'æœªåˆ†ç±?),
                      ...widget.categories,
                    ]);
                  }
                  final filtered = widget.categories
                      .where(
                        (c) => c.name
                            .replaceAll(' ', '')
                            .toLowerCase()
                            .contains(pattern.toLowerCase()),
                      )
                      .toList();
                  if (filtered.isEmpty || pattern == 'æœªåˆ†ç±?) {
                    filtered.insert(0, const CategoryModel(name: 'æœªåˆ†ç±?));
                  }
                  return Future.value(filtered);
                },
                itemBuilder: (context, CategoryModel suggestion) => ListTile(
                  title: Text(
                    suggestion.name,
                    style: Theme.of(context).textTheme.bodyLarge,
                  ),
                  dense: true,
                ),
                onSelected: widget.onSelected,
                builder: (context, c, fNode) {
                  return TextField(
                    controller: c,
                    focusNode: widget.focusNode, // ä½¿ç”¨å¤–éƒ¨ä¼ å…¥çš?focusNode
                    onSubmitted: (_) => widget.onSubmitted?.call(),
                    inputFormatters: [
                      FilteringTextInputFormatter.deny(RegExp(r'\s')),
                    ],
                    decoration: InputDecoration(
                      hintText: _isFocused ? '' : '',
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                    ),
                  );
                },
                emptyBuilder: (context) => const Padding(
                  padding: EdgeInsets.all(0.0),
                  child: Text('æœªæ‰¾åˆ°åŒ¹é…çš„ç±»åˆ«'),
                ),
              ),
            ),
          ),
          const SizedBox(width: 0),
          IconButton(
            onPressed: widget.onTapChooseCategory,
            icon: const Icon(Icons.arrow_forward_ios),
            tooltip: 'é€‰æ‹©ç±»åˆ«',
          ),
        ],
    );
  }
}
import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:flutter/material.dart';

/// ä¿è´¨æœŸå•ä½ä¸‹æ‹?
class ShelfLifeUnitDropdown extends StatelessWidget {
  final String value;
  final List<String> options;
  final ValueChanged<String> onChanged;

  const ShelfLifeUnitDropdown({
    super.key,
    required this.value,
    required this.options,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.centerLeft,
      child: SizedBox(
        height: 48,
        child: IntrinsicWidth(
          child: DropdownButtonFormField2<String>(
            value: value,
            decoration: InputDecoration(
              contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              filled: false,
              border: InputBorder.none,
              enabledBorder: InputBorder.none,
              focusedBorder: InputBorder.none,
              hintStyle: Theme.of(context).inputDecorationTheme.hintStyle,
            ),
            items: options.map((unit) {
              return DropdownMenuItem(
                value: unit,
                child: Text(
                  _displayName(unit),
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
              );
            }).toList(),
            onChanged: (val) {
              if (val != null) onChanged(val);
            },
            buttonStyleData: const ButtonStyleData(
              padding: EdgeInsets.only(right: 4),
            ),
            iconStyleData: const IconStyleData(
              icon: Icon(Icons.arrow_drop_down),
              iconSize: 24,
            ),
            dropdownStyleData: DropdownStyleData(
              maxHeight: 200,
              decoration: BoxDecoration(borderRadius: BorderRadius.circular(12)),
            ),
          ),
        ),
      ),
    );
  }

  String _displayName(String unit) {
    switch (unit) {
      case 'days':
        return 'å¤?;
      case 'months':
        return 'ä¸ªæœˆ';
      case 'years':
        return 'å¹?;
      default:
        return unit;
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import '../../../domain/model/unit.dart';

/// å•ä½é€‰æ‹© TypeAhead è¾“å…¥ç»„ä»¶
class UnitTypeAheadField extends StatefulWidget {
  final TextEditingController controller;
  final FocusNode focusNode;
  final List<Unit> units;
  final int? selectedUnitId;
  final void Function(Unit unit) onSelected;
  final VoidCallback onTapAddAuxiliary;
  final VoidCallback onTapChooseUnit;
  final String hintText;
  final String? Function()? errorTextBuilder;
  final String? helperText;
  final VoidCallback? onClear;
  final VoidCallback? onSubmitted;

  const UnitTypeAheadField({
    super.key,
    required this.controller,
    required this.focusNode,
    required this.units,
    required this.selectedUnitId,
    required this.onSelected,
    required this.onTapAddAuxiliary,
    required this.onTapChooseUnit,
    this.hintText = 'åŸºæœ¬å•ä½ *',
    this.errorTextBuilder,
    this.helperText,
    this.onClear,
    this.onSubmitted,
  });

  @override
  State<UnitTypeAheadField> createState() => _UnitTypeAheadFieldState();
}

class _UnitTypeAheadFieldState extends State<UnitTypeAheadField> {
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    // æ·»åŠ ç›‘å¬å™?
    widget.focusNode.addListener(_onFocusChange);
  }

  @override
  void dispose() {
    // ç§»é™¤ç›‘å¬å™?
    widget.focusNode.removeListener(_onFocusChange);
    super.dispose();
  }

  void _onFocusChange() {
    setState(() {
      _isFocused = widget.focusNode.hasFocus;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // æ ‡ç­¾æ˜¾ç¤ºåœ¨å·¦è¾?
          SizedBox(
            width: 100,
            child: Padding(
              padding: const EdgeInsets.only(right: 12),
              child: Text(
                'åŸºæœ¬å•ä½ *',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
          Expanded(
            child: SizedBox(
              height: 48,
              child: TypeAheadField<Unit>(
                controller: widget.controller,
                suggestionsCallback: (pattern) {
                  if (pattern.isEmpty) return Future.value(widget.units);
                  final filtered = widget.units
                      .where((u) => u.name
                          .replaceAll(' ', '')
                          .toLowerCase()
                          .contains(pattern.toLowerCase()))
                      .toList();
                  return Future.value(filtered);
                },
                itemBuilder: (context, Unit suggestion) => ListTile(
                  title: Text(
                    suggestion.name,
                    style: Theme.of(context).textTheme.bodyLarge,
                  ),
                  dense: true,
                ),
                onSelected: widget.onSelected,
                builder: (context, c, fNode) {
                  return TextField(
                    controller: c,
                    focusNode: widget.focusNode, // ä½¿ç”¨å¤–éƒ¨ä¼ å…¥çš?focusNode ä»¥ä¾¿é¡µé¢æ§åˆ¶ç„¦ç‚¹
                    onSubmitted: (_) => widget.onSubmitted?.call(),
                    inputFormatters: [
                      FilteringTextInputFormatter.deny(RegExp(r'\s')),
                    ],
                    decoration: InputDecoration(
                      hintText: _isFocused ? '' : '',
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                      errorText: widget.errorTextBuilder?.call(),
                      helperText: widget.helperText,
                      helperStyle: TextStyle(
                        color: Colors.green.shade600,
                        fontSize: 12,
                      ),
                    ),
                  );
                },
                emptyBuilder: (context) => const Padding(
                  padding: EdgeInsets.all(0.0),
                  child: Text('æœªæ‰¾åˆ°åŒ¹é…çš„å•ä½'),
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            onPressed: widget.onTapAddAuxiliary,
            icon: const Icon(Icons.add),
            tooltip: 'æ·»åŠ è¾…å•ä½?,
          ),
          IconButton(
            onPressed: widget.onTapChooseUnit,
            icon: const Icon(Icons.arrow_forward_ios),
            tooltip: 'é€‰æ‹©å•ä½',
          ),
        ],
    );
  }
}
import 'package:flutter/material.dart';

/// æ¡ç è¾“å…¥ + æ‰«ç æŒ‰é’®
class BarcodeSection extends StatefulWidget {
  final TextEditingController controller;
  final VoidCallback onScan;

  const BarcodeSection({
    super.key,
    required this.controller,
    required this.onScan,
  });

  @override
  State<BarcodeSection> createState() => _BarcodeSectionState();
}

class _BarcodeSectionState extends State<BarcodeSection> {
  late FocusNode _focusNode;
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    // åˆ›å»ºä¸€ä¸ªæ–°çš?FocusNode
    _focusNode = FocusNode();
    // æ·»åŠ ç›‘å¬å™?
    _focusNode.addListener(_onFocusChange);
  }

  @override
  void dispose() {
    // é‡Šæ”¾ FocusNode
    _focusNode.dispose();
    super.dispose();
  }

  void _onFocusChange() {
    setState(() {
      _isFocused = _focusNode.hasFocus;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // æ ‡ç­¾æ˜¾ç¤ºåœ¨å·¦è¾?
          SizedBox(
            width: 100,
            child: Padding(
              padding: const EdgeInsets.only(right: 12),
              child: Text(
                'æ¡ç ',
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
              ),
            ),
          ),
          Expanded(
            child: SizedBox(
              height: 48,
              child: TextFormField(
                controller: widget.controller,
                focusNode: _focusNode,
                decoration: InputDecoration(
                  hintText: _isFocused ? '' : 'å»ºè®®ä¼˜å…ˆæ‰«ç ',
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          SizedBox(
            height: 33,
            child: ElevatedButton.icon(
              onPressed: widget.onScan,
              icon: const Icon(Icons.qr_code_scanner, size: 20),
              label: const Text('æ‰«ç '),
              style: ElevatedButton.styleFrom(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(3),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 16),
              ),
            ),
          ),
        ],
    );
  }
}
import 'package:flutter/material.dart';
import '../product_image_picker.dart';
import '../inputs/app_text_field.dart';
import 'barcode_section.dart';

/// åŸºç¡€ä¿¡æ¯åŒºï¼šå›¾ç‰‡ã€åç§°ã€æ¡ç ?
class BasicInfoSection extends StatelessWidget {
  final String? initialImagePath;
  final ValueChanged<String?> onImageChanged;

  final TextEditingController nameController;
  final FocusNode nameFocusNode;
  final VoidCallback onNameSubmitted;

  final TextEditingController barcodeController;
  final VoidCallback onScan;

  const BasicInfoSection({
    super.key,
    required this.initialImagePath,
    required this.onImageChanged,
    required this.nameController,
    required this.nameFocusNode,
    required this.onNameSubmitted,
    required this.barcodeController,
    required this.onScan,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.only(left: 16.0),
                  child: ProductImagePicker(
                    initialImagePath: initialImagePath,
                    onImageChanged: onImageChanged,
                    size: 120,
                    enabled: true,
                  ),
                ),
              ],
            ),
            const SizedBox(width: 16),
          ],
        ),
        const SizedBox(height: 16),
        AppTextField(
          controller: nameController,
          label: 'åç§°',
          isRequired: true,
          focusNode: nameFocusNode,
          onFieldSubmitted: (_) => onNameSubmitted(),
        ),
        const SizedBox(height: 16),
        BarcodeSection(
          controller: barcodeController,
          onScan: onScan,
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';

/// ä»·æ ¼åŒºå—ï¼šé›¶å”®ä»· + ä¿ƒé”€ä»?+ å»ºè®®é›¶å”®ä»?
class PricingSection extends StatefulWidget {
  final TextEditingController retailPriceController;
  final TextEditingController promotionalPriceController;
  final TextEditingController suggestedRetailPriceController;
  final FocusNode? retailPriceFocusNode;
  final VoidCallback? onRetailPriceSubmitted;

  const PricingSection({
    super.key,
    required this.retailPriceController,
    required this.promotionalPriceController,
    required this.suggestedRetailPriceController,
    this.retailPriceFocusNode,
    this.onRetailPriceSubmitted,
  });

  @override
  State<PricingSection> createState() => _PricingSectionState();
}

class _PricingSectionState extends State<PricingSection> {
  late FocusNode _promotionalPriceFocusNode;
  late FocusNode _suggestedRetailPriceFocusNode;

  @override
  void initState() {
    super.initState();
    _promotionalPriceFocusNode = FocusNode();
    _suggestedRetailPriceFocusNode = FocusNode();
  }

  @override
  void dispose() {
    _promotionalPriceFocusNode.dispose();
    _suggestedRetailPriceFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildPriceField(
          label: 'ä¿ƒé”€ä»?,
          controller: widget.promotionalPriceController,
          focusNode: _promotionalPriceFocusNode,
        ),
        const SizedBox(height: 16),
        _buildPriceField(
          label: 'å»ºè®®é›¶å”®ä»?,
          controller: widget.suggestedRetailPriceController,
          focusNode: _suggestedRetailPriceFocusNode,
        ),
        const SizedBox(height: 16),
        _buildPriceField(
          label: 'é›¶å”®ä»?,
          controller: widget.retailPriceController,
          focusNode: widget.retailPriceFocusNode,
          onFieldSubmitted: (_) => widget.onRetailPriceSubmitted?.call(),
        ),
      ],
    );
  }

  Widget _buildPriceField({
    required String label,
    required TextEditingController controller,
    FocusNode? focusNode,
    void Function(String)? onFieldSubmitted,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Padding(
            padding: const EdgeInsets.only(right: 12),
            child: Text(
              label,
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
          ),
        ),
        Expanded(
          child: SizedBox(
            height: 48,
            child: TextFormField(
              controller: controller,
              focusNode: focusNode,
              keyboardType: TextInputType.number,
              onFieldSubmitted: onFieldSubmitted,
              decoration: const InputDecoration(
                prefixText: 'Â¥ ',
                contentPadding: EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 12,
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import '../inputs/shelf_life_unit_dropdown.dart';

/// ä¿è´¨æœŸè¡¨å•åŒºå?
/// - å·¦ä¾§ï¼šä¿è´¨æœŸæ•°å€¼è¾“å…?
/// - å³ä¾§ï¼šä¿è´¨æœŸå•ä½ä¸‹æ‹‰
class ShelfLifeSection extends StatefulWidget {
  final TextEditingController shelfLifeController;
  final FocusNode? shelfLifeFocusNode;
  final String shelfLifeUnit;
  final List<String> shelfLifeUnitOptions;
  final ValueChanged<String> onShelfLifeUnitChanged;
  final VoidCallback? onSubmitted;

  const ShelfLifeSection({
    super.key,
    required this.shelfLifeController,
    this.shelfLifeFocusNode,
    required this.shelfLifeUnit,
    required this.shelfLifeUnitOptions,
    required this.onShelfLifeUnitChanged,
    this.onSubmitted,
  });

  @override
  State<ShelfLifeSection> createState() => _ShelfLifeSectionState();
}

class _ShelfLifeSectionState extends State<ShelfLifeSection> {
  late FocusNode _focusNode;
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    // ä½¿ç”¨ä¼ å…¥çš?focusNode æˆ–åˆ›å»ºä¸€ä¸ªæ–°çš?
    _focusNode = widget.shelfLifeFocusNode ?? FocusNode();
    // æ·»åŠ ç›‘å¬å™?
    _focusNode.addListener(_onFocusChange);
  }

  @override
  void dispose() {
    // å¦‚æœæˆ‘ä»¬åˆ›å»ºäº†æ–°çš?FocusNodeï¼Œåˆ™éœ€è¦é‡Šæ”¾å®ƒ
    if (widget.shelfLifeFocusNode == null) {
      _focusNode.dispose();
    }
    super.dispose();
  }

  void _onFocusChange() {
    setState(() {
      _isFocused = _focusNode.hasFocus;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // æ ‡ç­¾æ˜¾ç¤ºåœ¨å·¦è¾?
          SizedBox(
            width: 100,
            child: Padding(
              padding: const EdgeInsets.only(right: 12),
              child: Text(
                'ä¿è´¨æœ?,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
          Expanded(
            child: SizedBox(
              height: 48,
              child: TextFormField(
                controller: widget.shelfLifeController,
                focusNode: _focusNode,
                keyboardType: TextInputType.number,
                onFieldSubmitted: (_) => widget.onSubmitted?.call(),
                decoration: InputDecoration(
                  hintText: _isFocused ? '' : '',
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          ShelfLifeUnitDropdown(
            value: widget.shelfLifeUnit,
            options: widget.shelfLifeUnitOptions,
            onChanged: widget.onShelfLifeUnitChanged,
          ),
        ],
    );
  }
}
import 'package:flutter/material.dart';
import '../../../domain/model/unit.dart';
import '../../../domain/model/category.dart';
import '../inputs/unit_typeahead_field.dart';
import '../inputs/category_typeahead_field.dart';

/// å•ä½ + ç±»åˆ«ç»„åˆåŒºåŸŸ
class UnitCategorySection extends StatelessWidget {
  final TextEditingController unitController;
  final FocusNode unitFocusNode;
  final List<Unit> units;
  final int? selectedUnitId;
  final ValueChanged<Unit> onUnitSelected;
  final VoidCallback onTapAddAuxiliary;
  final VoidCallback onTapChooseUnit;
  final String? Function() errorTextBuilder;
  final String? helperText;
  final VoidCallback onUnitClear;
  final VoidCallback onUnitSubmitted;

  final TextEditingController categoryController;
  final FocusNode categoryFocusNode;
  final List<CategoryModel> categories;
  final int? selectedCategoryId;
  final ValueChanged<CategoryModel> onCategorySelected;
  final VoidCallback onTapChooseCategory;
  final VoidCallback onCategoryClear;
  final VoidCallback onCategorySubmitted;

  const UnitCategorySection({
    super.key,
    required this.unitController,
    required this.unitFocusNode,
    required this.units,
    required this.selectedUnitId,
    required this.onUnitSelected,
    required this.onTapAddAuxiliary,
    required this.onTapChooseUnit,
    required this.errorTextBuilder,
    required this.helperText,
    required this.onUnitClear,
    required this.onUnitSubmitted,
    required this.categoryController,
    required this.categoryFocusNode,
    required this.categories,
    required this.selectedCategoryId,
    required this.onCategorySelected,
    required this.onTapChooseCategory,
    required this.onCategoryClear,
    required this.onCategorySubmitted,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        UnitTypeAheadField(
          controller: unitController,
          focusNode: unitFocusNode,
          units: units,
          selectedUnitId: selectedUnitId,
          onSelected: onUnitSelected,
          onTapAddAuxiliary: onTapAddAuxiliary,
          onTapChooseUnit: onTapChooseUnit,
          errorTextBuilder: errorTextBuilder,
          helperText: helperText,
          onClear: onUnitClear,
          onSubmitted: onUnitSubmitted,
        ),
        const SizedBox(height: 16),
        CategoryTypeAheadField(
          controller: categoryController,
          focusNode: categoryFocusNode,
          categories: categories,
          selectedCategoryId: selectedCategoryId,
          onSelected: onCategorySelected,
          onTapChooseCategory: onTapChooseCategory,
          onClear: onCategoryClear,
          onSubmitted: onCategorySubmitted,
        ),
      ],
    );
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/model/supplier.dart';
import '../../domain/repository/i_supplier_repository.dart';
import '../../data/repository/supplier_repository.dart';
import '../../../../core/database/database.dart';

/// ä¾›åº”å•†æ“ä½œçŠ¶æ€?
enum SupplierOperationStatus { initial, loading, success, error }

/// ä¾›åº”å•†æ§åˆ¶å™¨çŠ¶æ€?
class SupplierControllerState {
  final SupplierOperationStatus status;
  final String? errorMessage;
  final Supplier? lastOperatedSupplier;

  const SupplierControllerState({
    this.status = SupplierOperationStatus.initial,
    this.errorMessage,
    this.lastOperatedSupplier,
  });

  SupplierControllerState copyWith({
    SupplierOperationStatus? status,
    String? errorMessage,
    Supplier? lastOperatedSupplier,
  }) {
    return SupplierControllerState(
      status: status ?? this.status,
      errorMessage: errorMessage,
      lastOperatedSupplier: lastOperatedSupplier ?? this.lastOperatedSupplier,
    );
  }

  bool get isLoading => status == SupplierOperationStatus.loading;
  bool get isError => status == SupplierOperationStatus.error;
  bool get isSuccess => status == SupplierOperationStatus.success;
}

/// ä¾›åº”å•†æ§åˆ¶å™¨ - ç®¡ç†ä¾›åº”å•†çš„å¢åˆ æ”¹æ“ä½?
class SupplierController extends StateNotifier<SupplierControllerState> {
  final ISupplierRepository _repository;

  SupplierController(this._repository) : super(const SupplierControllerState());

  /// æ·»åŠ ä¾›åº”å•?
  Future<void> addSupplier(Supplier supplier) async {
    state = state.copyWith(status: SupplierOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹æ·»åŠ ä¾›åº”å•† - ${supplier.name}');

      // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨
      final exists = await _repository.isSupplierNameExists(supplier.name);
      if (exists) {
        throw Exception('ä¾›åº”å•†åç§°å·²å­˜åœ¨');
      }

      await _repository.addSupplier(supplier);

      state = state.copyWith(
        status: SupplierOperationStatus.success,
        lastOperatedSupplier: supplier,
      );

      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†æ·»åŠ æˆåŠ?);
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†æ·»åŠ å¤±è´? $e');
      state = state.copyWith(
        status: SupplierOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// æ›´æ–°ä¾›åº”å•?
  Future<void> updateSupplier(Supplier supplier) async {
    state = state.copyWith(status: SupplierOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹æ›´æ–°ä¾›åº”å•† - ${supplier.name}');

      // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨ï¼ˆæ’é™¤å½“å‰ä¾›åº”å•†ï¼?
      final exists = await _repository.isSupplierNameExists(
        supplier.name,
        supplier.id,
      );
      if (exists) {
        throw Exception('ä¾›åº”å•†åç§°å·²å­˜åœ¨');
      }

      final success = await _repository.updateSupplier(supplier);
      if (!success) {
        throw Exception('æ›´æ–°ä¾›åº”å•†å¤±è´?);
      }

      state = state.copyWith(
        status: SupplierOperationStatus.success,
        lastOperatedSupplier: supplier,
      );

      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†æ›´æ–°æˆåŠ?);
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†æ›´æ–°å¤±è´? $e');
      state = state.copyWith(
        status: SupplierOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// åˆ é™¤ä¾›åº”å•?
  Future<void> deleteSupplier(int id) async {
    state = state.copyWith(status: SupplierOperationStatus.loading);

    try {
      print('ğŸ® æ§åˆ¶å™¨ï¼šå¼€å§‹åˆ é™¤ä¾›åº”å•† - $id');

      final deletedCount = await _repository.deleteSupplier(id);
      if (deletedCount == 0) {
        throw Exception('åˆ é™¤ä¾›åº”å•†å¤±è´¥ï¼Œæœªæ‰¾åˆ°æŒ‡å®šä¾›åº”å•†');
      }

      state = state.copyWith(status: SupplierOperationStatus.success);

      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†åˆ é™¤æˆåŠ?);
    } catch (e) {
      print('ğŸ® æ§åˆ¶å™¨ï¼šä¾›åº”å•†åˆ é™¤å¤±è´? $e');
      state = state.copyWith(
        status: SupplierOperationStatus.error,
        errorMessage: e.toString(),
      );
      rethrow;
    }
  }

  /// é‡ç½®çŠ¶æ€?
  void resetState() {
    state = const SupplierControllerState();
  }
}

// =============================================================================
// Riverpod æä¾›è€…å®šä¹?
// =============================================================================

/// ä¾›åº”å•†ä»“å‚¨æä¾›è€?
final supplierRepositoryProvider = Provider<ISupplierRepository>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return SupplierRepository(database);
});

/// ä¾›åº”å•†æ§åˆ¶å™¨æä¾›è€?
final supplierControllerProvider =
    StateNotifierProvider<SupplierController, SupplierControllerState>((ref) {
      final repository = ref.watch(supplierRepositoryProvider);
      return SupplierController(repository);
    });

/// è·å–æ‰€æœ‰ä¾›åº”å•†æä¾›è€?
final allSuppliersProvider = StreamProvider<List<Supplier>>((ref) {
  final repository = ref.watch(supplierRepositoryProvider);
  return repository.watchAllSuppliers();
});

/// æ ¹æ®IDè·å–ä¾›åº”å•†æä¾›è€?
final supplierByIdProvider = FutureProvider.family<Supplier?, int>((
  ref,
  id,
) {
  final repository = ref.watch(supplierRepositoryProvider);
  return repository.getSupplierById(id);
});

/// æ ¹æ®åç§°æœç´¢ä¾›åº”å•†æä¾›è€?
final searchSuppliersProvider = FutureProvider.family<List<Supplier>, String>((
  ref,
  searchTerm,
) {
  final repository = ref.watch(supplierRepositoryProvider);
  if (searchTerm.isEmpty) {
    return repository.getAllSuppliers();
  }
  return repository.searchSuppliersByName(searchTerm);
});

/// ä¾›åº”å•†æ•°é‡æä¾›è€?
final supplierCountProvider = FutureProvider<int>((ref) {
  final repository = ref.watch(supplierRepositoryProvider);
  return repository.getSupplierCount();
});

/// æ£€æŸ¥ä¾›åº”å•†åç§°æ˜¯å¦å­˜åœ¨æä¾›è€?
final supplierNameExistsProvider =
    FutureProvider.family<bool, Map<String, String?>>((ref, params) {
      final repository = ref.watch(supplierRepositoryProvider);
      final name = params['name']!;
      final excludeIdString = params['excludeId'];
      final excludeId = excludeIdString == null || excludeIdString.isEmpty
          ? null
          : int.tryParse(excludeIdString);
      return repository.isSupplierNameExists(name, excludeId);
    });
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/purchase_orders_table.dart';
import '../../../../core/database/purchase_order_items_table.dart';
import '../../../../core/database/products_table.dart';
import 'package:rxdart/rxdart.dart';

part 'purchase_dao.g.dart';

/// é‡‡è´­è®¢å•åŠå…¶æ‰€æœ‰æ˜ç»†çš„æ•°æ®ç±?
class PurchaseOrderWithItems {
  final PurchaseOrderData order;
  final List<PurchaseOrderItemWithDetails> items;

  PurchaseOrderWithItems({required this.order, required this.items});
}

/// é‡‡è´­è®¢å•æ˜ç»†åŠå…¶å…³è”äº§å“ä¿¡æ¯çš„æ•°æ®ç±»
class PurchaseOrderItemWithDetails {
  final PurchaseOrderItemData item;
  final ProductData product;

  PurchaseOrderItemWithDetails({required this.item, required this.product});
}

/// é‡‡è´­è®¢å•æ•°æ®è®¿é—®å¯¹è±¡ (DAO)
@DriftAccessor(
  tables: [PurchaseOrder, PurchaseOrderItem, Product],
)
class PurchaseDao extends DatabaseAccessor<AppDatabase>
    with _$PurchaseDaoMixin {
  PurchaseDao(super.db);

  // ===========================================================================
  // é‡‡è´­è®¢å• (Purchase Order) æ“ä½œ
  // ===========================================================================

  /// åˆ›å»ºä¸€ä¸ªæ–°çš„é‡‡è´­è®¢å•ï¼Œå¹¶è¿”å›å…¶è‡ªå¢ID
  Future<int> createPurchaseOrder(PurchaseOrderCompanion companion) {
    return into(db.purchaseOrder).insert(companion);
  }

  /// æ ¹æ®IDè·å–å•ä¸ªé‡‡è´­è®¢å•
  Future<PurchaseOrderData?> getPurchaseOrderById(int orderId) {
    return (select(
      db.purchaseOrder,
    )..where((tbl) => tbl.id.equals(orderId))).getSingleOrNull();
  }

  /// ç›‘å¬æ‰€æœ‰é‡‡è´­è®¢å•çš„å˜åŒ–
  Stream<List<PurchaseOrderData>> watchAllPurchaseOrders() {
    return select(db.purchaseOrder).watch();
  }

  /// åˆ é™¤ä¸€ä¸ªé‡‡è´­è®¢å•ï¼ˆéœ€è¦å…ˆåˆ é™¤å…¶æ‰€æœ‰æ˜ç»†ï¼‰
  Future<int> deletePurchaseOrder(int orderId) async {
    return transaction(() async {
      // 1. åˆ é™¤æ‰€æœ‰å…³è”çš„æ˜ç»†
      await (delete(
        db.purchaseOrderItem,
      )..where((tbl) => tbl.purchaseOrderId.equals(orderId))).go();
      // 2. åˆ é™¤è®¢å•æœ¬èº«
      return (delete(
        db.purchaseOrder,
      )..where((tbl) => tbl.id.equals(orderId))).go();
    });
  }

  // ===========================================================================
  // é‡‡è´­è®¢å•æ˜ç»† (Purchase Order Item) æ“ä½œ
  // ===========================================================================

  /// ä¸ºæŒ‡å®šçš„é‡‡è´­è®¢å•æ‰¹é‡æ·»åŠ æ˜ç»†
  Future<void> addPurchaseOrderItems(
    List<PurchaseOrderItemCompanion> companions,
  ) {
    return batch((batch) {
      batch.insertAll(db.purchaseOrderItem, companions);
    });
  }

  /// è·å–æŒ‡å®šé‡‡è´­è®¢å•çš„æ‰€æœ‰æ˜ç»?
  Future<List<PurchaseOrderItemData>> getPurchaseOrderItems(int orderId) {
    return (select(
      db.purchaseOrderItem,
    )..where((tbl) => tbl.purchaseOrderId.equals(orderId))).get();
  }

  // ===========================================================================
  // ç»„åˆæŸ¥è¯¢å’Œäº‹åŠ¡æ€§æ“ä½?
  // ===========================================================================

  /// ç›‘å¬ä¸€ä¸ªå®Œæ•´çš„é‡‡è´­è®¢å•ï¼ˆåŒ…å«å…¶æ‰€æœ‰æ˜ç»†åŠäº§å“ä¿¡æ¯ï¼?
  Stream<PurchaseOrderWithItems> watchPurchaseOrderWithItems(int orderId) {
    final orderStream = (select(
      db.purchaseOrder,
    )..where((tbl) => tbl.id.equals(orderId))).watchSingle();

    final itemsStream =
        (select(
          db.purchaseOrderItem,
        )..where((tbl) => tbl.purchaseOrderId.equals(orderId))).join([
          innerJoin(
            db.product,
            db.product.id.equalsExp(db.purchaseOrderItem.productId),
          ),
        ]).watch();

    return orderStream.switchMap((order) {
      return itemsStream.map((rows) {
        final detailedItems = rows.map((row) {
          return PurchaseOrderItemWithDetails(
            item: row.readTable(db.purchaseOrderItem),
            product: row.readTable(db.product),
          );
        }).toList();
        return PurchaseOrderWithItems(order: order, items: detailedItems);
      });
    });
  }

  /// åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„é‡‡è´­è®¢å•ï¼ˆåŒ…æ‹¬è®¢å•å¤´å’Œå¤šä¸ªæ˜ç»†é¡¹ï¼?
  /// è¿™æ˜¯ä¸€ä¸ªäº‹åŠ¡æ€§æ“ä½œï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€?
  Future<int> createFullPurchaseOrder({
    required PurchaseOrderCompanion order,
    required List<PurchaseOrderItemCompanion> items,
  }) {
    return transaction(() async {
      // 1. æ’å…¥è®¢å•å¤´ï¼Œè·å–æ–°è®¢å•çš„ID
      final orderId = await into(db.purchaseOrder).insert(order);

      // 2. ä¸ºæ¯ä¸ªæ˜ç»†é¡¹è®¾ç½®å¤–é”® (purchaseOrderId)
      final itemsWithOrderId = items.map((item) {
        return item.copyWith(purchaseOrderId: Value(orderId));
      }).toList();

      // 3. æ‰¹é‡æ’å…¥æ‰€æœ‰æ˜ç»†é¡¹
      await batch((batch) {
        batch.insertAll(db.purchaseOrderItem, itemsWithOrderId);
      });

      return orderId;
    });
  }

  // ===========================================================================
  // å·¥å…·æ–¹æ³•
  // ===========================================================================

  /// æ ¹æ®äº§å“IDè·å–æœ€è¿‘ä¸€æ¬¡çš„é‡‡è´­å•ä»·
  Future<int?> getLatestPurchasePrice(int productId) async {
    final query = select(db.purchaseOrderItem)
      ..where((tbl) => tbl.productId.equals(productId))
      ..orderBy([(t) => OrderingTerm.desc(t.id)])
      ..limit(1);

    final result = await query.getSingleOrNull();
    return result?.unitPriceInCents;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'purchase_dao.dart';

// ignore_for_file: type=lint
mixin _$PurchaseDaoMixin on DatabaseAccessor<AppDatabase> {
  $SupplierTable get supplier => attachedDatabase.supplier;
  $ShopTable get shop => attachedDatabase.shop;
  $PurchaseOrderTable get purchaseOrder => attachedDatabase.purchaseOrder;
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $PurchaseOrderItemTable get purchaseOrderItem =>
      attachedDatabase.purchaseOrderItem;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/suppliers_table.dart';

part 'supplier_dao.g.dart';

/// ä¾›åº”å•†æ•°æ®è®¿é—®å¯¹è±?(DAO)
/// ä¸“é—¨è´Ÿè´£ä¾›åº”å•†ç›¸å…³çš„æ•°æ®åº“æ“ä½?
@DriftAccessor(tables: [Supplier])
class SupplierDao extends DatabaseAccessor<AppDatabase>
    with _$SupplierDaoMixin {
  SupplierDao(super.db);

  /// æ·»åŠ ä¾›åº”å•?
  Future<int> insertSupplier(SupplierCompanion companion) async {
    return await into(db.supplier).insert(companion);
  }

  /// æ ¹æ®IDè·å–ä¾›åº”å•?
  Future<SupplierData?> getSupplierById(int id) async {
    return await (select(
      db.supplier,
    )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// æ ¹æ®åç§°è·å–ä¾›åº”å•?
  Future<SupplierData?> getSupplierByName(String name) async {
    return await (select(
      db.supplier,
    )..where((tbl) => tbl.name.equals(name))).getSingleOrNull();
  }

  /// è·å–æ‰€æœ‰ä¾›åº”å•†
  Future<List<SupplierData>> getAllSuppliers() async {
    return await select(db.supplier).get();
  }

  /// ç›‘å¬æ‰€æœ‰ä¾›åº”å•†å˜åŒ–
  Stream<List<SupplierData>> watchAllSuppliers() {
    return select(db.supplier).watch();
  }

  /// æ›´æ–°ä¾›åº”å•?
  Future<bool> updateSupplier(SupplierCompanion companion) async {
    final rowsAffected = await (update(
      db.supplier,
    )..where((tbl) => tbl.id.equals(companion.id.value))).write(companion);
    return rowsAffected > 0;
  }

  /// åˆ é™¤ä¾›åº”å•?
  Future<bool> deleteSupplier(int id) async {
    final rowsAffected = await (delete(
      db.supplier,
    )..where((tbl) => tbl.id.equals(id))).go();
    return rowsAffected > 0;
  }

  /// æ ¹æ®åç§°æœç´¢ä¾›åº”å•?
  Future<List<SupplierData>> searchSuppliersByName(
    String searchTerm,
  ) async {
    return await (select(
      db.supplier,
    )..where((tbl) => tbl.name.like('%$searchTerm%'))).get();
  }

  /// æ£€æŸ¥ä¾›åº”å•†æ˜¯å¦å­˜åœ¨
  Future<bool> supplierExists(String name) async {
    final result =
        await (selectOnly(db.supplier)
              ..addColumns([db.supplier.id])
              ..where(db.supplier.name.equals(name)))
            .getSingleOrNull();
    return result != null;
  }

  /// è·å–ä¾›åº”å•†æ•°é‡?
  Future<int> getSupplierCount() async {
    final countQuery = selectOnly(db.supplier)
      ..addColumns([db.supplier.id.count()]);
    final result = await countQuery.getSingle();
    return result.read(db.supplier.id.count()) ?? 0;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'supplier_dao.dart';

// ignore_for_file: type=lint
mixin _$SupplierDaoMixin on DatabaseAccessor<AppDatabase> {
  $SupplierTable get supplier => attachedDatabase.supplier;
}
import '../../domain/repository/i_supplier_repository.dart';
import '../../domain/model/supplier.dart';
import '../../../../core/database/database.dart';
import '../dao/supplier_dao.dart';
import 'package:drift/drift.dart';

/// ä¾›åº”å•†ä»“å‚¨å®ç°ç±»
/// åŸºäºæœ¬åœ°æ•°æ®åº“çš„ä¾›åº”å•†æ•°æ®è®¿é—®å±‚å®ç°
class SupplierRepository implements ISupplierRepository {
  final SupplierDao _supplierDao;

  SupplierRepository(AppDatabase database)
    : _supplierDao = database.supplierDao;

  @override
  Future<int> addSupplier(Supplier supplier) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ ä¾›åº”å•†ï¼ŒID: ${supplier.id}, åç§°: ${supplier.name}');
      return await _supplierDao.insertSupplier(_supplierToCompanion(supplier));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ·»åŠ ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<Supplier?> getSupplierById(int id) async {
    try {
      final data = await _supplierDao.getSupplierById(id);
      return data != null ? _supplierDataToModel(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®IDè·å–ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<Supplier?> getSupplierByName(String name) async {
    try {
      final data = await _supplierDao.getSupplierByName(name);
      return data != null ? _supplierDataToModel(data) : null;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®åç§°è·å–ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<List<Supplier>> getAllSuppliers() async {
    try {
      final dataList = await _supplierDao.getAllSuppliers();
      return dataList.map(_supplierDataToModel).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–æ‰€æœ‰ä¾›åº”å•†å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Stream<List<Supplier>> watchAllSuppliers() {
    try {
      return _supplierDao.watchAllSuppliers().map(
        (dataList) => dataList.map(_supplierDataToModel).toList(),
      );
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šç›‘å¬æ‰€æœ‰ä¾›åº”å•†å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<bool> updateSupplier(Supplier supplier) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°ä¾›åº”å•†ï¼ŒID: ${supplier.id}, åç§°: ${supplier.name}');
      return await _supplierDao.updateSupplier(_supplierToCompanion(supplier));
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ›´æ–°ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<int> deleteSupplier(int id) async {
    try {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤ä¾›åº”å•†ï¼ŒID: $id');
      final success = await _supplierDao.deleteSupplier(id);
      return success ? 1 : 0;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šåˆ é™¤ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<bool> isSupplierNameExists(String name, [int? excludeId]) async {
    try {
      final supplier = await _supplierDao.getSupplierByName(name);
      if (supplier == null) return false;
      if (excludeId != null && supplier.id == excludeId) return false;
      return true;
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ£€æŸ¥ä¾›åº”å•†åç§°æ˜¯å¦å­˜åœ¨å¤±è´¥: $e');
      rethrow;
    }
  }

  @override
  Future<List<Supplier>> searchSuppliersByName(String searchTerm) async {
    try {
      final dataList = await _supplierDao.searchSuppliersByName(searchTerm);
      return dataList.map(_supplierDataToModel).toList();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šæ ¹æ®åç§°æœç´¢ä¾›åº”å•†å¤±è´? $e');
      rethrow;
    }
  }

  @override
  Future<int> getSupplierCount() async {
    try {
      return await _supplierDao.getSupplierCount();
    } catch (e) {
      print('ğŸ—ƒï¸?ä»“å‚¨å±‚ï¼šè·å–ä¾›åº”å•†æ•°é‡å¤±è´? $e');
      rethrow;
    }
  }

  /// å°†é¢†åŸŸæ¨¡å‹è½¬æ¢ä¸ºæ•°æ®åº“Companionå¯¹è±¡
  SupplierCompanion _supplierToCompanion(Supplier supplier) {
    return SupplierCompanion(
      id: supplier.id == null ? const Value.absent() : Value(supplier.id!),
      name: Value(supplier.name),
      updatedAt: Value(DateTime.now()),
    );
  }

  /// å°†æ•°æ®åº“Dataå¯¹è±¡è½¬æ¢ä¸ºé¢†åŸŸæ¨¡å?
  Supplier _supplierDataToModel(SupplierData data) {
    return Supplier(id: data.id, name: data.name);
  }
}
import 'package:drift/drift.dart' hide JsonKey;
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:stocko_app/core/database/database.dart';
import 'package:stocko_app/core/database/purchase_orders_table.dart';
import 'purchase_order_item.dart';
part 'purchase_order.freezed.dart';
part 'purchase_order.g.dart';

@freezed
abstract class PurchaseOrderModel with _$PurchaseOrderModel {
  const factory PurchaseOrderModel({
    int? id,
    required int supplierId,
    required int shopId,
    @Default(PurchaseOrderStatus.preset) PurchaseOrderStatus status,
    @Default(<PurchaseOrderItemModel>[]) List<PurchaseOrderItemModel> items,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _PurchaseOrderModel;

  const PurchaseOrderModel._();

  PurchaseOrderCompanion toTableCompanion() {
    return PurchaseOrderCompanion(
      id: id == null ? const Value.absent() : Value(id!),
      supplierId: Value(supplierId),
      shopId: Value(shopId),
      status: Value(status),
      // createdAt/updatedAt ç”±æ•°æ®åº“é»˜è®¤å€¼ç»´æŠ¤ï¼Œé™¤éå¤–éƒ¨æŒ‡å®š
      createdAt: createdAt == null ? const Value.absent() : Value(createdAt!),
      updatedAt: updatedAt == null ? const Value.absent() : Value(updatedAt!),
    );
  }

  factory PurchaseOrderModel.fromJson(Map<String, dynamic> json) =>
      _$PurchaseOrderModelFromJson(json);

  factory PurchaseOrderModel.fromTableData(
    PurchaseOrderData data, {
    List<PurchaseOrderItemModel> items = const [],
  }) {
    return PurchaseOrderModel(
      id: data.id,
      supplierId: data.supplierId,
      shopId: data.shopId,
      status: data.status,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
      items: items,
    );
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'purchase_order.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PurchaseOrderModel {

 int? get id; int get supplierId; int get shopId; PurchaseOrderStatus get status; List<PurchaseOrderItemModel> get items; DateTime? get createdAt; DateTime? get updatedAt;
/// Create a copy of PurchaseOrderModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PurchaseOrderModelCopyWith<PurchaseOrderModel> get copyWith => _$PurchaseOrderModelCopyWithImpl<PurchaseOrderModel>(this as PurchaseOrderModel, _$identity);

  /// Serializes this PurchaseOrderModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PurchaseOrderModel&&(identical(other.id, id) || other.id == id)&&(identical(other.supplierId, supplierId) || other.supplierId == supplierId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,supplierId,shopId,status,const DeepCollectionEquality().hash(items),createdAt,updatedAt);

@override
String toString() {
  return 'PurchaseOrderModel(id: $id, supplierId: $supplierId, shopId: $shopId, status: $status, items: $items, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class $PurchaseOrderModelCopyWith<$Res>  {
  factory $PurchaseOrderModelCopyWith(PurchaseOrderModel value, $Res Function(PurchaseOrderModel) _then) = _$PurchaseOrderModelCopyWithImpl;
@useResult
$Res call({
 int? id, int supplierId, int shopId, PurchaseOrderStatus status, List<PurchaseOrderItemModel> items, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class _$PurchaseOrderModelCopyWithImpl<$Res>
    implements $PurchaseOrderModelCopyWith<$Res> {
  _$PurchaseOrderModelCopyWithImpl(this._self, this._then);

  final PurchaseOrderModel _self;
  final $Res Function(PurchaseOrderModel) _then;

/// Create a copy of PurchaseOrderModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? supplierId = null,Object? shopId = null,Object? status = null,Object? items = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,supplierId: null == supplierId ? _self.supplierId : supplierId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as PurchaseOrderStatus,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<PurchaseOrderItemModel>,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _PurchaseOrderModel extends PurchaseOrderModel {
  const _PurchaseOrderModel({this.id, required this.supplierId, required this.shopId, this.status = PurchaseOrderStatus.preset, final  List<PurchaseOrderItemModel> items = const <PurchaseOrderItemModel>[], this.createdAt, this.updatedAt}): _items = items,super._();
  factory _PurchaseOrderModel.fromJson(Map<String, dynamic> json) => _$PurchaseOrderModelFromJson(json);

@override final  int? id;
@override final  int supplierId;
@override final  int shopId;
@override@JsonKey() final  PurchaseOrderStatus status;
 final  List<PurchaseOrderItemModel> _items;
@override@JsonKey() List<PurchaseOrderItemModel> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  DateTime? createdAt;
@override final  DateTime? updatedAt;

/// Create a copy of PurchaseOrderModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PurchaseOrderModelCopyWith<_PurchaseOrderModel> get copyWith => __$PurchaseOrderModelCopyWithImpl<_PurchaseOrderModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PurchaseOrderModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PurchaseOrderModel&&(identical(other.id, id) || other.id == id)&&(identical(other.supplierId, supplierId) || other.supplierId == supplierId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,supplierId,shopId,status,const DeepCollectionEquality().hash(_items),createdAt,updatedAt);

@override
String toString() {
  return 'PurchaseOrderModel(id: $id, supplierId: $supplierId, shopId: $shopId, status: $status, items: $items, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class _$PurchaseOrderModelCopyWith<$Res> implements $PurchaseOrderModelCopyWith<$Res> {
  factory _$PurchaseOrderModelCopyWith(_PurchaseOrderModel value, $Res Function(_PurchaseOrderModel) _then) = __$PurchaseOrderModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int supplierId, int shopId, PurchaseOrderStatus status, List<PurchaseOrderItemModel> items, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class __$PurchaseOrderModelCopyWithImpl<$Res>
    implements _$PurchaseOrderModelCopyWith<$Res> {
  __$PurchaseOrderModelCopyWithImpl(this._self, this._then);

  final _PurchaseOrderModel _self;
  final $Res Function(_PurchaseOrderModel) _then;

/// Create a copy of PurchaseOrderModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? supplierId = null,Object? shopId = null,Object? status = null,Object? items = null,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_PurchaseOrderModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,supplierId: null == supplierId ? _self.supplierId : supplierId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as PurchaseOrderStatus,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<PurchaseOrderItemModel>,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'purchase_order.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PurchaseOrderModel _$PurchaseOrderModelFromJson(Map<String, dynamic> json) =>
    _PurchaseOrderModel(
      id: (json['id'] as num?)?.toInt(),
      supplierId: (json['supplierId'] as num).toInt(),
      shopId: (json['shopId'] as num).toInt(),
      status:
          $enumDecodeNullable(_$PurchaseOrderStatusEnumMap, json['status']) ??
          PurchaseOrderStatus.preset,
      items:
          (json['items'] as List<dynamic>?)
              ?.map(
                (e) =>
                    PurchaseOrderItemModel.fromJson(e as Map<String, dynamic>),
              )
              .toList() ??
          const <PurchaseOrderItemModel>[],
      createdAt: json['createdAt'] == null
          ? null
          : DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$PurchaseOrderModelToJson(_PurchaseOrderModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'supplierId': instance.supplierId,
      'shopId': instance.shopId,
      'status': _$PurchaseOrderStatusEnumMap[instance.status]!,
      'items': instance.items,
      'createdAt': instance.createdAt?.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
    };

const _$PurchaseOrderStatusEnumMap = {
  PurchaseOrderStatus.preset: 'preset',
  PurchaseOrderStatus.draft: 'draft',
  PurchaseOrderStatus.completed: 'completed',
};
import 'package:drift/drift.dart' hide JsonKey;
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:stocko_app/core/database/database.dart';

part 'purchase_order_item.freezed.dart';
part 'purchase_order_item.g.dart';

@freezed
abstract class PurchaseOrderItemModel with _$PurchaseOrderItemModel {
  const factory PurchaseOrderItemModel({
    int? id,
    required int purchaseOrderId,
    required int productId,
    required int unitPriceInCents,
    required int quantity,
    DateTime? productionDate,
  }) = _PurchaseOrderItemModel;

  const PurchaseOrderItemModel._();

  // --- ç®€å•æ ¡éª?---
  bool get isValidOrderId => purchaseOrderId > 0;
  bool get isValidProductId => productId > 0;
  bool get isValidQuantity => quantity > 0;
  bool get isValidUnitPrice => unitPriceInCents >= 0; // å•ä»·å…è®¸0ï¼ˆèµ å“åœºæ™¯ï¼‰

  bool get isValid =>
      isValidOrderId &&
      isValidProductId &&
      isValidQuantity &&
      isValidUnitPrice;

  List<String> get validationErrors {
    final errors = <String>[];
    if (!isValidOrderId) errors.add('é‡‡è´­è®¢å•IDå¿…é¡»å¤§äº0');
    if (!isValidProductId) errors.add('äº§å“IDå¿…é¡»å¤§äº0');
    if (!isValidQuantity) errors.add('æ•°é‡å¿…é¡»å¤§äº0');
    if (!isValidUnitPrice) errors.add('å•ä»·ä¸èƒ½ä¸ºè´Ÿæ•?);
    return errors;
  }

  /// è½¬ä¸º Drift Companionï¼ˆæ’å…?æ›´æ–°ç”¨ï¼‰
  /// åœ¨åˆ›å»ºæ•´å•æ—¶é€šå¸¸å…ˆæ‹¿åˆ?orderIdï¼Œå†ä¼ å…¥æ­¤æ–¹æ³•ç»Ÿä¸€è®¾ç½®å¤–é”®
  PurchaseOrderItemCompanion toTableCompanion(int orderId) {
    return PurchaseOrderItemCompanion(
      id: id == null ? const Value.absent() : Value(id!),
      purchaseOrderId: Value(orderId),
      productId: Value(productId),
      unitPriceInCents: Value(unitPriceInCents),
      quantity: Value(quantity),
      productionDate:
          productionDate != null ? Value(productionDate) : const Value.absent(),
    );
  }

  factory PurchaseOrderItemModel.fromJson(Map<String, dynamic> json) =>
      _$PurchaseOrderItemModelFromJson(json);

  factory PurchaseOrderItemModel.fromTableData(
    PurchaseOrderItemData data,
  ) {
    return PurchaseOrderItemModel(
      id: data.id,
      purchaseOrderId: data.purchaseOrderId,
      productId: data.productId,
      unitPriceInCents: data.unitPriceInCents,
      quantity: data.quantity,
      productionDate: data.productionDate,
    );
  }

  /// å·¥å‚æ–¹æ³•ï¼šå¸¦æ ¡éªŒåˆ›å»º
  static PurchaseOrderItemModel createWithValidation({
    int? id,
    required int purchaseOrderId,
    required int productId,
    required int unitPriceInCents,
    required int quantity,
    DateTime? productionDate,
  }) {
    final item = PurchaseOrderItemModel(
      id: id,
      purchaseOrderId: purchaseOrderId,
      productId: productId,
      unitPriceInCents: unitPriceInCents,
      quantity: quantity,
      productionDate: productionDate,
    );
    if (!item.isValid) {
      throw ArgumentError('æ•°æ®éªŒè¯å¤±è´¥: ${item.validationErrors.join(', ')}');
    }
    return item;
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'purchase_order_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PurchaseOrderItemModel {

 int? get id; int get purchaseOrderId; int get productId; int get unitPriceInCents; int get quantity; DateTime? get productionDate;
/// Create a copy of PurchaseOrderItemModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PurchaseOrderItemModelCopyWith<PurchaseOrderItemModel> get copyWith => _$PurchaseOrderItemModelCopyWithImpl<PurchaseOrderItemModel>(this as PurchaseOrderItemModel, _$identity);

  /// Serializes this PurchaseOrderItemModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PurchaseOrderItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.purchaseOrderId, purchaseOrderId) || other.purchaseOrderId == purchaseOrderId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.unitPriceInCents, unitPriceInCents) || other.unitPriceInCents == unitPriceInCents)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.productionDate, productionDate) || other.productionDate == productionDate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,purchaseOrderId,productId,unitPriceInCents,quantity,productionDate);

@override
String toString() {
  return 'PurchaseOrderItemModel(id: $id, purchaseOrderId: $purchaseOrderId, productId: $productId, unitPriceInCents: $unitPriceInCents, quantity: $quantity, productionDate: $productionDate)';
}


}

/// @nodoc
abstract mixin class $PurchaseOrderItemModelCopyWith<$Res>  {
  factory $PurchaseOrderItemModelCopyWith(PurchaseOrderItemModel value, $Res Function(PurchaseOrderItemModel) _then) = _$PurchaseOrderItemModelCopyWithImpl;
@useResult
$Res call({
 int? id, int purchaseOrderId, int productId, int unitPriceInCents, int quantity, DateTime? productionDate
});




}
/// @nodoc
class _$PurchaseOrderItemModelCopyWithImpl<$Res>
    implements $PurchaseOrderItemModelCopyWith<$Res> {
  _$PurchaseOrderItemModelCopyWithImpl(this._self, this._then);

  final PurchaseOrderItemModel _self;
  final $Res Function(PurchaseOrderItemModel) _then;

/// Create a copy of PurchaseOrderItemModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? purchaseOrderId = null,Object? productId = null,Object? unitPriceInCents = null,Object? quantity = null,Object? productionDate = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,purchaseOrderId: null == purchaseOrderId ? _self.purchaseOrderId : purchaseOrderId // ignore: cast_nullable_to_non_nullable
as int,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,unitPriceInCents: null == unitPriceInCents ? _self.unitPriceInCents : unitPriceInCents // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,productionDate: freezed == productionDate ? _self.productionDate : productionDate // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _PurchaseOrderItemModel extends PurchaseOrderItemModel {
  const _PurchaseOrderItemModel({this.id, required this.purchaseOrderId, required this.productId, required this.unitPriceInCents, required this.quantity, this.productionDate}): super._();
  factory _PurchaseOrderItemModel.fromJson(Map<String, dynamic> json) => _$PurchaseOrderItemModelFromJson(json);

@override final  int? id;
@override final  int purchaseOrderId;
@override final  int productId;
@override final  int unitPriceInCents;
@override final  int quantity;
@override final  DateTime? productionDate;

/// Create a copy of PurchaseOrderItemModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PurchaseOrderItemModelCopyWith<_PurchaseOrderItemModel> get copyWith => __$PurchaseOrderItemModelCopyWithImpl<_PurchaseOrderItemModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PurchaseOrderItemModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PurchaseOrderItemModel&&(identical(other.id, id) || other.id == id)&&(identical(other.purchaseOrderId, purchaseOrderId) || other.purchaseOrderId == purchaseOrderId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.unitPriceInCents, unitPriceInCents) || other.unitPriceInCents == unitPriceInCents)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.productionDate, productionDate) || other.productionDate == productionDate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,purchaseOrderId,productId,unitPriceInCents,quantity,productionDate);

@override
String toString() {
  return 'PurchaseOrderItemModel(id: $id, purchaseOrderId: $purchaseOrderId, productId: $productId, unitPriceInCents: $unitPriceInCents, quantity: $quantity, productionDate: $productionDate)';
}


}

/// @nodoc
abstract mixin class _$PurchaseOrderItemModelCopyWith<$Res> implements $PurchaseOrderItemModelCopyWith<$Res> {
  factory _$PurchaseOrderItemModelCopyWith(_PurchaseOrderItemModel value, $Res Function(_PurchaseOrderItemModel) _then) = __$PurchaseOrderItemModelCopyWithImpl;
@override @useResult
$Res call({
 int? id, int purchaseOrderId, int productId, int unitPriceInCents, int quantity, DateTime? productionDate
});




}
/// @nodoc
class __$PurchaseOrderItemModelCopyWithImpl<$Res>
    implements _$PurchaseOrderItemModelCopyWith<$Res> {
  __$PurchaseOrderItemModelCopyWithImpl(this._self, this._then);

  final _PurchaseOrderItemModel _self;
  final $Res Function(_PurchaseOrderItemModel) _then;

/// Create a copy of PurchaseOrderItemModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? purchaseOrderId = null,Object? productId = null,Object? unitPriceInCents = null,Object? quantity = null,Object? productionDate = freezed,}) {
  return _then(_PurchaseOrderItemModel(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,purchaseOrderId: null == purchaseOrderId ? _self.purchaseOrderId : purchaseOrderId // ignore: cast_nullable_to_non_nullable
as int,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,unitPriceInCents: null == unitPriceInCents ? _self.unitPriceInCents : unitPriceInCents // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,productionDate: freezed == productionDate ? _self.productionDate : productionDate // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'purchase_order_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PurchaseOrderItemModel _$PurchaseOrderItemModelFromJson(
  Map<String, dynamic> json,
) => _PurchaseOrderItemModel(
  id: (json['id'] as num?)?.toInt(),
  purchaseOrderId: (json['purchaseOrderId'] as num).toInt(),
  productId: (json['productId'] as num).toInt(),
  unitPriceInCents: (json['unitPriceInCents'] as num).toInt(),
  quantity: (json['quantity'] as num).toInt(),
  productionDate: json['productionDate'] == null
      ? null
      : DateTime.parse(json['productionDate'] as String),
);

Map<String, dynamic> _$PurchaseOrderItemModelToJson(
  _PurchaseOrderItemModel instance,
) => <String, dynamic>{
  'id': instance.id,
  'purchaseOrderId': instance.purchaseOrderId,
  'productId': instance.productId,
  'unitPriceInCents': instance.unitPriceInCents,
  'quantity': instance.quantity,
  'productionDate': instance.productionDate?.toIso8601String(),
};
import 'package:freezed_annotation/freezed_annotation.dart';

part 'supplier.freezed.dart';
part 'supplier.g.dart';

@freezed
abstract class Supplier with _$Supplier {
  const factory Supplier({int? id, required String name}) =
      _Supplier;

  factory Supplier.fromJson(Map<String, dynamic> json) =>
      _$SupplierFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'supplier.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Supplier {

 int? get id; String get name;
/// Create a copy of Supplier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SupplierCopyWith<Supplier> get copyWith => _$SupplierCopyWithImpl<Supplier>(this as Supplier, _$identity);

  /// Serializes this Supplier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Supplier&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Supplier(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $SupplierCopyWith<$Res>  {
  factory $SupplierCopyWith(Supplier value, $Res Function(Supplier) _then) = _$SupplierCopyWithImpl;
@useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class _$SupplierCopyWithImpl<$Res>
    implements $SupplierCopyWith<$Res> {
  _$SupplierCopyWithImpl(this._self, this._then);

  final Supplier _self;
  final $Res Function(Supplier) _then;

/// Create a copy of Supplier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _Supplier implements Supplier {
  const _Supplier({this.id, required this.name});
  factory _Supplier.fromJson(Map<String, dynamic> json) => _$SupplierFromJson(json);

@override final  int? id;
@override final  String name;

/// Create a copy of Supplier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SupplierCopyWith<_Supplier> get copyWith => __$SupplierCopyWithImpl<_Supplier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SupplierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Supplier&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Supplier(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$SupplierCopyWith<$Res> implements $SupplierCopyWith<$Res> {
  factory _$SupplierCopyWith(_Supplier value, $Res Function(_Supplier) _then) = __$SupplierCopyWithImpl;
@override @useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class __$SupplierCopyWithImpl<$Res>
    implements _$SupplierCopyWith<$Res> {
  __$SupplierCopyWithImpl(this._self, this._then);

  final _Supplier _self;
  final $Res Function(_Supplier) _then;

/// Create a copy of Supplier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_Supplier(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'supplier.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Supplier _$SupplierFromJson(Map<String, dynamic> json) =>
    _Supplier(id: (json['id'] as num?)?.toInt(), name: json['name'] as String);

Map<String, dynamic> _$SupplierToJson(_Supplier instance) => <String, dynamic>{
  'id': instance.id,
  'name': instance.name,
};
import '../model/supplier.dart';

/// ä¾›åº”å•†ä»“å‚¨æ¥å?
/// å®šä¹‰ä¾›åº”å•†ç›¸å…³çš„ä¸šåŠ¡æ“ä½œè§„èŒƒ
abstract class ISupplierRepository {
  /// æ·»åŠ ä¾›åº”å•?
  Future<int> addSupplier(Supplier supplier);

  /// æ ¹æ®IDè·å–ä¾›åº”å•?
  Future<Supplier?> getSupplierById(int id);

  /// æ ¹æ®åç§°è·å–ä¾›åº”å•?
  Future<Supplier?> getSupplierByName(String name);

  /// è·å–æ‰€æœ‰ä¾›åº”å•†
  Future<List<Supplier>> getAllSuppliers();

  /// ç›‘å¬æ‰€æœ‰ä¾›åº”å•†å˜åŒ–
  Stream<List<Supplier>> watchAllSuppliers();

  /// æ›´æ–°ä¾›åº”å•?
  Future<bool> updateSupplier(Supplier supplier);

  /// åˆ é™¤ä¾›åº”å•?
  Future<int> deleteSupplier(int id);

  /// æ£€æŸ¥ä¾›åº”å•†åç§°æ˜¯å¦å·²å­˜åœ?
  Future<bool> isSupplierNameExists(String name, [int? excludeId]);

  /// æ ¹æ®åç§°æœç´¢ä¾›åº”å•?
  Future<List<Supplier>> searchSuppliersByName(String searchTerm);

  /// è·å–ä¾›åº”å•†æ•°é‡?
  Future<int> getSupplierCount();
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/constants/app_routes.dart';
import '../../application/provider/supplier_providers.dart';
import '../../data/dao/purchase_dao.dart';
import '../../../../core/database/database.dart';
import '../../../product/data/repository/product_repository.dart';

// Provider for PurchaseDao
final purchaseDaoProvider = Provider<PurchaseDao>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return database.purchaseDao;
});

// Provider to watch all purchase orders
final purchaseOrdersProvider = StreamProvider<List<PurchaseOrderData>>((ref) {
  final dao = ref.watch(purchaseDaoProvider);
  // Sort by purchase date descending
  return dao.watchAllPurchaseOrders().map(
    (orders) => orders..sort((a, b) => b.createdAt.compareTo(a.createdAt)),
  );
});

// Provider to get items for a specific order
final purchaseOrderItemsProvider =
    FutureProvider.family<List<PurchaseOrderItemData>, int>((ref, orderId) {
      final dao = ref.watch(purchaseDaoProvider);
      return dao.getPurchaseOrderItems(orderId);
    });

class PurchaseRecordsScreen extends ConsumerWidget {
  const PurchaseRecordsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ordersAsync = ref.watch(purchaseOrdersProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('é‡‡è´­è®°å½•'),
        actions: [
          IconButton(
            onPressed: () => context.push(AppRoutes.purchaseCreate),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å»ºé‡‡è´­å?,
          ),
        ],
      ),
      body: ordersAsync.when(
        data: (orders) {
          if (orders.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.receipt_long, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    'æš‚æ— é‡‡è´­è®¢å•',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                ],
              ),
            );
          }
          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: orders.length,
            itemBuilder: (context, index) {
              final order = orders[index];
              return PurchaseOrderCard(order: order);
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('åŠ è½½å¤±è´¥: $error')),
      ),
    );
  }
}

class PurchaseOrderCard extends ConsumerStatefulWidget {
  final PurchaseOrderData order;

  const PurchaseOrderCard({super.key, required this.order});

  @override
  ConsumerState<PurchaseOrderCard> createState() => _PurchaseOrderCardState();
}

class _PurchaseOrderCardState extends ConsumerState<PurchaseOrderCard> {
  bool _isExpanded = false;

  @override
  Widget build(BuildContext context) {
    final suppliersAsync = ref.watch(allSuppliersProvider);
    final itemsAsync = ref.watch(purchaseOrderItemsProvider(widget.order.id));

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Column(
        children: [
          InkWell(
            onTap: () {
              setState(() {
                _isExpanded = !_isExpanded;
              });
            },
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'è®¢å•å? ${widget.order.id}',
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 4),
                        Text('æ—¥æœŸ: ${widget.order.createdAt.toString().substring(0, 10)}'),
                        suppliersAsync.when(
                          data: (suppliers) {
                            final supplier = suppliers
                                .where((s) => s.id == widget.order.supplierId)
                                .firstOrNull;
                            return Text('ä¾›åº”å•? ${supplier?.name ?? 'æœªçŸ¥'}');
                          },
                          loading: () => const Text('ä¾›åº”å•? åŠ è½½ä¸?..'),
                          error: (_, __) => const Text('ä¾›åº”å•? åŠ è½½å¤±è´¥'),
                        ),
                      ],
                    ),
                  ),
                  Column(
                    children: [
                      itemsAsync.when(
                        data: (items) {
                          final totalAmount = items.fold<double>(
                            0,
                            (sum, item) => sum + (item.unitPriceInCents * item.quantity),
                          );
                          final totalQuantity = items.fold<double>(
                            0,
                            (sum, item) => sum + item.quantity,
                          );
                          return Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Text(
                                'ï¿?{(totalAmount / 100).toStringAsFixed(2)}',
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                  color: Colors.green,
                                ),
                              ),
                              Text(
                                '${totalQuantity.toInt()}ä»?,
                                style: const TextStyle(fontSize: 12, color: Colors.grey),
                              ),
                            ],
                          );
                        },
                        loading: () => const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        ),
                        error: (_, __) => const Icon(Icons.error, color: Colors.red),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          if (_isExpanded)
            itemsAsync.when(
              data: (items) => Column(
                children: items
                    .map((item) => PurchaseOrderItemTile(item: item))
                    .toList(),
              ),
              loading: () => const Padding(
                padding: EdgeInsets.all(16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
              error: (e, s) => Padding(
                padding: const EdgeInsets.all(16.0),
                child: Center(child: Text('åŠ è½½æ˜ç»†å¤±è´¥: $e')),
              ),
            ),
        ],
      ),
    );
  }
}

class PurchaseOrderItemTile extends ConsumerWidget {
  final PurchaseOrderItemData item;

  const PurchaseOrderItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productAsync = ref.watch(productByIdProvider(item.productId));
    return ListTile(
      contentPadding: const EdgeInsets.only(
        left: 3,
        right: 16,
        top: 0,
        bottom: 0,
      ),
      minVerticalPadding: 0,
      dense: true,
      visualDensity: const VisualDensity(horizontal: 0, vertical: -3),
      minLeadingWidth: 0,
      title: Row(
        children: [
          Text(' ${item.id}  ', style: const TextStyle(fontSize: 14)),
          const SizedBox(width: 6),
          Expanded(
            child: productAsync.when(
              data: (product) => Text(
                product?.name ?? 'è´§å“ID: ${item.productId}',
                style: const TextStyle(fontSize: 16),
              ),
              loading: () => const Text('åŠ è½½ä¸?..'),
              error: (err, stack) => Text(
                'åŠ è½½è´§å“å¤±è´¥',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ),
          ),
        ],
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (item.productionDate != null)
            Text('ç”Ÿäº§æ—¥æœŸ: ${item.productionDate!.toString().substring(0, 10)}'),
        ],
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            'ï¿?{(item.unitPriceInCents / 100).toStringAsFixed(2)} Ã— ${item.quantity.toInt()}',
          ),
          Text(
            'ï¿?{((item.unitPriceInCents * item.quantity) / 100).toStringAsFixed(2)}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }
}
// é‡‡è´­ç›¸å…³å±å¹•å¯¼å‡º
export 'purchase_records_screen.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/database/database.dart' hide Customer;
import '../../data/dao/customer_dao.dart';
import '../../data/repository/customer_repository.dart';
import '../../domain/model/customer.dart';
import '../../domain/repository/i_customer_repository.dart';

final customerDaoProvider = Provider<CustomerDao>((ref) {
  final db = ref.watch(appDatabaseProvider);
  return CustomerDao(db);
});

final customerRepositoryProvider = Provider<ICustomerRepository>((ref) {
  final customerDao = ref.watch(customerDaoProvider);
  return CustomerRepository(customerDao);
});

final allCustomersProvider = FutureProvider<List<Customer>>((ref) async {
  final repository = ref.watch(customerRepositoryProvider);
  return repository.getAllCustomers();
});

final customerControllerProvider =
    StateNotifierProvider<CustomerController, AsyncValue<void>>((ref) {
  final repository = ref.watch(customerRepositoryProvider);
  return CustomerController(repository, ref);
});

class CustomerController extends StateNotifier<AsyncValue<void>> {
  final ICustomerRepository _repository;
  final Ref _ref;

  CustomerController(this._repository, this._ref) : super(const AsyncData(null));

  Future<void> addCustomer(Customer customer) async {
    state = const AsyncValue.loading();
    try {
      await _repository.addCustomer(customer);
      _ref.invalidate(allCustomersProvider);
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> updateCustomer(Customer customer) async {
    state = const AsyncValue.loading();
    try {
      await _repository.updateCustomer(customer);
      _ref.invalidate(allCustomersProvider);
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> deleteCustomer(String id) async {
    state = const AsyncValue.loading();
    try {
      await _repository.deleteCustomer(id);
      _ref.invalidate(allCustomersProvider);
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<bool> isCustomerNameExists(String name) async {
    return _repository.isCustomerNameExists(name);
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../product/domain/model/product.dart';
import '../../domain/model/sale_cart_item.dart';

/// é”€å”®åˆ—è¡¨çŠ¶æ€é€šçŸ¥å™?
///
/// ç®¡ç†é”€å”®é¡¹åˆ—è¡¨çš„çŠ¶æ€ï¼Œå¹¶æä¾›å¢ã€åˆ ã€æ”¹ã€æŸ¥ç­‰æ“ä½œã€?
class SaleListNotifier extends StateNotifier<List<SaleCartItem>> {
  SaleListNotifier() : super([]);

  /// æ·»åŠ å•ä¸ªé”€å”®é¡¹åˆ°åˆ—è¡¨å¤´éƒ?
  void addItem(SaleCartItem item) {
    state = [item, ...state];
  }

  /// æ·»åŠ å¤šä¸ªé”€å”®é¡¹åˆ°åˆ—è¡¨å¤´éƒ?
  void addAllItems(List<SaleCartItem> items) {
    state = [...items.reversed, ...state];
  }

  /// æ ¹æ®IDç§»é™¤é”€å”®é¡¹
  void removeItem(String itemId) {
    state = state.where((item) => item.id != itemId).toList();
  }

  /// æ›´æ–°æŒ‡å®šçš„é”€å”®é¡¹
  void updateItem(SaleCartItem updatedItem) {
    state = [
      for (final item in state)
        if (item.id == updatedItem.id) updatedItem else item,
    ];
  }

  /// æ·»åŠ ä¸€ä¸ªæ–°è´§å“ï¼Œæˆ–å¦‚æœå·²å­˜åœ¨åˆ™æ›´æ–°å…¶æ•°é‡?
  ///
  /// [product] - è¦æ·»åŠ çš„è´§å“å¯¹è±¡
  /// [unitName] - å•ä½åç§°
  /// [barcode] - æ¡ç 
  /// [sellingPriceInCents] - é”€å”®ä»·
  void addOrUpdateItem({
    required ProductModel product,
    required int unitId,
    String? unitName,
    String? barcode,
    String? batchId,
    int? sellingPriceInCents,
    required int conversionRate,
  }) {
    final actualUnitName = unitName ?? 'æœªçŸ¥å•ä½';
    // ä¼˜å…ˆé€šè¿‡æ¡ç åŒ¹é…ï¼Œå…¶æ¬¡é€šè¿‡è´§å“IDå’Œå•ä½åŒ¹é…?
    final existingItemIndex = state.indexWhere((item) {
      if (barcode != null && item.id.contains('item_${barcode}_')) {
        return true;
      }
      final sameBase = item.productId == product.id! && item.unitId == unitId;
      // è‹¥ä»»ä¸€æ–¹æœ‰ batchIdï¼Œåˆ™éœ€è¦ç›¸ç­‰æ‰åˆå¹¶ï¼›å¦åˆ™è§†ä¸ºä¸åŒæ‰¹æ¬¡ä¸åˆå¹¶
      if ((item.batchId ?? '') != (batchId ?? '')) return false;
      return sameBase;
    });

    if (existingItemIndex != -1) {
      // å¦‚æœè´§å“å·²å­˜åœ¨ï¼Œå¢åŠ æ•°é‡
      final existingItem = state[existingItemIndex];
      final updatedItem = existingItem.copyWith(
        quantity: existingItem.quantity + 1,
        amount: (existingItem.quantity + 1) * existingItem.sellingPriceInCents/100,
      );
      updateItem(updatedItem);
    } else {
      // å¦‚æœæ˜¯æ–°è´§å“ï¼Œåˆ›å»ºæ–°çš„é”€å”®é¡¹
      final itemId = barcode != null
          ? 'item_${barcode}_${DateTime.now().millisecondsSinceEpoch}'
          : 'item_${product.id!}_${unitId}_${DateTime.now().millisecondsSinceEpoch}';

      final newItem = SaleCartItem(
        id: itemId,
        productId: product.id!,
        productName: product.name,
        unitId: unitId,
        unitName: actualUnitName,
        batchId: batchId,
        sellingPriceInCents: sellingPriceInCents ?? 0,
        quantity: 1,
        amount: (sellingPriceInCents ?? 0.0) / 100, // è½¬æ¢ä¸ºå…ƒ
        conversionRate: conversionRate,
      );
      addItem(newItem);
    }
  }

  /// æ¸…ç©ºæ•´ä¸ªåˆ—è¡¨
  void clear() {
    state = [];
  }
}

/// é”€å”®åˆ—è¡¨Provider
///
/// è¿™æ˜¯UIå±‚è®¿é—?[SaleListNotifier] çš„å…¥å£ã€?
final saleListProvider =
    StateNotifierProvider<SaleListNotifier, List<SaleCartItem>>(
      (ref) => SaleListNotifier(),
    );

/// é”€å”®ç»Ÿè®¡ä¿¡æ¯Provider
///
/// æ´¾ç”Ÿè‡?[saleListProvider]ï¼Œç”¨äºé«˜æ•ˆè®¡ç®—æ€»è®¡ä¿¡æ¯ã€?
final saleTotalsProvider = Provider<Map<String, double>>((ref) {
  final items = ref.watch(saleListProvider);
  // final totalQuantity = items.fold(0.0, (sum, item) => sum + item.quantity * item.conversionRate);
  final totalQuantity = items.fold(0.0, (sum, item) => sum + item.quantity);
  final totalAmount = items.fold(0.0, (sum, item) => sum + item.amount);
  return {
    'varieties': items.length.toDouble(),
    'quantity': totalQuantity,
    'amount': totalAmount,
  };
});
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stocko_app/features/inventory/application/inventory_service.dart';
import 'package:stocko_app/features/sale/data/repository/sales_transaction_repository.dart';
import 'package:stocko_app/core/database/database.dart';

import '../../domain/model/sale_cart_item.dart';
import '../../domain/model/sales_transaction.dart';
import '../../domain/model/sales_transaction_item.dart';
import '../../domain/repository/i_sales_transaction_repository.dart';

class SaleService {
  SaleService({
    required this.ref,
    required this.salesTransactionRepository,
    required this.inventoryService,
  });

  final Ref ref;
  final ISalesTransactionRepository salesTransactionRepository;
  final InventoryService inventoryService;

  Future<String> processOneClickSale({
    required int salesOrderNo,
    required int shopId,
    required List<SaleCartItem> saleItems,
    String? remarks,
    required bool isSaleMode,
    int? customerId,
    String? customerName,
    SalesStatus status = SalesStatus.preset,
  }) async {
    final now = DateTime.now();
    final totalAmount = saleItems.fold(0.0, (sum, item) => sum + item.amount);

    final db = ref.read(appDatabaseProvider);

    return await db.transaction<String>(() async {
      // 1) å…ˆè½é”€å”®äº¤æ˜“ï¼Œæ‹¿åˆ°ID
      final transactionItems = saleItems.map((item) {
        return SalesTransactionItem(
          salesTransactionId: 0,
          productId: item.productId,
          batchId: item.batchId != null ? int.tryParse(item.batchId!) : null,
          quantity: item.quantity.toInt(),
          priceInCents: item.sellingPriceInCents,
        );
      }).toList();

      final transaction = SalesTransaction(
        shopId: shopId,
        totalAmount: totalAmount,
        actualAmount: totalAmount,
        remarks: remarks,
        customerId: customerId ?? 0,
        items: transactionItems,
        status: status,
      );

      final salesId = await salesTransactionRepository.addSalesTransaction(transaction);

      // 2) ä»…é”€å”®æ¨¡å¼ï¼šå†™å‡ºåº“å•ä¸æ˜ç»†ï¼Œå¹¶åœ¨åŒäº‹åŠ¡å†…æ‰£å‡åº“å­˜å¹¶è®°å½•æµæ°?
      if (isSaleMode) {
        await salesTransactionRepository.handleOutbound(
            shopId, salesId, saleItems);
      }

      // 3) æ‰£å‡æˆ–å›è¡¥åº“å­?+ å†™åº“å­˜æµæ°´ï¼ˆå…è®¸è´Ÿåº“å­˜ï¼‰
      for (final item in saleItems) {
        print('ğŸ” [DEBUG] Processing inventory for product ${item.productId}, shop $shopId, batch ${item.batchId}');
        
        // æ£€æŸ¥åº“å­˜è®°å½•æ˜¯å¦å­˜åœ?
        final existingInventory = await inventoryService.getInventory(item.productId, shopId);
        print('ğŸ” [DEBUG] Existing inventory: ${existingInventory?.quantity ?? "not found"}');
        
        final ok = isSaleMode
            ? await inventoryService.outbound(
                productId: item.productId,
                shopId: shopId,
                quantity: item.quantity.toInt(),
                batchId: item.batchId != null ? int.tryParse(item.batchId!) : null,
                time: now,
              )
            : await inventoryService.inbound(
                productId: item.productId,
                shopId: shopId,
                quantity: item.quantity.toInt(),
                batchId: item.batchId != null ? int.tryParse(item.batchId!) : null,
                time: now,
              );
        if (!ok) {
          // è‹¥åº“å­˜è®°å½•ä¸å­˜åœ¨å¯¼è‡´æ›´æ–°ä¸åˆ°ï¼ŒæŠ›é”™ä½¿äº‹åŠ¡å›æ»š
          final batchInfo = item.batchId != null ? ', batch ${item.batchId}' : '';
          throw StateError('Inventory operation failed for product ${item.productId} in shop $shopId$batchInfo. No inventory record found.');
        }
      }

      final receiptNumber = 'SALE-${now.millisecondsSinceEpoch}';
      print('Sale successful. Receipt number: $receiptNumber');
      return receiptNumber;
    });
  }
}

final saleServiceProvider = Provider<SaleService>((ref) {
  final salesTransactionRepository =
      ref.watch(salesTransactionRepositoryProvider);
  final inventoryService = ref.watch(inventoryServiceProvider);
  return SaleService(
    ref: ref,
    salesTransactionRepository: salesTransactionRepository,
    inventoryService: inventoryService,
  );
});
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/customers_table.dart';
import '../../domain/model/customer.dart' as domain;

part 'customer_dao.g.dart';

@DriftAccessor(tables: [Customers])
class CustomerDao extends DatabaseAccessor<AppDatabase> with _$CustomerDaoMixin {
  CustomerDao(super.db);

  Future<List<Customer>> getAllCustomers() => select(customers).get();
  Future<Customer?> getCustomerById(int id) => (select(customers)..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  Future<int> addCustomer(domain.Customer customer) {
    return into(customers).insert(
      CustomersCompanion.insert(
        name: customer.name,
      ),
    );
  }

  Future<bool> updateCustomer(domain.Customer customer) {
    return update(customers).replace(
      Customer(id: customer.id!, name: customer.name),
    );
  }

  Future<int> deleteCustomer(int id) => (delete(customers)..where((tbl) => tbl.id.equals(id))).go();
  Future<bool> isCustomerNameExists(String name) async {
    final result = await (select(customers)..where((tbl) => tbl.name.equals(name))).get();
    return result.isNotEmpty;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'customer_dao.dart';

// ignore_for_file: type=lint
mixin _$CustomerDaoMixin on DatabaseAccessor<AppDatabase> {
  $CustomersTable get customers => attachedDatabase.customers;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/sales_transactions_table.dart';

part 'sales_transaction_dao.g.dart';

@DriftAccessor(tables: [SalesTransaction])
class SalesTransactionDao extends DatabaseAccessor<AppDatabase> with _$SalesTransactionDaoMixin {
  SalesTransactionDao(super.db);

  /// æ’å…¥ä¸€ç¬”æ–°çš„é”€å”®äº¤æ˜?
  Future<int> insertSalesTransaction(SalesTransactionCompanion companion) {
    return into(db.salesTransaction).insert(companion);
  }

  /// æ ¹æ®IDæŸ¥æ‰¾é”€å”®äº¤æ˜?
  Future<SalesTransactionData?> findSalesTransactionById(int id) {
    return (select(db.salesTransaction)..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
  }

  /// ç›‘å¬æ‰€æœ‰çš„é”€å”®äº¤æ˜?
  Stream<List<SalesTransactionData>> watchAllSalesTransactions() {
    return select(db.salesTransaction).watch();
  }

  /// æ›´æ–°é”€å”®äº¤æ˜“çŠ¶æ€?
  Future<bool> updateSalesTransactionStatus(int id, String status) {
    return (update(db.salesTransaction)..where((tbl) => tbl.id.equals(id)))
        .write(SalesTransactionCompanion(
          status: Value(status),
          updatedAt: Value(DateTime.now()),
        ))
        .then((value) => value > 0);
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sales_transaction_dao.dart';

// ignore_for_file: type=lint
mixin _$SalesTransactionDaoMixin on DatabaseAccessor<AppDatabase> {
  $CustomersTable get customers => attachedDatabase.customers;
  $ShopTable get shop => attachedDatabase.shop;
  $SalesTransactionTable get salesTransaction =>
      attachedDatabase.salesTransaction;
}
import 'package:drift/drift.dart';
import '../../../../core/database/database.dart';
import '../../../../core/database/sales_transaction_items_table.dart';

part 'sales_transaction_item_dao.g.dart';

@DriftAccessor(tables: [SalesTransactionItem])
class SalesTransactionItemDao extends DatabaseAccessor<AppDatabase> with _$SalesTransactionItemDaoMixin {
  SalesTransactionItemDao(super.db);

  /// æ’å…¥ä¸€ä¸ªé”€å”®äº¤æ˜“é¡¹ç›?
  Future<int> insertSalesTransactionItem(SalesTransactionItemCompanion companion) {
    return into(db.salesTransactionItem).insert(companion);
  }

  /// æ‰¹é‡æ’å…¥é”€å”®äº¤æ˜“é¡¹ç›?
  Future<void> insertSalesTransactionItems(List<SalesTransactionItemCompanion> companions) {
    return batch((batch) {
      batch.insertAll(db.salesTransactionItem, companions);
    });
  }

  /// æ ¹æ®äº¤æ˜“IDæŸ¥æ‰¾é”€å”®é¡¹ç›?
  Future<List<SalesTransactionItemData>> findSalesTransactionItemsByTransactionId(String transactionId) {
    print('ğŸ” [DEBUG] DAO: findSalesTransactionItemsByTransactionId called with: $transactionId (type: ${transactionId.runtimeType})');
    print('ğŸ” [DEBUG] DAO: transactionId content: "$transactionId"');
    
    final parsedId = int.tryParse(transactionId);
    print('ğŸ” [DEBUG] DAO: Parsed ID: $parsedId, type: ${parsedId?.runtimeType}');
    print('ğŸ” [DEBUG] DAO: Parsed ID == null: ${parsedId == null}');
    
    if (parsedId == null) {
      print('ğŸ” [ERROR] DAO: Failed to parse transactionId: $transactionId');
      throw Exception('æ— æ³•è§£æäº¤æ˜“ID: $transactionId');
    }
    
    return (select(db.salesTransactionItem)..where((tbl) => tbl.salesTransactionId.equals(parsedId))).get();
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sales_transaction_item_dao.dart';

// ignore_for_file: type=lint
mixin _$SalesTransactionItemDaoMixin on DatabaseAccessor<AppDatabase> {
  $CustomersTable get customers => attachedDatabase.customers;
  $ShopTable get shop => attachedDatabase.shop;
  $SalesTransactionTable get salesTransaction =>
      attachedDatabase.salesTransaction;
  $UnitTable get unit => attachedDatabase.unit;
  $CategoryTable get category => attachedDatabase.category;
  $ProductTable get product => attachedDatabase.product;
  $ProductBatchTable get productBatch => attachedDatabase.productBatch;
  $SalesTransactionItemTable get salesTransactionItem =>
      attachedDatabase.salesTransactionItem;
}
import '../../domain/model/customer.dart' as domain;
import '../../domain/repository/i_customer_repository.dart';
import '../dao/customer_dao.dart';
import '../../../../core/database/database.dart';

class CustomerRepository implements ICustomerRepository {
  final CustomerDao _customerDao;

  CustomerRepository(this._customerDao);

  @override
  Future<void> addCustomer(domain.Customer customer) {
    return _customerDao.addCustomer(customer);
  }

  @override
  Future<void> deleteCustomer(String id) {
    return _customerDao.deleteCustomer(int.parse(id));
  }

  @override
  Future<List<domain.Customer>> getAllCustomers() async {
    final customers = await _customerDao.getAllCustomers();
    return customers.map((c) => c.toDomain()).toList();
  }

  @override
  Future<domain.Customer?> getCustomerById(String id) async {
    final customer = await _customerDao.getCustomerById(int.parse(id));
    return customer?.toDomain();
  }

  @override
  Future<void> updateCustomer(domain.Customer customer) {
    return _customerDao.updateCustomer(customer);
  }

  @override
  Future<bool> isCustomerNameExists(String name) {
    return _customerDao.isCustomerNameExists(name);
  }
}

extension on Customer {
  domain.Customer toDomain() {
    return domain.Customer(
      id: id,
      name: name,
    );
  }
}
import 'package:drift/drift.dart' as drift;
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:stocko_app/core/database/database.dart';
import 'package:stocko_app/features/sale/domain/model/sale_cart_item.dart';
import 'package:stocko_app/features/sale/domain/model/sales_transaction.dart';
import 'package:stocko_app/features/sale/domain/model/sales_transaction_item.dart';
import 'package:stocko_app/features/sale/domain/repository/i_sales_transaction_repository.dart';

part 'sales_transaction_repository.g.dart';

@riverpod
ISalesTransactionRepository salesTransactionRepository(SalesTransactionRepositoryRef ref) {
  final db = ref.watch(appDatabaseProvider);
  return SalesTransactionRepository(db);
}

class SalesTransactionRepository implements ISalesTransactionRepository {
  final AppDatabase _db;

  SalesTransactionRepository(this._db);

  @override
  Future<int> addSalesTransaction(SalesTransaction transaction) async {
    print('ğŸ” [DEBUG] Repository: addSalesTransaction called');
    final transactionCompanion = transaction.toTableCompanion();
    print('ğŸ” [DEBUG] Repository: transactionCompanion created');
    
    return await _db.transaction(() async {
      try {
        // æ’å…¥é”€å”®äº¤æ˜“å¹¶è·å–è‡ªå¢ID
        final transactionId = await _db.salesTransactionDao.insertSalesTransaction(transactionCompanion);
        print('ğŸ” [DEBUG] Repository: transaction inserted with ID: $transactionId');
        
        // ä½¿ç”¨çœŸå®çš„äº¤æ˜“IDåˆ›å»ºé”€å”®äº¤æ˜“é¡¹ç›®çš„companionå¯¹è±¡
        final itemCompanions = transaction.items.map((item) {
          print('ğŸ” [DEBUG] Repository: Processing item with salesTransactionId: $transactionId');
          return item.toTableCompanion(transactionId);
        }).toList();
        print('ğŸ” [DEBUG] Repository: ${itemCompanions.length} item companions created');
        
        // æ’å…¥é”€å”®äº¤æ˜“é¡¹ç›?
        await _db.salesTransactionItemDao.insertSalesTransactionItems(itemCompanions);
        print('ğŸ” [DEBUG] Repository: items inserted successfully');
        return transactionId;
      } catch (e) {
        print('ğŸ” [DEBUG] Repository: Error in transaction: $e');
        rethrow;
      }
    });
  }

  @override
  Stream<List<SalesTransaction>> watchAllSalesTransactions() {
    return _db.salesTransactionDao.watchAllSalesTransactions().map((transactions) {
      return transactions.map((t) => SalesTransaction.fromTableData(t)).toList();
    });
  }

  @override
  Future<SalesTransaction?> getSalesTransactionById(int id) async {
    final transactionData = await _db.salesTransactionDao.findSalesTransactionById(id);
    if (transactionData == null) {
      return null;
    }
    final itemsData = await _db.salesTransactionItemDao.findSalesTransactionItemsByTransactionId(id.toString());
    final items = itemsData.map((i) => SalesTransactionItem.fromTableData(i)).toList();
    return SalesTransaction.fromTableData(transactionData, items: items);
  }
  @override
  Future<int> handleOutbound(
      int shopId, int salesId, List<SaleCartItem> saleItems) async {
    final receiptId = await _db.outboundReceiptDao.insertOutboundReceipt(
      OutboundReceiptCompanion(
        shopId: drift.Value(shopId),
        reason: const drift.Value('é”€å”®å‡ºåº?),
        salesTransactionId: drift.Value(salesId),
      ),
    );

    // åˆå¹¶æ˜ç»†
    final Map<(int, int?), int> merged = {};
    for (final item in saleItems) {
      final key = (item.productId,
          item.batchId != null ? int.tryParse(item.batchId!) : null);
      merged.update(key, (q) => q + item.quantity.toInt(), ifAbsent: () => item.quantity.toInt());
    }

    // æ‰¹é‡å†™å…¥å‡ºåº“æ˜ç»†
    if (merged.isNotEmpty) {
      final companions = merged.entries.map((e) {
        final pid = e.key.$1;
        final bid = e.key.$2;
        final qty = e.value;
        return OutboundItemCompanion(
          receiptId: drift.Value(receiptId),
          productId: drift.Value(pid),
          quantity: drift.Value(qty),
          batchId: bid != null
              ? drift.Value(bid)
              : const drift.Value.absent(),
        );
      }).toList(growable: false);
      await _db.batch((batch) {
        batch.insertAll(_db.outboundItem, companions);
      });
    }
    return receiptId;
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sales_transaction_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$salesTransactionRepositoryHash() =>
    r'fc4b3ba249dafbb30ca01e4c183cfa4ba515cd3d';

/// See also [salesTransactionRepository].
@ProviderFor(salesTransactionRepository)
final salesTransactionRepositoryProvider =
    AutoDisposeProvider<ISalesTransactionRepository>.internal(
      salesTransactionRepository,
      name: r'salesTransactionRepositoryProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$salesTransactionRepositoryHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef SalesTransactionRepositoryRef =
    AutoDisposeProviderRef<ISalesTransactionRepository>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
import 'package:freezed_annotation/freezed_annotation.dart';

part 'customer.freezed.dart';
part 'customer.g.dart';

/// å®¢æˆ·é¢†åŸŸæ¨¡å‹
/// è¡¨ç¤ºå®¢æˆ·çš„ä¸šåŠ¡å®ä½?
@freezed
abstract class Customer with _$Customer {
  const factory Customer({int? id, required String name}) = _Customer;

  const Customer._();

  factory Customer.fromJson(Map<String, dynamic> json) =>
      _$CustomerFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'customer.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Customer {

 int? get id; String get name;
/// Create a copy of Customer
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CustomerCopyWith<Customer> get copyWith => _$CustomerCopyWithImpl<Customer>(this as Customer, _$identity);

  /// Serializes this Customer to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Customer&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Customer(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $CustomerCopyWith<$Res>  {
  factory $CustomerCopyWith(Customer value, $Res Function(Customer) _then) = _$CustomerCopyWithImpl;
@useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class _$CustomerCopyWithImpl<$Res>
    implements $CustomerCopyWith<$Res> {
  _$CustomerCopyWithImpl(this._self, this._then);

  final Customer _self;
  final $Res Function(Customer) _then;

/// Create a copy of Customer
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _Customer extends Customer {
  const _Customer({this.id, required this.name}): super._();
  factory _Customer.fromJson(Map<String, dynamic> json) => _$CustomerFromJson(json);

@override final  int? id;
@override final  String name;

/// Create a copy of Customer
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CustomerCopyWith<_Customer> get copyWith => __$CustomerCopyWithImpl<_Customer>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CustomerToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Customer&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'Customer(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$CustomerCopyWith<$Res> implements $CustomerCopyWith<$Res> {
  factory _$CustomerCopyWith(_Customer value, $Res Function(_Customer) _then) = __$CustomerCopyWithImpl;
@override @useResult
$Res call({
 int? id, String name
});




}
/// @nodoc
class __$CustomerCopyWithImpl<$Res>
    implements _$CustomerCopyWith<$Res> {
  __$CustomerCopyWithImpl(this._self, this._then);

  final _Customer _self;
  final $Res Function(_Customer) _then;

/// Create a copy of Customer
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? name = null,}) {
  return _then(_Customer(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'customer.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Customer _$CustomerFromJson(Map<String, dynamic> json) =>
    _Customer(id: (json['id'] as num?)?.toInt(), name: json['name'] as String);

Map<String, dynamic> _$CustomerToJson(_Customer instance) => <String, dynamic>{
  'id': instance.id,
  'name': instance.name,
};
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:drift/drift.dart' hide JsonKey;
import 'sales_transaction_item.dart';
import 'package:stocko_app/core/database/database.dart';

part 'sales_transaction.freezed.dart';
part 'sales_transaction.g.dart';

enum SalesStatus { preset, credit, settled, cancelled }

@freezed
abstract class SalesTransaction with _$SalesTransaction {
  const factory SalesTransaction({
    int? id,
    required int customerId,
    required int shopId,
    required double totalAmount,
    required double actualAmount,
    @Default(SalesStatus.preset) SalesStatus status,
    @Default(<SalesTransactionItem>[]) List<SalesTransactionItem> items,
    String? remarks,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _SalesTransaction;

  SalesTransactionCompanion toTableCompanion() {
    print('ğŸ” [DEBUG] Creating SalesTransactionCompanion with:');
    print('  - id: ${id ?? 0}');
    print('  - customerId: $customerId');
    print('  - shopId: $shopId');
    print('  - totalAmount: $totalAmount');
    print('  - actualAmount: $actualAmount');
    print('  - status: ${status.toString().split('.').last}');
    print('  - remarks: $remarks');

    // ä¿®å¤ï¼šå¯¹äºæ–°è®°å½•ï¼Œåº”è¯¥è®©æ•°æ®åº“è‡ªåŠ¨ç”ŸæˆIDï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨è®¾ç½®ä¸º0
    print('ğŸ” [DEBUG] ID is null: ${id == null}');

    return SalesTransactionCompanion(
      id: id == null ? const Value.absent() : Value(id!),
      customerId: Value(customerId),
      shopId: Value(shopId),
      totalAmount: Value(totalAmount),
      actualAmount: Value(actualAmount),
      status: Value(status.toString().split('.').last),
      remarks: Value(remarks),
    );
  }

  const SalesTransaction._();

  factory SalesTransaction.fromJson(Map<String, dynamic> json) =>
      _$SalesTransactionFromJson(json);

  factory SalesTransaction.fromTableData(
    SalesTransactionData data, {
    List<SalesTransactionItem> items = const [],
  }) {
    return SalesTransaction(
      id: data.id,
      customerId: data.customerId,
      totalAmount: data.totalAmount,
      actualAmount: data.totalAmount, // å‡è®¾å®é™…é‡‘é¢ç­‰äºæ€»é‡‘é¢?
      shopId: 0, // æ•°æ®åº“ä¸­æ²¡æœ‰ï¼Œæš‚æ—¶è®¾ä¸?
      status: SalesStatus.values.firstWhere(
        (e) => e.toString().split('.').last == data.status,
        orElse: () => SalesStatus.preset,
      ),
      remarks: data.remarks,
      items: items,
    );
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sales_transaction.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SalesTransaction {

 int? get id; int get customerId; int get shopId; double get totalAmount; double get actualAmount; SalesStatus get status; List<SalesTransactionItem> get items; String? get remarks; DateTime? get createdAt; DateTime? get updatedAt;
/// Create a copy of SalesTransaction
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SalesTransactionCopyWith<SalesTransaction> get copyWith => _$SalesTransactionCopyWithImpl<SalesTransaction>(this as SalesTransaction, _$identity);

  /// Serializes this SalesTransaction to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SalesTransaction&&(identical(other.id, id) || other.id == id)&&(identical(other.customerId, customerId) || other.customerId == customerId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.totalAmount, totalAmount) || other.totalAmount == totalAmount)&&(identical(other.actualAmount, actualAmount) || other.actualAmount == actualAmount)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,customerId,shopId,totalAmount,actualAmount,status,const DeepCollectionEquality().hash(items),remarks,createdAt,updatedAt);

@override
String toString() {
  return 'SalesTransaction(id: $id, customerId: $customerId, shopId: $shopId, totalAmount: $totalAmount, actualAmount: $actualAmount, status: $status, items: $items, remarks: $remarks, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class $SalesTransactionCopyWith<$Res>  {
  factory $SalesTransactionCopyWith(SalesTransaction value, $Res Function(SalesTransaction) _then) = _$SalesTransactionCopyWithImpl;
@useResult
$Res call({
 int? id, int customerId, int shopId, double totalAmount, double actualAmount, SalesStatus status, List<SalesTransactionItem> items, String? remarks, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class _$SalesTransactionCopyWithImpl<$Res>
    implements $SalesTransactionCopyWith<$Res> {
  _$SalesTransactionCopyWithImpl(this._self, this._then);

  final SalesTransaction _self;
  final $Res Function(SalesTransaction) _then;

/// Create a copy of SalesTransaction
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? customerId = null,Object? shopId = null,Object? totalAmount = null,Object? actualAmount = null,Object? status = null,Object? items = null,Object? remarks = freezed,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,customerId: null == customerId ? _self.customerId : customerId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,totalAmount: null == totalAmount ? _self.totalAmount : totalAmount // ignore: cast_nullable_to_non_nullable
as double,actualAmount: null == actualAmount ? _self.actualAmount : actualAmount // ignore: cast_nullable_to_non_nullable
as double,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as SalesStatus,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<SalesTransactionItem>,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _SalesTransaction extends SalesTransaction {
  const _SalesTransaction({this.id, required this.customerId, required this.shopId, required this.totalAmount, required this.actualAmount, this.status = SalesStatus.preset, final  List<SalesTransactionItem> items = const <SalesTransactionItem>[], this.remarks, this.createdAt, this.updatedAt}): _items = items,super._();
  factory _SalesTransaction.fromJson(Map<String, dynamic> json) => _$SalesTransactionFromJson(json);

@override final  int? id;
@override final  int customerId;
@override final  int shopId;
@override final  double totalAmount;
@override final  double actualAmount;
@override@JsonKey() final  SalesStatus status;
 final  List<SalesTransactionItem> _items;
@override@JsonKey() List<SalesTransactionItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  String? remarks;
@override final  DateTime? createdAt;
@override final  DateTime? updatedAt;

/// Create a copy of SalesTransaction
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SalesTransactionCopyWith<_SalesTransaction> get copyWith => __$SalesTransactionCopyWithImpl<_SalesTransaction>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SalesTransactionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SalesTransaction&&(identical(other.id, id) || other.id == id)&&(identical(other.customerId, customerId) || other.customerId == customerId)&&(identical(other.shopId, shopId) || other.shopId == shopId)&&(identical(other.totalAmount, totalAmount) || other.totalAmount == totalAmount)&&(identical(other.actualAmount, actualAmount) || other.actualAmount == actualAmount)&&(identical(other.status, status) || other.status == status)&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.remarks, remarks) || other.remarks == remarks)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.updatedAt, updatedAt) || other.updatedAt == updatedAt));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,customerId,shopId,totalAmount,actualAmount,status,const DeepCollectionEquality().hash(_items),remarks,createdAt,updatedAt);

@override
String toString() {
  return 'SalesTransaction(id: $id, customerId: $customerId, shopId: $shopId, totalAmount: $totalAmount, actualAmount: $actualAmount, status: $status, items: $items, remarks: $remarks, createdAt: $createdAt, updatedAt: $updatedAt)';
}


}

/// @nodoc
abstract mixin class _$SalesTransactionCopyWith<$Res> implements $SalesTransactionCopyWith<$Res> {
  factory _$SalesTransactionCopyWith(_SalesTransaction value, $Res Function(_SalesTransaction) _then) = __$SalesTransactionCopyWithImpl;
@override @useResult
$Res call({
 int? id, int customerId, int shopId, double totalAmount, double actualAmount, SalesStatus status, List<SalesTransactionItem> items, String? remarks, DateTime? createdAt, DateTime? updatedAt
});




}
/// @nodoc
class __$SalesTransactionCopyWithImpl<$Res>
    implements _$SalesTransactionCopyWith<$Res> {
  __$SalesTransactionCopyWithImpl(this._self, this._then);

  final _SalesTransaction _self;
  final $Res Function(_SalesTransaction) _then;

/// Create a copy of SalesTransaction
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? customerId = null,Object? shopId = null,Object? totalAmount = null,Object? actualAmount = null,Object? status = null,Object? items = null,Object? remarks = freezed,Object? createdAt = freezed,Object? updatedAt = freezed,}) {
  return _then(_SalesTransaction(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,customerId: null == customerId ? _self.customerId : customerId // ignore: cast_nullable_to_non_nullable
as int,shopId: null == shopId ? _self.shopId : shopId // ignore: cast_nullable_to_non_nullable
as int,totalAmount: null == totalAmount ? _self.totalAmount : totalAmount // ignore: cast_nullable_to_non_nullable
as double,actualAmount: null == actualAmount ? _self.actualAmount : actualAmount // ignore: cast_nullable_to_non_nullable
as double,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as SalesStatus,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<SalesTransactionItem>,remarks: freezed == remarks ? _self.remarks : remarks // ignore: cast_nullable_to_non_nullable
as String?,createdAt: freezed == createdAt ? _self.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime?,updatedAt: freezed == updatedAt ? _self.updatedAt : updatedAt // ignore: cast_nullable_to_non_nullable
as DateTime?,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sales_transaction.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_SalesTransaction _$SalesTransactionFromJson(Map<String, dynamic> json) =>
    _SalesTransaction(
      id: (json['id'] as num?)?.toInt(),
      customerId: (json['customerId'] as num).toInt(),
      shopId: (json['shopId'] as num).toInt(),
      totalAmount: (json['totalAmount'] as num).toDouble(),
      actualAmount: (json['actualAmount'] as num).toDouble(),
      status:
          $enumDecodeNullable(_$SalesStatusEnumMap, json['status']) ??
          SalesStatus.preset,
      items:
          (json['items'] as List<dynamic>?)
              ?.map(
                (e) => SalesTransactionItem.fromJson(e as Map<String, dynamic>),
              )
              .toList() ??
          const <SalesTransactionItem>[],
      remarks: json['remarks'] as String?,
      createdAt: json['createdAt'] == null
          ? null
          : DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$SalesTransactionToJson(_SalesTransaction instance) =>
    <String, dynamic>{
      'id': instance.id,
      'customerId': instance.customerId,
      'shopId': instance.shopId,
      'totalAmount': instance.totalAmount,
      'actualAmount': instance.actualAmount,
      'status': _$SalesStatusEnumMap[instance.status]!,
      'items': instance.items,
      'remarks': instance.remarks,
      'createdAt': instance.createdAt?.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
    };

const _$SalesStatusEnumMap = {
  SalesStatus.preset: 'preset',
  SalesStatus.credit: 'credit',
  SalesStatus.settled: 'settled',
  SalesStatus.cancelled: 'cancelled',
};
import 'package:drift/drift.dart' hide JsonKey;
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:stocko_app/core/database/database.dart';

part 'sales_transaction_item.freezed.dart';
part 'sales_transaction_item.g.dart';

@freezed
abstract class SalesTransactionItem with _$SalesTransactionItem {
  const factory SalesTransactionItem({
    int? id,
    required int salesTransactionId,
    required int productId,
    int? batchId,
    required int quantity,
    required int priceInCents,
  }) = _SalesTransactionItem;

  const SalesTransactionItem._();

  /// éªŒè¯äº§å“IDçš„æœ‰æ•ˆæ€?
  bool get isValidProductId => productId > 0;

  /// éªŒè¯æ‰¹æ¬¡IDçš„æœ‰æ•ˆæ€§ï¼ˆå¦‚æœæä¾›äº†æ‰¹æ¬¡IDï¼?
  bool get isValidBatchId => batchId == null;

  /// éªŒè¯æ•°é‡çš„æœ‰æ•ˆæ€?
  bool get isValidQuantity => quantity > 0;

  /// éªŒè¯å•ä½ä»·æ ¼çš„æœ‰æ•ˆæ€?
  bool get isValidPrice => priceInCents > 0;

  /// éªŒè¯æ‰€æœ‰å¿…å¡«å­—æ®µçš„æœ‰æ•ˆæ€?
  bool get isValid =>
      isValidSalesTransactionId &&
      isValidProductId &&
      isValidBatchId &&
      isValidQuantity &&
      isValidPrice;

  /// éªŒè¯é”€å”®äº¤æ˜“IDçš„æœ‰æ•ˆæ€?
  bool get isValidSalesTransactionId => salesTransactionId > 0;

  /// æ‰¹æ¬¡å¼•ç”¨å…³ç³»éªŒè¯ - æ£€æŸ¥æ˜¯å¦ä¸ºæ‰¹æ¬¡ç›¸å…³å•†å“
  bool get isBatchRelated => id != null;

  /// è·å–éªŒè¯é”™è¯¯ä¿¡æ¯åˆ—è¡¨
  List<String> get validationErrors {
    final errors = <String>[];

    if (!isValidSalesTransactionId) {
      errors.add('é”€å”®äº¤æ˜“IDå¿…é¡»å¤§äº0');
    }

    if (!isValidProductId) {
      errors.add('äº§å“IDå¿…é¡»å¤§äº0');
    }

    if (!isValidBatchId && batchId != null) {
      errors.add('æ‰¹æ¬¡IDä¸èƒ½ä¸ºç©ºå­—ç¬¦ä¸?);
    }

    if (!isValidQuantity) {
      errors.add('æ•°é‡å¿…é¡»å¤§äº0');
    }

    if (!isValidPrice) {
      errors.add('å•ä½ä»·æ ¼å¿…é¡»å¤§äº0');
    }

    return errors;
  }

  SalesTransactionItemCompanion toTableCompanion(int transactionId) {
    print('ğŸ” [DEBUG] Creating SalesTransactionItemCompanion with:');
    print('  - id: ${id ?? "null"} (type: ${id?.runtimeType})');
    print(
      '  - salesTransactionId: $transactionId (type: ${transactionId.runtimeType})',
    );
    print('  - productId: $productId (type: ${productId.runtimeType})');
    print('  - batchId: ${batchId ?? "null"} (type: ${batchId?.runtimeType})');
    print('  - quantity: $quantity (type: ${quantity.runtimeType})');
    print(
      '  - priceInCents: $priceInCents (type: ${priceInCents.runtimeType})',
    );

    // ä¿®å¤ï¼šå¯¹äºæ–°è®°å½•ï¼Œåº”è¯¥è®©æ•°æ®åº“è‡ªåŠ¨ç”ŸæˆIDï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨è®¾ç½®ä¸ºnull
    print('ğŸ” [DEBUG] ID is null: ${id == null}');
    print('ğŸ” [DEBUG] id is null: ${id == null}');

    // æ£€æŸ¥ç±»å‹è½¬æ?
    if (id != null && id is! int) {
      print('ğŸ” [ERROR] ID type mismatch: expected int, got ${id.runtimeType}');
    }

    try {
      return SalesTransactionItemCompanion(
        id: id == null ? const Value.absent() : Value(id as int),
        salesTransactionId: Value(transactionId),
        productId: Value(productId),
        batchId: batchId != null ? Value(batchId!) : const Value.absent(),
        quantity: Value(quantity),
        priceInCents: Value(priceInCents),
      );
    } catch (e) {
      print('ğŸ” [ERROR] Failed to create SalesTransactionItemCompanion: $e');
      rethrow;
    }
  }

  factory SalesTransactionItem.fromJson(Map<String, dynamic> json) =>
      _$SalesTransactionItemFromJson(json);

  factory SalesTransactionItem.fromTableData(SalesTransactionItemData data) {
    return SalesTransactionItem(
      id: data.id,
      salesTransactionId: data.salesTransactionId,
      productId: data.productId,
      batchId: data.batchId,
      quantity: data.quantity,
      priceInCents: data.priceInCents.toInt(),
    );
  }

  /// åˆ›å»ºå¸¦æœ‰æ•°æ®éªŒè¯çš„å®ä¾?
  /// ä½¿ç”¨æ­¤æ–¹æ³•ç¡®ä¿æ‰€æœ‰æ•°æ®éªŒè¯é€šè¿‡
  static SalesTransactionItem createWithValidation({
    int? id,
    required int salesTransactionId,
    required int productId,
    int? batchId,
    required int quantity,
    required int priceInCents,
  }) {
    final item = SalesTransactionItem(
      id: id,
      salesTransactionId: salesTransactionId,
      productId: productId,
      batchId: batchId,
      quantity: quantity,
      priceInCents: priceInCents,
    );

    if (!item.isValid) {
      throw ArgumentError('æ•°æ®éªŒè¯å¤±è´¥: ${item.validationErrors.join(", ")}');
    }

    return item;
  }
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sales_transaction_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SalesTransactionItem {

 int? get id; int get salesTransactionId; int get productId; int? get batchId; int get quantity; int get priceInCents;
/// Create a copy of SalesTransactionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SalesTransactionItemCopyWith<SalesTransactionItem> get copyWith => _$SalesTransactionItemCopyWithImpl<SalesTransactionItem>(this as SalesTransactionItem, _$identity);

  /// Serializes this SalesTransactionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SalesTransactionItem&&(identical(other.id, id) || other.id == id)&&(identical(other.salesTransactionId, salesTransactionId) || other.salesTransactionId == salesTransactionId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.priceInCents, priceInCents) || other.priceInCents == priceInCents));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,salesTransactionId,productId,batchId,quantity,priceInCents);

@override
String toString() {
  return 'SalesTransactionItem(id: $id, salesTransactionId: $salesTransactionId, productId: $productId, batchId: $batchId, quantity: $quantity, priceInCents: $priceInCents)';
}


}

/// @nodoc
abstract mixin class $SalesTransactionItemCopyWith<$Res>  {
  factory $SalesTransactionItemCopyWith(SalesTransactionItem value, $Res Function(SalesTransactionItem) _then) = _$SalesTransactionItemCopyWithImpl;
@useResult
$Res call({
 int? id, int salesTransactionId, int productId, int? batchId, int quantity, int priceInCents
});




}
/// @nodoc
class _$SalesTransactionItemCopyWithImpl<$Res>
    implements $SalesTransactionItemCopyWith<$Res> {
  _$SalesTransactionItemCopyWithImpl(this._self, this._then);

  final SalesTransactionItem _self;
  final $Res Function(SalesTransactionItem) _then;

/// Create a copy of SalesTransactionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? salesTransactionId = null,Object? productId = null,Object? batchId = freezed,Object? quantity = null,Object? priceInCents = null,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,salesTransactionId: null == salesTransactionId ? _self.salesTransactionId : salesTransactionId // ignore: cast_nullable_to_non_nullable
as int,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,priceInCents: null == priceInCents ? _self.priceInCents : priceInCents // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _SalesTransactionItem extends SalesTransactionItem {
  const _SalesTransactionItem({this.id, required this.salesTransactionId, required this.productId, this.batchId, required this.quantity, required this.priceInCents}): super._();
  factory _SalesTransactionItem.fromJson(Map<String, dynamic> json) => _$SalesTransactionItemFromJson(json);

@override final  int? id;
@override final  int salesTransactionId;
@override final  int productId;
@override final  int? batchId;
@override final  int quantity;
@override final  int priceInCents;

/// Create a copy of SalesTransactionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SalesTransactionItemCopyWith<_SalesTransactionItem> get copyWith => __$SalesTransactionItemCopyWithImpl<_SalesTransactionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SalesTransactionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SalesTransactionItem&&(identical(other.id, id) || other.id == id)&&(identical(other.salesTransactionId, salesTransactionId) || other.salesTransactionId == salesTransactionId)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.priceInCents, priceInCents) || other.priceInCents == priceInCents));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,salesTransactionId,productId,batchId,quantity,priceInCents);

@override
String toString() {
  return 'SalesTransactionItem(id: $id, salesTransactionId: $salesTransactionId, productId: $productId, batchId: $batchId, quantity: $quantity, priceInCents: $priceInCents)';
}


}

/// @nodoc
abstract mixin class _$SalesTransactionItemCopyWith<$Res> implements $SalesTransactionItemCopyWith<$Res> {
  factory _$SalesTransactionItemCopyWith(_SalesTransactionItem value, $Res Function(_SalesTransactionItem) _then) = __$SalesTransactionItemCopyWithImpl;
@override @useResult
$Res call({
 int? id, int salesTransactionId, int productId, int? batchId, int quantity, int priceInCents
});




}
/// @nodoc
class __$SalesTransactionItemCopyWithImpl<$Res>
    implements _$SalesTransactionItemCopyWith<$Res> {
  __$SalesTransactionItemCopyWithImpl(this._self, this._then);

  final _SalesTransactionItem _self;
  final $Res Function(_SalesTransactionItem) _then;

/// Create a copy of SalesTransactionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? salesTransactionId = null,Object? productId = null,Object? batchId = freezed,Object? quantity = null,Object? priceInCents = null,}) {
  return _then(_SalesTransactionItem(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int?,salesTransactionId: null == salesTransactionId ? _self.salesTransactionId : salesTransactionId // ignore: cast_nullable_to_non_nullable
as int,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as int?,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as int,priceInCents: null == priceInCents ? _self.priceInCents : priceInCents // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sales_transaction_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_SalesTransactionItem _$SalesTransactionItemFromJson(
  Map<String, dynamic> json,
) => _SalesTransactionItem(
  id: (json['id'] as num?)?.toInt(),
  salesTransactionId: (json['salesTransactionId'] as num).toInt(),
  productId: (json['productId'] as num).toInt(),
  batchId: (json['batchId'] as num?)?.toInt(),
  quantity: (json['quantity'] as num).toInt(),
  priceInCents: (json['priceInCents'] as num).toInt(),
);

Map<String, dynamic> _$SalesTransactionItemToJson(
  _SalesTransactionItem instance,
) => <String, dynamic>{
  'id': instance.id,
  'salesTransactionId': instance.salesTransactionId,
  'productId': instance.productId,
  'batchId': instance.batchId,
  'quantity': instance.quantity,
  'priceInCents': instance.priceInCents,
};
import 'package:freezed_annotation/freezed_annotation.dart';

part 'sale_cart_item.freezed.dart';
part 'sale_cart_item.g.dart';

@freezed
abstract class SaleCartItem with _$SaleCartItem {
  const factory SaleCartItem({
    required String id,
    required int productId,
    required String productName,
    required int unitId,
    required String unitName,
    String? batchId,
    required int sellingPriceInCents,
    required double quantity,
    required double amount,
    required int conversionRate,
  }) = _SaleCartItem;

  factory SaleCartItem.fromJson(Map<String, dynamic> json) =>
      _$SaleCartItemFromJson(json);
}
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sale_cart_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SaleCartItem {

 String get id; int get productId; String get productName; int get unitId; String get unitName; String? get batchId; int get sellingPriceInCents; double get quantity; double get amount; int get conversionRate;
/// Create a copy of SaleCartItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SaleCartItemCopyWith<SaleCartItem> get copyWith => _$SaleCartItemCopyWithImpl<SaleCartItem>(this as SaleCartItem, _$identity);

  /// Serializes this SaleCartItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SaleCartItem&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.productName, productName) || other.productName == productName)&&(identical(other.unitId, unitId) || other.unitId == unitId)&&(identical(other.unitName, unitName) || other.unitName == unitName)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.sellingPriceInCents, sellingPriceInCents) || other.sellingPriceInCents == sellingPriceInCents)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.amount, amount) || other.amount == amount)&&(identical(other.conversionRate, conversionRate) || other.conversionRate == conversionRate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,productName,unitId,unitName,batchId,sellingPriceInCents,quantity,amount,conversionRate);

@override
String toString() {
  return 'SaleCartItem(id: $id, productId: $productId, productName: $productName, unitId: $unitId, unitName: $unitName, batchId: $batchId, sellingPriceInCents: $sellingPriceInCents, quantity: $quantity, amount: $amount, conversionRate: $conversionRate)';
}


}

/// @nodoc
abstract mixin class $SaleCartItemCopyWith<$Res>  {
  factory $SaleCartItemCopyWith(SaleCartItem value, $Res Function(SaleCartItem) _then) = _$SaleCartItemCopyWithImpl;
@useResult
$Res call({
 String id, int productId, String productName, int unitId, String unitName, String? batchId, int sellingPriceInCents, double quantity, double amount, int conversionRate
});




}
/// @nodoc
class _$SaleCartItemCopyWithImpl<$Res>
    implements $SaleCartItemCopyWith<$Res> {
  _$SaleCartItemCopyWithImpl(this._self, this._then);

  final SaleCartItem _self;
  final $Res Function(SaleCartItem) _then;

/// Create a copy of SaleCartItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? productId = null,Object? productName = null,Object? unitId = null,Object? unitName = null,Object? batchId = freezed,Object? sellingPriceInCents = null,Object? quantity = null,Object? amount = null,Object? conversionRate = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,productName: null == productName ? _self.productName : productName // ignore: cast_nullable_to_non_nullable
as String,unitId: null == unitId ? _self.unitId : unitId // ignore: cast_nullable_to_non_nullable
as int,unitName: null == unitName ? _self.unitName : unitName // ignore: cast_nullable_to_non_nullable
as String,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as String?,sellingPriceInCents: null == sellingPriceInCents ? _self.sellingPriceInCents : sellingPriceInCents // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as double,amount: null == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as double,conversionRate: null == conversionRate ? _self.conversionRate : conversionRate // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _SaleCartItem implements SaleCartItem {
  const _SaleCartItem({required this.id, required this.productId, required this.productName, required this.unitId, required this.unitName, this.batchId, required this.sellingPriceInCents, required this.quantity, required this.amount, required this.conversionRate});
  factory _SaleCartItem.fromJson(Map<String, dynamic> json) => _$SaleCartItemFromJson(json);

@override final  String id;
@override final  int productId;
@override final  String productName;
@override final  int unitId;
@override final  String unitName;
@override final  String? batchId;
@override final  int sellingPriceInCents;
@override final  double quantity;
@override final  double amount;
@override final  int conversionRate;

/// Create a copy of SaleCartItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SaleCartItemCopyWith<_SaleCartItem> get copyWith => __$SaleCartItemCopyWithImpl<_SaleCartItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SaleCartItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SaleCartItem&&(identical(other.id, id) || other.id == id)&&(identical(other.productId, productId) || other.productId == productId)&&(identical(other.productName, productName) || other.productName == productName)&&(identical(other.unitId, unitId) || other.unitId == unitId)&&(identical(other.unitName, unitName) || other.unitName == unitName)&&(identical(other.batchId, batchId) || other.batchId == batchId)&&(identical(other.sellingPriceInCents, sellingPriceInCents) || other.sellingPriceInCents == sellingPriceInCents)&&(identical(other.quantity, quantity) || other.quantity == quantity)&&(identical(other.amount, amount) || other.amount == amount)&&(identical(other.conversionRate, conversionRate) || other.conversionRate == conversionRate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,productId,productName,unitId,unitName,batchId,sellingPriceInCents,quantity,amount,conversionRate);

@override
String toString() {
  return 'SaleCartItem(id: $id, productId: $productId, productName: $productName, unitId: $unitId, unitName: $unitName, batchId: $batchId, sellingPriceInCents: $sellingPriceInCents, quantity: $quantity, amount: $amount, conversionRate: $conversionRate)';
}


}

/// @nodoc
abstract mixin class _$SaleCartItemCopyWith<$Res> implements $SaleCartItemCopyWith<$Res> {
  factory _$SaleCartItemCopyWith(_SaleCartItem value, $Res Function(_SaleCartItem) _then) = __$SaleCartItemCopyWithImpl;
@override @useResult
$Res call({
 String id, int productId, String productName, int unitId, String unitName, String? batchId, int sellingPriceInCents, double quantity, double amount, int conversionRate
});




}
/// @nodoc
class __$SaleCartItemCopyWithImpl<$Res>
    implements _$SaleCartItemCopyWith<$Res> {
  __$SaleCartItemCopyWithImpl(this._self, this._then);

  final _SaleCartItem _self;
  final $Res Function(_SaleCartItem) _then;

/// Create a copy of SaleCartItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? productId = null,Object? productName = null,Object? unitId = null,Object? unitName = null,Object? batchId = freezed,Object? sellingPriceInCents = null,Object? quantity = null,Object? amount = null,Object? conversionRate = null,}) {
  return _then(_SaleCartItem(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,productId: null == productId ? _self.productId : productId // ignore: cast_nullable_to_non_nullable
as int,productName: null == productName ? _self.productName : productName // ignore: cast_nullable_to_non_nullable
as String,unitId: null == unitId ? _self.unitId : unitId // ignore: cast_nullable_to_non_nullable
as int,unitName: null == unitName ? _self.unitName : unitName // ignore: cast_nullable_to_non_nullable
as String,batchId: freezed == batchId ? _self.batchId : batchId // ignore: cast_nullable_to_non_nullable
as String?,sellingPriceInCents: null == sellingPriceInCents ? _self.sellingPriceInCents : sellingPriceInCents // ignore: cast_nullable_to_non_nullable
as int,quantity: null == quantity ? _self.quantity : quantity // ignore: cast_nullable_to_non_nullable
as double,amount: null == amount ? _self.amount : amount // ignore: cast_nullable_to_non_nullable
as double,conversionRate: null == conversionRate ? _self.conversionRate : conversionRate // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sale_cart_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_SaleCartItem _$SaleCartItemFromJson(Map<String, dynamic> json) =>
    _SaleCartItem(
      id: json['id'] as String,
      productId: (json['productId'] as num).toInt(),
      productName: json['productName'] as String,
      unitId: (json['unitId'] as num).toInt(),
      unitName: json['unitName'] as String,
      batchId: json['batchId'] as String?,
      sellingPriceInCents: (json['sellingPriceInCents'] as num).toInt(),
      quantity: (json['quantity'] as num).toDouble(),
      amount: (json['amount'] as num).toDouble(),
      conversionRate: (json['conversionRate'] as num).toInt(),
    );

Map<String, dynamic> _$SaleCartItemToJson(_SaleCartItem instance) =>
    <String, dynamic>{
      'id': instance.id,
      'productId': instance.productId,
      'productName': instance.productName,
      'unitId': instance.unitId,
      'unitName': instance.unitName,
      'batchId': instance.batchId,
      'sellingPriceInCents': instance.sellingPriceInCents,
      'quantity': instance.quantity,
      'amount': instance.amount,
      'conversionRate': instance.conversionRate,
    };
import '../model/customer.dart';

abstract class ICustomerRepository {
  Future<List<Customer>> getAllCustomers();
  Future<Customer?> getCustomerById(String id);
  Future<void> addCustomer(Customer customer);
  Future<void> updateCustomer(Customer customer);
  Future<void> deleteCustomer(String id);
  Future<bool> isCustomerNameExists(String name);
}
import 'package:stocko_app/features/sale/domain/model/sale_cart_item.dart';

import '../model/sales_transaction.dart';

abstract class ISalesTransactionRepository {
  /// æ’å…¥é”€å”®äº¤æ˜“ï¼Œè¿”å›ç”Ÿæˆçš„è‡ªå¢ID
  Future<int> addSalesTransaction(SalesTransaction transaction);
  Stream<List<SalesTransaction>> watchAllSalesTransactions();
  Future<SalesTransaction?> getSalesTransactionById(int id);

  Future<int> handleOutbound(
      int shopId, int salesId, List<SaleCartItem> saleItems);
}
import 'dart:async';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:collection/collection.dart'; // å¯¼å…¥ collection åŒ?
import '../../../product/domain/model/product.dart';
import '../../../../core/constants/app_routes.dart';
import '../../application/provider/sale_list_provider.dart';
import '../../application/provider/customer_providers.dart';
import '../../application/service/sale_service.dart';
import '../../domain/model/customer.dart';
import '../../domain/model/sales_transaction.dart';
import '../../../inventory/application/provider/shop_providers.dart';
import '../../../inventory/domain/model/shop.dart';
import '../../../inventory/presentation/providers/inbound_records_provider.dart';
import '../../../inventory/presentation/providers/inventory_query_providers.dart';
import '../../../inventory/presentation/providers/outbound_receipts_provider.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../../product/presentation/screens/product_selection_screen.dart';
import '../widgets/sale_item_card.dart';
import '../../../../core/utils/snackbar_helper.dart';
import '../../../../core/utils/sound_helper.dart';
import '../../../../core/widgets/universal_barcode_scanner.dart';
import '../../../../core/models/scanned_product_payload.dart';

enum SaleMode { sale, nonSale }

/// æ–°å»ºé”€å”®å•é¡µé¢
class CreateSaleScreen extends ConsumerStatefulWidget {
  final ScannedProductPayload? payload;
  const CreateSaleScreen({super.key, this.payload});

  @override
  ConsumerState<CreateSaleScreen> createState() => _CreateSaleScreenState();
}

class _CreateSaleScreenState extends ConsumerState<CreateSaleScreen> {
  final _remarksController = TextEditingController();
  final _customerController = TextEditingController();
  final _sourceController = TextEditingController(); // ä¸?æ¥æº'æ–°å¢Controller
  final _paymentController = TextEditingController(); // æ”¶æ¬¾Controller

  final SaleMode _currentMode = SaleMode.sale; // é»˜è®¤æ˜¯é”€å”®æ¨¡å¼?
  Customer? _selectedCustomer;
  Shop? _selectedShop;
  bool _isProcessing = false;
  String? _lastScannedBarcode;

  final FocusNode _shopFocusNode = FocusNode();
  final FocusNode _customerFocusNode = FocusNode();
  final FocusNode _paymentFocusNode = FocusNode();
  // æ¯ä¸ªæ¡ç›®çš„å”®ä»·ä¸æ•°é‡ FocusNode åˆ—è¡¨
  final List<FocusNode> _priceFocusNodes = [];
  final List<FocusNode> _quantityFocusNodes = [];

  @override
  void initState() {
    super.initState();
    _paymentFocusNode.addListener(() {
      if (_paymentFocusNode.hasFocus) {
        _paymentController.clear();
      }
    });
    _paymentController.text = '0';
    _paymentController.addListener(() => setState(() {}));
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(saleListProvider.notifier).clear();
      // æ¥æ”¶æ¥è‡ªé¦–é¡µæˆ–å…¶ä»–é¡µé¢çš„æ‰«ç è´§å“ï¼Œè‡ªåŠ¨æ·»åŠ åˆ°é”€å”®æ¸…å?
      final p = widget.payload;
      if (p != null) {
        // å¦‚æœæ˜¯åŸºæœ¬å•ä½ï¼ˆconversionRate = 1ï¼‰ï¼Œä½¿ç”¨ Product è¡¨çš„ effectivePrice
        // å¦åˆ™ä½¿ç”¨ UnitProduct è¡¨çš„ sellingPriceInCents
        final priceCents = p.conversionRate == 1
            ? (p.product.effectivePrice?.cents ?? 0)
            : (p.sellingPriceInCents ?? 0);
        try {
          ref
              .read(saleListProvider.notifier)
              .addOrUpdateItem(
                product: p.product,
                unitId: p.unitId,
                unitName: p.unitName,
                sellingPriceInCents: priceCents,
                conversionRate: p.conversionRate,
              );
          // å¯é€‰ï¼šæç¤ºå·²æ·»åŠ?
          // showAppSnackBar(context, message: 'å·²æ·»åŠ ï¼š${p.product.name}');
        } catch (_) {}
      }
    });
  }

  @override
  void dispose() {
    _remarksController.dispose();
    _customerController.dispose();
    _sourceController.dispose();
    _paymentController.dispose();
    _shopFocusNode.dispose();
    _customerFocusNode.dispose();
    _paymentFocusNode.dispose();
    for (var node in _quantityFocusNodes) {
      node.dispose();
    }
    for (var node in _priceFocusNodes) {
      node.dispose();
    }
    super.dispose();
  }

  void _ensureFocusNodes(int itemCount) {
    while (_quantityFocusNodes.length < itemCount) {
      _quantityFocusNodes.add(FocusNode());
    }
    while (_priceFocusNodes.length < itemCount) {
      _priceFocusNodes.add(FocusNode());
    }
    // å¦‚æœæ¡ç›®å‡å°‘ï¼Œä¸ç«‹åˆ»é”€æ¯å·²å­˜åœ¨çš„èŠ‚ç‚¹ï¼Œé¿å…å¼‚æ­¥ rebuild æœŸé—´è®¿é—®å·²é‡Šæ”¾å¯¹è±?
  }

  Future<void> _handleNextStep(int index) async {
    final saleItems = ref.read(saleListProvider);
    if (index >= saleItems.length) return;

    _moveToNextQuantity(index);
  }

  void _moveToNextQuantity(int index) {
    final itemCount = ref.read(saleListProvider).length;
    if (index + 1 < itemCount) {
      // è·³åˆ°ä¸‹ä¸€é¡¹çš„å”®ä»·ï¼ˆå…ˆä»·æ ¼åæ•°é‡ï¼‰
      _priceFocusNodes[index + 1].requestFocus();
    } else {
      // æœ€åä¸€é¡¹åè·³åˆ°æ”¶æ¬¾
      _paymentFocusNode.requestFocus();
    }
  }

  void _addManualProduct() async {
    final result = await Navigator.of(context).push<List<dynamic>>(
      MaterialPageRoute(builder: (context) => const ProductSelectionScreen()),
    );

    // å¦‚æœæ²¡æœ‰è¿”å›ç»“æœæˆ–ç»“æœä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›?
    if (result == null || result.isEmpty) return;

    try {
      // æ ¸å¿ƒä¿®å¤ï¼šå®‰å…¨è·å–äº§å“æ•°æ?
      final List<
        ({
          ProductModel product,
          int unitId,
          String unitName,
          int conversionRate,
          int? sellingPriceInCents,
          int? wholesalePriceInCents,
        })
      >
      productsWithUnit;

      try {
        productsWithUnit = await ref.read(allProductsWithUnitProvider.future);
      } catch (e) {
        print('è·å–äº§å“å•ä½æ•°æ®å¤±è´¥: $e');
        if (!mounted) return;
        showAppSnackBar(context, message: 'è·å–äº§å“æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', isError: true);
        return;
      }

      final selectedProducts = productsWithUnit
          .where((p) => result.contains(p.product.id))
          .toList();

      for (final p in selectedProducts) {
        try {
          // å¦‚æœæ˜¯åŸºæœ¬å•ä½ï¼ˆconversionRate = 1ï¼‰ï¼Œä½¿ç”¨ Product è¡¨çš„ effectivePrice
          // å¦åˆ™ä½¿ç”¨ UnitProduct è¡¨çš„ sellingPriceInCents
          final sellingPrice = p.conversionRate == 1
              ? (p.product.effectivePrice?.cents ?? 0)
              : (p.sellingPriceInCents ?? 0);
          ref
              .read(saleListProvider.notifier)
              .addOrUpdateItem(
                product: p.product,
                unitId: p.unitId,
                unitName: p.unitName,
                sellingPriceInCents: sellingPrice,
                conversionRate: p.conversionRate,
              );
        } catch (e) {
          print('æ·»åŠ äº§å“å¤±è´¥: ${p.product.name}, é”™è¯¯: $e');
          // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªäº§å“?
        }
      }
    } catch (e) {
      // æ•è·å¹¶å¤„ç†å¯èƒ½çš„å¼‚å¸¸
      print('æ·»åŠ æ‰‹åŠ¨äº§å“æ—¶å‘ç”Ÿé”™è¯? $e');
      if (!mounted) return;
      showAppSnackBar(
        context,
        message: 'æ·»åŠ è´§å“å¤±è´¥: ${e.toString()}',
        isError: true,
      );
    }
  }

  void _scanToAddProduct() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => Scaffold(
          body: SafeArea(
            child: UniversalBarcodeScanner(
              config: const BarcodeScannerConfig(
                title: 'æ‰«ç æ·»åŠ è´§å“',
                subtitle: 'æ‰«æè´§å“æ¡ç ä»¥æ·»åŠ å…¥åº“å•',
              ),
              onBarcodeScanned: _handleSingleProductScan,
            ),
          ),
        ),
      ),
    );
  }

  void _continuousScan() {
    _lastScannedBarcode = null; // é‡ç½®ä¸Šæ¬¡æ‰«æçš„æ¡ç ?
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => Scaffold(
          body: SafeArea(
            child: UniversalBarcodeScanner(
              config: const BarcodeScannerConfig(
                title: 'è¿ç»­æ‰«ç ',
                subtitle: 'å°†æ¡ç å¯¹å‡†æ‰«ææ¡†ï¼Œè‡ªåŠ¨è¿ç»­æ·»åŠ?,
                continuousMode: true, // å¯ç”¨è¿ç»­æ‰«ç æ¨¡å¼
                continuousDelay: 1500, // è®¾ç½®æ‰«ç é—´éš”
              ),
              onBarcodeScanned: _handleContinuousProductScan,
            ),
          ),
        ),
      ),
    );
  }

  void _confirmSale() async {
    if (_isProcessing) return;
    if (!_validateForm()) return;

    setState(() => _isProcessing = true);

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        final theme = Theme.of(context);
        return AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(color: theme.colorScheme.primary),
              const SizedBox(width: 24),
              Text('æ­£åœ¨å¤„ç†...', style: theme.textTheme.titleMedium),
            ],
          ),
        );
      },
    );

    try {
      final saleService = ref.read(saleServiceProvider);
      final int? customerId;
      final String? customerName;
      final bool isSaleMode = _currentMode == SaleMode.sale;

      if (isSaleMode) {
        if (_selectedCustomer != null) {
          customerId = _selectedCustomer!.id;
          customerName = _selectedCustomer!.name;
        } else {
          // å¦‚æœå®¢æˆ·è¾“å…¥æ¡†ä¸ºç©ºï¼Œåˆ™å°†å®¢æˆ·idç½®ä¸º0
          customerId = _customerController.text.trim().isEmpty ? 0 : null;
          customerName = _customerController.text.trim().isEmpty
              ? 'åŒ¿åæ•£å®¢'
              : _customerController.text.trim();
        }
      } else {
        // éé”€å”®æ¨¡å¼?
        customerId = null;
        customerName = null;
      }

      print('ğŸ” [DEBUG] UI: Starting processOneClickSale');
      print('ğŸ” [DEBUG] UI - _selectedShop: ${_selectedShop?.id ?? "null"}');
      print(
        'ğŸ” [DEBUG] UI - _selectedCustomer: ${_selectedCustomer?.id ?? "null"}',
      );
      print(
        'ğŸ” [DEBUG] UI - _customerController: "${_customerController.text}"',
      );
      print(
        'ğŸ” [DEBUG] UI - saleItems count: ${ref.read(saleListProvider).length}',
      );
      print('ğŸ” [DEBUG] UI - remarks: "${_remarksController.text}"');
      print('ğŸ” [DEBUG] UI - isSaleMode: $isSaleMode');
      print('ğŸ” [DEBUG] UI - customerId: ${customerId ?? "null"}');
      print('ğŸ” [DEBUG] UI - customerName: $customerName');

      final receiptNumber = await saleService.processOneClickSale(
        salesOrderNo: DateTime.now().millisecondsSinceEpoch,
        shopId: _selectedShop!.id!,
        saleItems: ref.read(saleListProvider),
        remarks: _remarksController.text.isNotEmpty
            ? _remarksController.text
            : null,
        // æ–°å¢å’Œä¿®æ”¹çš„å‚æ•°
        isSaleMode: isSaleMode,
        customerId: customerId ?? 0,
        customerName: customerName,
      );
      print(
        'ğŸ” [DEBUG] UI: processOneClickSale Settled, receipt: $receiptNumber',
      );

      Navigator.of(context).pop();
      showAppSnackBar(context, message: 'âœ?é”€å”®æˆåŠŸï¼é”€å”®å•å·ï¼š$receiptNumber');

      // æ ¸å¿ƒä¿®å¤ï¼šä½¿å…¥åº“è®°å½•å’Œåº“å­˜æŸ¥è¯¢çš„Providerå¤±æ•ˆï¼Œä»¥ä¾¿åœ¨å¯¼èˆªååˆ·æ–°æ•°æ?
      ref.invalidate(inboundRecordsProvider);
      // åŒæ­¥åˆ·æ–°ï¼šä½¿å‡ºåº“è®°å½• Provider å¤±æ•ˆï¼Œåº“å­˜è®°å½•é¡µçš„â€œå‡ºåº“è®°å½•â€å¯è‡ªåŠ¨æ›´æ–°
      ref.invalidate(outboundReceiptsProvider);
      ref.invalidate(inventoryQueryProvider);

      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          // ä½¿ç”¨ go è€Œä¸æ˜?push, ä»¥æ›¿æ¢å½“å‰é¡µé¢ï¼Œè€Œä¸æ˜¯å †å?
          context.go(AppRoutes.saleRecords);
        }
      });
    } catch (e) {
      Navigator.of(context).pop();
      showAppSnackBar(
        context,
        message: 'â?é”€å”®å¤±è´? ${e.toString()}',
        isError: true,
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }

  void _confirmCreditSale() async {
    if (_isProcessing) return;
    if (!_validateForm()) return;

    setState(() => _isProcessing = true);

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        final theme = Theme.of(context);
        return AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(color: theme.colorScheme.primary),
              const SizedBox(width: 24),
              Text('æ­£åœ¨å¤„ç†...', style: theme.textTheme.titleMedium),
            ],
          ),
        );
      },
    );

    try {
      final saleService = ref.read(saleServiceProvider);
      final int? customerId;
      final String? customerName;
      final bool isSaleMode = _currentMode == SaleMode.sale;

      if (isSaleMode) {
        if (_selectedCustomer != null) {
          customerId = _selectedCustomer!.id;
          customerName = _selectedCustomer!.name;
        } else {
          // å¦‚æœå®¢æˆ·è¾“å…¥æ¡†ä¸ºç©ºï¼Œåˆ™å°†å®¢æˆ·idç½®ä¸º0
          customerId = _customerController.text.trim().isEmpty ? 0 : null;
          customerName = _customerController.text.trim().isEmpty
              ? 'åŒ¿åæ•£å®¢'
              : _customerController.text.trim();
        }
      } else {
        // éé”€å”®æ¨¡å¼?
        customerId = null;
        customerName = null;
      }

      print('ğŸ” [DEBUG] UI: Starting processOneClickSale (Credit)');
      print('ğŸ” [DEBUG] UI - _selectedShop: ${_selectedShop?.id ?? "null"}');
      print(
        'ğŸ” [DEBUG] UI - _selectedCustomer: ${_selectedCustomer?.id ?? "null"}',
      );
      print(
        'ğŸ” [DEBUG] UI - _customerController: "${_customerController.text}"',
      );
      print(
        'ğŸ” [DEBUG] UI - saleItems count: ${ref.read(saleListProvider).length}',
      );
      print('ğŸ” [DEBUG] UI - remarks: "${_remarksController.text}"');
      print('ğŸ” [DEBUG] UI - isSaleMode: $isSaleMode');
      print('ğŸ” [DEBUG] UI - customerId: ${customerId ?? "null"}');
      print('ğŸ” [DEBUG] UI - customerName: $customerName');

      final receiptNumber = await saleService.processOneClickSale(
        salesOrderNo: DateTime.now().millisecondsSinceEpoch,
        shopId: _selectedShop!.id!,
        saleItems: ref.read(saleListProvider),
        remarks: _remarksController.text.isNotEmpty
            ? _remarksController.text
            : null,
        // æ–°å¢å’Œä¿®æ”¹çš„å‚æ•°
        isSaleMode: isSaleMode,
        customerId: customerId ?? 0,
        customerName: customerName,
        status: SalesStatus.credit, // è®¾ç½®ä¸ºèµŠè´¦çŠ¶æ€?
      );
      print(
        'ğŸ” [DEBUG] UI: processOneClickSale (Credit) Settled, receipt: $receiptNumber',
      );

      Navigator.of(context).pop();
      showAppSnackBar(context, message: 'âœ?èµŠè´¦æˆåŠŸï¼é”€å”®å•å·ï¼š$receiptNumber');

      // æ ¸å¿ƒä¿®å¤ï¼šä½¿å…¥åº“è®°å½•å’Œåº“å­˜æŸ¥è¯¢çš„Providerå¤±æ•ˆï¼Œä»¥ä¾¿åœ¨å¯¼èˆªååˆ·æ–°æ•°æ?
      ref.invalidate(inboundRecordsProvider);
      // åŒæ­¥åˆ·æ–°ï¼šä½¿å‡ºåº“è®°å½• Provider å¤±æ•ˆï¼Œåº“å­˜è®°å½•é¡µçš„â€œå‡ºåº“è®°å½•â€å¯è‡ªåŠ¨æ›´æ–°
      ref.invalidate(outboundReceiptsProvider);
      ref.invalidate(inventoryQueryProvider);

      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          // ä½¿ç”¨ go è€Œä¸æ˜?push, ä»¥æ›¿æ¢å½“å‰é¡µé¢ï¼Œè€Œä¸æ˜¯å †å?
          context.go(AppRoutes.saleRecords);
        }
      });
    } catch (e) {
      Navigator.of(context).pop();
      showAppSnackBar(
        context,
        message: 'â?èµŠè´¦å¤±è´¥: ${e.toString()}',
        isError: true,
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }

  void _handleSingleProductScan(String barcode) async {
    showAppSnackBar(context, message: 'æ­£åœ¨æŸ¥è¯¢è´§å“ä¿¡æ¯...');

    try {
      final productOperations = ref.read(productOperationsProvider.notifier);
      final result = await productOperations.getProductWithUnitByBarcode(
        barcode,
      );

      if (!mounted) return;

      // æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½å…ˆå…³é—­æ‰«ç é¡µé?
      Navigator.of(context).pop();

      if (result != null) {
        // å¦‚æœæ˜¯åŸºæœ¬å•ä½ï¼ˆconversionRate = 1ï¼‰ï¼Œä½¿ç”¨ Product è¡¨çš„ effectivePrice
        // å¦åˆ™ä½¿ç”¨ UnitProduct è¡¨çš„ sellingPriceInCents
        final sellingPrice = result.conversionRate == 1
            ? (result.product.effectivePrice?.cents ?? 0)
            : (result.sellingPriceInCents ?? 0);
        ref
            .read(saleListProvider.notifier)
            .addOrUpdateItem(
              product: result.product,
              unitId: result.unitId,
              unitName: result.unitName,
              sellingPriceInCents: sellingPrice,
              conversionRate: result.conversionRate,
            );
        // æˆåŠŸæ·»åŠ å•†å“åæ’­æ”¾éŸ³æ•?
        HapticFeedback.lightImpact();
        SoundHelper.playSuccessSound();
      } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°äº§å“ï¼Œæ˜¾ç¤ºå¯¹è¯æ¡†
        _showProductNotFoundDialog(barcode);
      }
    } catch (e) {
      if (!mounted) return;
      // å…³é—­æ‰«ç é¡µé¢
      Navigator.of(context).pop();
      // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      showAppSnackBar(context, message: 'â?æŸ¥è¯¢è´§å“å¤±è´¥: $e', isError: true);
    }
  }

  void _handleContinuousProductScan(String barcode) async {
    // è¿ç»­æ‰«ç å»é‡ï¼šå¦‚æœæ¡ç ä¸ä¸Šä¸€ä¸ªç›¸åŒï¼Œåˆ™å¿½ç•?
    if (barcode == _lastScannedBarcode) {
      return;
    }

    // åœ¨è¿ç»­æ‰«ç æ¨¡å¼ä¸‹ï¼Œä¸æ˜¾ç¤ºå…¨å±€çš„åŠ è½½æç¤ºï¼Œè€Œæ˜¯å¿«é€Ÿåé¦?
    HapticFeedback.lightImpact();
    showAppSnackBar(context, message: 'æ¡ç : $barcode...');

    try {
      final productOperations = ref.read(productOperationsProvider.notifier);
      final result = await productOperations.getProductWithUnitByBarcode(
        barcode,
      );

      if (!mounted) return;

      if (result != null) {
        // å¦‚æœæ˜¯åŸºæœ¬å•ä½ï¼ˆconversionRate = 1ï¼‰ï¼Œä½¿ç”¨ Product è¡¨çš„ effectivePrice
        // å¦åˆ™ä½¿ç”¨ UnitProduct è¡¨çš„ sellingPriceInCents
        final sellingPrice = result.conversionRate == 1
            ? (result.product.effectivePrice?.cents ?? 0)
            : (result.sellingPriceInCents ?? 0);
        ref
            .read(saleListProvider.notifier)
            .addOrUpdateItem(
              product: result.product,
              unitId: result.unitId,
              unitName: result.unitName,
              sellingPriceInCents: sellingPrice,
              conversionRate: result.conversionRate,
            );
        _lastScannedBarcode = barcode; // ä»…åœ¨æˆåŠŸæ—¶æ›´æ–°ä¸Šä¸€ä¸ªæ¡ç ?
        // æˆåŠŸæ·»åŠ å•†å“åæ’­æ”¾éŸ³æ•?
        SoundHelper.playSuccessSound();
        // æˆåŠŸæ·»åŠ åç»™äºˆä¸€ä¸ªæ›´æ˜ç¡®çš„æç¤?
        showAppSnackBar(context, message: 'âœ?${result.product.name} å·²æ·»åŠ?);
      } else {
        _lastScannedBarcode = null; // å¦‚æœæœªæ‰¾åˆ°ï¼Œåˆ™å…è®¸ç«‹å³é‡æ‰?
        // æœªæ‰¾åˆ°è´§å“æ—¶ç»™äºˆä¸€ä¸ªå¤±è´¥æç¤?
        showAppSnackBar(
          context,
          message: 'â?æœªæ‰¾åˆ°æ¡ç å¯¹åº”çš„è´§å“: $barcode',
          isError: true,
        );
      }
    } catch (e) {
      if (!mounted) return;
      _lastScannedBarcode = null; // å¦‚æœå‡ºé”™ï¼Œåˆ™å…è®¸ç«‹å³é‡æ‰«
      showAppSnackBar(context, message: 'â?æŸ¥è¯¢å¤±è´¥: $e', isError: true);
    }
  }

  void _showProductNotFoundDialog(String barcode) {
    showDialog(
      context: context,
      builder: (context) {
        final theme = Theme.of(context);
        final textTheme = theme.textTheme;
        return AlertDialog(
          title: Text('è´§å“æœªæ‰¾åˆ?, style: textTheme.titleLarge),
          content: Text(
            'æ¡ç  $barcode å¯¹åº”çš„è´§å“æœªåœ¨ç³»ç»Ÿä¸­æ‰¾åˆ°ã€?,
            style: textTheme.bodyMedium,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('ç¡®å®š'),
            ),
          ],
        );
      },
    );
  }

  bool _validateForm() {
    if (_currentMode == SaleMode.sale) {
      // if (_selectedCustomer == null &&
      //     _customerController.text.trim().isEmpty) {
      //   showAppSnackBar(context, message: 'è¯·é€‰æ‹©æˆ–è¾“å…¥å®¢æˆ·åç§?, isError: true);
      //   return false;
      // }
    }
    if (_selectedShop == null) {
      showAppSnackBar(context, message: 'è¯·é€‰æ‹©å…¥åº“åº—é“º', isError: true);
      return false;
    }
    final saleItems = ref.read(saleListProvider);
    if (saleItems.isEmpty) {
      showAppSnackBar(context, message: 'è¯·å…ˆæ·»åŠ è´§å“', isError: true);
      return false;
    }
    for (final item in saleItems) {
      if (item.quantity <= 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„æ•°é‡å¿…é¡»å¤§äº?',
          isError: true,
        );
        return false;
      }
      if (_currentMode == SaleMode.sale && item.sellingPriceInCents < 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„å•ä»·ä¸èƒ½ä¸ºè´Ÿæ•°',
          isError: true,
        );
        return false;
      }
      // é‡‡è´­æ¨¡å¼ä¸‹ï¼Œå•ä»·ä¸èƒ½ä¸?
      if (_currentMode == SaleMode.sale && item.sellingPriceInCents == 0) {
        showAppSnackBar(
          context,
          message: 'è´§å“"${item.productName}"çš„å•ä»·ä¸èƒ½ä¸º0',
          isError: true,
        );
        return false;
      }
    }
    return true;
  }

  Widget _buildPaymentAndChangeSection(
    ThemeData theme,
    TextTheme textTheme,
    double change,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
      child: Card(
        elevation: 1,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Text('æ”¶æ¬¾:', style: textTheme.titleMedium),
              const SizedBox(width: 8),
              Flexible(
                flex: 1,
                child: TextFormField(
                  focusNode: _paymentFocusNode,
                  controller: _paymentController,
                  decoration: const InputDecoration(
                    prefixText: 'Â¥ ',
                    border: OutlineInputBorder(),
                    isDense: true,
                  ),
                  style: textTheme.titleMedium,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                ),
              ),
              const Spacer(flex: 1),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text('æ‰¾é›¶:', style: textTheme.titleMedium),
                  const SizedBox(width: 8),
                  Text(
                    'Â¥ ${change.toStringAsFixed(1)}',
                    style: textTheme.titleLarge?.copyWith(
                      color: change < 0
                          ? theme.colorScheme.error
                          : theme.colorScheme.primary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;

    final saleItemIds = ref.watch(
      saleListProvider.select((items) => items.map((e) => e.id).toList()),
    );
    final totals = ref.watch(saleTotalsProvider);
    final totalVarieties = totals['varieties']?.toInt() ?? 0;
    final totalQuantity = totals['quantity']?.toInt() ?? 0;
    final totalAmount = totals['amount'] ?? 0.0;

    // æ ¹æ®æ€»é‡‘é¢è‡ªåŠ¨æ›´æ–°æ”¶æ¬¾é‡‘é¢ï¼šæ”¶æ¬¾ = 100 * âŒˆæ€»é‡‘é¢?100âŒ?
    if (!_paymentFocusNode.hasFocus) {
      final calculatedPayment = totalAmount > 0
          ? (totalAmount / 100).ceil() * 100.0
          : 0.0;
      if (_paymentController.text != calculatedPayment.toStringAsFixed(0)) {
        _paymentController.text = calculatedPayment.toStringAsFixed(0);
      }
    }

    final paymentAmount = double.tryParse(_paymentController.text) ?? 0.0;
    final change = paymentAmount - totalAmount;

    _ensureFocusNodes(saleItemIds.length);

    final canPop = context.canPop();
    return PopScope(
      canPop: canPop,
      onPopInvoked: (bool didPop) {
        if (!didPop) {
          context.go('/');
        }
      },
      child: GestureDetector(
        onTap: () => FocusManager.instance.primaryFocus?.unfocus(),
        behavior: HitTestBehavior.opaque,
        child: Scaffold(
          appBar: AppBar(
            leading: !canPop
                ? IconButton(
                    icon: const Icon(Icons.arrow_back),
                    onPressed: () => context.go('/'),
                    tooltip: 'è¿”å›',
                  )
                : null,
            title: Row(mainAxisSize: MainAxisSize.min, children: [Text('æ”¶é“¶å?)]),
            actions: [const SizedBox(width: 8)],
          ),
          body: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildHeaderSection(theme, textTheme),
                const SizedBox(height: 0),
                if (saleItemIds.isEmpty)
                  _buildEmptyState(theme, textTheme)
                else
                  ...saleItemIds.asMap().entries.map((entry) {
                    final index = entry.key;
                    final itemId = entry.value;
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 0),
                      child: SaleItemCard(
                        key: ValueKey(itemId),
                        itemId: itemId,
                        shopId: _selectedShop?.id,
                        showPriceInfo: _currentMode == SaleMode.sale, // æ–°å¢
                        // ä»·æ ¼ä¸æ•°é‡?FocusNode æ³¨å…¥ï¼Œæ„å»ºç„¦ç‚¹é“¾è·?
                        sellingPriceFocusNode: _priceFocusNodes.length > index
                            ? _priceFocusNodes[index]
                            : null,
                        quantityFocusNode: _quantityFocusNodes.length > index
                            ? _quantityFocusNodes[index]
                            : null,
                        // å½“æ•°é‡æäº¤æ—¶ï¼Œè·³åˆ°ä¸‹ä¸€é¡¹çš„å”®ä»·æˆ–æ”¶æ¬?
                        onSubmitted: () => _handleNextStep(index),
                      ),
                    );
                  }),
                const SizedBox(height: 0),
                _buildActionButtons(theme, textTheme),
                const SizedBox(height: 4),
                _buildTotalsBar(
                  theme,
                  textTheme,
                  totalVarieties,
                  totalQuantity,
                  totalAmount,
                ),
                _buildPaymentAndChangeSection(theme, textTheme, change),
                const SizedBox(height: 4),
                _buildBottomAppBar(theme, textTheme),
                const SizedBox(height: 99), //åº•éƒ¨ç•™ç™½ä»¥é¿å…æŒ‰é’®è¢«é®æŒ¡
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(ThemeData theme, TextTheme textTheme) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 123, horizontal: 24),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
      ),
      child: Column(
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 56,
            color: theme.colorScheme.onSurfaceVariant.withOpacity(0.5),
          ),
          const SizedBox(height: 16),
          Text(
            'æš‚æ— è´§å“',
            style: textTheme.titleLarge?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'è¯·ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®æ·»åŠ è´§å“åˆ°å…¥åº“å?,
            style: textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant.withOpacity(0.7),
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(ThemeData theme, TextTheme textTheme) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _addManualProduct,
            icon: const Icon(Icons.add, size: 18),
            label: Text('æ·»åŠ è´§å“', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _scanToAddProduct,
            icon: const Icon(Icons.camera_alt_outlined, size: 18),
            label: Text('æ‰«ç æ·»åŠ ', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _continuousScan,
            icon: const Icon(Icons.qr_code_scanner, size: 18),
            label: Text('è¿ç»­æ‰«ç ', style: textTheme.bodyMedium),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTotalsBar(
    ThemeData theme,
    TextTheme textTheme,
    int totalVarieties,
    int totalQuantity,
    double totalAmount,
  ) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 5),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
        border: Border(
          top: BorderSide(color: theme.colorScheme.outline.withOpacity(0.3)),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          _buildTotalItem(textTheme, 'å“ç§', totalVarieties.toString()),
          _buildTotalItem(textTheme, 'æ€»æ•°', totalQuantity.toString()),
          if (_currentMode == SaleMode.sale)
            _buildTotalItem(
              textTheme,
              'æ€»é‡‘é¢?,
              'Â¥${totalAmount.toStringAsFixed(1)}',
              isAmount: true,
            ),
        ],
      ),
    );
  }

  Widget _buildTotalItem(
    TextTheme textTheme,
    String label,
    String value, {
    bool isAmount = false,
  }) {
    return RichText(
      text: TextSpan(
        style: textTheme.bodyMedium?.copyWith(
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        ),
        children: [
          TextSpan(text: '$label: '),
          TextSpan(
            text: value,
            style: textTheme.bodyLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: isAmount
                  ? Theme.of(context).colorScheme.primary
                  : Theme.of(context).colorScheme.onSurface,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBottomAppBar(ThemeData theme, TextTheme textTheme) {
    return Row(
      children: [
        Expanded(
          flex: 2, // èµŠè´¦æŒ‰é’®å?2 ä»½å®½åº?
          child: ElevatedButton.icon(
            onPressed: _isProcessing ? null : _confirmCreditSale,
            icon: _isProcessing
                ? const SizedBox(
                    width: 12,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 3,
                      color: Colors.white,
                    ),
                  )
                : const Icon(Icons.account_balance_wallet_outlined, size: 24),
            label: Text(
              _isProcessing ? 'æ­£åœ¨å¤„ç†...' : 'èµŠè´¦',
              style: textTheme.titleMedium?.copyWith(
                color: theme.colorScheme.onSecondary,
                fontWeight: FontWeight.bold,
              ),
            ),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              backgroundColor: theme.colorScheme.secondary,
              foregroundColor: theme.colorScheme.onSecondary,
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          flex: 3, // ç»“è´¦æŒ‰é’®å?3 ä»½å®½åº?
          child: ElevatedButton.icon(
            onPressed: _isProcessing ? null : _confirmSale,
            icon: _isProcessing
                ? const SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 3,
                      color: Colors.white,
                    ),
                  )
                : const Icon(Icons.check_circle_outline, size: 24),
            label: Text(
              _isProcessing ? 'æ­£åœ¨å¤„ç†...' : 'ç»“è´¦',
              style: textTheme.titleMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
              ),
            ),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 0),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              backgroundColor: theme.colorScheme.primary,
              foregroundColor: theme.colorScheme.onPrimary,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildHeaderSection(ThemeData theme, TextTheme textTheme) {
    final allShopsAsync = ref.watch(allShopsProvider);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 2,
              child: allShopsAsync.when(
                data: (shops) {
                  if (_selectedShop == null) {
                    final defaultShop = shops.firstWhereOrNull(
                      (shop) => shop.name == 'é•¿å±±çš„åº—',
                    );
                    if (defaultShop != null) {
                      WidgetsBinding.instance.addPostFrameCallback((_) {
                        if (mounted) {
                          setState(() {
                            _selectedShop = defaultShop;
                          });
                        }
                      });
                    }
                  }
                  return DropdownButtonFormField<Shop>(
                    key: const Key('shop_dropdown'),
                    focusNode: _shopFocusNode,
                    value: _selectedShop,
                    decoration: const InputDecoration(
                      isDense: true,
                      contentPadding: EdgeInsets.symmetric(vertical: 0),
                    ),
                    items: shops
                        .map(
                          (shop) => DropdownMenuItem(
                            value: shop,
                            child: Text(shop.name),
                          ),
                        )
                        .toList(),
                    onChanged: (value) {
                      setState(() {
                        _selectedShop = value;
                      });
                    },
                  );
                },
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (err, stack) => Text('æ— æ³•åŠ è½½åº—é“º: $err'),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              flex: 5,
              child: _currentMode == SaleMode.sale
                  ? Row(
                      crossAxisAlignment: CrossAxisAlignment.baseline,
                      textBaseline: TextBaseline.alphabetic,
                      children: [
                        Text('é¡¾å®¢:', style: const TextStyle(fontSize: 17)),
                        const SizedBox(width: 8),
                        Expanded(
                          child: TypeAheadField<Customer>(
                            key: const Key('customer_typeahead'),
                            controller: _customerController,
                            focusNode: _customerFocusNode,
                            suggestionsCallback: (pattern) async {
                              final allCustomers = await ref.read(
                                allCustomersProvider.future,
                              );
                              if (pattern.isEmpty) {
                                return allCustomers;
                              }
                              return allCustomers
                                  .where(
                                    (customer) => customer.name
                                        .toLowerCase()
                                        .contains(pattern.toLowerCase()),
                                  )
                                  .toList();
                            },
                            itemBuilder: (context, suggestion) {
                              return ListTile(
                                title: Text(suggestion.name),
                                contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 16.0,
                                ),
                              );
                            },
                            onSelected: (suggestion) {
                              setState(() {
                                _selectedCustomer = suggestion;
                                _customerController.text = suggestion.name;
                              });
                              // é€‰ä¸­å®¢æˆ·åå¤±å»ç„¦ç‚?
                              _customerFocusNode.unfocus();
                            },
                            builder: (context, controller, focusNode) {
                              return TextField(
                                controller: controller,
                                focusNode: focusNode,
                                decoration: const InputDecoration(
                                  hintText: 'æœç´¢æˆ–é€‰æ‹©',
                                  isDense: true,
                                  contentPadding: EdgeInsets.symmetric(
                                    vertical: 0,
                                  ),
                                ),
                                textInputAction: TextInputAction.next,
                                onSubmitted: (_) {
                                  // é¡¾å®¢åè·³åˆ°é¦–ä¸ªå”®ä»·ï¼›å¦‚æœæ²¡æœ‰æ¡ç›®åˆ™è·³åˆ°æ”¶æ¬?
                                  WidgetsBinding.instance.addPostFrameCallback((
                                    _,
                                  ) {
                                    if (_priceFocusNodes.isNotEmpty) {
                                      _priceFocusNodes.first.requestFocus();
                                    } else {
                                      _paymentFocusNode.requestFocus();
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.baseline,
                      textBaseline: TextBaseline.alphabetic,
                      children: [
                        Text('æ¥æº:', style: const TextStyle(fontSize: 17)),
                        const SizedBox(width: 8),
                        Expanded(
                          child: TextFormField(
                            controller: _sourceController,
                            style: const TextStyle(fontSize: 15.5),
                            decoration: const InputDecoration(
                              hintText: 'è¾“å…¥è´§å“æ¥æº (å¯é€?',
                              isDense: true,
                              contentPadding: EdgeInsets.symmetric(vertical: 0),
                            ),
                          ),
                        ),
                      ],
                    ),
            ),
          ],
        ),
        const SizedBox(height: 5),
        // Divider(color: theme.colorScheme.outline.withOpacity(0.5)),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import '../../application/provider/customer_providers.dart';
import '../../domain/model/customer.dart';
import '../../../../core/shared_widgets/loading_widget.dart';
import '../../../../core/shared_widgets/error_widget.dart';
import '../../../../core/utils/snackbar_helper.dart';

class CustomerSelectionScreen extends ConsumerStatefulWidget {
  final int? selectedCustomerId;

  const CustomerSelectionScreen({
    super.key,
    this.selectedCustomerId,
  });

  @override
  ConsumerState<CustomerSelectionScreen> createState() =>
      _CustomerSelectionScreenState();
}

class _CustomerSelectionScreenState extends ConsumerState<CustomerSelectionScreen> {
  int? _selectedCustomerId;

  @override
  void initState() {
    super.initState();
    _selectedCustomerId = widget.selectedCustomerId;
  }

  @override
  Widget build(BuildContext context) {
    final customersAsyncValue = ref.watch(allCustomersProvider);
    final controllerState = ref.watch(customerControllerProvider);

    ref.listen<AsyncValue<void>>(customerControllerProvider, (previous, next) {
      if (!next.isLoading && !next.hasError) {
        showAppSnackBar(context, message: 'æ“ä½œæˆåŠŸ');
      } else if (next.hasError) {
        showAppSnackBar(context,
            message: next.error.toString(), isError: true);
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('é€‰æ‹©å®¢æˆ·'),
        actions: [
          IconButton(
            onPressed: () => _showAddCustomerDialog(context),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å¢å®¢æˆ·',
          ),
        ],
      ),
      body: Column(
        children: [
          if (controllerState.isLoading) const LinearProgressIndicator(),
          Expanded(
            child: customersAsyncValue.when(
              data: (customers) => _buildCustomerList(context, customers),
              loading: () => const LoadingWidget(message: 'åŠ è½½å®¢æˆ·åˆ—è¡¨ä¸?..'),
              error: (error, stackTrace) => CustomErrorWidget(
                message: 'åŠ è½½å®¢æˆ·åˆ—è¡¨å¤±è´¥',
                onRetry: () => ref.invalidate(allCustomersProvider),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCustomerList(BuildContext context, List<Customer> customers) {
    if (customers.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.people, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text('æš‚æ— å®¢æˆ·', style: TextStyle(fontSize: 18, color: Colors.grey)),
            SizedBox(height: 8),
            Text(
              'ç‚¹å‡»å³ä¸Šè§’çš„ + å·æ·»åŠ æ–°å®¢æˆ·',
              style: TextStyle(fontSize: 14, color: Colors.grey),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () async {
        ref.invalidate(allCustomersProvider);
      },
      child: ListView.builder(
        padding: const EdgeInsets.symmetric(vertical: 8),
        itemCount: customers.length,
        itemBuilder: (context, index) {
          final customer = customers[index];
          return _buildCustomerTile(context, customer);
        },
      ),
    );
  }

  Widget _buildCustomerTile(BuildContext context, Customer customer) {
    final isSelected = _selectedCustomerId == customer.id;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Slidable(
        key: ValueKey(customer.id),
        endActionPane: ActionPane(
          motion: const DrawerMotion(),
          children: [
            Expanded(
              child: CustomSlidableAction(
                onPressed: (context) {
                  if (customer.id != null) {
                    ref
                        .read(customerControllerProvider.notifier)
                        .deleteCustomer(customer.id!.toString());
                  }
                },
                backgroundColor: Colors.red,
                child: const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.delete, color: Colors.white),
                    SizedBox(width: 8),
                    Text('åˆ é™¤', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
            ),
          ],
        ),
        child: Card(
          margin: const EdgeInsets.symmetric(horizontal: 16),
          elevation: isSelected ? 4 : 1,
          color: isSelected
              ? Theme.of(context).primaryColor.withOpacity(0.1)
              : null,
          child: ListTile(
            dense: true,
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0.0),
            title: Text(
              customer.name,
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                fontSize: 16,
              ),
            ),
            onTap: () {
              setState(() {
                _selectedCustomerId = customer.id;
              });
              _confirmSelection();
            },
          ),
        ),
      ),
    );
  }

  void _showAddCustomerDialog(BuildContext context) {
    final nameController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('æ–°å¢å®¢æˆ·'),
        content: Form(
          key: formKey,
          child: TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'å®¢æˆ·åç§°',
              hintText: 'è¯·è¾“å…¥å®¢æˆ·åç§?,
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.person),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'è¯·è¾“å…¥å®¢æˆ·åç§?;
              }
              return null;
            },
            autofocus: true,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                final customerName = nameController.text.trim();

                final controller =
                    ref.read(customerControllerProvider.notifier);
                final exists = await controller.isCustomerNameExists(customerName);

                if (exists) {
                  showAppSnackBar(context,
                      message: 'å®¢æˆ·åç§°å·²å­˜åœ?, isError: true);
                  return;
                }

                final customer = Customer(
                  name: customerName,
                );

                await controller.addCustomer(customer);

                if (mounted) {
                  Navigator.of(context).pop();
                }
              }
            },
            child: const Text('æ·»åŠ '),
          ),
        ],
      ),
    );
  }

  void _confirmSelection() {
    if (_selectedCustomerId != null) {
      final customers = ref.read(allCustomersProvider).value ?? [];
      final selectedCustomer = customers.firstWhere(
        (customer) => customer.id == _selectedCustomerId,
        orElse: () => throw Exception('é€‰ä¸­çš„å®¢æˆ·ä¸å­˜åœ¨'),
      );

      Navigator.of(context).pop(selectedCustomer);
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import '../../../../core/constants/app_routes.dart';
import '../../application/provider/customer_providers.dart';
import '../../data/dao/sales_transaction_dao.dart';
import '../../data/dao/sales_transaction_item_dao.dart';
import '../../../../core/database/database.dart';
import '../../../product/data/repository/product_repository.dart';

// Provider for SalesTransactionDao
final salesTransactionDaoProvider = Provider<SalesTransactionDao>((ref) {
  final database = ref.watch(appDatabaseProvider);
  return database.salesTransactionDao;
});

// Provider for SalesTransactionItemDao
final salesTransactionItemDaoProvider = Provider<SalesTransactionItemDao>((
  ref,
) {
  final database = ref.watch(appDatabaseProvider);
  return database.salesTransactionItemDao;
});

// Provider to watch all sales transactions
final salesTransactionsProvider = StreamProvider<List<SalesTransactionData>>((
  ref,
) {
  final dao = ref.watch(salesTransactionDaoProvider);
  // Sort by created date descending
  return dao.watchAllSalesTransactions().map(
    (sales) => sales..sort((a, b) => b.createdAt.compareTo(a.createdAt)),
  );
});

// Provider to get items for a specific sale
final salesTransactionItemsProvider =
    FutureProvider.family<List<SalesTransactionItemData>, String>((
      ref,
      saleId,
    ) {
      final dao = ref.watch(salesTransactionItemDaoProvider);
      return dao.findSalesTransactionItemsByTransactionId(saleId);
    });

class SalesRecordsScreen extends ConsumerWidget {
  const SalesRecordsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final salesAsync = ref.watch(salesTransactionsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('é”€å”®è®°å½?),
        actions: [
          IconButton(
            onPressed: () => context.push(AppRoutes.saleCreate),
            icon: const Icon(Icons.add),
            tooltip: 'æ–°å»ºé”€å”®å•',
          ),
        ],
      ),
      body: salesAsync.when(
        data: (sales) {
          if (sales.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.receipt_long, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    'æš‚æ— é”€å”®è®¢å?,
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                ],
              ),
            );
          }
          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: sales.length,
            itemBuilder: (context, index) {
              final sale = sales[index];
              return SaleOrderCard(sale: sale);
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('åŠ è½½å¤±è´¥: $error')),
      ),
    );
  }
}

class SaleOrderCard extends ConsumerWidget {
  final SalesTransactionData sale;

  const SaleOrderCard({super.key, required this.sale});

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final customersAsync = ref.watch(allCustomersProvider);
    final itemsAsync = ref.watch(
      salesTransactionItemsProvider(sale.id.toString()),
    );

    Widget cardContent = Card(
      margin: EdgeInsets.zero,
      child: InkWell(
        child: ExpansionTile(
          title: Row(
            children: [
              Text(
                'é”€å”®å•å? ${sale.id}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              if (sale.status == 'credit') ...[
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.orange.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'èµŠè´¦',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
              if (sale.status == 'settled') ...[
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'å·²ç»“æ¸?,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ],
          ),
          subtitle: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                _formatDateTime(sale.createdAt),
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
              const SizedBox(height: 4),
              customersAsync.when(
                data: (customers) {
                  final customer = customers
                      .where((c) => c.id == sale.customerId)
                      .firstOrNull;
                  return Text('å®¢æˆ·: ${customer?.name ?? 'æœªçŸ¥'}');
                },
                loading: () => const Text('å®¢æˆ·: åŠ è½½ä¸?..'),
                error: (_, __) => const Text('å®¢æˆ·: åŠ è½½å¤±è´¥'),
              ),
            ],
          ),
          trailing: itemsAsync.when(
            data: (items) {
              final totalAmount = items.fold<double>(
                0,
                (sum, item) => sum + (item.priceInCents * item.quantity),
              );
              final totalQuantity = items.fold<int>(
                0,
                (sum, item) => sum + item.quantity,
              );
              return Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    'ï¿?{(totalAmount / 100).toStringAsFixed(2)}',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.red,
                    ),
                  ),
                  Text(
                    '${totalQuantity.toInt()}ä»?,
                    style: const TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                ],
              );
            },
            loading: () => const SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
            error: (_, __) => const Icon(Icons.error, color: Colors.red),
          ),
          children: [
            itemsAsync.when(
              data: (items) => Column(
                children: items
                    .map((item) => SaleOrderItemTile(item: item))
                    .toList(),
              ),
              loading: () => const Padding(
                padding: EdgeInsets.all(16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
              error: (e, s) => Padding(
                padding: const EdgeInsets.all(16.0),
                child: Center(child: Text('åŠ è½½æ˜ç»†å¤±è´¥: $e')),
              ),
            ),
          ],
        ),
      ),
    );

    // åªæœ‰èµŠè´¦å•æ‰èƒ½å·¦æ»‘æ˜¾ç¤ºé”€è´¦æŒ‰é’?
    Widget content;
    if (sale.status == 'credit') {
      content = Slidable(
        endActionPane: ActionPane(
          motion: const DrawerMotion(),
          extentRatio: 0.25,
          children: [
            SlidableAction(
              onPressed: (context) {
                _handleSettlePayment(context, ref);
              },
              backgroundColor: Colors.green,
              foregroundColor: Colors.white,
              icon: Icons.check_circle,
              label: 'é”€è´?,
              borderRadius: BorderRadius.circular(12),
              padding: EdgeInsets.zero,
              autoClose: true,
              flex: 1,
            ),
          ],
        ),
        child: cardContent,
      );
    } else {
      content = cardContent;
    }

    return Container(margin: const EdgeInsets.all(4.0), child: content);
  }

  Future<void> _handleSettlePayment(BuildContext context, WidgetRef ref) async {
    final dao = ref.read(salesTransactionDaoProvider);
    final success = await dao.updateSalesTransactionStatus(sale.id, 'settled');

    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('é”€è´¦æˆåŠ?), backgroundColor: Colors.green),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('é”€è´¦å¤±è´¥ï¼Œè¯·é‡è¯?), backgroundColor: Colors.red),
      );
    }
  }
}

class SaleOrderItemTile extends ConsumerWidget {
  final SalesTransactionItemData item;

  const SaleOrderItemTile({super.key, required this.item});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productAsync = ref.watch(productByIdProvider(item.productId));
    return ListTile(
      contentPadding: const EdgeInsets.only(
        left: 3,
        right: 16,
        top: 0,
        bottom: 0,
      ),
      minVerticalPadding: 0,
      dense: true,
      visualDensity: const VisualDensity(horizontal: 0, vertical: -3),
      minLeadingWidth: 0,
      title: Row(
        children: [
          Text(' ${item.id}  ', style: const TextStyle(fontSize: 14)),
          const SizedBox(width: 6),
          Expanded(
            child: productAsync.when(
              data: (product) => Text(
                product?.name ?? 'è´§å“ID: ${item.productId}',
                style: const TextStyle(fontSize: 16),
              ),
              loading: () => const Text('åŠ è½½ä¸?..'),
              error: (err, stack) => Text(
                'åŠ è½½è´§å“å¤±è´¥',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ),
          ),
        ],
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            'ï¿?{(item.priceInCents / 100).toStringAsFixed(2)} Ã— ${item.quantity.toInt()}',
          ),
          Text(
            'ï¿?{(item.priceInCents * item.quantity / 100).toStringAsFixed(2)}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../product/application/provider/product_providers.dart';
import '../../../product/application/provider/batch_providers.dart';
import '../../../../core/widgets/cached_image_widget.dart';
import '../../application/provider/sale_list_provider.dart';
import '../../domain/model/sale_cart_item.dart';

/// é”€å”®å•å•†å“é¡¹å¡ç‰?
/// æ˜¾ç¤ºå•†å“ä¿¡æ¯ã€ä»·æ ¼ã€æ•°é‡å’Œé‡‘é¢è¾“å…¥ç­?
class SaleItemCard extends ConsumerStatefulWidget {
  final String itemId;
  final FocusNode? quantityFocusNode;
  // æ–°å¢ï¼šå…è®¸å¤–éƒ¨ä¼ å…¥å”®ä»·è¾“å…¥æ¡†çš?FocusNodeï¼Œç”¨äºè·¨å¡ç‰‡ç„¦ç‚¹é“¾è·¯
  final FocusNode? sellingPriceFocusNode;
  final VoidCallback? onSubmitted;
  final bool showPriceInfo;
  // æ–°å¢ï¼šç”¨äºåŠ è½½æ‰¹æ¬¡ï¼ˆæŒ‰äº§å“?åº—é“ºï¼?
  final int? shopId;

  const SaleItemCard({
    required super.key,
    required this.itemId,
    this.quantityFocusNode,
    this.sellingPriceFocusNode,
    this.onSubmitted,
    this.showPriceInfo = true,
    this.shopId,
  });

  @override
  ConsumerState<SaleItemCard> createState() => _SaleItemCardState();
}

class _SaleItemCardState extends ConsumerState<SaleItemCard> {
  final _sellingPriceController = TextEditingController();
  final _quantityController = TextEditingController();

  final _sellingPriceFocusNode = FocusNode();

  // ç»Ÿä¸€è·å–å½“å‰ä½¿ç”¨çš„å”®ä»?FocusNodeï¼ˆå¤–éƒ¨ä¼˜å…ˆï¼Œå…¶æ¬¡å†…éƒ¨ï¼?
  FocusNode get _priceNode =>
      widget.sellingPriceFocusNode ?? _sellingPriceFocusNode;

  void _onSellingPriceFocusChange() {
    if (_priceNode.hasFocus) {
      _sellingPriceController.clear();
    } else {
      if (_sellingPriceController.text.isEmpty) {
        final item = ref
            .read(saleListProvider)
            .firstWhere((it) => it.id == widget.itemId);
        // æ˜¾ç¤ºä¸ºå…ƒï¼ˆåˆ†/100ï¼?
        _sellingPriceController.text = (item.sellingPriceInCents / 100)
            .toStringAsFixed(1);
      }
    }
  }

  void _onQuantityFocusChange() {
    if (widget.quantityFocusNode?.hasFocus == true) {
      _quantityController.clear();
    } else {
      if (_quantityController.text.isEmpty) {
        final item = ref
            .read(saleListProvider)
            .firstWhere((it) => it.id == widget.itemId);
        _quantityController.text = item.quantity.toStringAsFixed(0);
      }
    }
  }

  @override
  void initState() {
    super.initState();
    _priceNode.addListener(_onSellingPriceFocusChange);
    widget.quantityFocusNode?.addListener(_onQuantityFocusChange);
  }

  @override
  void didUpdateWidget(SaleItemCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.quantityFocusNode != oldWidget.quantityFocusNode) {
      oldWidget.quantityFocusNode?.removeListener(_onQuantityFocusChange);
      widget.quantityFocusNode?.addListener(_onQuantityFocusChange);
    }
    if (widget.sellingPriceFocusNode != oldWidget.sellingPriceFocusNode) {
      // åˆ‡æ¢å¤–éƒ¨å”®ä»· FocusNode æ—¶ï¼Œè¿ç§»ç›‘å¬
      (oldWidget.sellingPriceFocusNode ?? _sellingPriceFocusNode)
          .removeListener(_onSellingPriceFocusChange);
      _priceNode.addListener(_onSellingPriceFocusChange);
    }
  }

  @override
  void dispose() {
    _sellingPriceController.dispose();
    _quantityController.dispose();
    // ä»…ç§»é™¤ç›‘å¬ï¼›ä»…é”€æ¯å†…éƒ¨èŠ‚ç‚?
    (widget.sellingPriceFocusNode ?? _sellingPriceFocusNode).removeListener(
      _onSellingPriceFocusChange,
    );
    _sellingPriceFocusNode.dispose();
    widget.quantityFocusNode?.removeListener(_onQuantityFocusChange);
    super.dispose();
  }

  void _updateItem(SaleCartItem item) {
    // å°†è¾“å…¥çš„å°æ•°ä»·æ ¼ï¼ˆå…ƒï¼‰è½¬æ¢ä¸ºåˆ?
    final String priceText = _sellingPriceController.text.trim();
    final sellingPriceInCents = ((double.tryParse(priceText) ?? 0) * 100)
        .round();
    final quantity = int.tryParse(_quantityController.text) ?? 0;
    final amount = sellingPriceInCents / 100 * quantity;

    final updatedItem = item.copyWith(
      sellingPriceInCents: sellingPriceInCents,
      quantity: quantity.toDouble(),
      amount: amount,
    );

    ref.read(saleListProvider.notifier).updateItem(updatedItem);
  }

  void _updateItemBatch(SaleCartItem item, int? batchId) {
    final updatedItem = item.copyWith(batchId: batchId?.toString());
    ref.read(saleListProvider.notifier).updateItem(updatedItem);
  }

  @override
  Widget build(BuildContext context) {
    final item = ref.watch(
      saleListProvider.select(
        (items) => items.firstWhere((it) => it.id == widget.itemId),
      ),
    );

    if (!_priceNode.hasFocus &&
        _sellingPriceController.text !=
            (item.sellingPriceInCents / 100).toStringAsFixed(2)) {
      // åŒæ­¥æ§åˆ¶å™¨æ–‡æœ¬ä¸ºå…ƒï¼ˆåˆ?100ï¼?
      _sellingPriceController.text = (item.sellingPriceInCents / 100)
          .toStringAsFixed(1);
    }
    if (widget.quantityFocusNode?.hasFocus == false &&
        _quantityController.text != item.quantity.toStringAsFixed(0)) {
      _quantityController.text = item.quantity.toStringAsFixed(0);
    }

    return Card(
      elevation: 2,
      child: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.all(3),
            child: Consumer(
              builder: (context, ref, _) {
                final productAsync = ref.watch(
                  productByIdProvider(item.productId),
                );

                return productAsync.when(
                  loading: () => const SizedBox(
                    height: 80,
                    child: Center(child: CircularProgressIndicator()),
                  ),
                  error: (e, st) => const SizedBox(
                    height: 80,
                    child: Center(
                      child: Icon(Icons.error, color: Colors.red, size: 30),
                    ),
                  ),
                  data: (product) {
                    return Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 60,
                          height: 80,
                          child: product?.image?.isNotEmpty == true
                              ? CachedImageWidget(
                                  imagePath: product!.image!,
                                  fit: BoxFit.cover,
                                )
                              : const Center(
                                  child: Icon(
                                    Icons.image_outlined,
                                    color: Colors.grey,
                                    size: 30,
                                  ),
                                ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Row(
                                crossAxisAlignment: CrossAxisAlignment.center,
                                children: [
                                  SizedBox(
                                    width: 120,
                                    child: Text(
                                      item.productName,
                                      style: const TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w500,
                                      ),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),

                                  // æ‰¹æ¬¡ï¼ˆç”Ÿäº§æ—¥æœŸï¼‰é€‰æ‹©ï¼šä»…å½“å¯ç”¨æ‰¹æ¬¡ç®¡ç†ä¸”å­˜åœ¨åº—é“ºID
                                  if (product?.enableBatchManagement == true &&
                                      widget.shopId != null) ...[
                                    const SizedBox(width: 8),
                                    SizedBox(
                                      width: 130,
                                      child: Consumer(
                                        builder: (context, ref, __) {
                                          final batchesAsync = ref.watch(
                                            batchesByProductAndShopProvider((
                                              productId: item.productId,
                                              shopId: widget.shopId!,
                                            )),
                                          );
                                          return batchesAsync.when(
                                            loading: () => const SizedBox(
                                              height: 30,
                                              child: Center(
                                                child: SizedBox(
                                                  width: 16,
                                                  height: 16,
                                                  child:
                                                      CircularProgressIndicator(
                                                        strokeWidth: 2,
                                                      ),
                                                ),
                                              ),
                                            ),
                                            error: (e, st) => const SizedBox(
                                              height: 30,
                                              child: Center(
                                                child: Icon(
                                                  Icons.error,
                                                  size: 16,
                                                  color: Colors.red,
                                                ),
                                              ),
                                            ),
                                            data: (list) {
                                              // é€‰é¡¹ï¼šæ˜¾ç¤ºç”Ÿäº§æ—¥æœŸï¼ˆæŒ?id å»é‡ï¼Œé˜²æ­¢å‡ºç°é‡å¤?valueï¼?
                                              final options = list;
                                              final uniqueOptions = {
                                                for (final b in options)
                                                  b.id: b,
                                              }.values.toList();
                                              final selectedId = int.tryParse(
                                                item.batchId ?? '',
                                              );

                                              // è‹¥å½“å‰é€‰ä¸­æ‰¹æ¬¡ä¸åœ¨æ–°åº—é“ºçš„æ‰¹æ¬¡åˆ—è¡¨ä¸­ï¼Œç½®ç©ºä»¥é¿å…?Dropdown çš„æ–­è¨€é”™è¯¯
                                              final isValid =
                                                  selectedId != null &&
                                                  uniqueOptions.any(
                                                    (b) => b.id == selectedId,
                                                  );

                                              // è‹¥æ— æœ‰æ•ˆé€‰æ‹©ï¼Œåˆ™é»˜è®¤ä½¿ç”¨æœ€æ—©çš„ç”Ÿäº§æ—¥æœŸ
                                              int? defaultId;
                                              if (!isValid &&
                                                  uniqueOptions.isNotEmpty) {
                                                final sortedByDate =
                                                    [...uniqueOptions]..sort(
                                                      (a, b) => a.productionDate
                                                          .compareTo(
                                                            b.productionDate,
                                                          ),
                                                    );
                                                defaultId =
                                                    sortedByDate.first.id;
                                              }

                                              final effectiveValue = isValid
                                                  ? selectedId
                                                  : defaultId;

                                              // å¼‚æ­¥å°†é»˜è®¤å€¼å†™å›ï¼ˆæˆ–åœ¨åˆ‡æ¢åº—é“ºåä¿®æ­£ä¸ºæœ‰æ•ˆé»˜è®¤å€¼ï¼‰
                                              if (!isValid &&
                                                  effectiveValue != null) {
                                                WidgetsBinding.instance
                                                    .addPostFrameCallback((_) {
                                                      _updateItemBatch(
                                                        item,
                                                        effectiveValue,
                                                      );
                                                    });
                                              }

                                              return DropdownButtonFormField<
                                                int
                                              >(
                                                isDense: true,
                                                value: effectiveValue,
                                                decoration:
                                                    const InputDecoration(
                                                      isDense: true,
                                                      contentPadding:
                                                          EdgeInsets.symmetric(
                                                            horizontal: 8,
                                                            vertical: 6,
                                                          ),
                                                      border:
                                                          OutlineInputBorder(),
                                                    ),
                                                hint: const Text('ç”Ÿäº§æ—¥æœŸ'),
                                                items: uniqueOptions
                                                    .map(
                                                      (b) =>
                                                          DropdownMenuItem<int>(
                                                            value: b.id,
                                                            child: Text(
                                                              // ä»…æ—¥æœŸéƒ¨åˆ?
                                                              b.productionDate
                                                                  .toLocal()
                                                                  .toString()
                                                                  .split(' ')
                                                                  .first,
                                                              overflow:
                                                                  TextOverflow
                                                                      .ellipsis,
                                                            ),
                                                          ),
                                                    )
                                                    .toList(),
                                                onChanged: (val) {
                                                  _updateItemBatch(item, val);
                                                },
                                              );
                                            },
                                          );
                                        },
                                      ),
                                    ),
                                  ],

                                  const Spacer(),
                                ],
                              ),
                              const SizedBox(height: 3),
                              if (widget.showPriceInfo)
                                Row(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Expanded(
                                      flex: 6,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'å”®ä»·',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: TextFormField(
                                              controller:
                                                  _sellingPriceController,
                                              focusNode: _priceNode,
                                              keyboardType:
                                                  const TextInputType.numberWithOptions(
                                                    decimal: true,
                                                  ),
                                              textInputAction:
                                                  TextInputAction.next,
                                              decoration: const InputDecoration(
                                                border: OutlineInputBorder(),
                                                contentPadding:
                                                    EdgeInsets.symmetric(
                                                      horizontal: 12,
                                                      vertical: 7,
                                                    ),
                                                // prefixText: 'Â¥',
                                              ),
                                              onChanged: (value) =>
                                                  _updateItem(item),
                                              onFieldSubmitted: (value) {
                                                // ä»·æ ¼å›è½¦åï¼Œå…ˆè·³åˆ°åŒå¡ç‰‡çš„æ•°é‡ï¼›è‹¥æ— æ•°é‡èŠ‚ç‚¹ï¼Œåˆ™äº¤ç»™çˆ¶å±‚å¤„ç†
                                                if (widget.quantityFocusNode !=
                                                    null) {
                                                  widget.quantityFocusNode!
                                                      .requestFocus();
                                                } else {
                                                  widget.onSubmitted?.call();
                                                }
                                              },
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                    const SizedBox.square(dimension: 12.0),
                                    Expanded(
                                      flex: 4,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'æ•°é‡',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: TextFormField(
                                              controller: _quantityController,
                                              focusNode:
                                                  widget.quantityFocusNode,
                                              keyboardType:
                                                  const TextInputType.numberWithOptions(
                                                    decimal: false,
                                                  ),
                                              textInputAction:
                                                  TextInputAction.next,
                                              decoration: const InputDecoration(
                                                border: OutlineInputBorder(),
                                                contentPadding:
                                                    EdgeInsets.symmetric(
                                                      horizontal: 12,
                                                      vertical: 4,
                                                    ),
                                              ),
                                              onChanged: (value) =>
                                                  _updateItem(item),
                                              onFieldSubmitted: (value) =>
                                                  widget.onSubmitted?.call(),
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                    const SizedBox.square(dimension: 12.0),

                                    Padding(
                                      padding: const EdgeInsets.only(top: 24.0),
                                      child: Text(
                                        item.unitName,
                                        style: TextStyle(
                                          fontSize: 16,
                                          color: Colors.grey[600],
                                        ),
                                      ),
                                    ),
                                    const SizedBox(width: 22.0),

                                    Expanded(
                                      flex: 7,
                                      child: Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          const Text(
                                            'é‡‘é¢',
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.grey,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          SizedBox(
                                            height: 27,
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Padding(
                                                padding:
                                                    const EdgeInsets.symmetric(
                                                      horizontal: 12.0,
                                                    ),
                                                child: Text(
                                                  'Â¥${item.amount.toStringAsFixed(1)}',
                                                  style: const TextStyle(
                                                    fontSize: 14,
                                                  ),
                                                ),
                                              ),
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ],
                                ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                );
              },
            ),
          ),
          Positioned(
            top: -15,
            right: -15,
            child: IconButton(
              onPressed: () =>
                  ref.read(saleListProvider.notifier).removeItem(widget.itemId),
              icon: const Icon(Icons.close, size: 18),
              style: IconButton.styleFrom(
                backgroundColor: Colors.red.shade50,
                foregroundColor: Colors.red,
                minimumSize: const Size(24, 24),
                padding: EdgeInsets.zero,
              ),
              tooltip: 'åˆ é™¤',
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../../../core/services/image_cache_service.dart';
import '../../../../core/utils/snackbar_helper.dart';

/// å›¾ç‰‡ç¼“å­˜ç®¡ç†é¡µé¢
/// æä¾›ç¼“å­˜çŠ¶æ€æŸ¥çœ‹å’Œç®¡ç†åŠŸèƒ½
class ImageCacheManagementScreen extends StatefulWidget {
  const ImageCacheManagementScreen({super.key});

  @override
  State<ImageCacheManagementScreen> createState() =>
      _ImageCacheManagementScreenState();
}

class _ImageCacheManagementScreenState
    extends State<ImageCacheManagementScreen> {
  final ImageCacheService _cacheService = ImageCacheService();
  Map<String, dynamic>? _cacheStatus;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadCacheStatus();
  }

  Future<void> _loadCacheStatus() async {
    setState(() {
      _isLoading = true;
    });

    try {
      final status = _cacheService.getCacheStatus();
      setState(() {
        _cacheStatus = status;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      showAppSnackBar(context, message: 'è·å–ç¼“å­˜çŠ¶æ€å¤±è´? $e', isError: true);
    }
  }

  Future<void> _clearAllCache() async {
    final confirmed = await _showConfirmDialog(
      'æ¸…ç†æ‰€æœ‰ç¼“å­?,
      'ç¡®å®šè¦æ¸…ç†æ‰€æœ‰å›¾ç‰‡ç¼“å­˜å—ï¼Ÿè¿™ä¸ªæ“ä½œä¸å¯æ¢å¤ã€?,
    );

    if (confirmed) {
      setState(() {
        _isLoading = true;
      });

      try {
        await _cacheService.clearAllCache();
        await _loadCacheStatus();
        showAppSnackBar(context, message: 'ç¼“å­˜æ¸…ç†å®Œæˆ');
      } catch (e) {
        setState(() {
          _isLoading = false;
        });
        showAppSnackBar(context, message: 'æ¸…ç†ç¼“å­˜å¤±è´¥: $e', isError: true);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('å›¾ç‰‡ç¼“å­˜ç®¡ç†'),
        actions: [
          IconButton(
            onPressed: _loadCacheStatus,
            icon: const Icon(Icons.refresh),
            tooltip: 'åˆ·æ–°',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _buildContent(),
    );
  }

  Widget _buildContent() {
    if (_cacheStatus == null) {
      return const Center(child: Text('æ— æ³•è·å–ç¼“å­˜çŠ¶æ€?));
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildCacheOverviewCard(),
          const SizedBox(height: 16),
          _buildCacheDetailsCard(),
          const SizedBox(height: 16),
          _buildActionsCard(),
          const SizedBox(height: 16),
          _buildTipsCard(),
        ],
      ),
    );
  }

  Widget _buildCacheOverviewCard() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.cached, color: Theme.of(context).primaryColor),
                const SizedBox(width: 8),
                Text(
                  'ç¼“å­˜æ¦‚è§ˆ',
                  style: Theme.of(
                    context,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatusItem(
                    'å†…å­˜ç¼“å­˜',
                    '${_cacheStatus!['memoryCount']}/${_cacheStatus!['maxMemorySize']}',
                    Colors.blue,
                    Icons.memory,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildStatusItem(
                    'å­—èŠ‚ç¼“å­˜',
                    '${_cacheStatus!['byteCount']}/${_cacheStatus!['maxByteSize']}',
                    Colors.green,
                    Icons.storage,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCacheDetailsCard() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.info_outline, color: Theme.of(context).primaryColor),
                const SizedBox(width: 8),
                Text(
                  'ç¼“å­˜è¯¦æƒ…',
                  style: Theme.of(
                    context,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildDetailItem(
              'ç¼©ç•¥å›¾ç¼“å­˜ç›®å½?,
              _cacheStatus!['thumbnailCacheDir'] ?? 'æœªè®¾ç½?,
              Icons.folder,
            ),
            const SizedBox(height: 8),
            _buildDetailItem(
              'å†…å­˜ç¼“å­˜ä½¿ç”¨ç?,
              '${((_cacheStatus!['memoryCount'] as int) / (_cacheStatus!['maxMemorySize'] as int) * 100).toStringAsFixed(1)}%',
              Icons.pie_chart,
            ),
            const SizedBox(height: 8),
            _buildDetailItem(
              'å­—èŠ‚ç¼“å­˜ä½¿ç”¨ç?,
              '${((_cacheStatus!['byteCount'] as int) / (_cacheStatus!['maxByteSize'] as int) * 100).toStringAsFixed(1)}%',
              Icons.donut_small,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionsCard() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.settings, color: Theme.of(context).primaryColor),
                const SizedBox(width: 8),
                Text(
                  'ç¼“å­˜æ“ä½œ',
                  style: Theme.of(
                    context,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                ),
              ],
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _clearAllCache,
                icon: const Icon(Icons.clear_all),
                label: const Text('æ¸…ç†æ‰€æœ‰ç¼“å­?),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.red,
                  foregroundColor: Colors.white,
                ),
              ),
            ),
            const SizedBox(height: 8),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: _loadCacheStatus,
                icon: const Icon(Icons.refresh),
                label: const Text('åˆ·æ–°ç¼“å­˜çŠ¶æ€?),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTipsCard() {
    return Card(
      color: Colors.blue.shade50,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.lightbulb_outline, color: Colors.blue.shade700),
                const SizedBox(width: 8),
                Text(
                  'ç¼“å­˜è¯´æ˜',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Colors.blue.shade700,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              'â€?å†…å­˜ç¼“å­˜ï¼šå­˜å‚¨å·²è§£ç çš„å›¾ç‰‡å¯¹è±¡ï¼Œè®¿é—®é€Ÿåº¦æœ€å¿«\n'
              'â€?å­—èŠ‚ç¼“å­˜ï¼šå­˜å‚¨å›¾ç‰‡å­—èŠ‚æ•°æ®ï¼Œå‡å°‘ç£ç›˜è¯»å–\n'
              'â€?ç£ç›˜ç¼“å­˜ï¼šå­˜å‚¨ä¼˜åŒ–åçš„ç¼©ç•¥å›¾ï¼ŒæŒä¹…åŒ–å­˜å‚¨\n'
              'â€?ç¼“å­˜ä¼šè‡ªåŠ¨ç®¡ç†ï¼Œæ— éœ€æ‰‹åŠ¨æ¸…ç†\n'
              'â€?æ¸…ç†ç¼“å­˜ä¼šé‡Šæ”¾å†…å­˜å¹¶åˆ é™¤ç£ç›˜æ–‡ä»¶',
              style: TextStyle(color: Colors.blue.shade700, fontSize: 14),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusItem(
    String title,
    String value,
    Color color,
    IconData icon,
  ) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        children: [
          Icon(icon, color: color, size: 28),
          const SizedBox(height: 8),
          Text(
            title,
            style: TextStyle(
              fontSize: 12,
              color: color.withOpacity(0.8),
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: TextStyle(
              fontSize: 16,
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailItem(String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 16, color: Colors.grey.shade600),
        const SizedBox(width: 8),
        Text(
          '$label:',
          style: TextStyle(
            fontWeight: FontWeight.w500,
            color: Colors.grey.shade700,
          ),
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            value,
            style: const TextStyle(fontSize: 14),
            overflow: TextOverflow.ellipsis,
          ),
        ),
        IconButton(
          onPressed: () => _copyToClipboard(value),
          icon: const Icon(Icons.copy, size: 16),
          iconSize: 16,
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(),
        ),
      ],
    );
  }

  Future<bool> _showConfirmDialog(String title, String content) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(content),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('ç¡®å®š'),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  void _copyToClipboard(String text) {
    Clipboard.setData(ClipboardData(text: text));
    showAppSnackBar(context, message: 'å·²å¤åˆ¶åˆ°å‰ªè´´æ?);
  }

}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:markdown_widget/markdown_widget.dart';

class PrivacyPolicyScreen extends StatelessWidget {
  const PrivacyPolicyScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('éšç§æ”¿ç­–'),
      ),
      body: FutureBuilder(
        future: rootBundle.loadString('assets/text/privacy_policy.md'),
        builder: (BuildContext context, AsyncSnapshot<String> snapshot) {
          if (snapshot.connectionState == ConnectionState.done) {
            if (snapshot.hasError) {
              return Center(child: Text('åŠ è½½å¤±è´¥: ${snapshot.error}'));
            }
            if (snapshot.hasData) {
              return MarkdownWidget(
                data: snapshot.data!,
                padding: const EdgeInsets.all(16.0),
              );
            }
          }
          return const Center(child: CircularProgressIndicator());
        },
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../../../core/widgets/privacy_debug_helper.dart';
import '../widgets/privacy_policy_dialog.dart';

class PrivacyTestScreen extends StatelessWidget {
  const PrivacyTestScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('éšç§æ”¿ç­–æµ‹è¯•'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'éšç§æ”¿ç­–å¼¹çª—æµ‹è¯•å·¥å…·',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            
            ElevatedButton(
              onPressed: () => PrivacyDebugHelper.showDebugInfo(context),
              child: const Text('æŸ¥çœ‹éšç§æ”¿ç­–çŠ¶æ€?),
            ),
            
            const SizedBox(height: 10),
            
            ElevatedButton(
              onPressed: () async {
                await PrivacyDebugHelper.resetPrivacyStatus();
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('éšç§æ”¿ç­–çŠ¶æ€å·²é‡ç½®ï¼Œè¯·é‡å¯åº”ç”¨æŸ¥çœ‹å¼¹çª—')),
                  );
                }
              },
              style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
              child: const Text('é‡ç½®éšç§æ”¿ç­–çŠ¶æ€?),
            ),
            
            const SizedBox(height: 10),
            
            ElevatedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  barrierDismissible: false,
                  builder: (context) => PrivacyPolicyDialog(
                    onAgreed: () async {
                      Navigator.of(context).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('æµ‹è¯•ï¼šç”¨æˆ·å·²åŒæ„éšç§æ”¿ç­–')),
                      );
                    },
                  ),
                );
              },
              style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              child: const Text('æ‰‹åŠ¨æ˜¾ç¤ºéšç§æ”¿ç­–å¼¹çª—'),
            ),
            
            const SizedBox(height: 30),
            
            const Card(
              child: Padding(
                padding: EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'ä½¿ç”¨è¯´æ˜ï¼?,
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    SizedBox(height: 8),
                    Text('1. ç‚¹å‡»"æŸ¥çœ‹éšç§æ”¿ç­–çŠ¶æ€?æ£€æŸ¥å½“å‰çŠ¶æ€?),
                    Text('2. ç‚¹å‡»"é‡ç½®éšç§æ”¿ç­–çŠ¶æ€?æ¸…é™¤åŒæ„è®°å½•'),
                    Text('3. é‡å¯åº”ç”¨æŸ¥çœ‹å¼¹çª—æ˜¯å¦æ­£å¸¸æ˜¾ç¤º'),
                    Text('4. ç‚¹å‡»"æ‰‹åŠ¨æ˜¾ç¤º"æµ‹è¯•å¼¹çª—åŠŸèƒ½'),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:file_picker/file_picker.dart';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/services.dart' show rootBundle;
import 'package:fluttertoast/fluttertoast.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter/foundation.dart';
 
 import '../../../../core/database/database.dart';
import '../../../../core/services/toast_service.dart';
import '../../../product/application/product_import_service.dart';
import 'image_cache_management_screen.dart';
import 'privacy_policy_screen.dart';
import 'terms_of_service_screen.dart';
import '../../../backup/presentation/screens/backup_management_screen.dart';
import '../../../backup/presentation/screens/auto_backup_settings_screen.dart';
import '../../../../core/constants/app_routes.dart';
import 'package:go_router/go_router.dart';

/// é€šç”¨è®¾ç½®é¡µé¢
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  /// æ„å»ºåˆ†åŒºæ ‡é¢˜
  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleSmall?.copyWith(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  /// æ˜¾ç¤ºå¤‡ä»½åŠŸèƒ½å¸®åŠ©å¯¹è¯æ¡?
  void _showBackupHelpDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.help_outline),
            SizedBox(width: 8),
            Text('å¤‡ä»½åŠŸèƒ½ä½¿ç”¨æŒ‡å—'),
          ],
        ),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildHelpSection(
                context,
                'ä»€ä¹ˆæ˜¯æ•°æ®å¤‡ä»½ï¼?,
                'æ•°æ®å¤‡ä»½æ˜¯å°†æ‚¨çš„åº“å­˜æ•°æ®ï¼ˆäº§å“ã€åº“å­˜ã€é”€å”®è®°å½•ç­‰ï¼‰å¯¼å‡ºåˆ°æ–‡ä»¶ä¸­ï¼Œä»¥é˜²æ•°æ®ä¸¢å¤±æˆ–è®¾å¤‡æ›´æ¢æ—¶ä½¿ç”¨ã€?,
              ),
              const SizedBox(height: 16),
              _buildHelpSection(
                context,
                'å¦‚ä½•åˆ›å»ºå¤‡ä»½ï¼?,
                '1. ç‚¹å‡»"å¤‡ä»½ç®¡ç†"è¿›å…¥å¤‡ä»½ç•Œé¢\n2. ç‚¹å‡»"åˆ›å»ºå¤‡ä»½"æŒ‰é’®\n3. è®¾ç½®å¤‡ä»½é€‰é¡¹ï¼ˆåç§°ã€åŠ å¯†ç­‰ï¼‰\n4. ç­‰å¾…å¤‡ä»½å®Œæˆ',
              ),
              const SizedBox(height: 16),
              _buildHelpSection(
                context,
                'å¦‚ä½•æ¢å¤æ•°æ®ï¼?,
                '1. åœ¨å¤‡ä»½ç®¡ç†ç•Œé¢ç‚¹å‡?æ¢å¤"æŒ‰é’®\n2. é€‰æ‹©å¤‡ä»½æ–‡ä»¶\n3. é€‰æ‹©æ¢å¤æ¨¡å¼ï¼ˆæ›¿æ¢æˆ–åˆå¹¶ï¼‰\n4. ç¡®è®¤æ¢å¤æ“ä½œ',
              ),
              const SizedBox(height: 16),
              _buildHelpSection(
                context,
                'è‡ªåŠ¨å¤‡ä»½åŠŸèƒ½',
                'å¯ç”¨è‡ªåŠ¨å¤‡ä»½åï¼Œç³»ç»Ÿä¼šå®šæœŸè‡ªåŠ¨åˆ›å»ºå¤‡ä»½æ–‡ä»¶ï¼Œæ— éœ€æ‰‹åŠ¨æ“ä½œã€‚å»ºè®®å¼€å¯æ­¤åŠŸèƒ½ä»¥ç¡®ä¿æ•°æ®å®‰å…¨ã€?,
              ),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer.withValues(alpha: 0.3),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.lightbulb_outline,
                      color: Theme.of(context).colorScheme.primary,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'å»ºè®®å®šæœŸåˆ›å»ºå¤‡ä»½ï¼Œå¹¶å°†é‡è¦å¤‡ä»½æ–‡ä»¶ä¿å­˜åˆ°äº‘å­˜å‚¨æˆ–å…¶ä»–å®‰å…¨ä½ç½®ã€?,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('çŸ¥é“äº?),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const BackupManagementScreen(),
                ),
              );
            },
            child: const Text('ç«‹å³ä½“éªŒ'),
          ),
        ],
      ),
    );
  }

  /// æ„å»ºå¸®åŠ©å†…å®¹åŒºå—
  Widget _buildHelpSection(BuildContext context, String title, String content) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          content,
          style: Theme.of(context).textTheme.bodySmall,
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('è®¾ç½®')),
      body: ListView(
        children: [
          // æ•°æ®å¤‡ä»½å’Œæ¢å¤éƒ¨åˆ?
          _buildSectionHeader(context, 'æ•°æ®å¤‡ä»½å’Œæ¢å¤?),
          ListTile(
            leading: const Icon(Icons.backup),
            title: const Text('å¤‡ä»½ç®¡ç†'),
            subtitle: const Text('åˆ›å»ºå’Œç®¡ç†æ•°æ®å¤‡ä»?),
            trailing: IconButton(
              icon: const Icon(Icons.help_outline),
              onPressed: () => _showBackupHelpDialog(context),
              tooltip: 'å¤‡ä»½åŠŸèƒ½å¸®åŠ©',
            ),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const BackupManagementScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.schedule),
            title: const Text('è‡ªåŠ¨å¤‡ä»½'),
            subtitle: const Text('é…ç½®è‡ªåŠ¨å¤‡ä»½è®¾ç½®'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const AutoBackupSettingsScreen(),
                ),
              );
            },
          ),
          const Divider(),
          _buildSectionHeader(context, 'ç³»ç»Ÿç®¡ç†'),
          ListTile(
            leading: const Icon(Icons.cached),
            title: const Text('å›¾ç‰‡ç¼“å­˜ç®¡ç†'),
            subtitle: const Text('æŸ¥çœ‹å’Œæ¸…ç†åº”ç”¨ç¼“å­?),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const ImageCacheManagementScreen(),
                ),
              );
            },
          ),
          const Divider(),
          _buildSectionHeader(context, 'æ³•å¾‹ä¿¡æ¯'),
          ListTile(
            leading: const Icon(Icons.privacy_tip_outlined),
            title: const Text('éšç§æ”¿ç­–'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const PrivacyPolicyScreen(),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.description_outlined),
            title: const Text('ç”¨æˆ·åè®®'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const TermsOfServiceScreen(),
                ),
              );
            },
          ),
          const Divider(),
          const _DataManagementSection(),
          if (kDebugMode) ...[
           const Divider(),
           _buildSectionHeader(context, 'å¼€å‘è°ƒè¯?),
           ListTile(
             leading: const Icon(Icons.bug_report),
             title: const Text('äº§å“æ¢å¤æµ‹è¯•'),
             subtitle: const Text('æµ‹è¯•äº§å“æ•°æ®æ¢å¤åŠŸèƒ½'),
             onTap: () => context.push(AppRoutes.productRestoreDebug),
           ),
           ListTile(
             leading: const Icon(Icons.restore),
             title: const Text('é‡ç½®éšç§æ”¿ç­–çŠ¶æ€?),
             subtitle: const Text('ä»…åœ¨å¼€å‘æ¨¡å¼ä¸‹å¯è§'),
             onTap: () async {
               final prefs = await SharedPreferences.getInstance();
               await prefs.setBool('isPrivacyPolicyAgreed', false);
               ToastService.show(
                 'éšç§æ”¿ç­–çŠ¶æ€å·²é‡ç½®ï¼Œè¯·é‡å¯åº”ç”¨',
                 length: Toast.LENGTH_LONG,
               );
             },
           ),
         ],
        ],
      ),
    );
  }
}

/// æ•°æ®ç®¡ç†éƒ¨åˆ†
class _DataManagementSection extends ConsumerWidget {
  const _DataManagementSection();

  Future<void> _importProductsFromFile(
    BuildContext context,
    WidgetRef ref,
  ) async {
    try {
      // 1. é€‰æ‹©æ–‡ä»¶
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['json'],
      );

      if (result == null || result.files.single.path == null) {
        ToastService.info('æœªé€‰æ‹©æ–‡ä»¶');
        return;
      }

      // 2. è¯»å–å¹¶è§£ææ–‡ä»?
      final file = File(result.files.single.path!);
      final content = await file.readAsString();
      final List<dynamic> jsonData = jsonDecode(content);
      final List<Map<String, dynamic>> productsData = jsonData
          .cast<Map<String, dynamic>>();

      // 3. è°ƒç”¨æœåŠ¡æ‰§è¡Œå¯¼å…¥
      final db = ref.read(appDatabaseProvider); // ä½¿ç”¨æ­£ç¡®çš?provider
      final importService = ProductImportService(db);

      ToastService.info('æ­£åœ¨å¯¼å…¥...');

      final importResult = await importService.bulkInsertProducts(productsData);

      if (importResult != null) {
        // ä½¿ç”¨ ToastService æ˜¾ç¤ºç»“æœ
        ToastService.show(
          importResult,
          length: Toast.LENGTH_LONG,
          backgroundColor: importResult.contains('å¤±è´¥')
              ? Colors.red
              : Colors.green,
        );
      }
    } catch (e) {
      ToastService.error('å¯¼å…¥å¤±è´¥: $e');
    }
  }

  Future<void> _importProductsFromAsset(
    BuildContext context,
    WidgetRef ref,
  ) async {
    try {
      ToastService.info('æ­£åœ¨ä»åº”ç”¨å†…åŠ è½½ç¤ºä¾‹æ•°æ®...');

      // 1. å®šä¹‰è¦åŠ è½½çš„æ–‡ä»¶åˆ—è¡¨
      final List<String> assetFiles = [
        'assets/data/jy_products1.json',
        'assets/data/jy_products2.json',
        'assets/data/jy_products3.json',
        'assets/data/jy_products4.json',
        'assets/data/jy_products5.json',
        'assets/data/jy_products6.json',
        'assets/data/jy_products7.json',
        'assets/data/jy_products8.json',
        'assets/data/jy_products9.json',
        'assets/data/jy_products10.json',
        'assets/data/jy_products11.json',
      ];

      // 2. è¯»å–å¹¶è§£ææ‰€æœ‰æ–‡ä»?
      final List<Map<String, dynamic>> productsData = [];
      for (final assetFile in assetFiles) {
        try {
          final String content = await rootBundle.loadString(assetFile);
          final List<dynamic> jsonData = jsonDecode(content);
          productsData.addAll(jsonData.cast<Map<String, dynamic>>());
        } catch (e) {
          // å¦‚æœæŸä¸ªæ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œå¯ä»¥é€‰æ‹©è®°å½•æ—¥å¿—æˆ–é€šçŸ¥ç”¨æˆ·
          ToastService.error('åŠ è½½æ–‡ä»¶ $assetFile å¤±è´¥: $e');
        }
      }

      if (productsData.isEmpty) {
        ToastService.info('æ²¡æœ‰å¯å¯¼å…¥çš„è´§å“æ•°æ®ã€?);
        return;
      }

      // 2. è°ƒç”¨æœåŠ¡æ‰§è¡Œå¯¼å…¥
      final db = ref.read(appDatabaseProvider);
      final importService = ProductImportService(db);
      final importResult = await importService.bulkInsertProducts(productsData);

      if (importResult != null) {
        ToastService.show(
          importResult,
          length: Toast.LENGTH_LONG,
          backgroundColor: importResult.contains('å¤±è´¥')
              ? Colors.red
              : Colors.green,
        );
      }
    } catch (e) {
      ToastService.error('å¯¼å…¥å¤±è´¥: $e');
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ExpansionTile(
      leading: const Icon(Icons.storage),
      title: const Text('æ•°æ®ç®¡ç†'),
      subtitle: const Text('å¯¼å…¥å’Œå¯¼å‡ºæ•°æ?),
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          child: ElevatedButton.icon(
            onPressed: () => _importProductsFromFile(context, ref),
            icon: const Icon(Icons.file_upload),
            label: const Text('ä»æ–‡ä»¶å¯¼å…¥è´§å“?),
            style: ElevatedButton.styleFrom(
              minimumSize: const Size(double.infinity, 40), // æŒ‰é’®å®½åº¦å¡«å……
            ),
          ),
        ),
        Padding(
          padding: const EdgeInsets.fromLTRB(16.0, 0, 16.0, 8.0),
          child: ElevatedButton.icon(
            onPressed: () => _importProductsFromAsset(context, ref),
            icon: const Icon(Icons.data_usage),
            label: const Text('åŠ è½½ç¤ºä¾‹è´§å“'),
            style: ElevatedButton.styleFrom(
              minimumSize: const Size(double.infinity, 40), // æŒ‰é’®å®½åº¦å¡«å……
            ),
          ),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:markdown_widget/markdown_widget.dart';

class TermsOfServiceScreen extends StatelessWidget {
  const TermsOfServiceScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ç”¨æˆ·åè®®'),
      ),
      body: FutureBuilder(
        future: rootBundle.loadString('assets/text/terms_of_service.md'),
        builder: (BuildContext context, AsyncSnapshot<String> snapshot) {
          if (snapshot.connectionState == ConnectionState.done) {
            if (snapshot.hasError) {
              return Center(child: Text('åŠ è½½å¤±è´¥: ${snapshot.error}'));
            }
            if (snapshot.hasData) {
              return MarkdownWidget(
                data: snapshot.data!,
                padding: const EdgeInsets.all(16.0),
              );
            }
          }
          return const Center(child: CircularProgressIndicator());
        },
      ),
    );
  }
}
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';

class PrivacyPolicyDialog extends StatefulWidget {
  final Future<void> Function() onAgreed;

  const PrivacyPolicyDialog({super.key, required this.onAgreed});

  @override
  State<PrivacyPolicyDialog> createState() => _PrivacyPolicyDialogState();
}

class _PrivacyPolicyDialogState extends State<PrivacyPolicyDialog> {
  bool _agreed = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('ç”¨æˆ·åè®®ä¸éšç§æ”¿ç­?),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          RichText(
            text: TextSpan(
              style: Theme.of(context).textTheme.bodyMedium,
              children: [
                const TextSpan(text: 'è¯·æ‚¨åœ¨ä½¿ç”¨æœ¬åº”ç”¨å‰ï¼Œä»”ç»†é˜…è¯»å¹¶å……åˆ†ç†è§?),
                TextSpan(
                  text: 'ã€Šç”¨æˆ·åè®®ã€?,
                  style: const TextStyle(
                    color: Colors.blue,
                    decoration: TextDecoration.underline,
                  ),
                  recognizer: TapGestureRecognizer()
                    ..onTap = () {
                      context.push('/settings/user-agreement');
                    },
                ),
                const TextSpan(text: 'å’?),
                TextSpan(
                  text: 'ã€Šéšç§æ”¿ç­–ã€?,
                  style: const TextStyle(
                    color: Colors.blue,
                    decoration: TextDecoration.underline,
                  ),
                  recognizer: TapGestureRecognizer()
                    ..onTap = () {
                      context.push('/settings/privacy-policy');
                    },
                ),
                const TextSpan(
                  text: 'çš„å…¨éƒ¨å†…å®¹ã€‚å½“æ‚¨ç‚¹å‡?åŒæ„"å¹¶å¼€å§‹ä½¿ç”¨æˆ‘ä»¬çš„äº§å“æˆ–æœåŠ¡ï¼Œå³è¡¨ç¤ºæ‚¨å·²å……åˆ†ç†è§£å¹¶åŒæ„æœ¬åè®®å’Œæ”¿ç­–ã€?,
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Checkbox(
                value: _agreed,
                onChanged: (bool? value) {
                  setState(() {
                    _agreed = value ?? false;
                  });
                },
              ),
              const Flexible(
                child: Text('æˆ‘å·²é˜…è¯»å¹¶åŒæ„ã€Šç”¨æˆ·åè®®ã€‹å’Œã€Šéšç§æ”¿ç­–ã€?),
              ),
            ],
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () {
            // ç”¨æˆ·ä¸åŒæ„éšç§æ”¿ç­–ï¼Œé€€å‡ºåº”ç”?
            SystemNavigator.pop();
          },
          child: const Text('ä¸åŒæ„?),
        ),
        TextButton(
          onPressed: _agreed
              ? () async {
                  await widget.onAgreed();
                }
              : null,
          child: const Text('åŒæ„'),
        ),
      ],
    );
  }
}
